<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>硬件知识</title>
      <link href="/posts/7948/"/>
      <url>/posts/7948/</url>
      
        <content type="html"><![CDATA[<h2 id="diy电脑功耗怎么考虑"><a href="#diy电脑功耗怎么考虑" class="headerlink" title="diy电脑功耗怎么考虑"></a>diy电脑功耗怎么考虑</h2><p><a href="http://www.lotpc.com/zjzn/8670.html">电源功耗如何计算</a></p><h3 id="台式机电源功耗如何计算（简洁版）"><a href="#台式机电源功耗如何计算（简洁版）" class="headerlink" title="台式机电源功耗如何计算（简洁版）"></a>台式机电源功耗如何计算（简洁版）</h3><p><strong>（CPU TDP功耗 + 显卡TDP功耗 + 其它硬件功耗按40W）÷ 0.6 = 电源额定功率（单位：W瓦）</strong></p><p>CPU和显卡是硬件中功耗大户，所以取这两个硬件的TDP功耗，虽然TDP功耗并不是实际功耗，但是可以借用TDP功耗指标来计算。</p><p>其它硬件可以打包功耗为40W，例如主板6W，内存2W一根，机械硬盘8W，固态硬盘2W，还有其它包括机箱风扇或者光驱等。</p><p>为什么除以0.6，在满载时仍然保留40%冗余功率。</p><p>以上电源功率计算公式为独立显卡为主，核心显卡（集成显卡）通常使用250W-300W额定功率足够了，建议额定300W起步。</p><p>注意：得出的电源功率需要根据实际情况适当加减取整，如果怕不够可以再加50W。</p><p>例子：<br>i3-9100F+GTX1650电脑主机，i3-9100F TDP功耗为65W，GTX1650 TDP功耗为75W，其它硬件大致按40W算。那么就是（65+75+40）÷ 0.6=300W，建议额定300W-350W。</p><p>i5-9400F+GTX1660Super的电脑主机，i5-9400F TDP功耗为65W，GTX1660Super TDP功耗为125W，其它硬件大致按40W算。那么就是（65+125+40）÷ 0.6=383W，建议额定400W-450W。</p><p>i7-9700F+RTX2060 SUPER的电脑主机，i7-9700F TDP功耗为65W，RTX2060 SUPER TDP功耗为175W，其它硬件大致按40W算。那么就是（65+175+40）÷ 0.6=466W，建议500W-550W。</p><p>i7-9700K+RTX2070Super的电脑主机，i7-9700K TDP功耗为95W，RTX2070Super TDP功耗为215W，其它硬件大致按40W算。那么就是（95+215+40）÷ 0.6=583W，建议额定550W-600W。</p><p>i7-9900K+RTX2080Super的电脑主机，i9-9900K TDP功耗为95W，RTX2080Super TDP功耗为250W，其它硬件大致按40W算。那么就是（95+250+40）÷ 0.6=641W，建议额定650W。</p><p>R5 3600+RX5700的电脑主机，R5 3600 TDP功耗为65W，RX5700 TDP功耗为185W，其它硬件大致按40W算。那么就是（65+185+40）÷ 0.6=483W，建议500W-550W。</p><h3 id="迷你主机功耗计算例子"><a href="#迷你主机功耗计算例子" class="headerlink" title="迷你主机功耗计算例子"></a>迷你主机功耗计算例子</h3><p>以HP EliteDesk 800 65W G2微型台式电脑为例，其中65W表示整个电脑系统在正常运行时的平均功耗。</p><p><strong>通常情况下，整个电脑系统在正常运行时的平均功耗应该远低于组件的额定功耗之和。这是因为硬件组件在实际使用过程中的功耗并不是始终保持在额定功耗水平，而是根据系统负载和任务需求而变化的。考虑到整体系统功耗的控制，设计者会在选择和配置硬件组件时进行平衡。他们会考虑到各个组件的功耗特性，系统的散热能力以及整体系统在正常使用情况下的功耗。如果CPU的额定功耗为65W，加上内存、硬盘等其他组件的功耗，整体功耗可能会超过65W，但这并不意味着系统不能正常运行。系统设计者通常会预留一定的功耗余量，以应对高负载情况和临时功耗峰值。</strong></p><p>以下是一些硬件组件的功耗范例：</p><p>CPU：例如Intel Core i5-6600，功耗范围为65W。</p><p>内存：通常情况下，内存的功耗较低，可以忽略不计。</p><p>硬盘：例如固态硬盘（SSD），功耗范围为1W至4W，具体取决于型号和容量。</p><p>显卡（如果有独立显卡）：例如NVIDIA GeForce GTX 1650，功耗范围为75W至150W，具体取决于型号和厂商。</p><p>主板：主板的功耗通常较低，一般在10W以下。</p><p>散热器和风扇：功耗较小，一般在1W至5W之间。</p><p><strong>电源的额定功率一定要比各个硬件的功耗之和高，不然可能带不动。</strong></p><h3 id="功耗过高，可能出现的问题"><a href="#功耗过高，可能出现的问题" class="headerlink" title="功耗过高，可能出现的问题"></a>功耗过高，可能出现的问题</h3><ol><li><p>过热问题：高功耗会导致系统各个组件（如CPU、显卡、硬盘等）的温度升高。如果散热不足，可能会引发过热问题，导致系统性能下降、崩溃或损坏硬件。</p></li><li><p>电源供电不足：高功耗可能超出电源的供电能力，导致电压下降、电流不稳定等问题。这可能引起系统不稳定，甚至造成系统崩溃或无法正常启动。</p></li><li><p>性能下降：当系统整体功耗过高时，电源和其他组件可能无法提供足够的电能来支持系统的高性能运行。这可能导致系统性能下降，例如运行速度变慢、应用程序响应变慢等。</p></li><li><p>硬件故障：长期以高功耗运行系统可能会对硬件组件造成损坏或加速磨损。例如，过高的电压、电流可能导致电路元件损坏、芯片烧毁等。</p></li></ol><p>为了避免这些问题，建议根据硬件组件的功耗规格和系统的电源供应能力，合理选择和配置硬件，并确保系统整体功耗在可接受范围内。定期清理和维护散热系统也是保持系统性能和稳定性的重要措施。</p><h3 id="即使电源功率足够，功耗过高也有问题"><a href="#即使电源功率足够，功耗过高也有问题" class="headerlink" title="即使电源功率足够，功耗过高也有问题"></a>即使电源功率足够，功耗过高也有问题</h3><p>虽然电源功率足够大可以提供更高的功耗，但系统功耗高并不意味着一定没有问题。尽管电源功率足够大可以满足系统的高功耗需求，但仍然需要考虑以下几个方面：</p><ol><li><p>散热问题：高功耗会导致系统内部产生更多的热量，需要足够的散热系统来有效降低温度。如果散热不足，可能会导致硬件温度升高，影响系统的稳定性和寿命。</p></li><li><p>稳定性问题：虽然电源功率足够大，但电源供电的稳定性也是至关重要的。如果电源的输出电压、电流不稳定，可能导致系统的不稳定运行、崩溃或损坏硬件。</p></li><li><p>能效问题：高功耗意味着系统需要更多的电能供应，这可能导致能效下降。较高的功耗也会导致电费增加。</p></li></ol><p>因此，尽管电源功率足够大可以支持高功耗系统，但仍建议根据实际需求选择适当的硬件配置，以平衡性能、稳定性、散热和能效等因素。定期清理和维护散热系统也是保持系统性能和稳定性的重要措施。</p>]]></content>
      
      
      <categories>
          
          <category> 硬件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习</title>
      <link href="/posts/48513/"/>
      <url>/posts/48513/</url>
      
        <content type="html"><![CDATA[<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><h3 id="loss-backward-耗时严重"><a href="#loss-backward-耗时严重" class="headerlink" title="loss.backward()耗时严重"></a>loss.backward()耗时严重</h3><p>loss.backward()主要是计算梯度，为后面更新参数做准备，如果这一步耗时严重，要么是网络结构复杂，要么是<strong>计算图非常大</strong>。如果某个tensor的requires.grad属于被开启，那么就会为其分配一个计算图。</p><p><strong>背景：</strong><br></p><pre class="line-numbers language-none"><code class="language-none">pde_data = torch.from_numpy(pd.read_csv(self.config.pde_data_path).values).float().to(self.device)self.pde_Xs = [pde_data[:, i:i+1].requires_grad_() for i in range(self.config.X_dim)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br>上面这段代码是读取数据后，然后开启requires<em>grad</em>()，但是它是对所有的数据都开启requires<em>grad</em>()，即使后面batch只使用了很小一部分数据，但是loss.backward()还是会计算这一部分，导致很慢。<p></p><p><strong>正确的做法：</strong><br>在取出batch的时候才为这些数据开启requires<em>grad</em>()</p><h3 id="tensor必须在同一个设备上面"><a href="#tensor必须在同一个设备上面" class="headerlink" title="tensor必须在同一个设备上面"></a>tensor必须在同一个设备上面</h3><p>有时候需要把numpy转为tensor，再转回来。</p><p>可能会遇到不在同一个设备上面，需要阻断反向传播等。<br>下面给一个简单的例子：</p><pre class="line-numbers language-none"><code class="language-none">// 把numpy转为tensor，再换为32位的（网络接受的是32位），在移动到同一个device上predict = net(torch.from_numpy(XYT).float().to(config.device))// tensor转换为numpy，除了要先放到cpu上，还需要阻断反向传播，requires_grad为falsepredict = predict.cpu().detach().numpy()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><p>regression:回归</p><p>training data set = training set:训练数据集/训练集</p><p>sample = data point = data instance:样本/数据点/数据样本</p><p>label = target:标签/目标</p><p>feature = covariate:特性/协变量</p><p>translation:平移</p><p>gradient descent:梯度下降</p><p>minibatch stochastic gradient descent:小批量随机梯度下降</p><p>batch size:批量大小</p><p>hyperparameter tuning:调参</p><p>trade-off:取舍/权衡<br><a href="https://zhuanlan.zhihu.com/p/338415312">原文链接</a></p><p>深度学习领域中的几个指标也相同。</p><p>主要的指标有如下四个：</p><p>（1）精度：自然精度是一个模型最根本的衡量指标，如果一个模型精度不高，再快，再绿色环保也无济于事。基本上所有刷榜的工作都是用其他所有指标换精度：比如用更深的网络就是用memory和computation换精度。然而到了实际应用中，尤其是部署侧，工程师越来越多的用一些方法适当的减少精度从而换取更小的内存占用或者运算时间</p><p>（2）内存：Out Of Memory Error恐怕是炼丹师最常见的情况了。内存（或者说可以高效访问的存储空间）的尺寸是有限的，如果网络训练需要的内存太大了，可能程序直接就报错了，即使不报错，也需要把内存中的数据做个取舍，一部分存到相对较慢的存储介质中（比如host memory）。</p><p>(3) 通信：随着网络规模越来越大，分布式训练已经是state-of-the-art的网络模型必不可少的部分（你见过谁用单卡在ImageNet训练ResNet50？），在大规模分布式系统，通信带宽比较低，相比于computation或者memory load/sotre，network communication会慢很多，如果可以降低通信量，那么整个网络的训练时间就会有大幅减少：这样研究员就不会借口调参，实际上把模型往服务器上一扔自己就跑出去浪了。(资本家狂喜)</p><p>（4）计算：虽然我们用的是计算机，但实际上恐怕只有很少的时间用于计算(computation)了，因为大多数时间都在等待数据的读取或者网络通信，不过即便如此，对于一些计算密集型的神经网络结构（比如BERT，几乎都是矩阵乘法），制约我们的往往是设备的计算能力（FLOPS），即每秒钟可以处理多少浮点计算。</p><p>常见的trade-off:<br>（1）计算换内存<br>（2）通信换内存<br>（3）计算换通信<br>（4）显存换计算<br>（5）精度换计算/内存/通信</p><p>孪生网络（Siamese newtowk）:<a href="https://zhuanlan.zhihu.com/p/35040994">原文链接</a></p><h3 id="hard-soft-physical-constraints"><a href="#hard-soft-physical-constraints" class="headerlink" title="hard/soft physical constraints"></a>hard/soft physical constraints</h3><p>在深度学习与计算流体力学领域中，”hard physical constraints”（硬物理约束）指的是在模型建立和求解过程中必须严格遵守的物理规律或约束条件。这些约束条件通常是基于问题的物理性质和基本定律，例如质量守恒、能量守恒、动量守恒等。</p><p>在计算流体力学中，硬物理约束可能包括以下方面：</p><ol><li>质量守恒：流体的入口和出口质量流量必须保持平衡。</li><li>动量守恒：流体中的动量转移满足牛顿第二定律。</li><li>能量守恒：流体中的能量转移满足能量守恒定律。</li><li>不可压缩性：在不可压缩流体模拟中，流体密度保持恒定。</li><li>边界条件：在模拟中，需要定义适当的边界条件以满足问题的物理要求。</li></ol><p>在深度学习中，硬物理约束指的是将物理约束直接嵌入到深度学习模型中的方法。通过在模型的设计和训练过程中引入这些硬物理约束，可以更好地确保生成的结果符合物理定律和约束条件。这有助于提高模型的物理合理性和实用性。</p><p>总而言之，硬物理约束是指在深度学习与计算流体力学中必须遵守的严格物理规律和约束条件，确保模型与实际物理系统的一致性。</p><hr><p>在深度学习与计算流体力学领域中，”soft physical constraints”（软物理约束）指的是在模型建立和求解过程中考虑的物理规律或约束条件，但其遵守程度可以有一定的灵活性或容忍度。与硬物理约束相比，软物理约束更加柔性，允许在一定程度上违背或放宽约束条件，以获得更好的模型拟合或求解结果。</p><p>软物理约束通常是通过引入损失函数或惩罚项来实现的，以在模型训练或优化过程中对违反约束条件进行惩罚或限制。这样可以在尽量满足物理规律的同时，允许一定程度的误差或适应性，以提高模型的灵活性和适应性。</p><p>在计算流体力学中，软物理约束可以包括以下方面：</p><ol><li>不稳定流动约束：在流体模拟中，允许一定程度的不稳定性或涡旋生成，而不要求完全消除或压制。</li><li>数值耗散约束：在数值模拟中，可以引入一定的耗散项或平滑操作，以减少数值震荡或不稳定性，同时保持一定的数值精度。</li><li>材料参数估计约束：在模型中，对材料参数或未知参数的估计可以具有一定的容忍度，以考虑实际系统的不确定性或噪声。</li></ol><p>总而言之，软物理约束是在深度学习与计算流体力学中考虑的相对柔性的物理规律或约束条件。通过在模型的训练或优化过程中引入相应的损失函数或惩罚项，可以在一定程度上允许约束条件的违背，以提高模型的适应性和灵活性。</p><h3 id="Non-intrusive-Reduced-Order-Model-非侵入式降阶模型"><a href="#Non-intrusive-Reduced-Order-Model-非侵入式降阶模型" class="headerlink" title="Non-intrusive Reduced Order Model(非侵入式降阶模型)"></a>Non-intrusive Reduced Order Model(非侵入式降阶模型)</h3><p>在深度学习中，“Non-intrusive Reduced Order Model”（非侵入式降阶模型）是一种用于减少高维问题复杂性的建模方法。它的目标是通过将高维问题映射到低维空间中，以降低计算成本和内存需求，同时保持问题的关键特征和准确性。</p><p>传统的减少高维问题复杂性的方法通常是通过降阶技术，如主成分分析（PCA）或奇异值分解（SVD），来提取问题的主要模式或特征，并建立一个低维模型。然而，这些方法通常需要对问题的物理方程进行修改或重新建模，因此被称为“侵入式模型”。</p><p>相比之下，非侵入式降阶模型采用机器学习技术，如深度学习，通过学习数据集中的模式和关系来构建低维模型，而无需对物理方程进行修改。它可以通过将输入数据映射到低维表示空间，并使用深度神经网络来学习映射函数，从而实现降维和建模。</p><p>非侵入式降阶模型在减少计算负担、加速模拟和优化高维问题方面具有潜力。它可以在保持问题关键特征和准确性的同时，提供更高效的模型求解和分析能力。这种方法在多个领域中得到应用，包括流体力学、结构分析、图像处理等。</p><p>需要注意的是，非侵入式降阶模型的性能和适用性取决于所选择的机器学习算法、数据集质量和训练过程等因素。因此，在具体应用中，需要根据问题的特点和需求，选择适当的非侵入式降阶方法和技术，以获得准确和高效的模型求解结果。</p><hr><p>在”Non-intrusive Reduced Order Model”中，”Non-intrusive”（非侵入式）是指建立降阶模型时，不需要对原始问题进行修改或重新建模的特性。它强调了在建立模型时不需要修改问题的物理方程或引入额外的信息，而是通过使用外部数据或机器学习方法来近似原始问题。</p><p>传统的降阶方法通常要求对问题的物理方程进行简化或修改，以提取主要模式或减少系统的自由度。这种方法被称为”侵入式”，因为它们需要对原始问题进行干预或修改。</p><p>相比之下，”Non-intrusive Reduced Order Model”使用非侵入式的方法来构建降阶模型。它不需要修改原始问题的物理方程，而是利用外部数据或机器学习技术来建立一个近似模型。这意味着原始问题的求解过程保持不变，只是在模拟或优化中引入降维的近似模型。</p><p>非侵入式方法的优点在于它们能够在保持原始问题的准确性和复杂性的同时，减少计算成本和内存需求。它们提供了一种灵活的方式来处理高维问题，同时提供较低的计算复杂度和更高的模拟速度。</p><p>总而言之，”Non-intrusive Reduced Order Model”中的”Non-intrusive”表示在构建降阶模型时不需要修改原始问题的物理方程或引入额外信息，而是通过使用外部数据或机器学习技术来近似原始问题。这种方法提供了一种非侵入性、灵活性和高效性的方式来处理高维问题的模拟和优化。</p><h3 id="矩阵计算"><a href="#矩阵计算" class="headerlink" title="矩阵计算"></a>矩阵计算</h3><p>在深度学习相关的资料里面，标量就表示一个数，向量是由多个数组成的。</p><p>常规的导数求导没有什么难度，现在将导数扩展到向量，会出现四种情况：</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/Snipaste_2023-03-02_22-49-16.png" alt=""></p><p>y为标量或向量；x为标量或向量</p><p>1、标量求导就不说了，高中常识；<br>2、y是标量，x是向量的情况。实际上就是y=f(x1,x2,…,xn)的意思。拿y=f(x1,x2)为例解释，有一个三维坐标轴体系，水平面的横轴和竖轴分别是x1、x2，立面上的轴是y，水平面上任意一个点(x1,x2)都对应y轴上的一个点，很明显这就是一个面，<strong>因此他的导数是一个向量</strong>，所以结果是横着写的。</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/Snipaste_2023-03-02_22-54-05.png" alt=""></p><p>3、y是向量，x是标量的情况。这实际上就是【y1,y2,…,yn】=【f(x1),f(x2),…,f(xn)】，对x求导就是求出y=yi时那一个点上的斜率，<strong>结果是标量</strong>，所以结果是竖着写的。</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/Snipaste_2023-03-02_22-55-43.png" alt=""></p><p>4、y、x都是向量的情况。根据上面描述，求导实际上就是求出了y=yi时，那一个平面形状边缘上的<strong>向量</strong>，因此是横着写的。</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/Snipaste_2023-03-02_22-56-14.png" alt=""></p><hr><p>关于动手学习深度学习，自动微分章节里面2.5.1例子的理解<a href="https://zh.d2l.ai/chapter_preliminaries/autograd.html">原链接</a></p><p>我们对函数$y=2x^Tx$关于列向量x求导，假设变量x为 $x=[0,1,2,3]$</p><p>可以容易的得到y是标量，且值为28.<br>参考上面提到的四种情况，求导结果应该为向量。</p><p>可以把$y=2x^Tx$看作是$y=2x^2$，求导后为$4x$，那么带入$x=[0,1,2,3]$，最后的结果为$[0,4,8,12]$</p><p>还有另外一种理解方式，把向量$x$里面的值用${x_1},{x_2}$代替，那么$y=2{x_1^2}+2{x_2^2}+2{x_3^2}+2{x_4^2}$，然后再对每个分量进行求导，即可得到梯度。$[4{x_1},4{x_2},4{x_3},4{x_4}]$，把${x_1},{x_2}$的值带入，得到最终的结果$[0,4,8,12]$</p><p>同样的，对于该小节下面的例子<br></p><pre class="line-numbers language-none"><code class="language-none">x.grad.zero_()  //  x梯度清零，x=[0,1,2,3]y=x.sum()     // 按上面的方法，y=x1+x2+x3+x4y.backward()  x.grad<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br>x梯度清零，$x=[0,1,2,3]$<p></p><p>按上面的方法，$y=x1+x2+x3+x4$</p><p>$\frac{\partial y}{\partial x} = [1,1,1,1] $</p><h3 id="损失函数和梯度下降的关系"><a href="#损失函数和梯度下降的关系" class="headerlink" title="损失函数和梯度下降的关系"></a>损失函数和梯度下降的关系</h3><p>以线性回归为例，模型为：$y=wx+b$。<br>其中$w$,$b$是我们要求的参数，深度学习大多数时候就是要把参数求出来</p><p>损失函数：为了量化目标的实际值与预测值之间的差距。以平方损失函数为例，带入样本就可以得到差距。损失函数值越小，说明效果越好。<strong>我们就是要找到使损失函数值最小的那组参数</strong></p><p><strong>梯度下降就是让我们找到那组参数的优化算法</strong></p><p>下面举一个梯度下降法的使用例子。<a href="https://www.cnblogs.com/pinard/p/5970503.html">例子来源</a></p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/QQ截图20230316215219.png" alt=""></p><p>上图中步骤4稍微说明下，是单独对每个变量求偏导数后得到的，这样结果就是一个标量而不是向量。具体的过程看下图。</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/Snipaste_2023-03-16_21-55-24.png" alt=""></p><p><strong>当梯度下降的距离小于给定的值，就停止计算，得到的参数值就是最终的结果。</strong></p><h3 id="深度学习为什么要加入隐藏层"><a href="#深度学习为什么要加入隐藏层" class="headerlink" title="深度学习为什么要加入隐藏层"></a>深度学习为什么要加入隐藏层</h3><p><strong>让特征可以更好的进行线性划分</strong></p><p><a href="https://zhuanlan.zhihu.com/p/114925231">原链接</a></p><p>例如区分以下三张图片哪个是人脸，也就是人脸识别，神经网络模型应该怎么建立呢？为了简单起见，输入层的每个节点代表图片的某个像素，个数为像素点的个数，输出层简单地定义为一个节点，标示是还是不是。</p><p>那么隐含层怎么分析呢？ 我们先从感性地角度认识这个人脸识别问题，试着将这个问题分解为一些列的子问题，比如，</p><p>在上方有头发吗？</p><p>在左上、右上各有一个眼睛吗？</p><p>在中间有鼻子吗？</p><p>在下方中间位置有嘴巴吗？</p><p>在左、右两侧有耳朵吗？</p><p>假如对以上这些问题的回答，都是“yes”，或者大部分都是“yes”，那么可以判定是人脸，否则不是人脸。但是，这种判断忽略了某些特殊情况，比如某个人没有长头发，某个人的左半边脸被花丛遮挡了等等，等处在这些环境中时，这种方法的判断可能会有问题。</p><p>承上，将原问题分解为子问题的过程如果用神经网络来表达的话，可以这样表示，方框表示为某个子网络：</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/v2-ede0b2e88c349591fa6e47c4d3a96b8e_720w.webp" alt=""></p><p>以上每个子网络，还可以进一步分解为更小的问题，比如判断左上是一个眼睛吗的问题，可以分解为：</p><p>有眼球吗？<br>有眼睫毛吗？<br>有虹膜吗？<br>…</p><p>以上，这个子网络还可以进一步分解，.一层又一层地分解，直到，回答的问题简单到能在一个单独的神经元上被回答。</p><p>这种带有两个或多个隐含层的神经网络，称为深度神经网络，deep neural networks，简称为 DNN。</p><h3 id="为什么要使用编码器和解码器"><a href="#为什么要使用编码器和解码器" class="headerlink" title="为什么要使用编码器和解码器"></a>为什么要使用编码器和解码器</h3><p>编码器是压缩数据，解码器是还原数据。一压一还意义何在？</p><p>编码：捕获了输入数据的最重要的特征，并且舍弃了一些不重要的细节；数据被压缩后，对硬件的负担也变小了。</p><p>解码：使重建的数据尽可能接近原始输入数据。</p><p>训练过程中，Convolutional Autoencoder (CAE)通常使用重构损失（比如均方误差）来衡量重建的数据和原始输入数据的差异，然后通过反向传播和优化算法来不断调整网络参数，使得重构损失最小。</p><p>总的来说，Convolutional Autoencoder (CAE)的主要步骤是：输入数据 —&gt; 编码器（卷积+池化）—&gt; 潜在特征表示 —&gt; 解码器（上采样+卷积）—&gt; 输出数据（重建的数据）。</p><h3 id="熵、信息熵、相对熵、KL散度、交叉熵损失、softmax"><a href="#熵、信息熵、相对熵、KL散度、交叉熵损失、softmax" class="headerlink" title="熵、信息熵、相对熵、KL散度、交叉熵损失、softmax"></a>熵、信息熵、相对熵、KL散度、交叉熵损失、softmax</h3><h4 id="softmax"><a href="#softmax" class="headerlink" title="softmax"></a>softmax</h4><p>softmax函数能够将未规范化的预测变换为非负数并且总和为1，同时让模型保持 可导的性质</p><h4 id="熵和信息熵"><a href="#熵和信息熵" class="headerlink" title="熵和信息熵"></a>熵和信息熵</h4><p>熵和信息熵本质是一个东西，就是换了个说法而已。</p><p>熵：在信息论中则表示事务的不确定性。信息量与信息熵是相对的，告诉你一件事实，你获取了信息量，但减少了熵。或者说，得知一件事实后信息熵减少的量，就是你得到的这个事实所包含的信息的量。</p><p>熵的公式：$H(x)=-\sum<em>{i=1}^{n} P\left(x</em>{i}\right) \log <em>{2} P\left(x</em>{i}\right)$</p><p>n:表示随机变量可能的取值<br>x:表示随机变量<br>P(x):表示随机变量x的概率函数</p><p><strong>log以10，2或者e为底，对结果熵的判断没有影响</strong></p><h4 id="相对熵和交叉熵"><a href="#相对熵和交叉熵" class="headerlink" title="相对熵和交叉熵"></a>相对熵和交叉熵</h4><p><strong>相对熵就是KL散度</strong></p><p>$D<em>{K L}(p | q)=\sum</em>{i=1}^{n} p\left(x<em>{i}\right) \log \left(\frac{p\left(x</em>{i}\right)}{q\left(x_{i}\right)}\right)$</p><p>用于衡量两个概率分布之间的差异。</p><p>我们把上面的公式展开</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/Snipaste_2023-04-07_10-59-34.png" alt=""></p><script type="math/tex; mode=display">\begin{aligned} D_{K L}(p \| q)&=\sum_{i=1}^{n} p\left(x_{i}\right) \log \left(\frac{p\left(x_{i}\right)}{q\left(x_{i}\right)}\right) \\               &=\sum_{i=1}^{n}p(x_{i})l o g\,p(x_{i})-\sum_{i=1}^{n}p(x_{i})l o g q(x_{i})\\               &= -(-\sum_{i=1}^{n}p(x_{i})l o g\,p(x_{i})) - \sum_{i=1}^{n}p(x_{i})l o g q(x_{i})                     \\               &=  -H(P) + H(P,Q)               \\               &= H(P,Q) -H(P)              \\               &= 交叉熵 - 信息熵                      \\\end{aligned}</script><p>p(x)表示真实概率分布，q(x)表示预测概率分布<br><strong>交叉熵刻画的是实际输出（概率）与期望输出（概率）的距离，也就是交叉熵的值越小，两个概率分布就越接近，即拟合的更好。</strong></p><p>当p(x)=q(x)时，相对熵为0<br>相对熵越小越好，相对熵和交叉熵的差距只有一个常数。那么相对熵达到最小值的适合，也就是交叉熵达到最小的时候。所以对q(x)的优化等效于求交叉熵的最小值，交叉熵的最小值也就是求最大似然估计</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/v2-95c59c2a55a6782d45b20b9e00913da7_1440w.webp" alt=""></p><h4 id="似然函数、极大似然函数"><a href="#似然函数、极大似然函数" class="headerlink" title="似然函数、极大似然函数"></a>似然函数、极大似然函数</h4><p>p(x|θ)也是一个有着两个变量的函数。如果，你将θ设为常量，则你会得到一个概率函数（关于x的函数）；如果，你将x设为常量你将得到似然函数（关于θ的函数）。</p><p>概率描述的是：指定参数后，预测即将发生事件的可能性；</p><p>似然描述的是：在已知某些观测所得到的结果时，对有关事物的性质的参数进行估计；</p><p>极大似然估计是在已知一堆数据和分布类型的前提下，反推最有可能的参数是什么，也就是“它最像这个分布哪组参数下表现出来的数据”。</p><p>举个例子：</p><p>将抽球结果作为$X$，即离散随机变量，设白球为<br>$X=1$，黑球为 $X=0$。假设抽到白球的概率为 $\theta$，$\theta$ 即是未知的需要通过极大似然估计得出的参数。</p><p>写出一次预测的似然函数：</p><script type="math/tex; mode=display">L(\theta|x)=f(x|\theta)=P(x,\theta)=\theta^{x}*{(1-\theta)}^{(1-x)}</script><p>这里解释下为什么是这样的：</p><p>如果抽到的是白球，就是$X=1$,密度函数是$\theta$，带入公式没有问题；<br>如果抽到的是黑球，就是$X=0$,密度函数是$1-\theta$，带入公式没有问题；</p><p>对于二项分布，出现符合观测情况的，白球出现7次，黑球出现三次的概率密度函数为<br>$P(X,\theta)=P(x1,\theta)<em>P(x2,\theta)</em>..\cdot P(x10,\theta)=\theta^{7}*(1-\theta)^{3}$</p><p>写成似然函数形式为：</p><p>$L(\theta|X)=P(X,\theta)=\theta^{7}*(1-\theta)^{3}$</p><h4 id="似然函数和交叉熵的关系"><a href="#似然函数和交叉熵的关系" class="headerlink" title="似然函数和交叉熵的关系"></a>似然函数和交叉熵的关系</h4><p>为了求最大的似然函数，我们往往取对数，最后发现二分类的极大似然函数和二分类交叉熵相同</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/Snipaste_2023-04-07_21-07-24.png" alt=""></p><p><a href="https://blog.51cto.com/u_15899958/5909794">原文链接</a></p><h3 id="训练集、验证集、测试集"><a href="#训练集、验证集、测试集" class="headerlink" title="训练集、验证集、测试集"></a>训练集、验证集、测试集</h3><p>在深度学习中，通常会将数据集划分为三个部分：训练集（Training Set）、验证集（Validation Set）和测试集（Test Set）。这三个数据集的主要目的是用于模型的训练、调优和评估。</p><ol><li><p>训练集（Training Set）：训练集是用来训练深度学习模型的数据集。模型在训练集上进行反向传播和参数更新，通过不断调整模型参数来拟合训练数据中的模式和规律。</p></li><li><p>验证集（Validation Set）：验证集是用于模型调优和选择最佳模型的数据集。在训练过程中，通过在验证集上评估模型的性能，可以及时监测模型的泛化能力和过拟合情况。通过对模型的超参数和结构进行调整，选择在验证集上表现最佳的模型。</p></li><li><p>测试集（Test Set）：测试集是用于最终评估模型性能的数据集。它是在训练和验证过程中没有被使用过的独立数据集。通过在测试集上评估模型的性能，可以获得对模型真实泛化能力的评估结果。测试集的结果可以用来判断模型的性能是否达到了预期要求。</p></li></ol><p>区别：</p><ul><li>训练集用于模型的训练，通过反向传播和参数更新来拟合数据集。</li><li>验证集用于模型的调优和选择最佳模型，通过评估模型在验证集上的性能来进行超参数和结构的调整。</li><li>测试集用于最终评估模型的性能，检验模型的泛化能力。</li></ul><p>这三个数据集的划分有助于确保模型在未见过的数据上具有较好的泛化能力，同时避免模型在训练过程中过度拟合训练数据。通常，数据集的划分比例是将数据的大部分分配给训练集（70-80%），一小部分用于验证集（10-15%），剩余的部分用于测试集（10-15%）。</p><h3 id="欠拟合、过拟合"><a href="#欠拟合、过拟合" class="headerlink" title="欠拟合、过拟合"></a>欠拟合、过拟合</h3><p><a href="https://zhuanlan.zhihu.com/p/72038532">原文链接</a></p><p>训练误差：模型在训练数据集上计算得到的误差</p><p>泛化误差：模型应用在同样从原始样本的分布中抽取的无限多数据样本时，模型误差的期望。</p><p>度量泛化能力的好坏，最直观的表现就是模型的过拟合（overfitting）和欠拟合（underfitting）。过拟合和欠拟合是用于描述模型在训练过程中的两种状态。一般来说，训练过程会是如下所示的一个曲线图。</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/v2-0ecc4dee7383ccf1995de08cdddc84d9_720w.jpg" alt=""></p><p>训练刚开始的时候，模型还在学习过程中，处于欠拟合区域。随着训练的进行，训练误差和测试误差都下降。在到达一个临界点之后，训练集的误差下降，测试集的误差上升了，这个时候就进入了过拟合区域——由于训练出来的网络过度拟合了训练集，对训练集以外的数据却不work。</p><ol><li>什么是欠拟合</li></ol><p>欠拟合是指模型不能在训练集上获得足够低的误差。换句换说，就是模型复杂度低，模型在训练集上就表现很差，没法学习到数据背后的规律。</p><ol><li><p>如何解决欠拟合<br>欠拟合基本上都会发生在训练刚开始的时候，经过不断训练之后欠拟合应该不怎么考虑了。但是如果真的还是存在的话，可以通过增加网络复杂度或者在模型中增加特征，这些都是很好解决欠拟合的方法。</p></li><li><p>什么是过拟合</p></li></ol><p>过拟合是指训练误差和测试误差之间的差距太大。换句换说，就是模型复杂度高于实际问题，模型在训练集上表现很好，但在测试集上却表现很差。模型对训练集”死记硬背”（记住了不适用于测试集的训练集性质或特点），没有理解数据背后的规律，泛化能力差。</p><ol><li>为什么会出现过拟合</li></ol><p>造成原因主要有以下几种：<br>1、训练数据集样本单一，样本不足。如果训练样本只有负样本，然后那生成的模型去预测正样本，这肯定预测不准。所以训练样本要尽可能的全面，覆盖所有的数据类型。<br>2、训练数据中噪声干扰过大。噪声指训练数据中的干扰数据。过多的干扰会导致记录了很多噪声特征，忽略了真实输入和输出之间的关系。<br>3、模型过于复杂。模型太复杂，已经能够“死记硬背”记下了训练数据的信息，但是遇到没有见过的数据的时候不能够变通，泛化能力太差。我们希望模型对不同的模型都有稳定的输出。模型太复杂是过拟合的重要因素。</p><ol><li>如何防止过拟合</li></ol><p>要想解决过拟合问题，就要显著减少测试误差而不过度增加训练误差，从而提高模型的泛化能力。我们可以使用正则化（Regularization）方法。那什么是正则化呢？正则化是指修改学习算法，使其降低泛化误差而非训练误差。</p><p>常用的正则化方法根据具体的使用策略不同可分为：（1）直接提供正则化约束的参数正则化方法，如L1/L2正则化；（2）通过工程上的技巧来实现更低泛化误差的方法，如提前终止(Early stopping)和Dropout；（3）不直接提供约束的隐式正则化方法，如数据增强等。</p><h3 id="学习率、batchsize、batch、epoch的区别"><a href="#学习率、batchsize、batch、epoch的区别" class="headerlink" title="学习率、batchsize、batch、epoch的区别"></a>学习率、batchsize、batch、epoch的区别</h3><ol><li>epoch:一个Epoch就是将所有训练样本训练一次的过程。然而，当一个Epoch的样本（也就是所有的训练样本）数量可能太过庞大（对于计算机而言），就需要把它分成多个小块，也就是就是分成多个Batch 来进行训练。</li><li>Batch（批 / 一批样本）:将整个训练样本分成若干个Batch。</li><li>Batch Size:每批样本的大小。</li><li>Iteration:训练一个Batch就是一次Iteration（这个概念跟程序语言中的迭代器相似）</li></ol><p>Batch Size定义：一次训练所选取的样本数。</p><p>Batch Size的大小影响模型的优化程度和速度。同时其直接影响到GPU内存的使用情况，假如GPU内存不大，该数值最好设置小一点。</p><h4 id="为什么要提出Batch-Size"><a href="#为什么要提出Batch-Size" class="headerlink" title="为什么要提出Batch Size?"></a>为什么要提出Batch Size?</h4><p>在没有使用Batch Size之前，这意味着网络在训练时，是一次把所有的数据（整个数据库）输入网络中，然后计算它们的梯度进行反向传播，由于在计算梯度时使用了整个数据库，所以计算得到的梯度方向更为准确。但在这情况下，计算得到不同梯度值差别巨大，难以使用一个全局的学习率，所以这时一般使用Rprop这种基于梯度符号的训练算法，单独进行梯度更新。</p><p>在小样本数的数据库中，不使用Batch Size是可行的，而且效果也很好。但是一旦是大型的数据库，一次性把所有数据输进网络，肯定会引起内存的爆炸。所以就提出Batch Size的概念。</p><h4 id="Batch-Size合适的优点："><a href="#Batch-Size合适的优点：" class="headerlink" title="Batch Size合适的优点："></a>Batch Size合适的优点：</h4><p>1、通过并行化提高内存的利用率。就是尽量让你的GPU满载运行，提高训练速度。</p><p>2、单个epoch的迭代次数减少了，参数的调整也慢了，假如要达到相同的识别精度，需要更多的epoch。</p><p>3、适当Batch Size使得梯度下降方向更加准确。</p><h4 id="Batch-Size从小到大的变化对网络影响"><a href="#Batch-Size从小到大的变化对网络影响" class="headerlink" title="Batch Size从小到大的变化对网络影响"></a>Batch Size从小到大的变化对网络影响</h4><p>1、没有Batch Size，梯度准确，只适用于小样本数据库</p><p>2、Batch Size=1，梯度变来变去，非常不准确，网络很难收敛。</p><p>3、Batch Size增大，梯度变准确，</p><p>4、Batch Size增大，梯度已经非常准确，再增加Batch Size也没有用</p><p>注意：Batch Size增大了，要到达相同的准确度，必须要增大epoch。</p><p>GD（Gradient Descent）：就是没有利用Batch Size，用基于整个数据库得到梯度，梯度准确，但数据量大时，计算非常耗时，同时神经网络常是非凸的，网络最终可能收敛到初始点附近的局部最优点。</p><p>SGD（Stochastic Gradient Descent）：就是Batch Size=1，每次计算一个样本，梯度不准确，所以学习率要降低。</p><p>mini-batch SGD：就是选着合适Batch Size的SGD算法，mini-batch利用噪声梯度，一定程度上缓解了GD算法直接掉进初始点附近的局部最优值。同时梯度准确了，学习率要加大</p><h4 id="学习率和batch对学习效果的影响"><a href="#学习率和batch对学习效果的影响" class="headerlink" title="学习率和batch对学习效果的影响"></a>学习率和batch对学习效果的影响</h4><p><a href="https://www.zhihu.com/question/32673260/answer/675161450">学习率和batch对学习效果的影响</a></p><h3 id="为什么把连续性特征离散化，离散化有何好处"><a href="#为什么把连续性特征离散化，离散化有何好处" class="headerlink" title="为什么把连续性特征离散化，离散化有何好处"></a>为什么把连续性特征离散化，离散化有何好处</h3><p><strong>数据离散化的原因主要有以下几点：</strong></p><p>1、算法需要</p><p>比如决策树、朴素贝叶斯等算法，都是基于离散型的数据展开的。如果要使用该类算法，必须将离散型的数据进行。有效的离散化能减小算法的时间和空间开销，提高系统对样本的分类聚类能力和抗噪声能力。</p><p>2、离散化的特征相对于连续型特征更易理解，更接近知识层面的表达</p><p>比如工资收入，月薪2000和月薪20000，从连续型特征来看高低薪的差异还要通过数值层面才能理解，但将其转换为离散型数据（底薪、高薪），则可以更加直观的表达出了我们心中所想的高薪和底薪。</p><p>3、可以有效的克服数据中隐藏的缺陷，使模型结果更加稳定</p><p><strong>离散化的优势</strong></p><ol><li><p>离散特征的增加和减少都很容易，易于模型的快速迭代；</p></li><li><p>稀疏向量内积乘法运算速度快，计算结果方便存储，容易扩展；</p></li><li><p>离散化后的特征对异常数据有很强的鲁棒性：比如一个特征是年龄&gt;30是1，否则0。如果特征没有离散化，一个异常数据“年龄300岁”会给模型造成很大的干扰；</p></li><li><p>逻辑回归属于广义线性模型，表达能力受限；单变量离散化为N个后，每个变量有单独的权重，相当于为模型引入了非线性，能够提升模型表达能力，加大拟合；</p></li><li><p>离散化后可以进行特征交叉，由M+N个变量变为M*N个变量，进一步引入非线性，提升表达能力；</p></li><li><p>特征离散化后，模型会更稳定，比如如果对用户年龄离散化，20-30作为一个区间，不会因为一个用户年龄长了一岁就变成一个完全不同的人。当然处于区间相邻处的样本会刚好相反，所以怎么划分区间是门学问；</p></li><li><p>特征离散化以后，起到了简化了逻辑回归模型的作用，降低了模型过拟合的风险。</p></li></ol><h3 id="深度学习的参数"><a href="#深度学习的参数" class="headerlink" title="深度学习的参数"></a>深度学习的参数</h3><p>参数是模型学习的各种权重和偏置。<br>$y=kx+b$<br>如果x是输入，y是输出。那么k就是权重，b就是偏置。训练模型学的就是权重和偏置。</p><p><strong>模型的大小通常是指模型参数的数量。一个模型参数的数量越多，模型就越大。</strong></p><p>卷积神经网络（Convolutional Neural Networks，CNN）的参数主要体现在卷积层、全连接层和偏置项中。这些参数包括每个卷积核的权重、全连接层中各节点的权重以及每一层的偏置项。</p><p>以一个简单的CNN为例，该网络包含一个卷积层和一个全连接层：</p><p>卷积层：假设输入图像大小为28x28x1（例如，灰度图像），卷积核大小为5x5，卷积核的数量为32。那么，卷积层的参数数量就是5x5x1x32（卷积核的宽度 x 卷积核的高度 x 输入的通道数 x 卷积核的数量）=800。（<strong>因为卷积核中的每个数目都是参数，不是固定的。所有卷积核的每一项都是参数</strong>）另外，每个卷积核都有一个对应的偏置项，所以卷积层的偏置项数量就是32。因此，卷积层的总参数数量为800+32=832。</p><p>全连接层：假设卷积层的输出通过池化和展平操作后，大小为512，然后连接到全连接层，全连接层的节点数量为10（例如，用于10分类的问题）。那么，全连接层的参数数量就是512x10=5120。同样，全连接层的偏置项数量就是10。因此，全连接层的总参数数量为5120+10=5130。</p><p>因此，这个CNN的总参数数量为832（卷积层）+5130（全连接层）=5962。这就是参数数量的计算方式。</p><h2 id="深度学习代码解析"><a href="#深度学习代码解析" class="headerlink" title="深度学习代码解析"></a>深度学习代码解析</h2><h3 id="自定义激活函数并调用"><a href="#自定义激活函数并调用" class="headerlink" title="自定义激活函数并调用"></a>自定义激活函数并调用</h3><pre class="line-numbers language-none"><code class="language-none">import torchimport torch.nn as nn# 定义一个自定义的激活函数class CustomActivation(nn.Module):    def __init__(self, a_init_value):        super().__init__()        self.a = nn.Parameter(torch.tensor(a_init_value))    def forward(self, x):        return 1.0 / (1.0 + torch.exp(-self.a * x))# 定义一个网络层，其中使用了自定义的激活函数class MyLayer(nn.Module):    def __init__(self, input_size, output_size):        super(MyLayer, self).__init__()        self.linear = nn.Linear(input_size, output_size)        self.custom_activation = CustomActivation(a_init_value=0.1)    def forward(self, x):        x = self.linear(x)        x = self.custom_activation(x)        return x# 使用自定义的网络层my_layer = MyLayer(10, 20)# 随机生成一个输入数据input_data = torch.randn(5, 10)# 使用自定义的网络层进行前向传播output_data = my_layer(input_data)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先，我们从torch.nn模块中导入Module类，然后定义了一个新的类CustomActivation，这个类继承了Module类，所以它也是一个PyTorch的网络模块。我们在CustomActivation类的初始化函数<strong>init</strong>中定义了一个可以训练的参数self.a。这个参数是用nn.Parameter函数从输入的初始化值a_init_value创建的，它会自动添加到模块的参数列表中，所以在优化过程中，优化器会自动更新这个参数。</p><p>在CustomActivation类的forward方法中，我们定义了这个自定义激活函数的具体操作。当我们用这个模块处理输入数据时，PyTorch会自动调用这个方法。在这个方法中，我们先用torch.exp函数计算-self.a * x的指数，然后再用1.0 / (1.0 + …)计算出这个自定义激活函数的输出。</p><p>接下来，我们定义了一个新的网络层MyLayer。这个网络层有一个线性层self.linear和一个自定义激活函数self.custom_activation。在这个网络层的forward方法中，我们先用线性层处理输入数据，然后再用自定义激活函数处理线性层的输出。</p><p>在这段代码的最后部分，我们创建了一个MyLayer的实例my_layer，然后用这个实例处理了一个随机生成的输入数据input_data。我们先用torch.randn函数生成了一个形状为(5, 10)的随机张量，然后把这个张量作为输入数据传递给了my_layer。在这个过程中，PyTorch会自动调用my_layer的forward方法，计算出网络层的输出。</p><p>总的来说，这段代码主要展示了如何在PyTorch中自定义一个激活函数，并把这个激活函数用在一个网络层中。在这个过程中，我们用到了PyTorch的Module类、Parameter类、Linear类等关键功能。</p><p>在my_layer = MyLayer(10, 20)中，10和20分别是神经网络层（线性层）的输入维度和输出维度。</p><p>输入维度10意味着每个输入样本应有10个特征。<br>输出维度20意味着该层将每个输入样本转换为具有20个特征的输出。<br>input_data = torch.randn(5, 10)中的5和10分别代表批次大小（batch size）和特征数。其中：</p><h2 id="度量学习"><a href="#度量学习" class="headerlink" title="度量学习"></a>度量学习</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>度量学习 (Metric Learning) == 距离度量学习 (Distance Metric Learning，DML) == 相似度学习。</p><p>在数学中,一个度量(或距离函数)是一个定义集合中元素之间”距离”的函数.</p><p>一个具有度量的集合可以称之为度量空间.</p><p><strong>“不同于分类学习，度量学习是通过学习数据之间的相似性程度来获得一个更有意义或者说更具可分性的特征空间。”</strong></p><h3 id="度量学习作用"><a href="#度量学习作用" class="headerlink" title="度量学习作用"></a>度量学习作用</h3><p>比较样本点和中心点的相似度.</p><h3 id="为什么要用度量学习-度量学习和传统分类方法的区别"><a href="#为什么要用度量学习-度量学习和传统分类方法的区别" class="headerlink" title="为什么要用度量学习/度量学习和传统分类方法的区别"></a>为什么要用度量学习/度量学习和传统分类方法的区别</h3><p>K-means、K近邻方法、SVM等算法，比较依赖于输入时给定的度量，比如：数据之间的相似性，那么将面临的一个基本的问题是如何获取数据之间的相似度。为了处理各种各样的特征相似度，我们可以在特定的任务通过选择合适的特征并手动构建距离函数。然而这种方法会需要很大的人工投入，也可能对数据的改变非常不鲁棒。度量学习作为一个理想的替代，可以根据不同的任务来自主学习出针对某个特定任务的度量距离函数。</p><h3 id="深度度量学习和传统度量学习的区别"><a href="#深度度量学习和传统度量学习的区别" class="headerlink" title="深度度量学习和传统度量学习的区别"></a>深度度量学习和传统度量学习的区别</h3><p>对于传统度量学习而言，由于其处理原始数据的能力有限，因此需要首先使用特征工程的知识对数据进行预处理，然后再用度量学习的算法进行学习。一些传统的度量学习方法只能学习出线性特征，虽然有一些能够提取非线性特征的核方法被提出，但对学习效果也没有明显提升。随着深度学习的出现，得益于激活函数学习非线性特征的优秀能力，深度学习方法能够自动地从原始数据中学出高质量的特征。因此深度学习的网络结构与传统的度量学习方法相结合能够带来理想的效果。如图2所示，采用MNIST作为例子，a中的橙色线条是同类样本之间的距离，蓝色线条是异类样本之间的距离。b是随着训练的进行，这两种距离的变化趋势。可以看出同类样本间距离减小，异类样本间距离增加。</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/v2-ff8034cbf2b2e8b8740bd1e92202febb_720w.webp" alt=""></p><h3 id="深度度量学习"><a href="#深度度量学习" class="headerlink" title="深度度量学习"></a>深度度量学习</h3><p>通过深层结构，学习到高抽象化的非线性特征以及数据之间的相似性关系。</p><p>DML三大关键点： <strong>采样策略、合适的距离度量函数以及模型结构</strong>，因此当前DML模型往往基于指定任务在这些方面进行改进。</p><p><a href="https://blog.csdn.net/supergxt/article/details/118155049">原文链接</a></p><h3 id="度量学习类别"><a href="#度量学习类别" class="headerlink" title="度量学习类别"></a>度量学习类别</h3><p>从广义上可以将度量学习分为:(1)通过线性变换的度量学习和非线性模型的度量学习.</p><p>（1）线性变换的度量学习</p><p>线性度量学习问题也称为马氏度量学习问题,又可以分为监督学习和非监督学习两类.</p><p>监督的全局度量学习：<br>Information-theoretic metric learning(ITML)<br>Mahalanobis Metric Learning for Clustering(MMC)<br>Maximally Collapsing Metric Learning (MCML)</p><p>监督的局部度量学习：<br>Neighbourhood Components Analysis (NCA)<br>Large-Margin Nearest Neighbors (LMNN)<br>Relevant Component Analysis(RCA)<br>Local Linear Discriminative Analysis(Local LDA)</p><p>非监督的度量学习：<br>主成分分析(Pricipal Components Analysis, PCA)<br>多维尺度变换(Multi-dimensional Scaling, MDS)<br>非负矩阵分解(Non-negative Matrix Factorization,NMF)<br>独立成分分析(Independent components analysis, ICA)<br>邻域保持嵌入(Neighborhood Preserving Embedding,NPE)<br>局部保留投影(Locality Preserving Projections. LPP)</p><p>（2）非线性模型<br>非线性降维算法可以看作属于非线性度量学习：<br>等距映射(Isometric Mapping,ISOMAP)<br>局部线性嵌入(Locally Linear Embedding, LLE)<br>拉普拉斯特征映射(Laplacian Eigenmap，LE ) </p><p>通过核方法来对线性映射进行扩展：<br>Non-Mahalanobis Local Distance Functions<br>Mahalanobis Local Distance Functions<br>Metric Learning with Neural Networks</p><h2 id="卷积神经网络（CNN）"><a href="#卷积神经网络（CNN）" class="headerlink" title="卷积神经网络（CNN）"></a>卷积神经网络（CNN）</h2><h3 id="传统神经网络"><a href="#传统神经网络" class="headerlink" title="传统神经网络"></a>传统神经网络</h3><p><a href="https://www.ruanyifeng.com/blog/2017/07/neural-network.html">原文链接</a></p><p>神经网络搭建需要满足三个条件：</p><ol><li>输入和输出</li><li>权重（w）和阈值（b）</li><li>多层感知器的结构</li></ol><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/bg2017071205.png" alt=""></p><p>其中，最困难的部分就是确定权重（w）和阈值（b）。目前为止，这两个值都是主观给出的，但现实中很难估计它们的值，必需有一种方法，可以找出答案。</p><p>这种方法就是试错法。其他参数都不变，w（或b）的微小变动，记作Δw（或Δb），然后观察输出有什么变化。不断重复这个过程，直至得到对应最精确输出的那组w和b，就是我们要的值。这个过程称为模型的训练。</p><p>因此，神经网络的运作过程如下：</p><ol><li>确定输入和输出</li><li>找到一种或多种算法（数学公式），可以从输入得到输出</li><li>找到一组已知答案的数据集，用来训练模型，估算w和b</li><li>一旦新的数据产生，输入模型，就可以得到结果，同时对w和b进行校正</li></ol><h3 id="传统神经网络数学公式推导（全连接）"><a href="#传统神经网络数学公式推导（全连接）" class="headerlink" title="传统神经网络数学公式推导（全连接）"></a>传统神经网络数学公式推导（全连接）</h3><p><a href="https://zhuanlan.zhihu.com/p/273595649">原文链接</a></p><h3 id="传统神经网络的问题"><a href="#传统神经网络的问题" class="headerlink" title="传统神经网络的问题"></a>传统神经网络的问题</h3><ol><li>图像需要处理的数据量太大，导致成本很高，效率很低</li></ol><p>现在随随便便一张图片都是 1000×1000 像素以上的， 每个像素都有RGB 3个参数来表示颜色信息。</p><p>假如我们处理一张 1000×1000 像素的图片，我们就需要处理3百万个参数！</p><p>1000×1000×3=3,000,000</p><p><strong>卷积神经网络 – CNN 解决的第一个问题就是「将复杂问题简化」，把大量参数降维成少量参数，再做处理。</strong></p><ol><li>图像在数字化的过程中很难保留原有的特征，导致图像处理的准确率不高<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/98412-2019-06-12-tuxiangtx.png.webp" alt=""></li></ol><p>假如有圆形是1，没有圆形是0，那么圆形的位置不同就会产生完全不同的数据表达。但是从视觉的角度来看，图像的内容（本质）并没有发生变化，只是位置发生了变化。</p><p>所以当我们移动图像中的物体，用传统的方式的得出来的参数会差异很大！这是不符合图像处理的要求的。</p><p><strong>CNN 解决了这个问题，他用类似视觉的方式保留了图像的特征，当图像做翻转，旋转或者变换位置时，它也能有效的识别出来是类似的图像。</strong></p><p>具体表现为：</p><p><strong>CNN（卷积神经网络）相对于传统的全连接神经网络（FNN），可以通过卷积层（权值共享、局部连接）和池化层（空间维度的降采样）的设计来实现参数降维，从而减少模型中的参数数量。</strong></p><h3 id="CNN的基本步骤"><a href="#CNN的基本步骤" class="headerlink" title="CNN的基本步骤"></a>CNN的基本步骤</h3><p>卷积神经网络（Convolutional Neural Network，CNN）是一种在计算机视觉和图像处理任务中广泛应用的深度学习模型。CNN通过模拟生物视觉系统中神经元的工作原理，能够自动学习图像和视频等数据的特征表示。</p><p>CNN的基本概念包括以下几个要素：<br><a href="https://blog.csdn.net/v_JULY_v/article/details/51812459">相关链接，写的不错</a></p><ol><li><p>卷积层（Convolutional Layer）：卷积层是CNN的核心组成部分。它通过使用一系列可学习的滤波器（也称为卷积核）对输入图像进行卷积操作，从而提取图像中的局部特征。卷积层的输出被称为特征图（Feature Map）。</p></li><li><p>池化层（Pooling Layer）：池化层用于减少特征图的空间维度，同时保留主要的特征信息。池化层也称为下采样。常用的池化操作包括最大池化（Max Pooling）和平均池化（Average Pooling）。池化层可以帮助减少计算量，提取图像的不变性，并且能够控制模型的过拟合。</p></li><li><p>激活函数（Activation Function）：激活函数引入非线性性质，使得CNN能够学习复杂的非线性特征。常用的激活函数包括ReLU（Rectified Linear Unit）、Sigmoid和Tanh等。</p></li><li><p>全连接层（Fully Connected Layer）：全连接层将前面的卷积层和池化层的输出连接到输出层，进行最终的分类或回归任务。</p></li><li><p>反向传播（Backpropagation）：CNN利用反向传播算法进行训练。反向传播通过计算损失函数关于模型参数的梯度，以更新模型参数来最小化损失函数。</p></li></ol><p>下面是一个简单的CNN示例，以图像分类为任务：</p><p>输入：一张32x32像素的彩色图像</p><ol><li>卷积层：使用一组3x3大小的卷积核，对输入图像进行卷积操作，得到特征图。</li><li>激活函数：对特征图的每个元素应用ReLU激活函数，增加非线性性质。</li><li>池化层：使用2x2大小的最大池化，将特征图的尺寸减半。</li><li>卷积层：再次使用一组3x3大小的卷积核，对池化后的特征图进行卷积操作，得到新的特征图。</li><li>激活函数：对新的特征图的每个元素应用ReLU激活函数。</li><li>池化层：再次使用2x2大小的最</li></ol><p>大池化，将特征图的尺寸减半。</p><ol><li>展平层（Flatten）：将池化层的输出展平为一维向量。</li><li>全连接层：将展平的向量连接到全连接层，并应用激活函数。</li><li>输出层：使用适当的激活函数（如Softmax）进行多类别分类。</li></ol><p>这个例子只是一个简化的CNN结构，实际中可能会有更多的卷积层、池化层和全连接层，以及一些正则化和优化技巧，来提高模型的性能和稳定性。</p><p>请注意，具体的CNN结构和参数设置会根据不同的任务和数据集而有所不同，需要根据实际情况进行调整和优化。</p><h3 id="CNN数学公式推导"><a href="#CNN数学公式推导" class="headerlink" title="CNN数学公式推导"></a>CNN数学公式推导</h3><p><a href="https://blog.csdn.net/weipf8/article/details/103917202">链接1</a></p><p><a href="https://tech.youmi.net/2016/07/163347168.html">链接2</a></p><p>卷积的过程：</p><!-- <img src="gif/convProcess.gif" width = "" height = ""> --><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/convProcess.gif" alt=""></p><p>卷积神经网络是权值共享，非全连接的神经网络。以2个卷积层和2个池化层的卷积神经网络为例，其结构图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/a7b9429e-436f-11e6-85c5-ceab16a79342.jpg" alt=""></p><p>从这个图可以看出几个关键的地方：</p><ol><li>卷积层和池化（采样）层结束的时候都需要一个激活函数，就是f(.)。</li><li>卷积核可以不止有一个，可以采用多个卷积核分别进行卷积, 这样便可以得到多个特征图。有时, 对于一张三通道彩色图片, 或者如第三层特征图所示, 输入的是一组矩阵, 这时卷积核也不再是一层的, 而要变成相应的深度.</li></ol><!-- <img src="gif/Three-channelFeature.gif" width = "" height = ""> --><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/Three-channelFeature.gif" alt=""></p><p>上图中是经过一次卷积后的结果，得到了3个特征图。再次卷积时，输入的是一组矩阵, 这时卷积核也不再是一层的, 而要变成相应的深度。, 最左边是输入的特征图矩阵, 深度为 3, 补零(Zero Padding)层数为 1, 每次滑动的步幅为 2. 中间两列粉色的矩阵分别是两组卷积核, 一组有三个, 三个矩阵分别对应着卷积左侧三个输入矩阵, 每一次滑动卷积会得到三个数, 这三个数的和作为卷积的输出. 最右侧两个绿色的矩阵分别是两组卷积核得到的特征图。</p><h3 id="如何理解多尺度CNN中的尺度"><a href="#如何理解多尺度CNN中的尺度" class="headerlink" title="如何理解多尺度CNN中的尺度"></a>如何理解多尺度CNN中的尺度</h3><p>在多尺度CNN中，”多尺度”指的是对输入数据进行不同尺度的处理和分析。这种处理方式可以帮助网络更好地捕捉到输入数据中的多尺度特征，从而提高模型的性能和泛化能力。</p><p>通常，多尺度CNN会通过以下几种方式来实现多尺度处理：</p><ol><li><p>多尺度输入：将输入数据在不同尺度下进行变换，例如通过缩放、裁剪或填充等操作，以获取不同尺度的图像输入。这样，网络可以同时关注不同尺度下的特征信息。</p></li><li><p>多尺度卷积：在网络的某些层中使用不同大小的卷积核或不同步长的卷积操作，以捕捉不同尺度的特征。这样，网络可以通过不同尺度的卷积感受野来分析输入数据。</p></li><li><p>多尺度池化：在池化层中使用不同大小的池化窗口或不同步长的池化操作，以对特征图进行降采样。这样可以保留不同尺度下的特征信息。</p></li><li><p>多尺度特征融合：将来自不同尺度的特征进行融合，以综合利用不同尺度的信息。这可以通过特征图的级联、加权求和、并行分支等方式来实现。</p></li></ol><p>通过多尺度处理，多尺度CNN能够更好地适应不同尺度的目标或特征，并更全面地理解输入数据。这对于许多计算机视觉任务如目标检测、语义分割和图像分类等是非常有益的。</p><h3 id="什么是CNN的尺度-scale"><a href="#什么是CNN的尺度-scale" class="headerlink" title="什么是CNN的尺度(scale)"></a>什么是CNN的尺度(scale)</h3><p><a href="https://blog.csdn.net/xjp_xujiping/article/details/110324506">原文链接</a></p><p><a href="https://blog.csdn.net/m0_47891203/article/details/124202487">相关链接</a></p><p>卷积神经网络里涉及到三种尺度：深度、宽度、分辨率。</p><ul><li>深度指的是网络有多深，或者说有多少层。</li><li>宽度指的是网络有多宽，比如卷积层的通道数。</li><li>分辨率指的是输入卷积层的图像、特征图的空间分辨率。</li></ul><p>也可以简单的理解为不同尺寸的图片，或者不同分辨率的图片。</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/7df63c0c5b279fc8251f0075c04f2a9f.png" alt=""></p><p>模型尺度。(a) 是一个基本的网络模型；(b)-(d) 分别单独在宽度、深度、分辨率的维度上增加尺度；(e) 是论文提出的混合尺度变换，用统一固定的比例放缩三个不同维度的尺度。</p><h3 id="感受野"><a href="#感受野" class="headerlink" title="感受野"></a>感受野</h3><p>若感受野太小，表明网络只能观察到图像的局部特征；若感受野太大，虽然对全局信息理解更强，但通常也包含了许多无效信息。为了提高有效感受野从而避免冗余信息，捕获多尺度特征是当前研究者们常采用的方法。比如拿望远镜看远方为小视野，直接光看为大视野。</p><h2 id="循环神经网络（RNN）"><a href="#循环神经网络（RNN）" class="headerlink" title="循环神经网络（RNN）"></a>循环神经网络（RNN）</h2><h3 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h3><p><a href="https://blog.csdn.net/v_JULY_v/article/details/89894058">原文链接</a></p><p><a href="https://zhuanlan.zhihu.com/p/30844905">原文链接</a></p><p>在实际应用中，我们还会遇到很多序列形的数据：</p><p>如：</p><ol><li>自然语言处理问题。x1可以看做是第一个单词，x2可以看做是第二个单词，依次类推。</li><li>语音处理。此时，x1、x2、x3……是每帧的声音信号。</li><li>时间序列问题。例如每天的股票价格等等。</li></ol><p><strong>而其中，序列形的数据就不太好用原始的神经网络处理了。所以为了解决一些这样类似的问题，能够更好的处理序列的信息，RNN就诞生了。</strong></p><p>一个简单的循环神经网络如下所示：<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/v2-3884f344d71e92d70ec3c44d2795141f_720w.webp" alt=""></p><p>我们现在这样来理解，如果把上面有W的那个带箭头的圈去掉，它就变成了最普通的全连接神经网络。x是一个向量，它表示输入层的值（这里面没有画出来表示神经元节点的圆圈）；s是一个向量，它表示隐藏层的值（这里隐藏层面画了一个节点，你也可以想象这一层其实是多个节点，节点数与向量s的维度相同）；</p><p>U是输入层到隐藏层的权重矩阵，o也是一个向量，它表示输出层的值；V是隐藏层到输出层的权重矩阵。</p><p>那么，现在我们来看看W是什么。循环神经网络的隐藏层的值s不仅仅取决于当前这次的输入x，还取决于上一次隐藏层的值s。权重矩阵 W就是隐藏层上一次的值作为这一次的输入的权重。</p><p>我们给出这个抽象图对应的具体图：</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/v2-206db7ba9d32a80ff56b6cc988a62440_720w.webp" alt=""></p><p>如果我们把上面的图展开，循环神经网络也可以画成下面这个样子：</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/v2-b0175ebd3419f9a11a3d0d8b00e28675_720w.webp" alt=""></p><p>现在看上去就比较清楚了，这个网络在t时刻接收到输入$x<em>t$之后，隐藏层的值是$s_t$，输出值是$o_t$ 。关键一点是,$s_t$的值不仅仅取决于$x_t$ ，还取决于$s</em>{t-1}$ 。我们可以用下面的公式来表示循环神经网络的计算方法：</p><p>用公式表示如下：<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/v2-9524a28210c98ed130644eb3c3002087_720w.png" alt=""></p><h3 id="RNN的局限：长期依赖（Long-TermDependencies）问题"><a href="#RNN的局限：长期依赖（Long-TermDependencies）问题" class="headerlink" title="RNN的局限：长期依赖（Long-TermDependencies）问题"></a>RNN的局限：长期依赖（Long-TermDependencies）问题</h3><p>一些更加复杂的场景。比如我们试着去预测“I grew up in France…I speak fluent French”最后的词“French”。当前的信息建议下一个词可能是一种语言的名字，但是如果我们需要弄清楚是什么语言，我们是需要先前提到的离当前位置很远的“France”的上下文。这说明相关信息和当前预测位置之间的间隔就肯定变得相当的大。</p><p>不幸的是，在这个间隔不断增大时，RNN会丧失学习到连接如此远的信息的能力。</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/38adde9a4649e5ea3809f10306d56bb0.png" alt=""></p><p>在理论上，RNN绝对可以处理这样的长期依赖问题。人们可以仔细挑选参数来解决这类问题中的最初级形式，但在实践中，RNN则没法太好的学习到这些知识。Bengio,etal.(1994)等人对该问题进行了深入的研究，他们发现一些使训练RNN变得非常困难的相当根本的原因。</p><p>换句话说， RNN 会受到短时记忆的影响。如果一条序列足够长，那它们将很难将信息从较早的时间步传送到后面的时间步。</p><p>因此，如果你正在尝试处理一段文本进行预测，RNN 可能从一开始就会遗漏重要信息。在反向传播期间（反向传播是一个很重要的核心议题，本质是通过不断缩小误差去更新权值，从而不断去修正拟合的函数），RNN 会面临梯度消失的问题。</p><p><strong>因为梯度是用于更新神经网络的权重值（新的权值 = 旧权值 - 学习率*梯度），梯度会随着时间的推移不断下降减少，而当梯度值变得非常小时，就不会继续学习。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/7e5e9272c2f6db440c4092bca444057f.png" alt="">​</p><p>换言之，在递归神经网络中，获得小梯度更新的层会停止学习—— 那些通常是较早的层。 由于这些层不学习，<strong>RNN会忘记它在较长序列中以前看到的内容，因此RNN只具有短时记忆。</strong></p><p>而梯度爆炸则是因为计算的难度越来越复杂导致。</p><p>然而，幸运的是，有个RNN的变体——LSTM，可以在一定程度上解决梯度消失和梯度爆炸这两个问题！</p><h3 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h3><p><a href="https://blog.csdn.net/v_JULY_v/article/details/89894058">原文链接</a></p><h3 id="LSTM变体"><a href="#LSTM变体" class="headerlink" title="LSTM变体"></a>LSTM变体</h3><p><a href="https://blog.csdn.net/v_JULY_v/article/details/89894058">原文链接</a></p><h3 id="Seq2Seq"><a href="#Seq2Seq" class="headerlink" title="Seq2Seq"></a>Seq2Seq</h3><p><a href="https://www.jianshu.com/p/80436483b13b">原文链接</a></p><h2 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h2><h3 id="KNN算法"><a href="#KNN算法" class="headerlink" title="KNN算法"></a>KNN算法</h3><p><a href="https://zhuanlan.zhihu.com/p/25994179">原链接</a></p><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>K近邻算法，即是给定一个训练数据集，对新的输入实例，在训练数据集中找到与该实例最邻近的K个实例，这K个实例的多数属于某个类，就把该输入实例分类到这个类中。（这就类似于现实生活中少数服从多数的思想）根据这个说法，咱们来看下引自维基百科上的一幅图：</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/v2-c3f1d2553e7467d7da5f9cd538d2b49a_720w.png" alt=""></p><p>如上图所示，有两类不同的样本数据，分别用蓝色的小正方形和红色的小三角形表示，而图正中间的那个绿色的圆所标示的数据则是待分类的数据。这也就是我们的目的，来了一个新的数据点，我要得到它的类别是什么？好的，下面我们根据k近邻的思想来给绿色圆点进行分类。</p><p>如果K=3，绿色圆点的最邻近的3个点是2个红色小三角形和1个蓝色小正方形，少数从属于多数，基于统计的方法，判定绿色的这个待分类点属于红色的三角形一类。</p><p>如果K=5，绿色圆点的最邻近的5个邻居是2个红色三角形和3个蓝色的正方形，还是少数从属于多数，基于统计的方法，判定绿色的这个待分类点属于蓝色的正方形一类。</p><p>从上面例子我们可以看出，k近邻的算法思想非常的简单，也非常的容易理解，那么我们是不是就到此结束了，该算法的原理我们也已经懂了，也知道怎么给新来的点如何进行归类，只要找到离它最近的k个实例，哪个类别最多即可。</p><h4 id="k近邻算法中k的选取以及特征归一化的重要性"><a href="#k近邻算法中k的选取以及特征归一化的重要性" class="headerlink" title="k近邻算法中k的选取以及特征归一化的重要性"></a>k近邻算法中k的选取以及特征归一化的重要性</h4><ol><li>选取k值以及它的影响</li></ol><p>如果我们选取较小的k值，那么就会意味着我们的整体模型会变得复杂，容易发生过拟合</p><p>如果我们选取较大的k值，就相当于用较大邻域中的训练数据进行预测，这时与输入实例较远的（不相似）训练实例也会对预测起作用，使预测发生错误，k值的增大意味着整体模型变得简单。我们很容易学习到噪声。</p><p>我们想，如果k=N（N为训练样本的个数）,那么无论输入实例是什么，都将简单地预测它属于在训练实例中最多的类。这时，模型是不是非常简单，这相当于你压根就没有训练模型呀！</p><ol><li>距离的度量<br>在上文中说到，k近邻算法是在训练数据集中找到与该实例最邻近的K个实例，这K个实例的多数属于某个类，我们就说预测点属于哪个类。</li></ol><p>定义中所说的最邻近是如何度量呢？我们怎么知道谁跟测试点最邻近。这里就会引出我们几种度量俩个点之间距离的标准。</p><p><strong>度量学习可以应用于此</strong></p><ol><li>特征归一化的必要性<br>为了保证每个特征同等重要性，我们这里对每个特征进行归一化。</li></ol><h2 id="线性神经网络"><a href="#线性神经网络" class="headerlink" title="线性神经网络"></a>线性神经网络</h2><h3 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h3><p>线性回归基于几个简单的假设： 首先，假设自变量$x$<br>和因变量$y$之间的关系是线性的， 即$y$可以表示为$x$<br>中元素的加权和，这里通常允许包含观测值的一些噪声； 其次，我们假设任何噪声都比较正常，如噪声遵循正态分布。</p><!-- 线性模型：$\hat{y}=w_1x_1+...+w_dx_d+b$ --><p><strong>线性回归的关键在于寻找最好的模型参数</strong>，需要两个东西：<br>（1）一种模型质量的度量方式：<strong>损失函数</strong><br>（2）一种能够更新模型以提高模型预测质量的方法：<strong>优化算法</strong></p><p>模型的优化过程就是：随机抽样一个小批量$\beta$，它是由固定数量的训练样本组成的。 然后，我们计算小批量的平均损失关于模型参数的导数（也可以称为梯度）。 最后，我们将梯度乘以一个预先确定的正数$\eta$，并从当前参数的值中减掉。</p><h2 id="conda常用命令"><a href="#conda常用命令" class="headerlink" title="conda常用命令"></a>conda常用命令</h2><ol><li>获取版本号<pre class="line-numbers language-none"><code class="language-none">conda --version// conda -V<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>获取帮助</p><pre class="line-numbers language-none"><code class="language-none">conda --helpconda -h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>查看某一命令的帮助，如update命令及remove命令</p><pre class="line-numbers language-none"><code class="language-none">conda update --helpconda remove --help<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>创建环境</p><pre class="line-numbers language-none"><code class="language-none">conda create --name your_env_name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p>创建制定python版本的环境</p><pre class="line-numbers language-none"><code class="language-none">conda create --name your_env_name python=2.7conda create --name your_env_name python=3conda create --name your_env_name python=3.5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>列举当前所有环境</p><pre class="line-numbers language-none"><code class="language-none">conda info --envsconda env list<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>进入某个环境</p><pre class="line-numbers language-none"><code class="language-none">activate your_env_name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>退出当前环境</p><pre class="line-numbers language-none"><code class="language-none">deactivate <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>复制某个环境<br></p><pre class="line-numbers language-none"><code class="language-none">conda create --name new_env_name --clone old_env_name <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>删除某个环境<p></p><pre class="line-numbers language-none"><code class="language-none">conda remove --name your_env_name --all<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="CUDA、CUDNN相关的内容"><a href="#CUDA、CUDNN相关的内容" class="headerlink" title="CUDA、CUDNN相关的内容"></a>CUDA、CUDNN相关的内容</h2><p>一般来说，如果要使用CUDA，一共需要安装3个东西Nvidia驱动、CUDA、CUDNN。</p><p>CUDA看作是一个工作台，上面配有很多工具，如锤子、螺丝刀等。cuDNN是基于CUDA的深度学习GPU加速库，有了它才能在GPU上完成深度学习的计算。它就相当于工作的工具，比如它就是个扳手。但是CUDA这个工作台买来的时候，并没有送扳手。想要在CUDA上运行深度神经网络，就要安装cuDNN，就像你想要拧个螺帽就要把扳手买回来。这样才能使GPU进行深度神经网络的工作，工作速度相较CPU快很多。</p><p>但是我们经常只安装CUDA Driver，比如我们的笔记本电脑，安装个CUDA Driver就可正常看视频、办公和玩游戏了。</p><h3 id="Nvidia驱动"><a href="#Nvidia驱动" class="headerlink" title="Nvidia驱动"></a>Nvidia驱动</h3><p>Nvidia驱动可以单独安装，也可以使用CUDA Toolkit Installer安装，CUDA Toolkit Installer通常会集成了GPU driver Installer和CUDA。<br>安装完成以后，使用<code>nvidia-smi</code>可以驱动是否安装成功。nvidia-smi 全称是 NVIDIA System Management Interface ，是一种命令行实用工具，旨在帮助管理和监控NVIDIA GPU设备。</p><h3 id="CUDA"><a href="#CUDA" class="headerlink" title="CUDA"></a>CUDA</h3><p>可以使用命令行、官网下载脚本、CUDA Toolkit Installer。<br><strong>不过目前看下来，使用官网下载的.run脚本（这是cuda10.1的安装包cuda_10.1.105_418.39_linux.run）是最容易成功的，虽然比较费时间。这个脚本里面也包含了驱动安装，如果安装了驱动，就不要再安装了</strong></p><p><strong>安装的时候我曾经遇到过gcc版本过高的问题，并且无法直接使用命令行来降低版本。只能通过网上下载低版本的包，然后再安装</strong><br>安装后使用<code>nvcc -v</code>来看是否安装成功</p><h3 id="nvcc和nvidia-smi的关系"><a href="#nvcc和nvidia-smi的关系" class="headerlink" title="nvcc和nvidia-smi的关系"></a>nvcc和nvidia-smi的关系</h3><p>nvcc 属于CUDA的编译器，将程序编译成可执行的二进制文件，nvidia-smi 全称是 NVIDIA System Management Interface ，是一种命令行实用工具，旨在帮助管理和监控NVIDIA GPU设备。</p><p>CUDA有 runtime api 和 driver api，两者都有对应的CUDA版本， nvcc —version 显示的就是前者对应的CUDA版本，而 nvidia-smi显示的是后者对应的CUDA版本。</p><p><strong>如果使用了单独的GPU driver installer来安装GPU dirver，这样就会导致 nvidia-smi 和 nvcc —version 显示的版本不一致了。</strong></p><p>通常，<strong>driver api的版本能向下兼容runtime api的版本，即 nvidia-smi 显示的版本大于nvcc —version 的版本通常不会出现大问题。</strong></p><h3 id="如何选择与CUDA版本匹配的Pytorch"><a href="#如何选择与CUDA版本匹配的Pytorch" class="headerlink" title="如何选择与CUDA版本匹配的Pytorch"></a>如何选择与CUDA版本匹配的Pytorch</h3><p>如果nvcc和nvidia-smi的版本不一致，应该如何选择pytorch的版本？<br><strong>选择与nvcc -v 对应的CUDA版本</strong></p><h2 id="pytorch安装"><a href="#pytorch安装" class="headerlink" title="pytorch安装"></a>pytorch安装</h2><h3 id="cuda安装"><a href="#cuda安装" class="headerlink" title="cuda安装"></a>cuda安装</h3><p><a href="https://zhuanlan.zhihu.com/p/94220564">原链接</a></p><p>桌面右键打开英伟达控制面板，点击帮助-&gt;系统信息-&gt;组件</p><p>可以看到支持的版本，安装的cuda版本必须小于等于该版本</p><p>安装好cuda后，安装cuDNN。<br>版本要和cuda对应起来</p><h3 id="miniconda和pytorch安装"><a href="#miniconda和pytorch安装" class="headerlink" title="miniconda和pytorch安装"></a>miniconda和pytorch安装</h3><p><a href="https://zhuanlan.zhihu.com/p/174738684">原链接</a></p><p><a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/">miniconda的镜像</a></p><p>要注意安装的是x86_64的版本，一开始装成的x86(32位，一直出问题)</p><p>安装pytorch的时候要进入<a href="https://pytorch.org/get-started/previous-versions/">这里</a>。根据对应的cuda版本来下载，最然根据教程来验证是否安装成果。</p><h3 id="安装jupyter-notebook"><a href="#安装jupyter-notebook" class="headerlink" title="安装jupyter notebook"></a>安装jupyter notebook</h3><p>安装jupyter notebook有三个办法：</p><p><strong>方法1：</strong><br><strong>为每一个 conda 环境 都安装 jupyter</strong></p><p>上面的安装好以后，使用<code>conda activate d2l</code>，激活d2l环境。<br>用<code>conda install jupyter</code>安装一直卡在那，换pip安装。但是还是因为网速原因没成功，可以使用临时换源的办法：</p><pre class="line-numbers language-none"><code class="language-none">pip install jupyter -i https://pypi.tuna.tsinghua.edu.cn/simple<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>方法2：</strong></p><p>在base环境安装好jupyter后</p><pre class="line-numbers language-none"><code class="language-none">conda create -n my-conda-env                               # creates new virtual envconda activate my-conda-env                                # activate environment in terminalconda install ipykernel                                    # install Python kernel in new conda envipython kernel install --user --name=my-conda-env-kernel   # configure Jupyter to use Python kernel<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后在base环境运行jupyter，下面两种方式都可以切换环境</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/微信图片_20230315114520.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/微信图片_20230315114528.png" alt=""></p><p><strong>缺点是你新建一个环境，就要重复操作一次</strong></p><p><strong>方法3：</strong></p><pre class="line-numbers language-none"><code class="language-none">conda activate my-conda-env    # this is the environment for your project and codeconda install ipykernelconda deactivateconda activate base      # could be also some other environmentconda install nb_conda_kernelsjupyter notebook<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：这里的 <code>conda install nb_conda_kernels</code> 是在 base 环境下操作的。</p><p>然后就可以进行conda环境求换，方式和法2相同。</p><p>本人在使用方法3的时候遇到了问题，web端显示500，命令行显示的关键信息如下：</p><p><strong>ImportError: cannot import name ‘contextfilter’ from ‘jinja2’</strong></p><p>最后的解决方法：<br></p><pre class="line-numbers language-none"><code class="language-none">conda update nbconvert<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p><h3 id="导入torchvision出现错误"><a href="#导入torchvision出现错误" class="headerlink" title="导入torchvision出现错误"></a>导入torchvision出现错误</h3><p>cuda和pythorch都安装成功的时候，且gpu也能正常使用。但是运行d2l里面的代码报错：<br></p><pre class="line-numbers language-none"><code class="language-none">import torch 成功import torchvision,报错DLL:找不到模块<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>根据torch版本找到对应的torchvision，然后卸载torchvision再安装，显示没有这个版本。当时安装torch的时候，torchvision也安装了，且版本正确。</p><p><strong>解决办法：</strong></p><ol><li>先查看一下Pillow的版本</li></ol><pre class="line-numbers language-none"><code class="language-none">pip show Pillow<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果没有直接安装<br></p><pre class="line-numbers language-none"><code class="language-none">pip install Pillow<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p><p>如果有，先卸载<br></p><pre class="line-numbers language-none"><code class="language-none">pip uninstall Pillow<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p><p>再安装<br></p><pre class="line-numbers language-none"><code class="language-none">pip install Pillow<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p><p>然后检验torchvision是否正常<br></p><pre class="line-numbers language-none"><code class="language-none">import torchvisiontorchvision.__version__ #'0.8.2'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p></p><h2 id="卷积相关的内容"><a href="#卷积相关的内容" class="headerlink" title="卷积相关的内容"></a>卷积相关的内容</h2><h3 id="网络模型参数的关系"><a href="#网络模型参数的关系" class="headerlink" title="网络模型参数的关系"></a>网络模型参数的关系</h3><p>编码器：<br></p><pre class="line-numbers language-none"><code class="language-none">convlstm_encoder_params = [    [        OrderedDict({'conv1_leaky_1': [1, 16, 3, 1, 1]}),        OrderedDict({'conv2_leaky_1': [64, 64, 3, 2, 1]}),        OrderedDict({'conv3_leaky_1': [96, 96, 3, 2, 1]}),    ],    [        CLSTM_cell(shape=(64,64), input_channels=16, filter_size=5, num_features=64),        CLSTM_cell(shape=(32,32), input_channels=64, filter_size=5, num_features=96),        CLSTM_cell(shape=(16,16), input_channels=96, filter_size=5, num_features=96)    ]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>OrderedDict定义了一个卷积层的参数，包括<strong>输入通道数、输出通道数、卷积核大小、步长和填充</strong>。<p></p><p>CLSTM_cell定义了一个CLSTM单元，包括<strong>特定的形状、输入通道数、滤波器（卷积核）大小和特征数量（隐藏状态通道数）</strong>。</p><p>下面给一个具体的例子：<br>输入到编码器的特征维度为（16, 10, 1, 64, 64）。</p><p>经过第一个卷积层conv1_leaky_1后，输出特征维度变为（16, 10, 16, 64, 64）。</p><p>之后，这个输出进入到第一个CLSTM_cell，此时shape为（64, 64），输入通道为16，经过卷积LSTM后，输出特征维度为（16, 10, 64, 64, 64）。</p><p>然后，这个输出经过第二个卷积层conv2_leaky_1，输出特征维度变为（16, 10, 64, 32, 32）。</p><p>然后，这个输出进入到第二个CLSTM_cell，此时shape为（32, 32），输入通道为64，经过卷积LSTM后，输出特征维度为（16, 10, 96, 32, 32）。</p><p>然后，这个输出经过第三个卷积层conv3_leaky_1，输出特征维度变为（16, 10, 96, 16, 16）。</p><p>最后，这个输出进入到第三个CLSTM_cell，此时shape为（16, 16），输入通道为96，经过卷积LSTM后，输出特征维度为（16, 10, 96, 16, 16）。</p><p>此时已经完成了编码阶段，这个输出将作为解码器的输入。</p><p>在解码阶段，过程类似：</p><p>这个输出经过第一个反卷积层deconv1_leaky_1，输出特征维度变为（16, 10, 96, 32, 32）。</p><p>然后，这个输出进入到第一个解码器的CLSTM_cell，此时shape为（32, 32），输入通道为96，经过卷积LSTM后，输出特征维度为（16, 10, 96, 32, 32）。</p><p>然后，这个输出经过第二个反卷积层deconv2_leaky_1，输出特征维度变为（16, 10, 96, 64, 64）。</p><p>然后，这个输出进入到第二个解码器的CLSTM_cell，此时shape为（64, 64），输入通道为96，经过卷积LSTM后，输出特征维度为（16, 10, 64, 64, 64）。</p><p>最后，这个输出经过最后一个卷积层conv3_leaky_1和conv4_leaky_1，最后的输出特征维度为（16, 10, 1, 64, 64），这就是最后的输出结果。</p><h3 id="图像尺寸、卷积核大小、步长、填充之间的关系或数学公式"><a href="#图像尺寸、卷积核大小、步长、填充之间的关系或数学公式" class="headerlink" title="图像尺寸、卷积核大小、步长、填充之间的关系或数学公式"></a>图像尺寸、卷积核大小、步长、填充之间的关系或数学公式</h3><pre class="line-numbers language-none"><code class="language-none">输出高度 = (输入高度 - 核高度 + 2 * 填充) / 步长 + 1输出宽度 = (输入宽度 - 核宽度 + 2 * 填充) / 步长 + 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="反卷积层：图像尺寸、卷积核大小、步长、填充之间的关系或数学公式"><a href="#反卷积层：图像尺寸、卷积核大小、步长、填充之间的关系或数学公式" class="headerlink" title="反卷积层：图像尺寸、卷积核大小、步长、填充之间的关系或数学公式"></a>反卷积层：图像尺寸、卷积核大小、步长、填充之间的关系或数学公式</h3><pre class="line-numbers language-none"><code class="language-none">OutputSize = (InputSize - 1) * Stride - 2 * Padding + KernelSize + OutputPadding其中：InputSize 是输入特征图的尺寸。Stride 是卷积核移动的步长。Padding 是在输入特征图周围填充的零的数量。KernelSize 是卷积核的尺寸。OutputPadding 是添加到输出尺寸的额外元素数量。一般在进行转置卷积时，如果希望输出尺寸刚好是输入尺寸的某个倍数，且不能通过调整步长和填充来达到，那么就需要使用OutputPadding。例如，如果你的输入特征图尺寸为16x16，你希望将其上采样为32x32，你使用的卷积核大小为4，步长为2，那么你可以将填充设置为1，无需OutputPadding。此时，使用上述公式计算得到的输出尺寸就为：OutputSize = (16 - 1) * 2 - 2 * 1 + 4 + 0 = 32因此，你的输出特征图的尺寸就为32x32。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="数据相关操作"><a href="#数据相关操作" class="headerlink" title="数据相关操作"></a>数据相关操作</h2><h3 id="轴（axis）"><a href="#轴（axis）" class="headerlink" title="轴（axis）"></a>轴（axis）</h3><p><a href="https://zhuanlan.zhihu.com/p/31275071">原文链接</a></p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[1,2,3],[2,3,4],[3,4,9]])&gt;&gt;&gt; aarray([[1, 2, 3],       [2, 3, 4],       [3, 4, 9]])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个array的维数只有2，即axis轴有两个，分别是axis=0和axis=1。如下图所示，该二维数组的第0维(axis=0)有三个元素(左图)，即axis=0轴的长度length为3；第1维(axis=1)也有三个元素(右图)，即axis=1轴的长度length为3。正是因为axis=0、axis=1的长度都为3，矩阵横着竖着都有3个数，所以该矩阵在线性代数是3维的(rank秩为3)。</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/v2-76b727aedf756d03c854f3b045345c23_r.png" alt=""></p><p>因此，axis就是数组层级。</p><p>当axis=0，该轴上的元素有3个(数组的size为3)</p><p>a[0]、a[1]、a[2]</p><p>当axis=1，该轴上的元素有3个(数组的size为3)</p><p>a[0][0]、a[0][1]、a[0][2]</p><p>（或者a[1][0]、a[1][1]、a[1][2]）</p><p>（或者a[2][0]、a[2][1]、a[2][2]）</p><p>再比如下面shape为(3,2,4)的array：<br></p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; b = np.array([[[1,2,3,4],[1,3,4,5]],[[2,4,7,5],[8,4,3,5]],[[2,5,7,3],[1,5,3,7]]])&gt;&gt;&gt; barray([[[1, 2, 3, 4],        [1, 3, 4, 5]],       [[2, 4, 7, 5],        [8, 4, 3, 5]],       [[2, 5, 7, 3],        [1, 5, 3, 7]]])&gt;&gt;&gt; b.shape(3, 2, 4)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>这个shape（用tuple表示）可以理解为在每个轴（axis）上的size，也即占有的长度（length)。为了更进一步理解，我们可以暂时把多个axes想象成多层layers。axis=0表示第一层(下图黑色框框)，该层数组的size为3，对应轴上的元素length = 3；axis=1表示第二层(下图红色框框)，该层数组的size为2，对应轴上的元素length = 2；axis=2表示第三层(下图蓝色框框)，对应轴上的元素length = 4。<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/v2-5c8aad40f74a3adee72f8f7fb5be89a6_720w.webp" alt=""><p></p><h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><p><a href="https://blog.csdn.net/weixin_44330492/article/details/100126774?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-100126774-blog-78934529.235%5Ev38%5Epc_relevant_anti_t3&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-100126774-blog-78934529.235%5Ev38%5Epc_relevant_anti_t3&amp;utm_relevant_index=1">原文链接</a></p><pre class="line-numbers language-none"><code class="language-none">import numpya=numpy.arange(1, 7).reshape((2, 3))b=numpy.arange(7, 13).reshape((2, 3))c=numpy.arange(13, 19).reshape((2, 3))d=numpy.arange(19, 25).reshape((2, 3))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这四个用于堆叠的数组如下所示：<br></p><pre class="line-numbers language-none"><code class="language-none">[[1 2 3]            [4 5 6]] [[ 7  8  9] [10 11 12]] [[13 14 15] [16 17 18]] [[19 20 21] [22 23 24]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><pre class="line-numbers language-none"><code class="language-none">print(numpy.stack([a, b,c,d], axis=0))print(numpy.stack([a, b,c,d], axis=0).shape)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>输出结果：</p><pre class="line-numbers language-none"><code class="language-none">[[[ 1  2  3]               [ 4  5  6]] [[ 7  8  9]  [10 11 12]] [[13 14 15]  [16 17 18]] [[19 20 21]  [22 23 24]]]  (4, 2, 3)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>形象理解：<strong>axis等于几就说明在哪个维度上进行堆叠</strong>。当axis=0的时候，意味着整体，也就是一个2行3列的数组。所以对于0维堆叠，相当于简单的物理罗列，比如这四个数组代表的是4张图像的数据，进行0维堆叠也就是把它们按顺序排放了起来，形成了一个(4,2,3)的3维数组。</p><p>axis=1<br></p><pre class="line-numbers language-none"><code class="language-none">print(numpy.stack([a, b,c,d], axis=1))print(numpy.stack([a, b,c,d], axis=1).shape)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br>输出：<br><pre class="line-numbers language-none"><code class="language-none">[[[ 1  2  3]  [ 7  8  9]  [13 14 15]  [19 20 21]] [[ 4  5  6]  [10 11 12]  [16 17 18]  [22 23 24]]]  (2, 4, 3)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>形象理解：<strong>axis等于几就说明在哪个维度上进行堆叠</strong>。当axis=1的时候，意味着第一个维度，也就是数组的每一行。所以对于1维堆叠，4个2行3列的数组，各自拿出自己的第一行数据进行堆叠形成3维数组的第一“行”，各自拿出自己的第二行数据进行堆叠形成3维数组的第二“行”，从而形成了一个(2,4,3)的3维数组。比如这四个数组分别代表的是对同一张图像进行不同处理后的数据，进行1维堆叠可以将这些不同处理方式的数据有条理的堆叠形成一个数组，方便后续的统一处理。<p></p><p>axis=2<br></p><pre class="line-numbers language-none"><code class="language-none">print(numpy.stack([a, b,c,d], axis=2))print(numpy.stack([a, b,c,d], axis=2).shape)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br><pre class="line-numbers language-none"><code class="language-none">[[[ 1  7 13 19]  [ 2  8 14 20]  [ 3  9 15 21]] [[ 4 10 16 22]  [ 5 11 17 23]  [ 6 12 18 24]]]  (2, 3, 4)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h3 id="concatenate"><a href="#concatenate" class="headerlink" title="concatenate"></a>concatenate</h3><p><a href="https://blog.csdn.net/weixin_41770169/article/details/80565073">原文链接</a></p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])&gt;&gt;&gt; b = np.array([[5, 6]])&gt;&gt;&gt; np.concatenate((a, b), axis=0)array([[1, 2],       [3, 4],       [5, 6]])&gt;&gt;&gt; np.concatenate((a, b.T), axis=1)array([[1, 2, 5],       [3, 4, 6]])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="pytorch中图像分割"><a href="#pytorch中图像分割" class="headerlink" title="pytorch中图像分割"></a>pytorch中图像分割</h3><p>简单版：<strong>reshape比view更加好用</strong><br>[原文链接]（<a href="https://blog.csdn.net/Flag_ing/article/details/109129752）">https://blog.csdn.net/Flag_ing/article/details/109129752）</a></p><p>我们以实际的代码来看下：<br></p><pre class="line-numbers language-none"><code class="language-none"># 输入的是一个5维数组，我要切割为80*20的小块batch_size, seq_length, channels, h, w = data.shape# n_h*n_w就是切割后的小块总数n_h = h // patch_hn_w = w // patch_w# 对原来的tensor形状进行变化images = images.view(batch_size, seq_length, channels, n_h, patch_h, n_w, patch_w)# 变化后进行重排序，原来是（0,1,2,3,4,5,6），变换后就是（batch_size, seq_length, channels，n_h， n_w， patch_h， patch_w）;再用reshape重构images.permute(0,1,2,3,5,4,6).reshape(batch_size, seq_length, channels, n_h*n_w, patch_h, patch_w)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h3 id="查看数据结构的维度的维度"><a href="#查看数据结构的维度的维度" class="headerlink" title="查看数据结构的维度的维度"></a>查看数据结构的维度的维度</h3><p><strong>tensor:</strong><br></p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt;a = torch.randn(2,2)&gt;&gt;&gt;a.shape    # 使用shape查看Tensor维度torch.Size([2,2])&gt;&gt;&gt;a.size()    # 使用size()函数查看Tensor维度torch.Size([2,2])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><strong>数组或list:</strong><br><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt;import numpy as np&gt;&gt;&gt;x = [[[1,2,3],[4,5,6]],[[7,8,9],[0,1,2]],[[3,4,5],[6,7,8]]]&gt;&gt;&gt;np.array(x).shape&gt;&gt;&gt;print(x.shape) (3, 2, 3)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h3 id="TensorDataset与DataLoader的使用"><a href="#TensorDataset与DataLoader的使用" class="headerlink" title="TensorDataset与DataLoader的使用"></a>TensorDataset与DataLoader的使用</h3><p><a href="https://blog.csdn.net/F845992311/article/details/123478399">原链接</a></p><p>TensorDataset是个只用来存放tensor(张量)的数据集，而DataLoader是一个数据加载器，一般用到DataLoader的时候就说明需要遍历和操作数据了。TensorDataset(tensor1,tensor2)的功能就是<strong>形成数据(特征)tensor1和标签tensor2的对应，也就是说tensor1中是数据，而tensor2是tensor1所对应的标签</strong>。需要注意的是，tensor1和tensor2的最高维数要相同。比如下面这个例子，tensor1.shape(12,3); tensor2.shape(12)</p><p>来个小例子:</p><pre class="line-numbers language-none"><code class="language-none">from torch.utils.data import TensorDataset,DataLoaderimport torch a = torch.tensor([[1, 2, 3],                  [4, 5, 6],                  [7, 8, 9],                  [1, 2, 3],                  [4, 5, 6],                  [7, 8, 9],                  [1, 2, 3],                  [4, 5, 6],                  [7, 8, 9],                  [1, 2, 3],                  [4, 5, 6],                  [7, 8, 9]]) b = torch.tensor([44, 55, 66, 44, 55, 66, 44, 55, 66, 44, 55, 66])train_ids = TensorDataset(a,b)# 切片输出print(train_ids[0:4]) # 第0,1,2,3行# 循环取数据for x_train,y_label in train_ids:    print(x_train,y_label)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面是对应的输出:<br></p><pre class="line-numbers language-none"><code class="language-none">(tensor([[1, 2, 3],        [4, 5, 6],        [7, 8, 9],        [1, 2, 3]]), tensor([44, 55, 66, 44]))===============================================tensor([1, 2, 3]) tensor(44)tensor([4, 5, 6]) tensor(55)tensor([7, 8, 9]) tensor(66)tensor([1, 2, 3]) tensor(44)tensor([4, 5, 6]) tensor(55)tensor([7, 8, 9]) tensor(66)tensor([1, 2, 3]) tensor(44)tensor([4, 5, 6]) tensor(55)tensor([7, 8, 9]) tensor(66)tensor([1, 2, 3]) tensor(44)tensor([4, 5, 6]) tensor(55)tensor([7, 8, 9]) tensor(66)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>从输出结果我们就可以很好的理解，tensor型数据和tensor型标签的对应了，这就是TensorDataset的基本应用。接下来我们把构造好的TensorDataset封装到DataLoader来操作里面的数据:<p></p><pre class="line-numbers language-none"><code class="language-none"># 参数说明，dataset=train_ids表示需要封装的数据集，batch_size表示一次取几个# shuffle表示乱序取数据，设为False表示顺序取数据，True表示乱序取数据train_loader = DataLoader(dataset=train_ids,batch_size=4,shuffle=False)# 注意enumerate返回值有两个,一个是序号，一个是数据（包含训练数据和标签）# enumerate里面可以不要1，直接写train_loader# format里面也可以写为ifor i,data in enumerate(train_loader,1):    train_data, label = data    print(' batch:{0} train_data:{1}  label: {2}'.format(i+1, train_data, label))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面是输出：<br></p><pre class="line-numbers language-none"><code class="language-none">batch:1 x_data:tensor([[1, 2, 3],       [4, 5, 6],       [7, 8, 9],       [1, 2, 3]])  label: tensor([44, 55, 66, 44])batch:2 x_data:tensor([[4, 5, 6],       [7, 8, 9],       [1, 2, 3],       [4, 5, 6]])  label: tensor([55, 66, 44, 55])batch:3 x_data:tensor([[7, 8, 9],       [1, 2, 3],       [4, 5, 6],       [7, 8, 9]])  label: tensor([66, 44, 55, 66])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h3 id="numpy-transpose-—坐标轴转换"><a href="#numpy-transpose-—坐标轴转换" class="headerlink" title="numpy.transpose()—坐标轴转换"></a>numpy.transpose()—坐标轴转换</h3><p><a href="https://blog.csdn.net/u012762410/article/details/78912667">原文链接</a></p><p>举个例子，假设x是一个二维数组，那么</p><pre><code class="lang-x.transpose((0,1))```">没有变化```x.transpose((1,0))</code></pre><p>把1轴的数据和0轴数据进行了交换</p><p>x 为：<br></p><pre class="line-numbers language-none"><code class="language-none">array([[0, 1],       [2, 3]])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p></p><p>我们不妨设第一个方括号“[]”为 0轴 ，第二个方括号为 1轴 ，则x可在 0-1坐标系 下表示如下：<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMjI3MTYxNDQ5MDA4.png" alt=""></p><p>因为 x.transpose((0,1)) 表示按照原坐标轴改变序列，也就是保持不变<br>而 x.transpose((1,0)) 表示交换 ‘0轴’ 和 ‘1轴’，所以就得到如下图所示结果：<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMjI3MTYyMjIyNTcz.png" alt=""></p><pre class="line-numbers language-none"><code class="language-none">x[0][0] == 0x[0][1] == 2x[1][0] == 1x[1][1] == 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>x 转置了<br></p><pre class="line-numbers language-none"><code class="language-none">array([[0, 2],       [1, 3]])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p></p><p>注意，任何时候你都要保持清醒，告诉自己第一个方括号“[]”为 0轴 ，第二个方括号为 1轴<br>此时，transpose转换关系就清晰了。</p><h3 id="numpy复制并扩充维度"><a href="#numpy复制并扩充维度" class="headerlink" title="numpy复制并扩充维度"></a>numpy复制并扩充维度</h3><p>a的shape从（96，96）变成（1000，96，96）</p><pre class="line-numbers language-none"><code class="language-none">np.expand_dims(a,0).repeat(1000,axis=0)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解释：<br>expand_dims表示增加一个维度，这个维度增加在a的0维度。repeat代表重复的次数，axis代表在哪个维度进行重复。</p><p>可以根据自己的需要更改参数。</p><h3 id="loss可视化"><a href="#loss可视化" class="headerlink" title="loss可视化"></a>loss可视化</h3><p>有时候我们想观察模型训练时候的loss，可以使用tesorboard。这里举个例子</p><pre class="line-numbers language-none"><code class="language-none">from torch.utils.tensorboard import SummaryWriter//将数据保存到指定的文件夹。这里注意下，一般是在代码根目录下面的./run/*。例如/run/202307230293tb = SummaryWriter(run_dir)//第一个参数是名称，第二个参数是y值，第三个参数是x值。(用x,y画图)tb.add_scalar('TranLoss', loss_aver, epoch)tb.add_scalar('ValidLoss', loss_aver, epoch)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们在run目录下面执行如下命令<br></p><pre class="line-numbers language-none"><code class="language-none">tensorboard --logdir=./202307230293//或者下面这个tensorboard --logdir=./202307230293 --port 8123<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br>如果不指定端口，那么默认是6006<p></p><p><strong>但是我们的代码是在内网跑的，很有可能只开放了22端口，本地浏览器通过 ip:端口 是没法访问的，考虑到安全性，是没法开其他端口，只有把端口映射出来</strong></p><p>这里以mobaxterm为例，xshell也可以[原链接](<a href="https://blog.csdn.net/qq_40944311/article/detail">https://blog.csdn.net/qq_40944311/article/detail</a></p><p>s/121396856)</p><ol><li>在Tools中打开MobaSSHTunnel(port forwarding)<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/311dadfca866487bbf1bff428bd9446d.png" alt=""></li><li>点击New SSH tunnel<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/1ee8c2a718bb4f00971e151933e81da8.png" alt=""></li><li>配置信息<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/417febd4d05c479d88adae9966308a04.png" alt=""><br>1、选择第一个Local port forwarding</li></ol><p>2、输入想要映射到本地的端口号</p><p>3、输入远程连接的信息，ip、用户名、ssh端口号22</p><p>4、输入服务器端被映射的端口信息</p><ol><li>点击运行<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/693532a9ffd84ed99182d4dfa8a17b1b.png" alt=""></li><li>访问端口<br>在服务器上run目录下输入<pre class="line-numbers language-none"><code class="language-none">tensorboard --logdir=./202307230293<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p>在本地浏览器输入 <strong>localhost:6006</strong><br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/f1012b75a3cb497fab1f00a76b5bb8d1.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>金融相关</title>
      <link href="/posts/8600/"/>
      <url>/posts/8600/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么不能直接印钱"><a href="#为什么不能直接印钱" class="headerlink" title="为什么不能直接印钱"></a>为什么不能直接印钱</h2><ol><li>美国不收人民币，只有外国人买了我们的东西，我们有了美元，才能去买美国人的东西。</li><li>多印的人民币，如果只在国内消费，那么迟早会让钱越来越贬值；如果国外消费，需要先兑换成美元，国家贮备的美元有限。即使成果兑换了，去外面买东西，别人也会拿钱来买中国的东西，要知道这样的钱最终会流向中国，可是这样的钱，是没有实际的价值支持的，这样的钱越多了，钱就不值钱了，这样必定会导到通货膨胀，钱不值钱了，钱变成了纸了，钱就失去了价值，这个国家的经济就会出现问题，金融危机就会暴发。</li></ol><p><a href="https://www.zhihu.com/question/67928805">https://www.zhihu.com/question/67928805</a></p><h2 id="金融机构杠杆率"><a href="#金融机构杠杆率" class="headerlink" title="金融机构杠杆率"></a>金融机构杠杆率</h2><h3 id="什么是杠杆"><a href="#什么是杠杆" class="headerlink" title="什么是杠杆"></a>什么是杠杆</h3><p><a href="https://www.zhihu.com/question/20417339/answer/136814369">金融机构的去杠杆化以及杠杆率是什么意思？ - 张立伟的回答 - 知乎</a></p><p>手里有10万，在A处获得20万的授信，拿到20万，买了30万的股票。</p><p>拿着30万的股票去B处，B看你有30万股票，又给你60万额度，用60万去买股票，手里有90万市值</p><p>这样反复循环，钱会翻很多倍。如果赚了就是很高的收益。但是风险也很高，在杠杆的加持下，赔了也是翻倍的赔。如果一段时间市场不涨不跌，当初借钱的年利率还在，也还是亏的，只有割舍本金。<br><strong>收益被杠杆放大的同时，贷款利率也被同样放大</strong></p>]]></content>
      
      
      <categories>
          
          <category> 金融 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 金融 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生活小知识</title>
      <link href="/posts/569/"/>
      <url>/posts/569/</url>
      
        <content type="html"><![CDATA[<h2 id="做饭"><a href="#做饭" class="headerlink" title="做饭"></a>做饭</h2><h3 id="一个人菜的分量"><a href="#一个人菜的分量" class="headerlink" title="一个人菜的分量"></a>一个人菜的分量</h3><p>以我个人一顿的量为例，因为我自己做饭一顿是一肉两个菜：<br>肉大概在150-160g左右<br>胡萝卜8-9cm左右<br>豌豆米、毛豆米、玉米粒大概是超市里面盒装的一半<br>白蘑菇7-8个<br>土豆：中等大小1个<br>番茄：1个</p><h3 id="炒肉"><a href="#炒肉" class="headerlink" title="炒肉"></a>炒肉</h3><ol><li>如果肉是片状或丝状等小面积，就是热锅冷油；如果肉是排骨这种大面积的，可以用热锅热油，因为面积大，不怕下锅就焦</li></ol><h3 id="煎荷包蛋"><a href="#煎荷包蛋" class="headerlink" title="煎荷包蛋"></a>煎荷包蛋</h3><p>注意事项：</p><ol><li>热锅冷油，油一定要少，因为蛋黄里面有油</li><li>火一定要开小，不然很快就焦了</li><li>第一面成形的时候可以开始翻动煎第二面 ，第二面好了就可以起锅</li></ol><h2 id="健康"><a href="#健康" class="headerlink" title="健康"></a>健康</h2><h3 id="发烧"><a href="#发烧" class="headerlink" title="发烧"></a>发烧</h3><p><strong>注：本文所写的知识由网上摘抄和自身经历结合，谨慎参考。</strong><br>发烧到底应该多盖点捂汗还是物理散热（冷敷） </p><ol><li>刚开始感觉到冷，可以喝点姜汤（如果有的话）</li><li>如果觉得冷那就多盖点捂汗，如果觉得热那就物理散热（冷敷）。</li><li>一般来说39°以上考虑物理散热。物理散热别盖那么厚，一般就好。物理散热可以用温毛巾擦拭全身，然后再用温毛巾夹在腋下，有必要也可也在额头放一个温毛巾或散热贴，如此反复。</li><li>时刻询问病人的身体状况，根据状况调整水的温度。当擦拭一个小时后，病人身体温度降下来，我开始第二个小时时还是用的原来的水，但是病人感觉冷了，凉了，就说明这时候他的体温降了，不需要再用这么凉的了，我就用温凉水涮洗毛巾放在额头及两个腋窝，擦拭身体局部换为了十分钟一次（如果还是感觉冷就可以不擦了）腋窝的毛巾只要有凉意就可以不用换了，只换额头的毛巾即可，也不用太频繁。</li><li>38.5°以上可以开始吃退烧药，低于这个温度可以不吃，吃一般的感冒药就好。退烧药不能多吃，吃多了器官受不了。</li><li>顺势而为，病人觉得舒服基本方向就没错。如果难受的受不了，马上停下来。</li></ol><hr><p><a href="https://www.zhihu.com/question/20237032/answer/17605688">原文链接</a></p><p>首先，体温调节的原理要搞清楚，一般都采用体温调定点学说：恒温动物有一确定的调定点数值（如人类为37℃），如果体温偏离这个数值，则通过反馈系统将信息送回调节中枢，对产热或散热活动加以调节，以维持体温的恒定。发热的原理：外生致热源进入人体（比如细菌），激发免疫，产生内生致热源，与下丘脑的受体结合，使体温的调定点升高，那么人体认为，你的体温是偏低的，就会促使你产热，并让你感到寒冷，战栗，起鸡皮疙瘩，同时这个时候一般是没有汗的。当体温升高到与调定点相同的时候，人不会再感到冷，反而会舒服一点。病原体被清除，调定点回到正常，这时候一般大汗淋漓，体温迅速回落。那么为什么要捂被子？我觉得是针对不是非常严重的发烧，想让体温升高，而不是降低，达到平衡期，从而缓解症状。经过人体调节，消除内生致热源的作用，体温调节点回复，然后你会大量出汗，恢复正常体温。但是，人的调节能力是有限的，是缓慢的，如果体温过高，高到影响人的意识了，这个时候，捂被子就不是明智之举了，我们一般就会采用物理降温的方法，迅速降温，保护机体的功能。所以，成人发热能不能捂被子？看你烧的严重不严重。同理，小儿的原理也是一样的，但是基本不会捂被子，为什么呢？小儿小丘脑的体温调节中枢可能发育未完全（大脑发育完全一般在13岁左右，至于这个调节中枢。。希望知道的人补充=。=），其次，小儿并没有完善的调节能力（肌肉，皮肤等）。你会发现，小儿一旦发热，随便就上39，40℃了。所以小儿发热，一般都需要物理降温，家长要密切观察，及时降温。（至于“高体温对于人体的危害”我就不赘述了，不属于题目的范畴）正确对待发热，体温不是很高的时候，多喝水，多休息，酌情盖被子。但是体温比较高的时候，还是要记得及时吃药，并降温！</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 发烧 </tag>
            
            <tag> 做饭 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>思考</title>
      <link href="/posts/8600/"/>
      <url>/posts/8600/</url>
      
        <content type="html"><![CDATA[<h2 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h2><h3 id="云南-80-后正厅级干部段颖被双开-，哪些信息值得关注？"><a href="#云南-80-后正厅级干部段颖被双开-，哪些信息值得关注？" class="headerlink" title="云南 80 后正厅级干部段颖被双开 ，哪些信息值得关注？"></a>云南 80 后正厅级干部段颖被双开 ，哪些信息值得关注？</h3><p>题目源自知乎，内容大多也源自知乎</p><p>背景：2月17日（2023年），云南省纪委监委网站通报了去年8月通报查处的“80后”正厅级干部段颖“双开”的消息。</p><p>通报称，经查，段颖丧失理想信念，背离初心使命，对抗组织审查，在组织函询时不如实说明问题；官德不修，底线失守，与私营企业主勾肩搭背，大搞权钱交易，长期收受礼品礼金，接受旅游活动安排，与他人搞权色交易；私德不正，严重违反社会公德、家庭美德，与多人发生不正当性关系；利用职务便利，为他人在承揽工程项目、工程款拨付、转接党组织关系等方面提供帮助，非法收受他人财物。</p><p>云南省纪委监委指出，段颖违反党的政治纪律、中央八项规定精神、组织纪律、廉洁纪律、工作纪律、生活纪律，构成职务违法，涉嫌受贿犯罪，且在党的十八大后不收敛、不收手，直至党的十九大后仍不知止，情节严重、性质恶劣，应予严肃处理。依据《中国共产党纪律处分条例》《中华人民共和国监察法》《中华人民共和国公职人员政务处分法》等有关规定，经云南省纪委常委会会议研究并报云南省委批准，决定给予段颖开除党籍处分；由云南省监委给予其开除公职处分；收缴其违纪违法所得；将其涉嫌犯罪问题移送检察机关依法审查起诉，所涉财物一并移送。</p><p><strong>—————————————-分割线—————————————————————————-</strong></p><p><strong>回答1：</strong></p><p><a href="https://www.zhihu.com/question/584646196/answer/2899770645">与多人发生不正当性关系，云南 80 后正厅级干部段颖被双开 ，哪些信息值得关注？ - 次肘子么的回答 - 知乎</a></p><p>对这种火箭提拔，毫无资源背景，大政绩，又飞速落马的的年轻官员。我只想到一个词，手套，用之即弃那种。</p><p>一个合格的手套，不能太聪明，又不能太愚蠢，而是清楚自己的身份，这样能保证，出事了，嘴会严，不乱咬，身后事，自然有人打点，这是规矩，不然以后谁还做手套。</p><p>拿床上那点事做掩护，代价最轻，各方面都能下得来台。抓个没啥背景的，付出的代价最小，沾边的也就是个内部警告，没听说过沾花边新闻下岗的，顶天算生活作风问题，大多也就是喝喝茶而已，新闻都不用上。</p><p>如果一张关系网，需要一个人当做利益输送的节点，这个人背景越干净越好，因为杀鸡儆猴的时候，不需要付出太大的政治代价。</p><p>不太恰当的比喻，很多企业成立新公司或者关联企业，法人基本都用素人，这个素人需要是领导信得过的亲信，过往履历干净，甚至查无此人，并且领导把握的住，不会出什么幺蛾子。</p><p>再说，投资促进局是干啥的，可以去查查规章制度，基本都是各种协调，跟踪，服务于本省的招商引资项目，不经手钱，但所有招商引资的计划都参与，像极了一家公司的行政办公室。</p><p>一个寻常的企业平台，啥岗位帮领导管钱，你以为是财务，其实利益枢纽，核心部门是行政，公章都在谁手里，是行政，财务去银行办对公账户事项，谁去监督，还是行政，没公章，你屁事办不了。</p><p>如果云南省招商引资这条线上，有体制内的人想抽油水，那么负责管后勤的岗位，用没家族背景和政治资源的亲信，最稳妥。出事就可以替换掉，啥也不影响。</p><p><strong>回答2：</strong></p><p><a href="https://www.zhihu.com/question/584646196/answer/2900543520">与多人发生不正当性关系，云南 80 后正厅级干部段颖被双开 ，哪些信息值得关注？ - 写手一条城的回答 - 知乎</a></p><p>看一下官方的通报：<br></p><pre class="line-numbers language-none"><code class="language-none">经查，段颖丧失理想信念，背离初心使命，对抗组织审查，在组织函询时不如实说明问题；官德不修，底线失守，与私营企业主勾肩搭背，大搞权钱交易，长期收受礼品礼金，接受旅游活动安排，与他人搞权色交易；私德不正，严重违反社会公德、家庭美德，与多人发生不正当性关系；利用职务便利，为他人在承揽工程项目、工程款拨付、转接党组织关系等方面提供帮助，非法收受他人财物。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>最大的问题在最前面的一句话里——<strong>对抗审查，不如实说明问题</strong>。<p></p><p>这句话的隐藏意思，大概率是段厅被别人牵出来了，而且是已经实锤的事儿。</p><p>审查，是给了段厅一个坦白交待的机会。</p><p>但是段厅显然也很清楚，事儿太大，如实说明等于死，还不如搏一搏。</p><p>那么「权色交易」这个词是在哪里？</p><p>是在官徳不修，底线失守，与私营企业主勾肩搭背，大搞权钱交易…..后边。</p><p>你注意看，这一个分号里的内容，是在说什么？</p><p>说的是：</p><p>段颖利用自己的「权」，换私营企业给的好处。</p><p>是段厅收了私营企业给的钱、给的礼品，接受了私营企业安排的旅游活动…….</p><p>还有，私营企业给段厅献上的「色」。</p><p>所以，这句话的含义，不是段厅用自己的姿色往上爬，是段厅爬上去以后，有人用小鲜肉献给段厅当礼物，段厅没把持住，给小鲜肉吸了。</p><p>再看后边，「与多人发生不正当性关系」，这个是说在哪里？</p><p>是在「严重违反社会公德、家庭美德」后边，你们该不会以为段厅是给多少个人当三吧？</p><p><strong>总结：严重的违纪放在前面</strong></p><h3 id="为什么当今社会单亲妈妈越来越多？"><a href="#为什么当今社会单亲妈妈越来越多？" class="headerlink" title="为什么当今社会单亲妈妈越来越多？"></a>为什么当今社会单亲妈妈越来越多？</h3><p><a href="https://www.zhihu.com/question/526069248/answer/3093422231">原文链接</a></p><p>女人所谓的感觉是什么？</p><p>视觉，男人的颜值；听觉，男人的花言巧语。</p><p>只要能调动你情绪的，你才会认为这是感觉。</p><p>部分骗子，是怎么骗人的？</p><p>骗术的核心，是调动人的情绪。在人情绪反常态的时候，在有限的时间里，做出失去理智的判断。</p><p>比如先和你说你儿子出车祸了，然后你慌了，然后告诉你正在抢救，要钱很急，你慌了就转了。</p><p>渣男，又是怎么渣的？<br>渣男的核心是从来不为说过的话复制。<br>可以昧着良心夸你，谈起未来可以无线画饼。<br>可以捕捉到你需要的情绪价值，然后在当下立刻提供出来。不需要考虑以后，因为他也没想过以后。</p><p><strong>评论区回答</strong><br>问：某女说：“我在网上刷到喜欢的小朋友，他就说这都是炒作”</p><p>答：你看，这就是我说的感觉。男的说话让你不爽。网上可爱的小朋友给你最直观的视觉听觉的可爱感受。男的确实不会说话，但是他想表达的是什么？是不是可以理解成网络上假的东西太多，我们不要过度关注和自己生活无关的东西。你觉得不爽，也是因为他没有迎合你。就好像男的拿一张美女身材照片，你会说人家都是p的，现实里这样的很少云云。男的一棍子打死这种方法确实让人反感，但是这种方法在现实里也能省去很多麻烦。</p><h2 id="政治"><a href="#政治" class="headerlink" title="政治"></a>政治</h2><h3 id="如何评价李德胜"><a href="#如何评价李德胜" class="headerlink" title="如何评价李德胜"></a>如何评价李德胜</h3><p>参考《关于建国以来党的若干历史问题的决议》</p><p>以下回答源自wiki:<br>会议指出，李德胜是“伟大的马克思主义者，是伟大的无产阶级革命家、战略家和理论家”，虽然晚年犯了严重错误，但是就他的一生来看则“功绩是第一位的，错误是第二位的”。撇除掉争议的部分，决议认为“他为我们党和中国人民解放军的创立和发展，为中国各族人民解放事业的胜利，为中华人民共和国的缔造和我国社会主义事业的发展，做出了永远不可磨灭的贡献。他为世界被压迫民族的解放和人类进步事业作出了重大贡献。”，提到正面部份则做积极的评价。</p><p>其思想的价值体现在三个方面：</p><ul><li>实事求是：即要理论联系实际，解放思想，用客观实践检验真理；</li><li>群众路线：即一切为了群众，一切依靠群众，从群众中来，到群众中去；</li><li>独立自主、自力更生：即要把方针要放在本国实际和本国人民力量的基点上，找出适合本国情况的发展道路。</li></ul><h3 id="少和别人谈政治"><a href="#少和别人谈政治" class="headerlink" title="少和别人谈政治"></a>少和别人谈政治</h3><p><strong>与人打交道的一个基本原则是求同存异</strong>。按理说真理是越辩越明，实际上，越辩越乱，朋友越辩越少。<br>因为成长环境、受教育程度不同等因素，导致不同的人对同一个问题的看法可能完全相反。</p><p>下面讲一个故事：</p><p><strong>故事前提：河畔上一对情侣对一些社会现象的看法产生了分歧，故事截取部分。</strong><br></p><pre class="line-numbers language-none"><code class="language-none">她:你是我见到的最痛恨国家的人我:相反，我是最爱国家的人，我看到国家的问题，我需要提出来，我希望国家好。如果国家做的任何举动，我都说好（没有@司马，老胡），那这是一种不负责任的行为她:可是你无时无刻在说国家不好我:首先，我没有无时无刻在说，武汉支援这种只有中国能调动的起来的事情我肯定了很多次。其次，国家做的好的地方，新闻，报纸，自媒体，春晚都在说，一天说了22h，我用剩下的2h说为什么不行?她:你受到什么虐待了，你可以举举例吗?你过得这么痛苦每天。我:高房价算不算?把地区平均房价与平均工资做比，中国应该是首屈一指的吧?她:但你明天就要买房了吗?你不是说你不买房吗?我:我是说我不买房，可是就算我嘴巴再硬，十年可以不买，二十年呢?三十年呢?中国人文化上就是要有自己的一套房的。她:可你明天要买房吗?你怎么知道未来十年二十年房价不会降呢?我:因为房价直降意味着将有大量的资产直接蒸发。假如房子去年值100万，今年只值70万了，那相当于30万凭空蒸发了。这将对社会稳定度，金融稳定度带来极大的冲击。她:我们不如说一说现在可能会影响到你的吧，这种未来一二十年的事先不讨论了。我:比如996。她:可你现在955啊，你不是996啊。我:可是我们这一行基本全是996啊，这意味着以后我一旦想跳槽，那就只能选996了。但996本身是一件违法劳动法的事啊。退一步来说，ok，就算996了，那工作时长翻倍了，是不是收入应当翻倍?可是没有。她:可你现在不是996啊?我:可我两年后是要跳槽的啊。她:那我只能说，人不能，既要又要。我:我想换一份符合劳动法的工作，竟然成为了既要又要。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>对于这个问题，有一个回答我比较认同：</p><p><strong>我想，和女朋友还是少谈起这个。和别人也少谈，乖孩子相信国家相信dang,他未必是什么都不懂，朋友圈天天转发的小粉红，他也未必是一个二极管。怎么解释这个呢：在《大明王朝1566》里，嘉靖问海瑞：独你一人是忠臣贤臣直臣，其他人都是奸臣？ 也未必，只是路线不同，有的人比较理想主义，喜欢直来直去，就像海瑞，有的人什么都懂，大明的腐败严嵩不懂吗？徐阶不懂嘛？他们只是把“大明天下无敌”当成保护色，也是可以理解的，为了利益最大化，并不是什么都不懂。</strong></p><h3 id="如何解决中国的形式主义"><a href="#如何解决中国的形式主义" class="headerlink" title="如何解决中国的形式主义"></a>如何解决中国的形式主义</h3><p><a href="https://www.zhihu.com/question/58537603/answer/2908490834">如何解决中国的形式主义？ - 两岸蛙声啼不住的回答 - 知乎</a></p><p>现在是2023年2月28日。看完这篇这篇帖子，让我觉得我有时候也有点愤青。如果我是89年在北京读大学的大学生，估计我会冲的更靠前。</p><p>被一些负面或极端的事情所影响，的确容易产生愤青的思想。但是稍微冷静下，看看这几十年的发展和变化，我想还是能知道，别人做了些事实。</p><p>“现在回头看看，我当时不过是以一个时间横切片去看待事物，这个国家一直在发现问题并且着手解决问题，每次看见脑满肠肥的官员出来讲场面话就觉得烦，但是过段时间会发现问题真的正在被解决。”</p><p>作为90后的我，亲眼见证了都江堰的飞速发展（虽然托了地震的福），见证了中国力量。20年疫情爆发，武汉的雷神山和火神山也是这样的。</p><p><strong>国家的成长和改变，靠形式主义是搞不出来的。形式主义确实存在，但更多的是真正办事的人，他们的行动在改变这个国家。如果你只沉浸于关注攻击形式主义，也许就错过了更值得关注的事，那些精彩的历史</strong>。</p><h3 id="产业升级"><a href="#产业升级" class="headerlink" title="产业升级"></a>产业升级</h3><p><a href="https://www.zhihu.com/question/492697855/answer/2809461325">想证明产业升级失败，有大神讲讲吗？ - 奈河的回答 - 知乎</a></p><p>中美必然要你死我活的干。因为只有世界级的金融和军工，才能支撑14亿人口达到中等发达国家人均GDP。现在这俩巨型产业是美国掌控。<br>目前世界就是存量博弈。我们不动美国的蛋糕，最多2万美元人均GDP。这还是抽干日本德国的汽车制造，同时干掉韩国的船舶和三星才能填饱。同时印度和东南亚的制造业不能起来的情况下。</p><p>只有把这两个行业的国际竞争力搞上去，中国的人均GDP才有希望上3w乃至于让全球以人民币去计人均。</p><p>以美国越来越急迫的态度而言，<strong>产业升级已经是取得了初步的成功了，包括大飞机，汽车等高端制造业已经实现了质的飞跃。</strong></p><p>但是距离拿下美帝手中的无上剑盾，还有着不小的距离。</p><p><strong>革命尚未成功，同志仍需努力。道阻且长，行则将至。</strong></p><h3 id="统战价值"><a href="#统战价值" class="headerlink" title="统战价值"></a>统战价值</h3><p><a href="https://www.zhihu.com/question/487315119/answer/2314888017">什么是统战价值？ - 宇宙区长孙连城的回答 - 知乎</a></p><p>统战价值：在法律法规范围内，公权力为了让你不闹腾而付出的行政成本，成本越大统战价值就越高。</p><p><strong>存在统战价值的人有以下特征：你与公权力存在某种潜在的共同利益，如果你配合公权力，可以给当局带来更多的利益，如果你疏远公权力，可以给当局造成一定的损失，而这个选择权完全在你自己，俗称会哭的孩子有奶吃。</strong></p><p>具体案例：在本科阶段，绝大多数的同学都是按部就班地刷绩点，争取奖学金，拼竞赛，辅导员和学院领导对他们的关心很少，而且他们非常谨小慎微，生怕留下不好的印象而导致评奖评优受影响。而我直接躺平，60分万岁，只求毕业两证，评奖评优一概不在乎，集体活动一律拒绝出席，综合成绩年年垫底，辅导员和学院领导反而更关心我，害怕我被孤立出现心理问题，害怕我无法正常毕业给学院增加麻烦，只求我平安毕业不要惹事，临毕业时各类手续也是一路绿灯帮我办好。</p><p>在这个案例里，循规蹈矩的学生对于学院而言是不存在破坏力的，他们只会无偿给学院增添荣誉，甚至有求于辅导员和学院领导，因此他们的统战价值极低。而我属于无欲无求型，一个无欲无求的人对于行政人员而言是最不好拿捏的，因为你根本抓不住他的痛点——你骂他不思进取不求上进，他只会摆烂给你看；你用荣誉激励他，他根本不在乎；你用集体荣誉感忽悠他，他只关心自己舒不舒服。如果他存心捣乱，还会增加行政人员付出的额外成本，因此我的统战价值高于那些循规蹈矩的学生。</p><p><strong>高校是体制内统战价值最高的一批人，因为他们大多可以随时润</strong></p><h2 id="求职"><a href="#求职" class="headerlink" title="求职"></a>求职</h2><h3 id="体制内的父母是否希望孩子考公务员"><a href="#体制内的父母是否希望孩子考公务员" class="headerlink" title="体制内的父母是否希望孩子考公务员"></a>体制内的父母是否希望孩子考公务员</h3><p>部分内容源自：<a href="https://www.zhihu.com/question/410518114/answer/2859518210">为什么体制内的父母都希望孩子考公务员？ - 知乎</a></p><ol><li>除了少数高级官员，大多数人本很少有人有抬头看路的能力，求稳派占大多数。没有几次人生重大决定是依靠自己对规律的认识、趋势的分析以及对自我的认识。真正有能力、会整合资源和看趋势的体制内长辈早就在90年代下海。呆在体制内一味求稳和厌恶风险的思想也会往下传导，而导致他们的孩子在未来择业时容易把稳定看成重要的因素。</li><li>稳定不是一成不变，这种稳定是依附在一个机构或体系上。这种稳定也买断了和市场共通的部分技能的能力，导致体制内的人不敢轻易退出。</li><li>机构或体系会随着时代而变化，体制内待遇的提升主要依靠“羌湖模式”带来的土地收入。随着土地财政模式的转变，未来体制内会将更多权力下放市场。生育率的降低，需要公共服务的人也变少。</li><li>权力和钱或资产不同，无法直接继承。不同时代人所处的大环境不同，导致有些经验无法借鉴。过去的经验和市场几乎不互通，告诉孩子好好学习却不知道教育在社会结构中担当什么作用，自己也缺乏实践经验的方法论传导。孩子成长的自我环境很难让他检视自己认知方面被环境塑造的部分，而孩子选择进入体制内一般也很难超越父母的位置。</li><li>体制内父母最大的优点在于养老不是一个大问题，应该早点发现孩子的能力和天赋，悉心引导和提供支持。</li><li>对社会运行规则和自我有充分认知的人不会被“毒打”。不用被一些言论左右，对自己的力量和潜力进行无信阉割和贬损。</li></ol><h3 id="博士毕业去高校"><a href="#博士毕业去高校" class="headerlink" title="博士毕业去高校"></a>博士毕业去高校</h3><p><a href="https://www.zhihu.com/question/352844946/answer/1733695101">博士毕业去高校难度大吗？ - 湾区博士的回答 - 知乎</a></p><p>写于2022年12月2日<br><strong>1. 直接争取大城市一本高校讲师岗</strong></p><p>包括那些个特聘副教授/副研究员什么的，其实都是噱头，即高级待遇，实则中级职称。</p><p><strong>这个选择难度较大</strong>，是大部分想进高校的首要选择，对学术成果、个人能力、导师实力要求较高。</p><p>想留在这类一本高校，则要在3年内（首个聘期）拿到国基-青基项目，并发表可观的论文。</p><p><strong>2.寻找海外/境外Top100高校的博后offer，并建议争取在2个高校待够2-3年</strong></p><p>这个选择难度适中，其实更多取决于博士导师有无海外人脉资源。</p><p>如果导师的海外人脉一般，或者说刚好没有合适的招人机会。</p><p>需要靠自己写套磁信进行海投去寻找海外导师，那难度就很大了。</p><p>首选Top100的高校，实在没有拿到offer，可以尝试Top200的高校。</p><p><strong>3.留下来做本校本导的博后，与导师商量好工作分配，最大化彼此的利益，并争取出国待1年（这个很关键）</strong></p><p>这个选择难度较小，申请博后是简单的事情，主要是争取出国访学有点难度。</p><p>如果自己博导本身在院里就是大牛级别，并且导师对你能力比较认可，看好你的发展，主动邀请你留下来做博后。</p><p>那么不用犹豫，选这个道路，是比较好的选择。</p><p>但是，如果自己博导在本院是普通水准、普通地位，那么我是不建议留在原团队开展博后工作的。</p><p>因为未来发展中你大概率还是得离开这个学校，3年后博后出站你再次面临找工作的焦虑。</p><p><strong>4.选择一线城市的二本高校，当然是建议找有编制的</strong></p><p>顺口提提编制，现在全国的趋势是取消编制，所以啊，现在如果有编制的高校，那可以说是末班车。</p><p>这个选择难度不小，但是相比选择1则要容易一些。</p><p>其优点是有编制，且工资不低（小学校特色，在编制薪资基础上继续补贴），工作压力小，生活轻松、滋润。</p><p>缺点是二本院校以教学为主，且可能没有相对应的科研平台。</p><p>针对这种情况，我倒是有一个可行的解决思路（仅作为提议哈）。进去二本院校之后与原校博导保持良好联系，形成合作关系，继续回原团队做科研，赚外快，提升生活质量。这里就有一个要求，即自己博导年纪没有很大，距离退休还有一定年份，科研跟自己形成期限较长的合作。这条出路我之前其实也没有怎么考虑，因为想做好科研，觉得二本院校的科研条件相对来说太弱了，所以一心想去一本高校。慢慢我才发觉，很多事情也不是那么的绝对，不同的选择有不同的应对策略。去一个竞争小、压力小的高校，拿到编制，先保障了自己的未来生活，再寻求其他科研机会。这样的“曲线救国”方案，现在看来是比较可行的。</p><p><strong>5. 去国内排名靠前的高校做博后</strong><br>这个选择难度较小，因为国内许多高校的博后门槛不高。</p><p>但是要注意一点，在国内高校做博后一定要进去大佬团队，打入大牛团队。</p><p>并且要与原导师保持良好的联络与合作，不然就真不如第1条。</p><p>但是这条出路是有风险的，相对比较不稳定。</p><p>所以如若想在国内前排高校做博后，除了要去到大团队，最好是该团队与原导师有一定的联系。</p><p>这样可以为自己谋求更多的利益。</p><p><strong>6. 选择省内其他城市的本科院校（包括一本二本）</strong></p><p>这个选择难度适中，只要有足够的的科研成果便有较大希望。</p><p>这类学校的待遇都很好，且留校希望也比较大，但是科研平台较弱，想在学术上有大跃进肯定不太方便。</p><p>另外小城市的生活质量当然跟大城市没得比，如果是想回老家发展的同学，就很适合走这个道路。</p><p><strong>7. 选择大城市一本的师资博后</strong><br>这个选择几乎没有难度，因为此类院校十分欢迎985博士过去从事博后研究，但是出站后留校难度则较大。</p><p>这条出路适合这样的人才：博士导师在目标高校学院里有人脉关系。</p><p>首先普通一本的博后经历的含金量是比较低的，如若自己未来无法留在该校，那么想去应聘更高水准的高校可以说是没有可能了，只能往二本院校走。</p><h3 id="博士毕业去高校还是企业"><a href="#博士毕业去高校还是企业" class="headerlink" title="博士毕业去高校还是企业"></a>博士毕业去高校还是企业</h3><p><a href="https://www.zhihu.com/question/267425239/answer/337241844">博士应该留高校还是去企业？ - pumaboy的回答 - 知乎</a></p><p>如果你在博士期间发的文章够多，文章水平够高，也是师从领域大牛或是老师的实力（各方面的实力，你懂的）足够，并且你个人头脑里的新想法足够多到你有自信在学术这条路上杀出一片属于自己的天地，那么很简单，高校欢迎你。</p><p>相反，你如果觉得自己的价值应该在于把自己的研究变成产品，变成实实在在可以看得见的利国利民的东西，那就不用考虑了产业界应该是你安身立命的好去处。</p><p>以上的一些说法都是比较极端的情况，那么一些不极端的情况，亦或是我个人不太清楚自己应该如何选择才能生存的更好该怎么办呢？</p><p>这时候就需要自己对自己的性格，能力，对生活的喜好，对生活水平的需求，家庭背景做一个综合评定来决定自己的出路。</p><h3 id="末流本科VS非升及走"><a href="#末流本科VS非升及走" class="headerlink" title="末流本科VS非升及走"></a>末流本科VS非升及走</h3><p><a href="33岁博士，中山大学助理教授和湖南师大讲师，选哪个？ - 菲克多可忒儿的回答 - 知乎https://www.zhihu.com/question/399563855/answer/1917014389">原文链接</a></p><p>核心观点：</p><p>第二.在我的原回答（也是更新过好几次的）中，似乎给读者造成了一种错觉：宁愿去末流地方本科院校，也不要去做各种非升即走的“高级博士后”。在此，我郑重声明：如果我的回答内容确实有这种指向或者倾向，是我的错，我在此申明更正这种我认为是错误的思想！！</p><p>第三.基于第2点，我诚恳地告诫所有潜在的读者朋友一句话：在你决定去那种地方本科院校，特别是那些经济落后、历史上一直都比较穷困、没有任何拿的出手的产业支撑的市（州）的学院时，千万要三思！！这种地方有几个特点：</p><ol><li>经济落后的背后更严重的是观念落后、管理落后、思想落后、教育落后、医疗落后，你本有机会在更好点儿的地方给你的下一代提供一个更好一点的教育和成长环境，但是你一旦去了这样的地方，这一切便与你无关了，你的下一代要从这种地方出来，又是一辈子的事情；</li><li>这种地方由于观念和管理落后，那离公平公正和法治就比较远，很多在好一点的地区或者城市理所当然、自然而然的事情，在这种地方便变得非同寻常，甚至难上加难，比如评职称评奖评绩效问题，年年改规定，年年不一样，但是有时候又无比死板，小到芝麻粒大小的事情，都有人搞手段压到你喘不过气来。另外，再以教育为例：在这种地方，你去的那个<em>学院，就是最高学府，你想给你以后的孩子请个兴趣老师或者学科老师，你都没有选择；然后，以医疗为例：在这种地方，一般最好的医院就是“*</em>市第一人民医院”，虽然是三甲，但是三甲和三甲之间的差别，比211和211之间的差距大的多，孩子老人感冒发烧，能给你折腾花进去大几千，这里的医师们每天下班后最大的乐趣就是打牌、打麻将、搞各种社交活动，而那些“真三甲”医院的医师们，下班后在给医学生修改论文、开组会、看文献、听最新医学报告、看医学书籍。你看看，你要选哪个？？你不博一把，你问心无愧不？博一把，上不封顶，最差还能去个经济条件稍微好点、离核心城市稍微近一些的地级市，也比去那穷乡僻壤之地强千百倍，对不？</li><li>这种类型的单位往往会开出比较高的安家费购房补贴之类的，这里边一般是当地政府承担一部分，学校给一部分，往往是分批次给，入职后一次性能拿到的可能不是很多，给的科研启动费有时候也会变着法子打折扣；此外，你博士毕业时，觉得三十万五十万很大一笔钱了，很多人一辈子都没见过这么多钱，心动了。但是，几十万，在人的一生来说，如果不是父母重疾在床需要救命，为了拿这笔钱享受生活而去这种地方，实乃不是明智之举。</li><li>一般这种学校的科研条件几乎没有，对实验学科极不友好，多数人在这种学校有成果，都得靠“科研外包”，找以前实验室的师兄师姐师弟师妹等关系帮自己做实验；这种类型的单位一般是没有硕士点的，更不会有博士点，不过最近几年为了硕士扩招，对硕士点审批进行大放水，很多地方学院也有硕士点了，但是，这样的学校，最好的生源，就是本校那些考不上稍微好点的外校又想读研的学生了，怎么样，大家可以自行脑补。</li><li>但是，一个萝卜一个坑，不管什么地方，都总有人会去。去这些地方的人，一般有三类：一类是成果实在太差实在没好的去处，二类是家庭或者家属等因素不得不选择这种地方（其实这个原因并不理智，因为选了这种地方大概率也给家里带不来什么综合效益），三类是幼稚的博士们觉得自己终于毕业了可以拜托原来的学校和导师可以“大干一场”了，这种很快会被打脸。不过，虽然存在不一定合理，但是存在也有存在的理由，这种地方学院也为以上三类博士提供了一个安身立命之处。去了这样地方，一定要有思想准备：这种地方，去了之后，一辈子都难以走出来。难以走出来的原因请看下一条：</li><li>一是客观主观等因素限制，难出成果；二是这种地方的学校会用各种手段，比如天价赔偿、服务期满后恶意扣留档案等方式拖住那些想跳槽的博士们，这一点这几年的案例层出不穷，不要有任何一点点侥幸心理。博士们是实实在在的个人，但是学校却是一个虚无的主体，这个主体干任何违法违规的事情，只要不是群众性质的或者会产生舆论的，学校作为一个虚无的主体，都会像空气一样，安然无恙。因此，得出结论：如果博士毕业，实在找不到合适的，可以当几年“高级博士后”博一把，搏一搏单车变摩托，赢了就赚了，输了也累积更多经验和成果，再去那种落后地方的本科院校也不迟，因为这种地方，永远都会缺人的，不用担心做完几年博后去不了。</li></ol><h3 id="31岁博士毕业是否适合进体制内"><a href="#31岁博士毕业是否适合进体制内" class="headerlink" title="31岁博士毕业是否适合进体制内"></a>31岁博士毕业是否适合进体制内</h3><p><a href="https://www.zhihu.com/question/582791172/answer/2938458683">31岁博士毕业，是否还适合进体制呢？ - 爽爽的老大的回答 - 知乎</a></p><p>我是沿海某省的985高校博士毕业，拿到了某个双一流高校的讲师offer(无非升即走)，两个研究所的offer，最后还是选择通过选调进入了某个省直机关，有几点是我在这个过程中考虑的，我们可以互相交流学习一下。</p><ol><li>去高校是否能按部就班拿到青基和国基。我觉得这是去高校前最需要考虑的一点。就我个人所识，青基的公平性较高，如果有研究基础，研究课题结合四个面向，再是基础研究，本子经过精雕细琢，机会还是很大，拿到青基之后，基本可以解决副教授的职称问题。但是国基和青基的水深程度很不一样，如果要评教授，没有国基估计需要大量的横向项目来解决。不要看现在你的导师手里横向不少，但是等到自己来的时候，可能并不这么乐观。一个是因为，现在的高校的生态紧张，资源紧张，985高校都有老师没有横向，想做校企联合的企业，在没有关系的情况下，肯定是会考虑学校平台的。二是因为，老师有一些横向来源是以前的同学，或者是学长学弟，那时候的大学生比现在的难度高太多，所以他们几乎都能在一些领域内做到较高水平，自己创业开办企业，这时候因为同学关系做校企联合顺理成章。我的导师去年的国基没有申请上，也算是让我放弃高校的一个重要原因，同时我也没有创业的同学或是家里有企业的，我觉得无论是纵向横向课题，我都没法规划一个方向。 </li><li>放弃研究所的原因有两点，一是不在核心，二是太累人了。HR面试的时候直言不讳地说，所里不喜欢所谓的90后职场整顿，项目没有做完就是要加班。当然所里开出的待遇确实也值得这些加班。研究所的核心部门一般都是总体设计或是总体规划部，这个部负责所里本子的起草，项目方案书写，可行性论证等等，其他的部门其实可以看为是业务部门。因为我的专业是老牌的工科专业，与这两个所的主要研究方向不一致，所以没有能去核心部门，想想也就放弃了。</li><li>对于前面朋友说，读到了博士不能接受一个学历比自己低很多人的职位更高，指使自己，我觉得这个存在问题。韩愈的《师说》说得很明白了，我觉得读到了博士，还不能真正认识到所谓的博士，教授，都是只是在某些的领域内有一定深度的研究，不能认识到在浩瀚的世界中时刻保持谦逊的学习姿态的话，应该好好想想这个博士给你带了什么，你又是为什么读了博士，它不是用来充门面的，也不是用来给自己增添虚荣心的。我们院有位杰青说得很好，他所带每位毕业的博士，都一定要在那个研究领域内超过自己才可以。这位杰青都这样，我们这些普通博士更应该孜孜矻矻。在体制内，博士刚进去就是一头雾水，更应该保持谦逊的态度学习。</li><li>对于选择公务员的一些心理活动。第一点的话是关于高校环境。很多人觉得高校环境简单。我在这个沿海的985高校待了近10年，走完了本硕博的路程，就我个人所见所感，高校老师想往上走，那和公务员是差不多的甚至还要更来事，尤其是没有什么根基的青椒，这点在去参加会议时的感触尤其深刻。如果说想躺平，两耳不闻窗外事，那为何不走选调呢。选调不用太来事，按部就班，在省直机关，处级干部不是太难，这个级别即使在部属高校里面，也是各个学院的（副）院长，学校各个处的（副）处长级别了。</li></ol><p><strong>总而言之，如果有信心拿到基金，高校首选，如果没有的话，选调省直机关较好，市直区直可以考虑但是不是很建议了。如果觉得自己最缺的是钱，那就去研究所。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思考 </tag>
            
            <tag> 求职 </tag>
            
            <tag> 政治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>singularity</title>
      <link href="/posts/23912/"/>
      <url>/posts/23912/</url>
      
        <content type="html"><![CDATA[<h2 id="def文件"><a href="#def文件" class="headerlink" title="def文件"></a>def文件</h2><p>如果我们要在singularity当中使用mpi，mpi需要加载环境变量才行。需要将用到的环境变量放到def文件中的%environment部分。</p><p>说一下%environment与%post的区别：<br>%environment里面的环境变量会在运行时加载；%post里面的环境变量会在build时加载</p><p><strong>官方给的mpich例子中的def文件中的%environment环境变量有误，需要更改其中的路径，否则会报错，找不到lib库。</strong></p><p>官方例子：<br></p><pre class="line-numbers language-none"><code class="language-none">%environment    # Point to MPICH binaries, libraries man pages    export MPICH_DIR=/opt/mpich-3.3.2    export PATH="$MPICH_DIR/bin:$PATH"    export LD_LIBRARY_PATH="$MPICH_DIR/lib:$LD_LIBRARY_PATH"    export MANPATH=$MPICH_DIR/share/man:$MANPATH<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>正确的例子：<br><pre class="line-numbers language-none"><code class="language-none">%environment    # Point to MPICH binaries, libraries man pages    export MPICH_DIR=/opt/mpich    export PATH="$MPICH_DIR/bin:$PATH"    export LD_LIBRARY_PATH="$MPICH_DIR/lib:$LD_LIBRARY_PATH"    export MANPATH=$MPICH_DIR/share/man:$MANPATH<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> singularity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Slurm 命令</title>
      <link href="/posts/34673/"/>
      <url>/posts/34673/</url>
      
        <content type="html"><![CDATA[<h2 id="基础概念介绍"><a href="#基础概念介绍" class="headerlink" title="基础概念介绍"></a>基础概念介绍</h2><p><a href="http://events.jianshu.io/p/58973da3b659">原链接</a><br>Slurm呢是一种脚本语言，是操作大型计算集群的脚本语言。<br>我们想象一下，如果我们很有钱，有个100台带带T100显卡的计算机组成的集群，我们怎么用呀？你可能会说，很简单呀就跑代码就是的。但是，请思考一下，如果我想同时用很多台计算机呢？那么这些计算机是不是要组成个局域网，然后我要写个代码协调这些计算机工作。是不是有点复杂了？</p><p>我们再想，如果这个集群我们希望能做大做强，不止给我一个人用，想给100个人，1000个人同时用，能行吗？这个时候自然还需要考虑协调用户的功能。这个协调用户包含很多东西，包括资源的分配，包括用户环境的安装等等。</p><p>是不是很复杂？这才哪到哪，我这还只是章口就来随便举的例子。真实的情况比这个要复杂的多得多，那我们怎么办？自己从头写代码来管理这个集群？显然不是，我们有专门的管理软件。这个管理软件呢不是我们今天的研究重点，我就不说了，我也不会哈哈哈哈。重点是如何使用这个管理软件，如何通过它来操作集群。我们呢正是通过slurm 脚本语言来控制这个管理软件的。</p><h2 id="集群常用概念"><a href="#集群常用概念" class="headerlink" title="集群常用概念"></a>集群常用概念</h2><p><strong>Resource</strong>：资源，作业运行过程中使用的可量化实体，包括硬件资源（节点、内存、CPU、GPU）和软件资源（License）<br><strong>Cluster</strong>：集群，包含计算、存储、网络等各种资源实体且彼此联系的资源集合，物理上一般由计算处理、互联通信、I/O存储、操作系统、编译器、运行环境、开发工具等多个软硬件子系统组成。<br><strong>Node</strong>：节点，是集群的基本组成单位，从角色上一半可以划分为管理节点、登录节点、计算节点、存储节点等。<br><strong>job</strong>：作业，物理构成，一组关联的资源分配请求，以及一组关联的处理过程。按交互方式，可以分为交互式作业和非交互式作业；按资源使用，可以分为串行作业和并行作业。<br><strong>queue</strong>：队列，带名称的作业容器，用户访问控制，资源使用限制。<br><strong>Job Schedule System</strong>：作业调度系统，负责监控和管理集群中资源和作业的软件系统。<br><strong>job step</strong>：作业步，单个作业可以有多个作业步。<br><strong>partition</strong>：分区，根据用户的权限，作业需要被提交到特定的分区中运行。<br><strong>tasks</strong>：任务数，默认一个任务使用一个CPU核，可理解为job需要的CPU核数。</p><h2 id="Slurm常用命令"><a href="#Slurm常用命令" class="headerlink" title="Slurm常用命令"></a>Slurm常用命令</h2><p>sbatch：提交作业脚本使其运行。<br>squeue：显示队列中的作业及作业状态。<br>scancel：取消排队或运行中的作业。<br>sinfo：显示节点状态。<br>scontrol：现实或设定slurm作业、队列、节点等状态。<br>salloc：为实时处理的作业分配资源：典型场景为分配资源并启动一个shell，然后用此shell执行srun命令去执行并行任务。<br>srun：交互式运行并行作业，一般用于短时间测试。</p><h2 id="Slurm作业提交"><a href="#Slurm作业提交" class="headerlink" title="Slurm作业提交"></a>Slurm作业提交</h2><p>slurm 有三种模式提交作业，分别为交互模式，批处理模式，分配模式，这三种方式只是作业提交方式的区别，在管理、调度、机时计算同等对待。</p><h3 id="srun"><a href="#srun" class="headerlink" title="srun"></a>srun</h3><pre class="line-numbers language-none"><code class="language-none">srun -J JOBNAME -p debug -N 2 -c 1 -n 32 --ntasks-per-node=16 -w node[3,4] -x node[1,5-6] --time=dd-hh:mm:ss --output=file_name --error=file_name --mail-user=address --mail-type=ALL mpirun -n 64 ./iPic3D ./inputfile/test.inp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="sbatch"><a href="#sbatch" class="headerlink" title="sbatch"></a>sbatch</h3><p>批处理作业是指用户编写作业脚本，指定资源需求约束，提交后台执行作业。提交批处理作业的命令为 sbatch，用户提交命令即返回命令行窗口，但此时作业在进入调度状态，在资源满足要求时，分配完计算结点之后，系统将在所分配的第一个计算结点（而不是登录结点）上加载执行用户的作业脚本。批处理作业的脚本为一个文本文件，脚本第一行以 “#!” 字符开头，并制定脚本文件的解释程序，如 sh，bash。</p><p>运行 sbatch filename 来提交任务；计算开始后，工作目录中会生成以 slurm 开头的.out 文件为输出文件（不指定输出的话）。</p><p>保存在运行程序目录下即可，文件名随意（可以无后缀，内容文本格式即可）；作业提交命令sbatch filename</p><p>简洁版:</p><p>确保 nodes * ntasks-per-node = ntasks</p><pre class="line-numbers language-none"><code class="language-none">#!/bin/bash#SBATCH -J test#SBATCH -p g1_user#SBATCH --nodes=1#SBATCH --ntasks-per-node=1#SBATCH --ntasks=1#SBATCH -o partition.out<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>详细版:</p><pre class="line-numbers language-none"><code class="language-none">#!/bin/bash                     %指定运行shell#提交单个作业#SBATCH --job-name=JOBNAME      %指定作业名称#SBATCH --partition=debug       %指定分区#SBATCH --nodes=2               %指定节点数量#SBATCH --cpus-per-task=1       %指定每个进程使用核数，不指定默认为1#SBATCH -n 32       %指定总进程数；不使用cpus-per-task，可理解为进程数即为核数#SBATCH --ntasks-per-node=16    %指定每个节点进程数/核数,使用-n参数（优先级更高），变为每个节点最多运行的任务数#SBATCH --nodelist=node[3,4]    %指定优先使用节点#SBATCH --exclude=node[1,5-6]   %指定避免使用节点#SBATCH --time=dd-hh:mm:ss      %作业最大运行时长，参考格式填写#SBATCH --output=file_name      %指定输出文件输出#SBATCH --error=file_name       %指定错误文件输出#SBATCH --mail-type=ALL         %邮件提醒,可选:END,FAIL,ALL#SBATCH --mail-user=address     %通知邮箱地址source /public/home/user/.bashrc   #导入环境变量文件mpirun -n 32 ./iPic3D ./inputfiles/test.inp #运行命令<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="节点信息查看"><a href="#节点信息查看" class="headerlink" title="节点信息查看"></a>节点信息查看</h2><pre class="line-numbers language-none"><code class="language-none">sinfo# 查看所有分区状态sinfo -a     # 查看所有分区状态sinfo -N# 查看节点状态sinfo -n node-name            # 查看指定节点状态sinfo --help    # 查看帮助信息# 节点状态信息alloc：节点满载idle：节点空闲mix：节点部分被占用down：节点下线drain：节点故障<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="作业列表查询"><a href="#作业列表查询" class="headerlink" title="作业列表查询"></a>作业列表查询</h2><pre class="line-numbers language-none"><code class="language-none">squeue# 查看运行中作业列表squeue -l # 查看列表细节信息squeue -j job-id # 查看指定运行中的作业信息# 作业状态R：正在运行PD：正在排队CG：已完成CD：已完成<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="作业信息查询"><a href="#作业信息查询" class="headerlink" title="作业信息查询"></a>作业信息查询</h2><pre class="line-numbers language-none"><code class="language-none">scontrol show job JOBID         #查看作业的详细信息scontrol show node              #查看所有节点详细信息scontrol show node node-name    #查看指定节点详细信息scontrol show node | grep CPU   #查看各节点cpu状态scontrol show node node-name | grep CPU #查看指定节点cpu状态<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="更新作业"><a href="#更新作业" class="headerlink" title="更新作业"></a>更新作业</h2><p>作业提交后，但相关作业属性错误，取消任务修改作业后需要重新排队，在作业运行开始前可以使用scontrol更新作业的运行属性。<br></p><pre class="line-numbers language-none"><code class="language-none">scontrol update jobid=JOBID ATTRIBUTE=INFO # ATTRIBUTE为下列属性名，INFO修改的属性值partition=&lt;name&gt;name=&lt;name&gt;numcpus=&lt;min_count-max_count&gt;numnodes=&lt;min_count-max_count&gt;numtasks=&lt;count&gt;reqnodelist=&lt;nodes&gt;reqcores=&lt;count&gt;nodelist=&lt;nodes&gt;excnodelist=&lt;nodes&gt;starttime=yyyy-mm-ddtimelimit=d-h:m:smincpusnode=&lt;count&gt;minmemorycpu=&lt;megabytes&gt;minmemorynode=&lt;megabytes&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h2 id="取消作业"><a href="#取消作业" class="headerlink" title="取消作业"></a>取消作业</h2><pre class="line-numbers language-none"><code class="language-none">scancel JOBID  # 终止作业<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> Linux </tag>
            
            <tag> Slurm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>花哨实用操作或工具</title>
      <link href="/posts/27392/"/>
      <url>/posts/27392/</url>
      
        <content type="html"><![CDATA[<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ol><li><p>文图帮<br>图片压缩、格式转换、尺寸调整<br>url:<a href="https://www.wentubang.com/#/resize">https://www.wentubang.com/#/resize</a></p></li><li><p>吼吼TV<br>看美剧<br><a href="https://www.hohovod.com/">https://www.hohovod.com/</a></p></li><li><p>latex表格生成<br><a href="https://www.tablesgenerator.com/">https://www.tablesgenerator.com/</a></p></li><li><p>json解析<br><a href="https://www.sojson.com/">https://www.sojson.com/</a></p></li><li><p>latex公式转换为公式<br>方法1：github开源工具：pix2tex<br>方法2：<a href="https://www.latexlive.com/home##">https://www.latexlive.com/home##</a>  （有限制次数）</p></li><li><p>图床<br>github开源工具：picgo</p></li></ol><p>插曲：之前通过csdn或其它地方拷贝的图片无法显示，手动一个一个修正太慢了，所以想用到脚本。但是再操作的时候遇到了好些麻烦，最终成功。需要的插件和代码放在下面：</p><p>PicGo自带的GitHub上传工具，不能同步删除GitHub仓库中的图片。<strong>这个时候如果再次上传（命令行或者url上传），可能会失败。</strong></p><p>因此，我们需要利用PicGo强大的插件功能实现同步操作相册和仓库图片</p><p>（1）点击PicGo左侧菜单最下方的插件设置，在搜索框中输入github-plus，点击灰色按钮安装</p><p>（2）安装完成后在左侧菜单找到github-plus，设置方法同Github图床设置，<strong>可以将path重新弄一个</strong>，因为之前github里的path还存在原图，手动清理太麻烦，就放在那不管，另起一个<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/githubplus%E9%85%8D%E7%BD%AE.png" alt=""></p><p>（3）设置后保存设置并点击“设为默认图床”按钮</p><pre class="line-numbers language-none"><code class="language-none">#coding=UTF-8import reimport http.clientimport jsonimport timeimage_url = []picture_name = []target_url = 'C://Software//Blog//source//_posts//花哨实用操作.md'# 遍历markdown文档，找到含有“在这里插入图片描述”的文字def find_in_note(target_url):    f = open(target_url, encoding='utf-8')               # 返回一个文件对象     line = f.readline()               # 调用文件的 readline()方法     while line:         start = 0        end = 0        if '在这里插入图片描述' in line or'img-blog.csdnimg.cn'in line:            for index, ch in enumerate(line):                if ch == "(":                    start = index                if ch == ")":                    end = index            tmp_line = line[start+1:end]            if "png" in tmp_line:                extension = "png"            if "jpeg" in tmp_line:                extension = "jpeg"            if "jpg" in tmp_line:                extension = "jpg"            if "webp" in tmp_line:                extension = "webp"                       image_url.append(tmp_line)            regex = r'([^/]+\.' + extension + r')'            result = re.search(regex, tmp_line)            if result:                extracted_string = result.group(1)                picture_name.append(extracted_string)            line = f.readline()         else:            line = f.readline()    f.close()  # 根据url来上传图片def uploadPictureByUrl(picUrl):    url = '127.0.0.1:36677'    path = '/upload'    data = {'list': [picUrl]}    headers = {'Content-Type': 'application/json'}    conn = http.client.HTTPConnection(url)    conn.request("POST", path, json.dumps(data), headers)    response = conn.getresponse()    print(response.status)    print(response.read().decode())    conn.close()# 拼接目标字符串def target_string(url):    str = '![](https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/' + url + ')'    return str# 遍历md文件，def replace_origin_url(target_url):    with open(target_url, 'r', encoding='utf-8') as file:        lines = file.readlines()    for i in range(len(lines)):        for j in picture_name:            if j in lines[i]:                res = target_string(j)                lines[i] = res + '\n'    with open(target_url, 'w', encoding='utf-8') as file:        file.writelines(lines)# 获取要上传图片的urlfind_in_note(target_url)# 批量上传图片for i in image_url:    uploadPictureByUrl(i)    time.sleep(0.5)# 遍历md文件，遇到需要变的，做字符串拼接后，替换replace_origin_url(target_url)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="同步油猴脚本"><a href="#同步油猴脚本" class="headerlink" title="同步油猴脚本"></a>同步油猴脚本</h2><p>进入油猴</p><ol><li>设置-&gt;“配置模式” 默认 “入门”，改成 “高级”<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/20210507191619179.png" alt=""></li><li>改成 “高级” 后，就出现了 TESLA 的配置<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/20210507192108356.png" alt=""></li><li>改好后点击下面的保存，就配置好了，这个时候这个chrome的配置就开始上传了。<strong>如果某个脚本被停用了应该无法被同步，可以打开</strong></li></ol><h2 id="手机投屏到电脑"><a href="#手机投屏到电脑" class="headerlink" title="手机投屏到电脑"></a>手机投屏到电脑</h2><p>背景：红米k30pro，win10电脑</p><ol><li>win10找到这个位置<br>设置-&gt;系统-&gt;投影到此电脑<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/80bfa5fec9714098b1d6db014cb405b6.png" alt=""></li></ol><p><strong>选择所有位置都可用</strong></p><p>红米手机-&gt;连接与共享-&gt;投影</p><p>注意：win10有可能一开始投影到此电脑没法选，需要下载一个东西（忘了是什么），搜一下就好。</p><h2 id="科学上网"><a href="#科学上网" class="headerlink" title="科学上网"></a>科学上网</h2><h3 id="手机作为代理服务器让其他设备翻墙"><a href="#手机作为代理服务器让其他设备翻墙" class="headerlink" title="手机作为代理服务器让其他设备翻墙"></a>手机作为代理服务器让其他设备翻墙</h3><h4 id="方法1，手机开启热点给其它设备"><a href="#方法1，手机开启热点给其它设备" class="headerlink" title="方法1，手机开启热点给其它设备"></a>方法1，手机开启热点给其它设备</h4><p>软件v2ray，在配置里面勾选允许其它设备接入，把sockt5和http的端口改为一致。同时选择一个节点运行</p><p>然后开启热点，查找到手机的ip，一般在高级设置里面。</p><p>进入电脑，连接手机热点，找到代理，手动代理，输入手机的ip和端口</p><h4 id="方法2，手机和其它设备处于同一局域网"><a href="#方法2，手机和其它设备处于同一局域网" class="headerlink" title="方法2，手机和其它设备处于同一局域网"></a>方法2，手机和其它设备处于同一局域网</h4><p>方法和法1差不多，详细的可以看油兔</p><h2 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h2><p><a href="https://juejin.cn/post/6844904169497690120">借鉴链接1</a><br><a href="https://xumingmingming.github.io/2019/06/28/linux/wai-wang-ssh-lian-jie-nei-wang-windows-shang-linux-xu-ni-ji/">借鉴链接2</a></p><p>内网穿透，即NAT（Network Address Translator）穿透，是指计算机在内网（局域网）内使用私有IP地址，在连接外网（互联网）时使用全局IP地址的技术。该技术被普遍使用在有多台主机但只通过一个公有IP地址访问的私有网络中。</p><p>举个例子：比如我在实验室配置了一个服务器 Server A，当我在实验室的时候，就可以通过自己的笔记本使用SSH连接【因为我和服务器处于一个局域网】，当我回宿舍以后，就没有办法直接使用SSH连接了【因为我和服务器不在一个局域网】，这个时候就需要进行NAT穿透，让我在宿舍也可以使用SSH连接Server A。</p><h3 id="NAT原理解析"><a href="#NAT原理解析" class="headerlink" title="NAT原理解析"></a>NAT原理解析</h3><ul><li><p>当信息由局域网向因特网传递时，源地址从专有地址转换为公用地址。由路由器跟踪每个连接上的目的地址和端口。</p></li><li><p>当数据返回路由器时，通过记录的连接跟踪数据来决定该转发给内部网的哪个主机；如果此时如果有多个公用地址可用，当数据包返回时，则会客户机的端口号可以用来分解数据包。</p></li></ul><p>下图以10.0.0.10的主机与163.221.120.9的主机进行通信为例进行讲解。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/26/17251920e32f946d~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt=""></p><ol><li><p>首先NAT路由器将发送源地址从私有IP地址(10.0.0.10)转换为全局的IP地址 (202.244.174.37)再发送数据</p></li><li><p>当数据从地址163.221.120.9发过来时，NAT路由器将目标地址从原句IP地址(202.244.174.37)先转换成私有IP地址10.0.0.10以后再转发</p></li></ol><h3 id="内网穿透工具"><a href="#内网穿透工具" class="headerlink" title="内网穿透工具"></a>内网穿透工具</h3><p>目前市面上有很多传统工具，较为知名的开源工具有<strong>Ngrok、FRP、 fcn、goProxy</strong>，其他还有一些商用的工具比如花生壳和基于等Ngrok和FRP二次开发的商用软件</p><p>详细见链接1，目前使用的是灵曜内网穿透</p><h3 id="怎样判断两个IP是否在同一局域网"><a href="#怎样判断两个IP是否在同一局域网" class="headerlink" title="怎样判断两个IP是否在同一局域网"></a>怎样判断两个IP是否在同一局域网</h3><p><a href="https://blog.51cto.com/u_11216726/1967245">原链接</a></p><p>1.在windows中，开始-&gt;cmd 进入Dos，输入ipconfig /all，查看网络配置。</p><p>2.首先看子网掩码（Subnet Mask），如果两台机器子网掩码不一致，不在一个局域网。</p><p>3.若子网掩码一致，再看IP地址的与子网掩码255对应的IP段是否一致，如果一致，属于一个子网，即一个局域网。</p><p>例如10.178.0.222与10.178.1.212两个IP地址，它们的子网掩码都是255.255.0.0，在 TCP/IP协议规则里面，IP地址与子网掩码做与运算，255换成十六进制就是FF，换成二进制就是11111111,10.178.0.222与255.255.0.0做与运算的结果是10.178.0.0，同样10.178.1.212与255.255.0.0做与运算也是10.178.0.0，因此这两个地址属于一个局域网。<br>而10.178.0.222与10.178.1.212两个IP地址，若它们的子网掩码都是255.255.255.0的话，他们就不属于一个局域网。这两个IP地址与子网掩码做与运算后结果分别为10.178.0.0和10.178.1.0，很明显IP不一致。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> VM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>名词解释</title>
      <link href="/posts/118/"/>
      <url>/posts/118/</url>
      
        <content type="html"><![CDATA[<h2 id="CFD"><a href="#CFD" class="headerlink" title="CFD"></a>CFD</h2><h3 id="weno3、weno5"><a href="#weno3、weno5" class="headerlink" title="weno3、weno5"></a>weno3、weno5</h3><p>在计算流体动力学（CFD）中，WENO，全称为加权基本非振荡器（Weighted Essentially Non-Oscillatory），是一种被广泛应用的数值方法，主要用于解决对流主导的流体动力学问题。</p><p>WENO方法的主要特点是能够在光滑区域中实现高阶精度，同时在激波和不连续性附近保持非振荡的解。这是通过对一组不同的预测子方案（即预测子 stencil）进行非线性加权来实现的，每个预测子方案对应于不同的插值多项式。</p><p>“WENO3”和“WENO5”指的是WENO方法的不同变体，数字表示用于构造预测子方案的插值多项式的阶数。例如，WENO3表示使用二阶插值多项式，而WENO5表示使用四阶插值多项式。<strong>理论上，WENO5在光滑区域的精度高于WENO3，但是在激波和不连续性附近，WENO5和WENO3的性能差距就不那么明显了。</strong></p><h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><h3 id="半导体"><a href="#半导体" class="headerlink" title="半导体"></a>半导体</h3><h2 id="并行计算"><a href="#并行计算" class="headerlink" title="并行计算"></a>并行计算</h2><h3 id="vectorization"><a href="#vectorization" class="headerlink" title="vectorization"></a>vectorization</h3><p><a href="https://zhuanlan.zhihu.com/p/337756824">原文链接</a><br>向量化即“批量操作”，批量操作在物理生活中也很常见，在计算机中最常见的执行模型就是SIMD（Single Instruction Multiple Data），即对批量的数据同时进行同样的操作以提高效率。如下图中左边的机器一次只能计算一对标量的相乘，于是四对数相乘就要算四次，而右边的机器能直接同时处理四个数，一次操作就能完成四对数相乘。</p><p><img src="https://pic4.zhimg.com/80/v2-691e76e69b27fd3a24a12b45eccbce8b_1440w.jpg" alt=""></p><h3 id="Cache-efficient"><a href="#Cache-efficient" class="headerlink" title="Cache-efficient"></a>Cache-efficient</h3><p>高速缓存</p><h3 id="RAM（Random-Access-Memory）"><a href="#RAM（Random-Access-Memory）" class="headerlink" title="RAM（Random Access Memory）"></a>RAM（Random Access Memory）</h3><p>随机存储器，俗称内存，我们常说的电脑内存8g，指的就是这个(也不完全正确)。RAM要求每时每刻都不断地供电，否则数据会丢失。它由半导体材料制作，是计算机的工作场所。</p><h3 id="ROM（Read-Only-Memory）"><a href="#ROM（Read-Only-Memory）" class="headerlink" title="ROM（Read Only Memory）"></a>ROM（Read Only Memory）</h3><p>只读存储器，应用于硬盘存储。一般由磁性材料制作，用来存放暂时不用的信息，只有加载到内存（RAM）中才能被CPU处理。即CPU与硬盘不发生直接的数据交换。</p><h3 id="Cache-（高速缓冲存储器）"><a href="#Cache-（高速缓冲存储器）" class="headerlink" title="Cache （高速缓冲存储器）"></a>Cache （高速缓冲存储器）</h3><p>Cache介于CPU与RAM之间，是一个读写速度比RAM更快的存储器。当CPU向RAM中写入或读出数据时会同步存储进Cache中，当CPU再次需要这些数据时，CPU就从Cache读取数据，而不是访问较慢的内存，如需要的数据在Cache中没有，CPU会再去读取Cache中的数据。</p><p>访问速度<br>Cache&gt;&gt;RAM&gt;&gt;ROM</p><h3 id="field-solvers"><a href="#field-solvers" class="headerlink" title="field solvers"></a>field solvers</h3><p>求解某个方程的可执行程序</p><p>直接翻译为场求解器，需要看一些cfd对于field的相关解释，和网格有关系。<br>下面是wiki对于Electromagnetic field solver的解释：<br><strong>电磁场求解器（或有时只是场求解器）是直接求解麦克斯韦方程组（麦克斯韦方程组的子集）的专用程序。</strong></p><h2 id="计算机"><a href="#计算机" class="headerlink" title="计算机"></a>计算机</h2><h3 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h3><p>I/O就是简单的数据Copy，仅此而已。</p><p>如果数据是从外部设备copy到内存中，这就是Input。<br>如果数据是从内存copy到外部设备，这就是Output。<br>内存与外部设备之间的数据copy就是I/O（Input/Output）</p><h3 id="race-condition"><a href="#race-condition" class="headerlink" title="race condition"></a>race condition</h3><p><strong>简洁版：</strong><br>两个线程访问共性数据（变量），并在同一时间对其修改</p><p><strong>长版：</strong></p><p>A race condition occurs when two or more threads can access shared data and they try to change it at the same time. Because the thread scheduling algorithm can swap between threads at any time, you don’t know the order in which the threads will attempt to access the shared data. Therefore, the result of the change in data is dependent on the thread scheduling algorithm, i.e. both threads are “racing” to access/change the data.</p><p>Problems often occur when one thread does a “check-then-act” (e.g. “check” if the value is X, then “act” to do something that depends on the value being X) and another thread does something to the value in between the “check” and the “act”. E.g:<br></p><pre class="line-numbers language-none"><code class="language-none">if (x == 5) // The "Check"{   y = x * 2; // The "Act"   // If another thread changed x in between "if (x == 5)" and "y = x * 2" above,   // y will not be equal to 10.}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>The point being, y could be 10, or it could be anything, depending on whether another thread changed x in between the check and act. You have no real way of knowing.<p></p><p>In order to prevent race conditions from occurring, you would typically put a lock around the shared data to ensure only one thread can access the data at a time. This would mean something like this:</p><pre class="line-numbers language-none"><code class="language-none">// Obtain lock for xif (x == 5){   y = x * 2; // Now, nothing can change x until the lock is released.               // Therefore y = 10}// release lock for x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ARM和X86的区别"><a href="#ARM和X86的区别" class="headerlink" title="ARM和X86的区别"></a>ARM和X86的区别</h3><p>ARM、x86和x64是计算机领域中常见的处理器架构。它们有以下区别：</p><ol><li><p>ARM架构（Advanced RISC Machine）：</p><ul><li>主要用于移动设备和嵌入式系统，如智能手机、平板电脑、物联网设备等。</li><li>设计简单，功耗低，适合移动设备的节能需求。</li><li>32位或64位处理器都有，但大多数ARM处理器仍然是32位的。</li><li>通常在移动设备中使用的操作系统是基于ARM架构开发的，如Android。</li></ul></li><li><p>x86架构：</p><ul><li>主要用于个人电脑和服务器领域。</li><li>由英特尔（Intel）首先引入，后来被AMD等公司采用。</li><li>最初是32位处理器，后来发展为64位处理器（x86-64或IA-32e），支持更大的内存地址空间。</li><li>主流操作系统，如Windows、Linux和macOS，都提供了针对x86架构的版本。</li></ul></li><li><p>x64架构（也称为AMD64或Intel 64）：</p><ul><li>是x86架构的64位扩展，具有更大的内存寻址空间和更高的性能。</li><li>支持64位指令集，并且可以运行32位和64位应用程序。</li><li>在桌面、服务器和高性能计算领域广泛应用。</li><li>主流操作系统，如Windows、Linux和macOS，都提供了x64架构的版本。</li></ul></li></ol><p>总结来说，ARM架构主要用于移动设备和嵌入式系统，x86架构主要用于个人电脑和服务器，而x64是x86架构的64位扩展，提供更高性能和更大内存寻址空间。</p><p>现在ARM在电脑上也有了。</p><p><strong>主流的品牌：</strong><br>以下是当前计算机领域中主流的处理器品牌：</p><p>ARM架构：</p><ul><li>Qualcomm（高通）：在移动设备市场上非常知名，其Snapdragon系列芯片广泛应用于智能手机和平板电脑。</li><li>Apple：苹果公司自家设计的ARM芯片，如M1芯片用于Mac电脑。</li></ul><p>x86架构：</p><ul><li>Intel：英特尔是全球最大的半导体公司之一，其处理器广泛应用于个人电脑、服务器和数据中心。</li><li>AMD：Advanced Micro Devices是另一家知名的处理器制造商，其处理器产品与Intel竞争，在桌面、服务器和游戏领域具有一定市场份额。</li></ul><p>需要注意的是，ARM架构主要用于移动设备和嵌入式系统，而x86架构主要用于个人电脑和服务器。在处理器品牌选择时，还应综合考虑性能、功耗、成本和适用场景等因素，以满足特定需求。</p><h2 id="机器学习-深度学习"><a href="#机器学习-深度学习" class="headerlink" title="机器学习/深度学习"></a>机器学习/深度学习</h2><h3 id="模型、算法、学习之间的关系"><a href="#模型、算法、学习之间的关系" class="headerlink" title="模型、算法、学习之间的关系"></a>模型、算法、学习之间的关系</h3><p><a href="https://zhuanlan.zhihu.com/p/26620760">原链接</a></p><ol><li>模型是一个从输入到输出的函数。</li><li>算法则是利用样本生成模型的方法。</li><li>学习（也可称为训练）则是利用样本通过算法生成模型的过程。下面举一个大家相对熟悉，而且可能实际操作过的例子：实验数据的线性拟合，一个简单而又经典的机器学习案例。</li></ol><h2 id="数理"><a href="#数理" class="headerlink" title="数理"></a>数理</h2><h3 id="张量"><a href="#张量" class="headerlink" title="张量"></a>张量</h3><p><a href="https://www.zhihu.com/question/20695804/answer/447498656">原链接</a></p><p>在机器学习等领域，张量就是多维数组。目的是把向量、矩阵推向更高的维度。</p><p><img src="https://picx.zhimg.com/80/v2-a28dec3a92213d05ea50166508a24847_720w.jpg?source=1940ef5c" alt=""></p><p>把三维张量画成一个立方体：</p><p><img src="https://pic1.zhimg.com/80/v2-60c5a16d8c0f8bed38bb7647d5644fdc_720w.jpg?source=1940ef5c" alt=""></p><p>我们就可以进一步画出更高维的张量：</p><p><img src="https://picx.zhimg.com/80/v2-52a52951320f056783c5831a5639af3d_720w.jpg?source=1940ef5c" alt=""></p><p>从数据结构上来看，张量就是多维数组。</p><p>这个定义本身没有错，但是没有真正反映张量的核心。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="MetaData（元数据）"><a href="#MetaData（元数据）" class="headerlink" title="MetaData（元数据）"></a>MetaData（元数据）</h3><p><a href="http://www.ruanyifeng.com/blog/2007/03/metadata.html">原文链接</a></p><p>元数据是用来描述数据的数据（Data that describes other data）</p><p>年龄（三十岁上下）、身高（个子高挑）、相貌（身材匀称，黑黑的眉毛，红红的脸蛋）、性格（活跃，吵吵嚷嚷，不停地哼着小俄罗斯的抒情歌曲，高声大笑）。有了这些信息，我们就可以大致想像出瓦莲卡是个什么样的人。推而广之，只要提供这几类的信息，我们也可以推测出其他人的样子。</p><p>这个例子中的”年龄”、”身高”、”相貌”、”性格”，就是元数据，因为它们是用来描述具体数据/信息的数据/信息。</p><p><strong>元数据最大的好处是，它使信息的描述和分类可以实现格式化，从而为机器处理创造了可能。</strong></p><h3 id="software-stack"><a href="#software-stack" class="headerlink" title="software stack"></a>software stack</h3><p><a href="https://www.techtarget.com/searchapparchitecture/definition/software-stack">原链接</a></p><p>软件堆栈是独立组件的集合，这些组件协同工作以支持应用程序的执行。这些组件可能包括操作系统、体系结构层（architectural layers）、协议、运行时环境、数据库和函数调用，它们在层次结构中彼此堆叠在一起。通常，层次结构中的较低级别组件与硬件交互，而层次结构中的较高级别组件为最终用户执行特定任务和服务。组件通过一系列遍历堆栈的复杂指令直接与应用程序通信。</p><p><img src="https://cdn.ttgtmedia.com/rms/onlineimages/itops-software_stack-h.png" alt=""></p><p>软件堆栈可以很简单，也可以很复杂，具体取决于所需的应用程序功能，并且可以合并来自组织的本地资源、第三方提供商（如 SaaS 供应商）或云提供商提供的组件和服务。</p><p><strong>例子</strong><br>LAMP（Linux，阿帕奇，MySQL，PHP）：这是一个众所周知的网络开发软件堆栈。堆栈层次结构的最低层是 Linux 操作系统，它与 Apache Web 服务器接口。层次结构的最高层是脚本语言 - 在本例中为PHP。（“P”也可以代表编程语言Python或Perl。LAMP堆栈很受欢迎，因为这些组件都是开源的，并且堆栈可以在商用硬件上运行。与通常紧密耦合且通常针对特定操作系统构建的整体式软件堆栈不同，LAMP堆栈是松散耦合的。这仅仅意味着，虽然这些组件最初不是为协同工作而设计的，但它们已被证明是互补的，并且经常一起使用。今天，LAMP组件现在都包含在几乎所有的Linux发行版中。开发人员可以将 MySQL 换成后格雷SQL 来创建缆普堆栈。LEAP 堆栈（Linux、桉树、AppScale、Python）是此开源软件堆栈的另一种风格，用于基于云的开发和服务交付。</p><p>MEAN（MongoDB，Express，Angular，Node.js）：这一堆开发工具有助于消除软件开发中经常遇到的语言障碍。平均堆栈的基础是蒙哥DB，一个NoSQL文档数据存储。HTTP 服务器是快速的，而角度是前端 JavaScript 的框架。堆栈的最高层是 Node，它是服务器端脚本的平台。请注意，MEAN不依赖于特定的操作系统，这为开发人员提供了更大的灵活性;它还使用JavaScript，这是一种无处不在的编程语言。开发人员可以使用余烬而不是角度，这创建了一个MEEN堆栈;或者使用 Vue.js作为 MEVN 堆栈中的前端开发框架。</p><h3 id="Benchmark"><a href="#Benchmark" class="headerlink" title="Benchmark"></a>Benchmark</h3><p><a href="https://en.wikipedia.org/wiki/Benchmark_(computing">原链接</a>)</p><p><strong>Benchmark:基准测试</strong></p><p>基准测试旨在模拟组件或系统上特定类型的工作负载。综合基准测试通过专门创建的程序来实现这一点，这些程序将工作负载强加给组件。应用程序基准测试在系统上运行实际程序。虽然应用程序基准测试通常可以更好地衡量给定系统上的实际性能，但综合基准测试对于测试单个组件（如硬盘或网络设备）非常有用。</p><p>基准测试在 CPU 设计中尤为重要，它使处理器架构师能够在微架构决策中进行测量和权衡。例如，如果基准测试提取应用程序的关键算法，它将包含该应用程序的性能敏感方面。在周期精确的模拟器上运行这个小得多的代码段可以提供有关如何提高性能的线索。</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="CRI"><a href="#CRI" class="headerlink" title="CRI"></a>CRI</h3><p><a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md">原链接</a></p><p>CRI (Container Runtime Interface) consists of a specifications/requirements (to-be-added), protobuf API, and libraries for container runtimes to integrate with kubelet on a node.</p>]]></content>
      
      
      <categories>
          
          <category> 并行计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并行计算 </tag>
            
            <tag> CFD </tag>
            
            <tag> 向量化 </tag>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/posts/9809/"/>
      <url>/posts/9809/</url>
      
        <content type="html"><![CDATA[<h2 id="实战案例"><a href="#实战案例" class="headerlink" title="实战案例"></a>实战案例</h2><h3 id="将markdown文章所有标题多加一级"><a href="#将markdown文章所有标题多加一级" class="headerlink" title="将markdown文章所有标题多加一级"></a>将markdown文章所有标题多加一级</h3><p>在markdown中,标题按照”#”标注，某次更换了主题，对于一级标题无法识别，导致目录树无法正常显示。如果直接使用替换。二级标题”##”会变成四个。</p><p><strong>解决方法:</strong><br><img src="https://s2.loli.net/2022/07/23/NOHAYuUkEDhwS6T.png" alt="Snipaste_2022-07-23_12-37-47.png"></p><pre class="line-numbers language-none"><code class="language-none">^#{1}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>^表示匹配文章开头</li><li>{1}匹配1次</li></ol><p><a href="https://c.runoob.com/front-end/854/">正则表达式在线工具</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typescript变量类型</title>
      <link href="/posts/62822/"/>
      <url>/posts/62822/</url>
      
        <content type="html"><![CDATA[<h2 id="TS语法以及类型"><a href="#TS语法以及类型" class="headerlink" title="TS语法以及类型"></a>TS语法以及类型</h2><p><a href="https://github.com/iamswr/ts_react_demo_20181207">原链接</a></p><h2 id="js和ts的区别"><a href="#js和ts的区别" class="headerlink" title="js和ts的区别"></a>js和ts的区别</h2><h3 id="1-动态编程语言和静态编程语言的区别"><a href="#1-动态编程语言和静态编程语言的区别" class="headerlink" title="1 . 动态编程语言和静态编程语言的区别"></a>1 . 动态编程语言和静态编程语言的区别</h3><ul><li>js属于动态类型的编程语言<ul><li>边解析边执行的语言, 错误只能在运行阶段发现</li></ul></li><li>ts属于静态编程的语言<ul><li>先编译(编译成js),再执行(不能直接执行, TSC工具将ts转换为js)</li></ul></li></ul><h3 id="2-兼容性-ts包含js-js所有语法ts都支持"><a href="#2-兼容性-ts包含js-js所有语法ts都支持" class="headerlink" title="2 . 兼容性: ts包含js(js所有语法ts都支持)"></a>2 . 兼容性: ts包含js(js所有语法ts都支持)</h3><h3 id="3-ts-有类型约束"><a href="#3-ts-有类型约束" class="headerlink" title="3 . ts 有类型约束"></a>3 . ts 有类型约束</h3><ul><li>ts有类型的支持, 有强大的代码提示(在写代码的时候就能发现问题)</li></ul><h3 id="4-ts的前端生态"><a href="#4-ts的前端生态" class="headerlink" title="4 . ts的前端生态"></a>4 . ts的前端生态</h3><ul><li>vue : vue3源码使用TS重写</li><li>React : TS +  Hooks</li><li>Angular : 默认支持 TS</li></ul><h2 id="搭建-TypeScript-运行环境"><a href="#搭建-TypeScript-运行环境" class="headerlink" title="搭建 TypeScript 运行环境"></a>搭建 TypeScript 运行环境</h2><h3 id="全局安装编译-TS-的工具包"><a href="#全局安装编译-TS-的工具包" class="headerlink" title="全局安装编译 TS 的工具包"></a>全局安装编译 TS 的工具包</h3><p>安装包：<code>npm i -g typescript</code></p><ul><li>typescript 包：用来编译 TS 代码的包，提供了 <code>tsc</code> 命令，实现了 <code>ts -&gt; js</code> 的转化</li><li>验证是否安装成功：<code>tsc –v</code> (查看 typescript 的版本)</li></ul><p>注意：Mac 电脑安装全局包时，需要添加 <code>sudo</code> 获取权限：<code>sudo npm i -g typescript</code></p><h3 id="编译并运行-TS-代码"><a href="#编译并运行-TS-代码" class="headerlink" title="编译并运行 TS 代码"></a>编译并运行 TS 代码</h3><p>步骤</p><ol><li><p>创建ts文件。例如 hello.ts 文件（注意：<strong>TS 文件的后缀名为 <code>.ts</code></strong>）</p></li><li><p>编译。将 TS 编译为 JS</p><p>在终端中输入命令，<code>tsc hello.ts</code>（此时，在同级目录中会出现一个同名的 JS 文件）</p></li><li><p>执行 JS 代码。</p><ol><li>在node中运行。在终端中输入命令，<code>node hello.js</code></li><li>在浏览器中运行。</li></ol></li></ol><h3 id="拓展：在线运行"><a href="#拓展：在线运行" class="headerlink" title="拓展：在线运行"></a>拓展：在线运行</h3><p><a href="https://www.typescriptlang.org/play">https://www.typescriptlang.org/play</a></p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p><code>npm bin -g</code> 可以查看全局安装的路径</p><p>环境变量 path 中有此路径即可 </p><h2 id="简化-ts-使用"><a href="#简化-ts-使用" class="headerlink" title="简化 ts 使用"></a>简化 ts 使用</h2><p>每次修改代码后，都要重复执行两个命令，才能运行 TS 代码，太繁琐。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">tsc  你的代码<span class="token punctuation">.</span>tsnode 你的代码<span class="token punctuation">.</span>js<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="简化方式"><a href="#简化方式" class="headerlink" title="简化方式"></a>简化方式</h3><p>使用 <code>ts-node</code> 包，直接在 Node.js 中执行 TS 代码。它提供了 <code>ts-node</code> 命令，可以简化执行命令。</p><h3 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h3><p><code>npm i -g ts-node</code></p><p>使用方式：<code>ts-node hello.ts</code> </p><p>相当于：1 tsc 命令  2 node（注意：ts-node 不会生成 js 文件）</p><p>解释：ts-node 命令在内部偷偷的将 TS -&gt; JS，然后，再运行 JS 代码</p><h2 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h2><p><strong>语法: <code>let 变量 :  类型 = 值</code></strong></p><p>约定了变量的类型 <code>: 类型</code></p><h2 id="ts-中的类型"><a href="#ts-中的类型" class="headerlink" title="ts 中的类型"></a>ts 中的类型</h2><h3 id="1-js中已有的类型"><a href="#1-js中已有的类型" class="headerlink" title="1 . js中已有的类型"></a>1 . js中已有的类型</h3><ol><li>原始类型 :  <code>number/string/boolean/null/undefined/symbol</code></li><li>对象类型 : <code>object</code>（包括，数组、对象、函数等对象）</li></ol><h3 id="2-ts-新增的类型"><a href="#2-ts-新增的类型" class="headerlink" title="2 .  ts 新增的类型"></a>2 .  ts 新增的类型</h3><ol><li><ol><li>联合类型</li><li>自定义类型(类型别名)</li><li>接口</li><li>元组</li><li>字面量类型</li><li>枚举</li><li>void</li><li>any </li><li>unkown</li><li>等</li></ol></li></ol><p>注意：</p><ol><li>原始类型在 TS 和 JS 中写法一致</li><li>对象类型在 TS 中更加细化，每个具体的对象（比如: 数组、对象、函数…）都有自己的类型语法</li></ol><h2 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h2><p>直接使用</p><p><strong>语法: <code>let 变量 :  类型 = 值</code></strong></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// 数值类型</span><span class="token keyword">let</span> age<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">18</span><span class="token comment">// 字符串类型</span><span class="token keyword">let</span> myName<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">'小花'</span><span class="token comment">// 布尔类型</span><span class="token keyword">let</span> isLoading<span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token comment">// undefined</span><span class="token keyword">let</span> un<span class="token operator">:</span> <span class="token keyword">undefined</span> <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token comment">// null</span><span class="token keyword">let</span> timer<span class="token operator">:</span><span class="token keyword">null</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token comment">// symbol</span><span class="token keyword">let</span> uniKey<span class="token operator">:</span><span class="token builtin">symbol</span> <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h2><p>在 ts 中没有明确指定类型时, 有些时候 ts 会帮助推断类型 ,不用指定类型</p><p>会推断类型的两种情况:</p><ul><li>声明变量并初始化时</li><li>决定函数返回值时</li></ul><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// 变量 age 的类型被自动推断为：number</span><span class="token keyword">let</span> age <span class="token operator">=</span> <span class="token number">18</span><span class="token comment">// 函数返回值的类型被自动推断为：number</span><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span>num1<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> num2<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> num1 <span class="token operator">+</span> num2<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为什么 vscode 上写 ts 代码有类型推论 </p><p>vscode 和 ts 都是微软的, 两者直接高度集成</p><h2 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h2><p><strong>语法 :</strong> <code>let 变量: 类型1 | 类型2 | 类型3 .... = 初始值</code></p><p><strong>解释：</strong><code>|</code>（竖线）在 TS 中叫做<strong>联合类型</strong>，即：由两个或多个其他类型组成的类型，表示可以是这些类型中的任意一种</p><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p><strong>type</strong>  关键字</p><p><strong>作用:</strong></p><ul><li>给类型取别名</li><li>定义一个新的类型</li></ul><p><strong>语法 :</strong> <code>type 别名 = 类型</code></p><p>搭配联合类型使用</p><p><strong>语法 :</strong> <code>type 别名 = 类型 | 类型1 | 类型2</code></p><h2 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h2><p><strong>两种定义格式</strong></p><p><strong>语法1 :</strong>   <code>let 变量 : 类型[ ] = [ 值...]</code></p><p><strong>语法2 :</strong>   <code>let 变量 : Array&lt;类型&gt; = [ 值...]</code></p><h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><h3 id="函数的类型"><a href="#函数的类型" class="headerlink" title="函数的类型"></a>函数的类型</h3><p>函数涉及的类型实际上指的是：<strong><code>函数参数</code></strong>和<strong><code>返回值</code></strong>的类型</p><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// 普通函数</span><span class="token keyword">function</span> <span class="token function">函数名</span><span class="token punctuation">(</span>形参<span class="token number">1</span>： 类型<span class="token operator">=</span>默认值， 形参<span class="token number">2</span>：类型<span class="token operator">=</span>默认值<span class="token punctuation">,</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token operator">:</span> 返回值类型 <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token comment">// 箭头函数</span><span class="token keyword">const</span> 函数名（形参<span class="token number">1</span>： 类型<span class="token operator">=</span>默认值， 形参<span class="token number">2</span>：类型<span class="token operator">=</span>默认值<span class="token punctuation">,</span> <span class="token operator">...</span><span class="token punctuation">)</span><span class="token operator">:</span>返回值类型 <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="type-自定义类型简化"><a href="#type-自定义类型简化" class="headerlink" title="type 自定义类型简化"></a>type 自定义类型简化</h3><p><code>type Fn = (参数:类型,参数2:类型)=&gt;类型</code></p><h2 id="函数的返回值类型-void"><a href="#函数的返回值类型-void" class="headerlink" title="函数的返回值类型 void"></a>函数的返回值类型 void</h2><p><strong>如果一个函数没有返回值 在js中是 undefined , 在ts中需要约定void </strong></p><h3 id="约定-void-类型-的三种情况"><a href="#约定-void-类型-的三种情况" class="headerlink" title="约定 void 类型 的三种情况"></a>约定 void 类型 的三种情况</h3><ul><li>函数没有返回值 （没有return 没有值）</li><li>返回 undefined</li><li>只有 return 没有值</li></ul><h3 id="函数的可选参数"><a href="#函数的可选参数" class="headerlink" title="函数的可选参数"></a>函数的可选参数</h3><p>调用时可以不传递的参数</p><p>例如：数组的 slice 方法，可以 <code>slice()</code> 也可以 <code>slice(1)</code> 还可以 <code>slice(1, 3)</code></p><p>语法 ： <code>function 函数名(形参1?： 类型， 形参2?：类型): 返回值类型 { }</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">mySlice</span><span class="token punctuation">(</span>start<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> end<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'起始索引：'</span><span class="token punctuation">,</span> start<span class="token punctuation">,</span> <span class="token string">'结束索引：'</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>注意：</strong> 必选参数要在可选参数之前</p><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p><strong>语法 ：</strong> <code>function 函数名(形参1：类型=默认值， 形参2：类型=默认值): 返回值类型 { }</code></p><p>默认和可选参数不能一起使用</p><h2 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h2><p><strong>定义对象的语法 :</strong></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> 对象名<span class="token operator">:</span> <span class="token punctuation">{</span>  属性名<span class="token number">1</span>：类型<span class="token number">1</span>，  属性名<span class="token number">2</span>：类型<span class="token number">2</span>，  <span class="token function">方法名1</span><span class="token punctuation">(</span>形参<span class="token number">1</span><span class="token operator">:</span> 类型<span class="token number">1</span>，形参<span class="token number">2</span><span class="token operator">:</span> 类型<span class="token number">2</span><span class="token punctuation">)</span>： 返回值类型<span class="token punctuation">,</span>  <span class="token function-variable function">方法名2</span><span class="token operator">:</span><span class="token punctuation">(</span>形参<span class="token number">1</span><span class="token operator">:</span> 类型<span class="token number">1</span>，形参<span class="token number">2</span><span class="token operator">:</span> 类型<span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> 返回值类型<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span> 属性名<span class="token number">1</span><span class="token operator">:</span> 值<span class="token number">1</span>，属性名<span class="token number">2</span>：值<span class="token number">2</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>可选属性</strong> </p><p><code>const 对象名: {属性名1？：类型1，属性名2：类型2 } = { 属性名2：值2 }</code></p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>当一个对象类型需要被多次使用, 两种方法</p><ul><li>type : 类型别名</li><li>interface : 接口</li></ul><h3 id="interface-使用"><a href="#interface-使用" class="headerlink" title="interface  使用"></a>interface  使用</h3><p>语法 :</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">接口名</span>  <span class="token punctuation">{</span>    属性<span class="token number">1</span><span class="token operator">:</span> 类型<span class="token number">1</span><span class="token punctuation">,</span> 属性<span class="token number">2</span><span class="token operator">:</span> 类型<span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注意 : 接口名 要 <code>I</code>(<code>大写I</code>)开头</p><h3 id="接口和类型的区别"><a href="#接口和类型的区别" class="headerlink" title="接口和类型的区别"></a>接口和类型的区别</h3><p>interface（接口）和 type（类型别名）的对比：</p><ul><li>相同点：都可以给对象指定类型</li><li>不同点:<ul><li>接口，只能为对象指定类型。它可以继承。</li><li>类型别名，不仅可以为对象指定类型，实际上可以为任意类型指定别名</li></ul></li></ul><p>推荐：<strong>能使用 type 就用 type</strong></p><h3 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h3><p><strong>两个接口之间有相同的属性或者方法, 可以通过继承实现</strong></p><h3 id="继承的实现-extends-关键字"><a href="#继承的实现-extends-关键字" class="headerlink" title="继承的实现 extends 关键字"></a>继承的实现 extends 关键字</h3><p>语法 : <code>interface 接口2 extends 接口1 {属性： 类型}</code></p><p>继承后 , 接口2 ,会拥有 接口1 的所有属性</p><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>是一个特殊的数字</p><p>两个特殊点</p><ul><li>约定了个数</li><li>约定了每个数字所对应的类型</li></ul><p>语法 : <code>[类型,类型]</code></p><p><strong>React 中 <code>useState()</code> 的返回值类型就是一个元组</strong></p><h2 id="字面量类型"><a href="#字面量类型" class="headerlink" title="字面量类型"></a>字面量类型</h2><p>const 定义出来的字符串或者数字, 或者正则 都是字面量类型</p><p>任意一个字面量都可以当有个类型来使用</p><h3 id="字面量的作用"><a href="#字面量的作用" class="headerlink" title="字面量的作用"></a>字面量的作用</h3><p>单个字面量没有什么用处，它一般和<strong>联合类型</strong> 一起使用， 用来表示一组明确的可选值列表。</p><p>例如：约定 Gender类型只能取girl和boy这两个字符串其中之一。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Gender</span> <span class="token operator">=</span> <span class="token string">'girl'</span> <span class="token operator">|</span> <span class="token string">'boy'</span><span class="token keyword">let</span> g1<span class="token operator">:</span> Gender <span class="token operator">=</span> <span class="token string">'girl'</span> <span class="token comment">// 正确</span><span class="token keyword">let</span> g2<span class="token operator">:</span> Gender <span class="token operator">=</span> <span class="token string">'boy'</span> <span class="token comment">// 正确</span><span class="token keyword">let</span> g3<span class="token operator">:</span> Gender <span class="token operator">=</span> <span class="token string">'man'</span> <span class="token comment">// 错误</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>应用场景: </p><ol><li>redux 中 ActionType 的设置可以使用 字面量配合组合类型使用</li><li>游戏中，游戏的方向键值只能是上、下、左、右中的任意一个<ul><li>解释：参数 direction 的值只能是 up/down/left/right 中的任意一个</li><li>优势：相比于 string 类型，使用字面量类型更加精确、严谨</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端语法+基础知识</title>
      <link href="/posts/43285/"/>
      <url>/posts/43285/</url>
      
        <content type="html"><![CDATA[<h2 id="javascript、ES6查漏补缺网址"><a href="#javascript、ES6查漏补缺网址" class="headerlink" title="javascript、ES6查漏补缺网址"></a>javascript、ES6查漏补缺网址</h2><p><a href="[https](https://wangdoc.com">链接</a>)</p><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="组件运行流程"><a href="#组件运行流程" class="headerlink" title="组件运行流程"></a>组件运行流程</h3><pre class="line-numbers language-none"><code class="language-none">export default function App() {  const [state, setState] = React.useState(0);    useEffect(() =&gt; {    console.log("第一次render时执行");  }, []);  useEffect(() =&gt; {    if (state &gt; 0) {      // console.log("第二次之后render时执行");      console.log('第 %i 次之后render时执行',state);    }  }, [state]);  useLayoutEffect(() =&gt; {    console.log("我比useEffect先执行");  });  console.log("我是前面的打印语句");  return (    &lt;div className="App"&gt;      &lt;h1&gt;{state}&lt;/h1&gt;      &lt;button        onClick={() =&gt; {          setState((x) =&gt; x + 1);        }}      &gt;        按钮+1      &lt;/button&gt;    &lt;/div&gt;  );}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://s2.loli.net/2022/07/25/RJpwkA9dfQ4UPzM.png" alt="未点击按钮"></p><p><img src="https://s2.loli.net/2022/07/25/HXBQeZVgbMu8pY9.png" alt="点击一次"></p><p>从上面我们可以看出执行顺序是这样：<br><strong>外部打印语句（console.log） -&gt; useLayoutEffect() -&gt; render() -&gt; useEffect()</strong></p><ol><li><p>当组件出现变动，这个顺序会重来一遍。</p></li><li><p>外部的console.log不论是放在useLayoutEffect()前后，都是优先输出的。</p></li></ol><h3 id="TS类型"><a href="#TS类型" class="headerlink" title="TS类型"></a>TS类型</h3><p>详见TS与JS区别</p><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p><strong>总结</strong><br>在来看一遍 箭头函数 与 普通函数，除了写法上的区别</p><blockquote><p>1、箭头函数没有自己的this。箭头函数会捕获其所在上下文的 this 值，作为自己的 this 值。<br>2、箭头函数 this不可变。call()、apply()、bind()、这些方法也 无法改变 箭头函数 this 的指向。<br>3、箭头函数 不能用 new关键字来实例化对象，不然会报错。<br>4、箭头函数没有arguments对象。</p></blockquote><p>可以看出，最重要的区别还是 在 this 上，所以要想用好 箭头函数，还是要对 this 有一定认识的。</p><p>箭头函数本质还是函数，我们来看看他与JavaScript中普通函数的区别，先看看写法上的区别。<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/2b6243000b0d48f69f6baf1e77293818.png" alt=""><br><strong>解释</strong><br>写箭头函数，我们记住一个顺序就好，参数、箭头、函数体、这个顺序记住就足够了，参数、箭头、函数体、这三个是必须的，函数名可以没有，但这三项必须有，一些简写的方式也是简写这三项里的东西。</p><p><strong>简写</strong><br>1、只有一个参数时，() 可省略</p><pre class="line-numbers language-none"><code class="language-none">//不简写var demo = (x) =&gt;{    console.log(x);}//简写var demo = x =&gt;{    console.log(x);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2、函数体只有一句时， {} 可以省略</p><pre class="line-numbers language-none"><code class="language-none">//不简写var demo = (x) =&gt;{    console.log(x);}//简写var demo = x =&gt; console.log(x);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3、函数体只有一条返回语句时，{} 和 return 都可以省略</p><pre class="line-numbers language-none"><code class="language-none">//不简写var demo = (x) =&gt; {     return x;}//简写var demo = (x) =&gt; x;   //注意别写成这样  var demo = (x) =&gt;{ x };  //或者 这样  var demo = (x) =&gt; return  x;  //要省略就都省略，不省略就都不省，别省一半,不然会出错的。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意：</strong><br>箭头函数放 参数 的地方就在 () 内，<br>没有参数，() 必须写，<br>一个参数，() 可写可不写，<br>多个参数，() 必须写。</p><p>箭头函数放 函数体 的地方在 {}内，<br>函数体 就 一句 {} 可写可不写，<br>函数体 不止一句，{} 必须写。</p><p>如果不知道，() {} 写不写，该不该省略，那就写，写了不会错。</p><p><strong>箭头函数 如果要返回一个对象，要简写的话， 需要用()包住这个对象</strong></p><pre class="line-numbers language-none"><code class="language-none">//不简写var demo = () =&gt;{     return {x:1};}  //简写var demo = () =&gt;({x:1});<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为什么会这样？因为如果不加 () ，那{ } 就表示的是语法块，不是表示一个对象，而加上()，按照规范来说，() 里面 { } 就会被解析为对象了。</p><p>对于 {x:1} 这个情况，他不仅可以表示一个对象，这个对象有个x属性，值为1，也可以表示为语法块中含有 名为 x 的 label，忘记 label语法的话，可以看<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/label">这里</a><br>如果不是很明白，可以看看这个<a href="https://www.zhihu.com/question/40902815">回答</a>，应该会理解的更加深刻。<br>所以这也解释了为什么会出现下面代码中的情况</p><pre class="line-numbers language-none"><code class="language-none">// 不报错var demo = () =&gt;{x:1};// 报错var demo = (y) =&gt;{y,x:1};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>对象的方法用 箭头函数写时，this 的指向 可能和你想的不一样</strong></p><pre class="line-numbers language-none"><code class="language-none">window.name='window';var obj = {    name:'obj',    show_name:() =&gt;{        console.log(this.name);    }    }obj.show_name(); //window<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>JavaScript使用的是函数作用域，在上面这段代码中对象的括号是不能封闭作用域的，所以此时的this还是指向window。<br>我们换成普通函数看看</p><pre class="line-numbers language-none"><code class="language-none">window.name='window';var obj = {    name:'obj',    show_name: function (){        console.log(this.name);    }    }obj.show_name();  //obj<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>换成普通函数，this 就不是指向window，而是指向 obj 对象了</p><p>箭头函数 与 普通函数 其他的区别</p><blockquote><p>1、箭头函数没有自己的this。箭头函数会捕获其所在上下文的 this 值，作为自己的 this 值。<br> 2、箭头函数 this不可变。call()、apply()、bind()、这些方法也 无法改变 箭头函数 this 的指向。<br>  3、箭头函数 不能用 new关键字来实例化对象，不然会报错。<br>  4、箭头函数没有arguments对象。</p></blockquote><p>1、箭头函数没有自己的this。箭头函数会捕获其所在上下文的 this 值，作为自己的 this 值。</p><pre class="line-numbers language-none"><code class="language-none">window.name = 'window';var obj = {    name:'obj',    show_name:function (){        function fn (){            console.log(this.name);        }        fn();    },}obj.show_name();  // window<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>声明一个 obj 对象，有一个name属性 与 show_name方法，上面这段代码，我的本意是想显示 obj对象的name， 但是没和我想的一样，一般我们会用 一个变量 self 或者 that 之类的留住this,像这样</p><pre class="line-numbers language-none"><code class="language-none">window.name = 'window';var obj = {    name:'obj',    show_name:function (){        //留住this        var that = this;        function fn (){            console.log(that.name);        }        fn();    },}obj.show_name();  //obj<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通常来说，箭头函数内部的this就是外层代码块的this</p><pre class="line-numbers language-none"><code class="language-none">window.name = 'window';var obj = {    name:'obj',    show_name:function (){        var fn = () =&gt; {            console.log(this.name);        }        fn();    },}obj.show_name(); //obj<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2、箭头函数 this 不可变。call()、apply()、bind()、这些方法也 无法改变 箭头函数 this 的指向。</p><pre class="line-numbers language-none"><code class="language-none">window.name = 'window';var obj = {    name:'obj',}function show_name(){    //这里 show_name 是一个普通的全局函数，所以他的this指window    console.log(this.name);}//用了 call 方法，把 show_nam 的this 指向了 obj 对象show_name.call(obj);  //obj<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>箭头函数 this 不可变</p><pre class="line-numbers language-none"><code class="language-none">window.name = 'window';var obj = {    name:'obj',}var show_name = () =&gt; {    //这里 show_name 是箭头函数，他的this指window，并且不会变    console.log(this.name);}//用了 call 方法，但是 this 没变，所以打印了 windowshow_name.call(obj);  //window<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3、箭头函数 不能用 new 关键字来实例化对象，不然会报错，箭头函数的this 不可变，new 也改变不了 this的 指向，而且更为重要的是，箭头函数内部并没有 [[Construct]] 方法，所以会没有原型属性（prototype），所以箭头函数没法当构造函数。</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/7803115884ae4f6ab5f8d4cd73cfe038.png" alt=""><br>4、箭头函数没有arguments对象，不能通过arguments对象访问传入参数，但是可以用rest参数实现<br>。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Rest_parameters">不了解的看这里</a></p><pre class="line-numbers language-none"><code class="language-none">var demo = (...theArgs) =&gt; theArgs;demo(1,2,3); //[1,2,3]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="链判断运算符"><a href="#链判断运算符" class="headerlink" title="链判断运算符"></a>链判断运算符</h3><p>作用：当访问一个对象属性是用来判断对 象 是 否 存 在<br>为什么要判断？？？？？<br>在项目中如果你不去判断对象是否存在在去访问属性，项目就崩了</p><p><strong>在es5要这样判断</strong></p><pre class="line-numbers language-none"><code class="language-none">const userName = Obj &amp;&amp;Obj.userInfo &amp;&amp; Obj.userInfo.userName ；//这样判断是不是很繁琐<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>es6写法</strong></p><pre class="line-numbers language-none"><code class="language-none">const userName = Obj?.userInfo?.userName;  //对比上面少了一大串<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>在es5的是否我们经常使用”||” 来设置默认值</strong></p><pre class="line-numbers language-none"><code class="language-none">let a = a.name || 'default'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>es6提供了null判断符 ？ ？ 两个问号来判断，只有当左边的值为null、undefined右边的值才会生效</strong></p><pre class="line-numbers language-none"><code class="language-none">let a = undefined ?? 'default'let a2 = null ?? 'default';console.log(a); //defaultconsole.log(a2); //default<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="扩展运算符-三个点"><a href="#扩展运算符-三个点" class="headerlink" title="扩展运算符-三个点"></a>扩展运算符-三个点</h3><h4 id="对象的扩展运算"><a href="#对象的扩展运算" class="headerlink" title="对象的扩展运算"></a>对象的扩展运算</h4><p>对象中的扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中</p><pre class="line-numbers language-none"><code class="language-none">let bar = { a: 1, b: 2 };let baz = { ...bar }; // { a: 1, b: 2 }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上述方法实际上等价于:</p><pre class="line-numbers language-none"><code class="language-none">let bar = { a: 1, b: 2 };let baz = Object.assign({}, bar); // { a: 1, b: 2 }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</p><p>Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。<strong>(如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性)。</strong></p><p>同样，如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。</p><pre class="line-numbers language-none"><code class="language-none">let bar = {a: 1, b: 2};let baz = {...bar, ...{a:2, b: 4}};  // {a: 2, b: 4}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>利用上述特性就可以很方便的修改对象的部分属性。在redux中的reducer函数规定必须是一个纯函数（如果不是很清楚什么是纯函数的可以参考这里），reducer中的state对象要求不能直接修改，可以通过扩展运算符把修改路径的对象都复制一遍，然后产生一个新的对象返回。</p><p>这里有点需要注意的是扩展运算符对对象实例的拷贝属于一种浅拷贝。肯定有人要问什么是浅拷贝？我们知道javascript中有两种数据类型，分别是基础数据类型和引用数据类型。基础数据类型是按值访问的，常见的基础数据类型有Number、String、Boolean、Null、Undefined，这类变量的拷贝的时候会完整的复制一份；引用数据类型比如Array，在拷贝的时候拷贝的是对象的引用，当原对象发生变化的时候，拷贝对象也跟着变化，比如：</p><pre class="line-numbers language-none"><code class="language-none">let obj1 = { a: 1, b: 2};let obj2 = { ...obj1, b: '2-edited'};console.log(obj1); // {a: 1, b: 2}console.log(obj2); //  {a: 1, b: "2-edited"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上面这个例子扩展运算符拷贝的对象是基础数据类型，因此对obj2的修改并不会影响obj1，如果改成这样：</p><pre class="line-numbers language-none"><code class="language-none">let obj1 = { a: 1, b: 2, c: {nickName: 'd'}};let obj2 = { ...obj1};obj2.c.nickName = 'd-edited';console.log(obj1); // {a: 1, b: 2, c: {nickName: 'd-edited'}}console.log(obj2); // {a: 1, b: 2, c: {nickName: 'd-edited'}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里可以看到，对obj2的修改影响到了被拷贝对象obj1，原因上面已经说了，因为obj1中的对象c是一个引用数据类型，拷贝的时候拷贝的是对象的引用。</p><h4 id="数组的扩展运算"><a href="#数组的扩展运算" class="headerlink" title="数组的扩展运算"></a>数组的扩展运算</h4><p>1.可以将数组转换为参数序列</p><pre class="line-numbers language-none"><code class="language-none">function add(x, y) {  return x + y;}const numbers = [4, 38];add(...numbers) // 42<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.可以复制数组</p><p>如果直接通过下列的方式进行数组复制是不可取的：</p><pre class="line-numbers language-none"><code class="language-none">const arr1 = [1, 2];const arr2 = arr1;arr2[0] = 2;arr1 // [2, 2]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>原因上面已经介绍过，用扩展运算符就很方便：</p><pre class="line-numbers language-none"><code class="language-none">const arr1 = [1, 2];const arr2 = [...arr1];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>还是记住那句话：<strong>扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中</strong>，这里参数对象是个数组，数组里面的所有对象都是基础数据类型，将所有基础数据类型重新拷贝到新的数组中。</p><p>3.扩展运算符可以与解构赋值结合起来，用于生成数组</p><pre class="line-numbers language-none"><code class="language-none">const [first, ...rest] = [1, 2, 3, 4, 5];first // 1rest  // [2, 3, 4, 5]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</strong></p><pre class="line-numbers language-none"><code class="language-none">const [...rest, last] = [1, 2, 3, 4, 5];// 报错const [first, ...rest, last] = [1, 2, 3, 4, 5];// 报错<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>扩展运算符还可以将字符串转为真正的数组</p><pre class="line-numbers language-none"><code class="language-none">[...'hello']// [ "h", "e", "l", "l", "o" ]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>比较常见的应用是可以将某些数据结构转为数组,比如：</p><pre class="line-numbers language-none"><code class="language-none">// arguments对象function foo() {  const args = [...arguments];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="控制台输出为输出内容为-object-Object"><a href="#控制台输出为输出内容为-object-Object" class="headerlink" title="控制台输出为输出内容为[object Object]"></a>控制台输出为输出内容为[object Object]</h3><p><a href="https://www.jianshu.com/p/d309d25789fd">原文链接</a></p><p><strong>解决方法：删掉其它字符（’+’这种符号），直接输出对象</strong></p><p><strong>问题原因：</strong></p><ol><li>加号的作用<br>首先，我们的代码中有+（加号）运算符，它在这种情况下（字符串 + 其它什么东西），会调用toString()方法，将其它类型的东西转化为字符串，再和原始字符串拼接成一个字符串；</li><li>toString()从哪里来，干了什么？</li></ol><ul><li>除了null和undefined之外，其他的类型(数值、布尔、字符串、对象)都有toString()方法，它返回相应值的字符串表现(并不修改原变量)。</li><li>每个对象都有一个toString()方法。</li><li>当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。</li><li>默认情况下，toString()方法被每个Object对象继承。如果此方法在自定义对象中未被覆盖，toString()返回 “[object type]”，其中type是对象的类型。</li></ul><p>而在上述项目中，res正是我们自定义的对象，所以res.toString()的结果为[object Object]，所以console.log(‘res:’ + res)的结果为res: [object Object]。</p><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><h3 id="父子组件相互传递数据"><a href="#父子组件相互传递数据" class="headerlink" title="父子组件相互传递数据"></a>父子组件相互传递数据</h3><p><a href="https://www.cnblogs.com/minorf/p/12978688.html">原链接</a></p><ol><li>创建父组件index<pre class="line-numbers language-none"><code class="language-none">import React, { useState } from "react";import { Input } from 'antd'import ChildComponent from "./ChildComponent"; export default () =&gt; {  const [inputValue1, setInputValue] = useState&lt;string&gt;('传递的第一个参数')  return (    &lt;div&gt;      &lt;div&gt;        &lt;h2&gt;父组件&lt;/h2&gt;        &lt;Input style={{ width: '200px' }} placeholder='请输入内容' value={inputValue1} onChange={(e) =&gt; setInputValue(e.target.value)} /&gt;      &lt;/div&gt;      &lt;ChildComponent inputValue1={inputValue1}/&gt;　　//向子组件传递了一个inputValue1   &lt;/div&gt;  );};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>创建子组件ChildComponent<pre class="line-numbers language-none"><code class="language-none">import React, { useState } from "react";import { Button } from "antd";export default (props: any) =&gt; {  return (    &lt;div&gt;      &lt;h2&gt;子组件&lt;/h2&gt;      &lt;p&gt;inputValue1：{props.inputValue1}&lt;/p&gt;　　//通过props拿到了父组件传递的inputValue1    &lt;/div&gt;  );};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>父组件向子组件传值<br>父组件向子组件传值时，先将需要传递的值传递给子组件，然后在子组件中，使用props来接收父组件传递过来的值，具体的可看创建父子组件的代码。</li></ol><p>父组件将inputValue1传递给子组件：<br></p><pre class="line-numbers language-none"><code class="language-none">&lt;ChildComponent inputValue1={inputValue1} /&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>子组件通过props接收inputValue1：<br><pre class="line-numbers language-none"><code class="language-none">&lt;p&gt;inputValue1：{props.inputValue1}&lt;/p&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p><ol><li>子组件向父组件传值<br>子组件向父组件传值时，需要通过触发方法来传递给父组件</li></ol><p>父组件定义一个方法：<br></p><pre class="line-numbers language-none"><code class="language-none">const childClickFunc = (value: any) =&gt; {    //通过触发方法改变父组件的值   value即为子组件传递给父组件的值    setInputValue(value)　  }&lt;ChildComponent inputValue1={inputValue1} childClick={childClickFunc} /&gt;     //定义一个childClickFunc方法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>子组件触发父组件方法：<br></p><pre class="line-numbers language-none"><code class="language-none">&lt;Button onClick={() =&gt; props.childClick('子组件改变父组件的inputValue')}&gt;点击改变父组件的值&lt;/Button&gt; //通过props触发父组件传递的方法<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p><ol><li>父组件向子组件传递多个值的写法<br>法一：<pre class="line-numbers language-none"><code class="language-none">&lt;ChildComponent inputValue1={inputValue1} inputValue2={inputValue2} inputValue3={inputValue3} childClick={childClickFunc} /&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>法二：<pre class="line-numbers language-none"><code class="language-none">&lt;ChildComponent {...{ inputValue1, inputValue2, inputValue3 }} childClick={childClickFunc} /&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="forEach-遍历"><a href="#forEach-遍历" class="headerlink" title="forEach 遍历"></a>forEach 遍历</h4><p>forEach 接收一个函数作为参数，在遍历每一项的时候，这个函数会被调用，同时将当前遍历到的项、当前项的下标（索引)、遍历的数组作为函数参数传递过来。</p><pre class="line-numbers language-none"><code class="language-none">var arr = ['第一项', '第二项', '第三项', '第四项', '第五项'];arr.forEach(function(item, index, arr) {  console.log('第' + (index + 1) + '项的值是：' + item);});<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p><a href="https://blog.csdn.net/wangdan_2013/article/details/78316844">原文链接</a></p><pre class="line-numbers language-none"><code class="language-none">let numbers = [1, 5, 10, 15];let doubles = numbers.map((x) =&gt; {   return x * 2;});// doubles is now [2, 10, 20, 30]// numbers is still [1, 5, 10, 15]let numbers = [1, 4, 9];let roots = numbers.map(Math.sqrt);// roots is now [1, 2, 3]// numbers is still [1, 4, 9]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>语法</strong></p><pre class="line-numbers language-none"><code class="language-none">let array = arr.map(function callback(currentValue, index, array) {     // Return element for new_array }[, thisArg])//currentValue，数组中正在处理的当前元素。//index，数组中正在处理的当前元素的索引。//array，map 方法被调用的数组。//thisArg可选的。执行 callback 函数时 使用的this 值。//返回值：一个新数组，每个元素都是回调函数的结果。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>描述</strong><br>map 方法会给原数组中的每个元素都按顺序调用一次 callback 函数。callback 每次执行后的返回值（包括 undefined）组合起来形成一个新数组。 callback 函数只会在有值的索引上被调用；那些从来没被赋过值或者使用 delete 删除的索引则不会被调用。</p><p>callback 函数会被自动传入三个参数：数组元素，元素索引，原数组本身。</p><p>如果 thisArg 参数有值，则每次 callback 函数被调用的时候，this 都会指向 thisArg 参数上的这个对象。如果省略了 thisArg 参数,或者赋值为 null 或 undefined，则 this 指向全局对象 。</p><p>map 不修改调用它的原数组本身（当然可以在 callback 执行时改变原数组）。</p><p>使用 map 方法处理数组时，数组元素的范围是在 callback 方法第一次调用之前就已经确定了。在 map 方法执行的过程中：原数组中新增加的元素将不会被 callback 访问到；若已经存在的元素被改变或删除了，则它们的传递到 callback 的值是 map 方法遍历到它们的那一时刻的值；而被删除的元素将不会被访问到。</p><p><strong>更多用法见原文</strong></p><h4 id="增减数组项"><a href="#增减数组项" class="headerlink" title="增减数组项"></a>增减数组项</h4><p><strong>慕课网javascript</strong></p><h4 id="Arrays-from"><a href="#Arrays-from" class="headerlink" title="Arrays.from"></a>Arrays.from</h4><p>先说下<strong>类数组</strong><br>类数组并不是数组，而是长得像数组的对象。<br></p><pre class="line-numbers language-none"><code class="language-none">var fakeArray = {  0: '第一项',  1: '第二项',  3: '第三项',  length: 3,};console.log(fakeArray[0]); // 输出："第一项"console.log(fakeArray.length); // 输出：3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><strong>但是我们不能直接使用数组的方法，需要先把类数组转化为数组,用的就是Arrays.from</strong><p></p><p>功能：</p><ol><li>类数组转化为数组</li><li>从字符串生成数组</li><li>从Set生成数组</li><li>从Map生成数组</li></ol><p>具体使用见慕课网ES6</p><h4 id="判断数组是否为空"><a href="#判断数组是否为空" class="headerlink" title="判断数组是否为空"></a>判断数组是否为空</h4><pre class="line-numbers language-none"><code class="language-none">var arr = [];if(Array.isArray(arr) &amp;&amp; arr.length === 0){    console.log('是空数组');}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="数组是否存在某个值"><a href="#数组是否存在某个值" class="headerlink" title="数组是否存在某个值"></a>数组是否存在某个值</h4><p><a href="https://segmentfault.com/a/1190000014202195">详细内容见原文</a></p><ol><li><p>array.indexOf<br>判断数组中是否存在某个值，如果存在返回数组元素的<strong>下标</strong>，否则返回-1</p><pre class="line-numbers language-none"><code class="language-none">let arr = ['something', 'anything', 'nothing', 'anything'];let index = arr.indexOf('nothing');# 结果：2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>array.includes(searchElement[, fromIndex])</p><pre class="line-numbers language-none"><code class="language-none">let numbers = [12, 5, 8, 130, 44];let result = numbers.includes(8);# 结果： trueresult = numbers.includes(118);# 结果： false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h4 id="判断对象是否为空"><a href="#判断对象是否为空" class="headerlink" title="判断对象是否为空"></a>判断对象是否为空</h4><ol><li><p>1.通过JSON自带的stringify()方法来判断</p><pre class="line-numbers language-none"><code class="language-none">   function isEmptyObj(obj) {    return JSON.stringify(obj) === '{}'    }console.log('对象是否为空：', isEmptyObj({}))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>使用ES6的Object.keys()方法</p><pre class="line-numbers language-none"><code class="language-none">function isEmptyObj(obj) {    return Object.keys(obj).length === 0}console.log('对象是否为空：', isEmptyObj({}))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>for in 循环判断</p><pre class="line-numbers language-none"><code class="language-none">function isEmptyObj(obj) {    for(let item in obj) {        return true    }    return false}    console.log('对象是否为空：', isEmptyObj({}))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="Object-create-创建实例对象"><a href="#Object-create-创建实例对象" class="headerlink" title="Object.create() 创建实例对象"></a>Object.create() 创建实例对象</h4><p><strong>原文见网道</strong><br>构造函数作为模板，可以生成实例对象。但是，有时拿不到构造函数，只能拿到一个现有的对象。我们希望以这个现有的对象作为模板，生成新的实例对象，这时就可以使用Object.create()方法。</p><pre class="line-numbers language-none"><code class="language-none">var person1 = {  name: '张三',  age: 38,  greeting: function() {    console.log('Hi! I\'m ' + this.name + '.');  }};var person2 = Object.create(person1);person2.name // 张三person2.greeting() // Hi! I'm 张三.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码中，对象person1是person2的模板，后者继承了前者的属性和方法。</p><h3 id="console-log-技巧"><a href="#console-log-技巧" class="headerlink" title="console.log() 技巧"></a>console.log() 技巧</h3><p><a href="https://blog.csdn.net/qq449245884/article/details/105085580">原文链接</a></p><ol><li>打印全变量名<br>变量加上大括号,要表示值和变量之间关系，可以用花括号把变量包起来：{b}<pre class="line-numbers language-none"><code class="language-none">console.log({b})<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>格式化<pre class="line-numbers language-none"><code class="language-none">const user = '前端小智';const attempts = 5; console.log('%s 登录失败了 %i 次', user, attempts);// 前端小智 登录失败了 5 次<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><h3 id="同步、异步"><a href="#同步、异步" class="headerlink" title="同步、异步"></a>同步、异步</h3><p><strong>同步</strong> 行为通常指代码从上到下一行一行的顺序执行，后面的代码总是在前面的代码执行完成以后才会执行。<br></p><pre class="line-numbers language-none"><code class="language-none">let a, b;function foo() {    a = 1;}foo();b = a + 1;console.log(b); //2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p><strong>异步</strong> 行为则指代码并非按照顺序执行，后面的代码不一定总是在前面的代码执行完成以后才会执行。<br></p><pre class="line-numbers language-none"><code class="language-none">let a, b;function foo() {    a = 1;}setTimeout(foo, 1000); //1 秒以后再调用 foo()b = a + 1;console.log(b); //NaN<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><ol><li><p>这里没有显式的调用 foo()，而是将函数名 foo 传递给 setTimeout，JavaScript 运行时在 1 秒以后会自动调用 foo()。</p></li><li><p>首先代码依然顺序执行，当执行到 setTimeout(foo, 1000); 时，JavaScript 主线程发现这是一个将要异步执行的任务，就会将 foo() 放入 任务队列 然后继续执行下面的同步代码 b = a + 1;，当 b = a + 1; 执行完毕，所有同步代码都被执行完成，此时 JavaScript 主线程再去 任务队列 中取出需要执行的任务来执行，也就是 1 秒后执行 foo()。</p></li><li><p>因为 b = a + 1; 先于 foo() 执行，所以这段异步操作执行后，变量 b 最终结果为 NaN。</p></li></ol><p>在 <strong>异步</strong> 操作示例中，<strong>setTimeout(foo, 1000)</strong>; 这句代码中的 <strong>foo</strong> 就可以被称作 回调函数。所谓 回调函数，就是被主线程放入到 任务队列 中的代码，这段代码通常以函数为单位，并且等到所有 同步 代码执行完成以后才会被执行。</p><p><strong>解决办法：</strong><br>所以上面的 <strong>异步</strong> 操作示例程序如果想得到与 <strong>同步</strong> 操作一样的结果，就得改成这样：</p><pre class="line-numbers language-none"><code class="language-none">let a, b;function foo() {    a = 1;    b = a + 1;    console.log(b); //2}setTimeout(foo, 1000); //1 秒以后再调用 foo()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为计算 b 的值时依赖 a 的值，而 a = 1; 是在 回调函数 中执行的，也就是说所有 同步 代码执行完成以后才会执行 回调函数 中的 异步 代码，所以 b = a + 1; 也要移动到 回调函数 中。回调函数 中的代码也是顺序执行的，所以 b = a + 1; 语句要放在 a = 1; 语句之后。这样就能使变量 b 最终结果为 2</p><h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3><p><a href="https://blog.csdn.net/qq_37860963/article/details/81539118?spm=1001.2101.3001.6650.8&amp;depth_1-utm_relevant_index=11">原文链接</a></p><pre class="line-numbers language-none"><code class="language-none">var isLiForget = false; //给一个布尔值判断小丽有没有忘记小花的生日var getCloth = new Promise(function(resolve,reject){    if(!isLiForget){ //没忘记        var cloth = {            color:'red',            price:'$120'        };        resolve(cloth); // 得到衣服    }else{        var err = new Error("forgot the promise"); //忘记了        reject(err);    }}); //之后就是调用Promise了var testFn = function(){    getCloth.then(function(fulfilled){        console.log(fulfilled);    }).catch(function(rejected){        console.log(rejected.message);    });}testFn();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于promise的理解</p><ol><li>resolve、reject会选择一个执行，这两个是调用这个对象的时候传过来的<strong>函数</strong></li><li>以上面代码为例。<code>resolve(cloth)</code>。resolve就是外面传过来的函数，其实就是``` function(fulfilled){<pre><code> console.log(fulfilled);  <pre class="line-numbers language-这个函数不就是答应吗，参数cloth与fulfilled对应，就是打印cloth的值" data-language="这个函数不就是答应吗，参数cloth与fulfilled对应，就是打印cloth的值"><code class="language-这个函数不就是答应吗，参数cloth与fulfilled对应，就是打印cloth的值">3. 要调用或者获取promise里面的值，需要用到then。写发有点区别，不过逻辑就是正确执行这个函数，错误执行那个函数。具体可以看链接。### async/await取值（很重要！！）![t2.png](https://s2.loli.net/2022/06/17/e6wAUrRa3HQzdbV.png)![t3.png](https://s2.loli.net/2022/06/17/9pqnMu5TcPIDGli.png)**我要把opts这个值传给组件里面的option属性，opts是一个数组，数组的值如下图所示**![t1.png](https://s2.loli.net/2022/06/17/1w6SBlZx39PAgpK.png)之前的做法是把值赋给一个变量，然后传给需要用的地方，但是行不通，估计是异步的原因，**state**可以解决这个问题。**解决方法****用useState定义一个变量(Options)，然后用更新函数接(serOptions)收新的值，再把这个变量放到需要的位置(option属性)就好。**### async/await[原链接](https://blog.csdn.net/qq_46658751/article/details/123373909)#### async作用 函数返回的是一个 Promise 对象，即便是字符串，数值，也会包装成Promise对象<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></code></pre>async function testAsync() {<br> return “hello async”;<br>}</li></ol><p>const result = testAsync();<br>console.log(result);<br></p><pre class="line-numbers language-none"><code class="language-none">![](https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/bd22592cd9fc45138b6cd8a70cbd50c6.png)#### await在等待什么await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值#### await等到要等的结果，之后呢？async 会将其后的函数（函数表达式或 Lambda）的返回值封装成一个 Promise 对象，而 await 会等待这个 Promise 完成，并将其 resolve 的结果返回出来。### 回调函数#### 用途**用途：一般情况下回调函数都用在页面与服务器的异步交互，以解决页面在提交请求后无法获得到服务器反馈的数据**为什么会出现面在提交请求后无法获得到服务器反馈的数据呢？首先来了解js的事件执行方式，如图![](https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/2020102020575826.png)js在执行程序时，所有代码都在执行栈中，此时都是同步在执行，但在运行代码时如果遇见事件绑定、计时器会将抛到异步任务队列里面等待js引擎执行，然后继续执行在执行栈中的代码，于此同时，被抛到异步执行队列里面的计时器会执行等待的时间，如果等待时间结束，则会将此事件抛到执行队列里面。执行栈里面的代码执行完成后，程序会去检查执行队列里面是否有事件，如果有，则拿出来执行。如果没有，则会一直循环检查，直到异步事件队列和执行队列里面都没有才结束程序#### 回调示例：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>var fs = require(“fs”);<p></p><p>function f(x) {<br>    console.log(x)<br>}</p><p>function writeFile(callback) { //callback，表示这个参数不是一个普通变量，而是一个函数<br>    fs.writeFile(‘input.txt’, ‘我是通过fs.writeFile 写入文件的内容’, function (err) {<br>        if (!err) {<br>            console.log(“文件写入完毕!”)<br>            c = 1<br>            callback(c) // 因为我们传进来的函数名是f()，所以此行相当于调用一次f(c)<br>        }<br>    });<br>}<br>var c = 0<br>writeFile(f) // 函数f作为一个参数传进writeFile函数<br></p><pre class="line-numbers language-none"><code class="language-none">1. 此处并不一定非要写为“callback”，你可以任意写成abc, iloveyou...等等随你高兴。callback只是一种约定俗成的写法，它明确地告诉代码阅读者：此处是一个回调函数。2. 在大多数编程语言中，函数的形参总是从外向内传递参数，但在JS中，如果形参碰到“关键字” callback 则完全相反，它表示从内向外反向调用某个外部函数。有时候，我们会看到一些函数的形参列表里直接嵌套一个函数的情况，其本质上仍然是回调函数，因为没有了函数名，所以也称**匿名函数**。如本例如果要写成这种风格的话就是长成这样了：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>var fs = require(“fs”);<p></p><p>function writeFile(callback) {<br>    fs.writeFile(‘input.txt’, ‘我是通过fs.writeFile 写入文件的内容’, function (err) {<br>        if (!err) {<br>            console.log(“文件写入完毕!”)<br>            c = 1<br>            callback(c)<br>        }<br>    });<br>}<br>var c = 0<br>writeFile(function (x) {<br>    console.log(x)<br>})<br></p><pre class="line-numbers language-none"><code class="language-none">### 获取异步函数返回值的方法在项目中会遇到通过ajax、setTimeout等异步操作向后台获取数据，而js自身不会等待数据拿到后再进行下一步操作，所以会导致其他函数无法获取异步操作函数内的数据。例如：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>function back(x,y){<br>    var ret;<br>    setTimeout(function(){<br>        ret = x + y;<br>    },1000)<br>    return ret;<br>};<p></p><p>console.log(back(10,20));    //undefined<br></p><pre class="line-numbers language-none"><code class="language-none">1. 回调函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br>function back(x,y,callback){<br>    setTimeout(function(){<br>        var ret = x + y<br>        callback(ret)<br>    },1000)<br>}<p></p><p>back(10,20,function(a){<br>    //在这里面就可以进行对数据的操作了</p><pre><code>console.log(a)    //a就是回调的结果，输出30</code></pre><p>})<br></p><pre class="line-numbers language-none"><code class="language-none">```function getSomething(cb) {    var r = 0;    setTimeout(function() {        r = 2;        cb(r)//回调函数    },10)}function compute(x) {    alert(x * 2);}getSomething(compute);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><ol><li><p>通过promise的方式</p><pre class="line-numbers language-none"><code class="language-none">function getSomething() {    var r = 0;    return new Promise(function(resolve) {        setTimeout(function(){            r = 2;            resolve(r);        },10)    })}function compute(x) {    alert(x * 2);}getSomething().then(compute);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>通过async的方式</p><pre class="line-numbers language-none"><code class="language-none">function getSomething() {    var r = 0;    return new Promise(function(resolve) {        setTimeout(function() {            r = 2;            resolve(r);        },10)    })}async function compute() {    var x = await getSomething();    alert(x * 2);}compute();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>通过generator方式实现</p><pre class="line-numbers language-none"><code class="language-none">function getSomething() {    var r = 0;    setTimeout(function() {        r = 2;        it.next(r);    },10);}function *compute(it) {    var x = yield getSomething();    alert(x * 2);}var it = compute();it.next();//同步的写法实现异步的逻辑<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>通过promise和generator相结合的方式</p><pre class="line-numbers language-none"><code class="language-none">function getSomething() {    var r = 0;    return new Promise(function(resolve) {        setTimeout(function() {            r = 2;            resolve(r);        },10)    })}function *compute() {    var x = yield getSomething();    alert(x * 2);}var it = compute();it.next().value.then(function(value) {    it.next(value);})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><p><strong>AJAX（Asynchronous Javascript And XML）翻译成中文就是“异步的Javascript和XML”</strong><br><strong>实现前后端数据的交互</strong></p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.Ajax最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。 <span class="token punctuation">(</span>这一特点给用户的感受是在不知不觉中完成请求和响应过程<span class="token punctuation">)</span> <span class="token number">2</span>.Ajax不需要任何浏览器插件，但需要用户允许javaScript在浏览器上执行。同步交互: 客户端发出一个请求后，需要等待服务器响应结束后，才能发出第二个请求。异步交互: 客户端发出一个请求后，无需要等待服务器响应结束，就可以发出第二个请求。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Ajax使用JavaScript技术向服务器发送异步请求</p><p>Ajax请求无须刷新整个页面</p><p>因为服务器响应内容不再是整个页面，而是页面中的部分内容，所以Ajax性能高！</p><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/a83d7857217f3e6d72b8fab68fb3adb9.gif" alt=""></p><h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><p><a href="[https](https://blog.csdn.net/a153375250/article/details/53434299">原链接</a>)</p><h3 id="JSX是什么"><a href="#JSX是什么" class="headerlink" title="JSX是什么"></a>JSX是什么</h3><p>JSX是一种像下面这样的语法：<br></p><pre class="line-numbers language-none"><code class="language-none">const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p><p>它是一种JavaScript语法扩展，在React中可以方便地用来描述UI。<br>质上，JSX为我们提供了创建React元素方法（React.createElement(component, props, …children)）的语法糖（syntactic sugar）。上面的代码实质上等价于：</p><pre class="line-numbers language-none"><code class="language-none">var element = React.createElement(  "h1",  null,  "Hello, world!");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="在JSX中使用JavaScript表达式"><a href="#在JSX中使用JavaScript表达式" class="headerlink" title="在JSX中使用JavaScript表达式"></a>在JSX中使用JavaScript表达式</h3><p>在JSX中插入JavaScript表达式十分简单，直接<strong>在JSX中将JS表达式用大括号括起来即可</strong>。例如：</p><pre class="line-numbers language-none"><code class="language-none">function formatName(user) {  return user.firstName + ' ' + user.lastName;}const user = {  firstName: 'Harper',  lastName: 'Perez'};const element = (  &lt;h1&gt;    Hello, {formatName(user)}!  &lt;/h1&gt;);ReactDOM.render(  element,  document.getElementById('root'));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码中用到了函数调用表达式fromatName(user)。</p><p>在JavaScript中，表达式就是一个短语，Javascript解释器会将其计算出一个结果，常量就是最简单的一类表达式。常用的表达式有：</p><ul><li>变量名；</li><li>函数定义表达式；</li><li>属性访问表达式；</li><li>函数调用表达式；</li><li>算数表达式；</li><li>关系表达式；</li><li>逻辑表达式；</li></ul><p>需要注意的是，if语句以及for循环不是JavaScript表达式，不能直接作为表达式写在{}中，但可以先将其赋值给一个变量（变量是一个JavaScript表达式）:</p><pre class="line-numbers language-none"><code class="language-none">function NumberDescriber(props) {  let description;  if (props.number % 2 == 0) {    description = &lt;strong&gt;even&lt;/strong&gt;;  } else {    description = &lt;i&gt;odd&lt;/i&gt;;  }  return &lt;div&gt;{props.number} is an {description} number&lt;/div&gt;;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="JSX属性值"><a href="#JSX属性值" class="headerlink" title="JSX属性值"></a>JSX属性值</h3><p>你可以使用引号将字符串字面量指定为属性值：<br><code>const element = &lt;div tabIndex="0"&gt;&lt;/div&gt;;</code><br><strong>注意这里的”0”是一个字符串字面量。</strong></p><p>或者你可以将一个JavaScript表达式嵌在一个大括号中作为属性值：<br><code>const element = &lt;img src={user.avatarUrl}&gt;&lt;/img&gt;;</code></p><p>这里用到的是JavaScript属性访问表达式，上面的代码将编译为：</p><p><code>const element = React.createElement("img", { src: user.avatarUrl });</code></p><h3 id="JSX的Children"><a href="#JSX的Children" class="headerlink" title="JSX的Children"></a>JSX的Children</h3><p>首先JSX可以是一个不包含Children的empty tag。如：</p><p><code>const element = &lt;img src={user.avatarUrl} /&gt;;</code></p><p>JSX也可以像HTML标签一样包含Children：</p><pre class="line-numbers language-none"><code class="language-none">const element = (  &lt;div&gt;    &lt;h1&gt;Hello!&lt;/h1&gt;    &lt;h2&gt;Good to see you here.&lt;/h2&gt;  &lt;/div&gt;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>后面一部分不是很重要，可看原文</strong><br>React自定义组件的chilren是不会像固有的HTML标签的子元素那样自动render的，我们看下面的例子：<br></p><pre class="line-numbers language-none"><code class="language-none">代码1class Test extends React.Component {    render() {      return (        &lt;div&gt;          Here is a list:          &lt;ul&gt;            &lt;li&gt;Item 1&lt;/li&gt;            &lt;li&gt;Item 2&lt;/li&gt;          &lt;/ul&gt;        &lt;/div&gt;      )     }};ReactDOM.render(    &lt;Test /&gt;,    document.getElementById('test'));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>以上代码定义的组件中都是build-in组件，类似div、p、ul、li等。它们中的子元素会直接render出来，像下面这样：<p></p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/htmlrender.jpg" alt=""></p><p>但是如果你使用用户定义组件，比如：<br></p><pre class="line-numbers language-none"><code class="language-none">class Test extends React.Component {    render() {      return (      &lt;Em&gt;        Here is a list:        &lt;ul&gt;          &lt;li&gt;Item 1&lt;/li&gt;          &lt;li&gt;Item 2&lt;/li&gt;        &lt;/ul&gt;      &lt;/Em&gt;    )     }};class Em extends React.Component {  render() {    return (&lt;div&gt;&lt;/div&gt;);  }}ReactDOM.render(    &lt;Test /&gt;,    document.getElementById('test'));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>并不能得到跟上面代码1一样的结果，我们得到的只是一个空的div标签：<p></p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/userrender.jpg" alt=""></p><p>如果你想得到和代码1一样的结果，需要显示地指定props.children，像下面这样：</p><pre class="line-numbers language-none"><code class="language-none">class Test extends React.Component {    render() {      return (          &lt;Em&gt;            Here is a list:            &lt;ul&gt;              &lt;li&gt;Item 1&lt;/li&gt;              &lt;li&gt;Item 2&lt;/li&gt;            &lt;/ul&gt;          &lt;/Em&gt;      )     }};class Em extends React.Component {  render() {    return (&lt;div&gt;{this.props.children}&lt;/div&gt;);  }}ReactDOM.render(    &lt;Test /&gt;,    document.getElementById('test'));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="JSX中的props"><a href="#JSX中的props" class="headerlink" title="JSX中的props"></a>JSX中的props</h3><p>指定JSX中的props有以下几种方式：</p><ol><li>使用JavaScript表达式</li></ol><p>任何有效的JavaScript表达式都可以作为prop的值，使用的时候将该表达式放在一对大括号中即可：</p><pre class="line-numbers language-none"><code class="language-none">&lt;MyComponent foo={1 + 2 + 3 + 4} /&gt;&lt;YourComponent clickTodo={(id) =&gt; this.props.handleClick(id)} /&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol><li>使用字符串字面量<br>字符串字面量可以作为prop值，下面的代码是等价的：</li></ol><pre class="line-numbers language-none"><code class="language-none">&lt;MyComponent message="hello world" /&gt;&lt;MyComponent message={'hello world'} /&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol><li>使用扩展运算符<br>如果你想将一个prop对象传入JSX，你可以使用扩展运算符…直接将整个prop对象传入。下面的2个组件是等价的：</li></ol><pre class="line-numbers language-none"><code class="language-none">function App1() {  return &lt;Greeting firstName="Ben" lastName="Hector" /&gt;;}function App2() {  const props = {firstName: 'Ben', lastName: 'Hector'};  return &lt;Greeting {...props} /&gt;;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>扩展运算符是一个es6特性。是一种传递属性的十分便利的方式。但请注意不要滥用该运算符，注意不要将一大堆毫不相关的prop一股脑全部传入下面的组件中。</p><h3 id="JSX中的Children"><a href="#JSX中的Children" class="headerlink" title="JSX中的Children"></a>JSX中的Children</h3><p>React组件中有一个特殊的prop–props.children。它指代了JSX表达式中开闭标签中包含的内容。</p><p>下面讨论的是几种指定JSX的children的方法：</p><p>(1)使用字符串字面量<br>(2)JSX元素作为children<br>(3)JavaScript表达式<br>(4)函数children</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>(1)使用JSX时要引入React库<br>(2)注意引入JSX中用到的自定义组件<br>(3)自定义组件首字母一定要大写<br>(4)元素标签名不能使用表达式<br>(5)设置style属性</p><p>在设置标签style属性的时候，要注意，我们是将一个描述style的对象以JavaScipt表达式的形式传入。因此应该有2层大括号：<br></p><pre class="line-numbers language-none"><code class="language-none">&lt;div style={{color:'red', margin:'10px auto'}}&gt;&lt;/div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p><h3 id="判断条件"><a href="#判断条件" class="headerlink" title="判断条件"></a>判断条件</h3><p>在react 组件return语句里面如果要使用判断语句，像下面这样。</p><pre class="line-numbers language-none"><code class="language-none">{judgeSchema(project)? (        &lt;div&gt;          &lt;Form1 schema={projtestParaHYPara}&gt;&lt;/Form1&gt;        &lt;/div&gt;    ):      null    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Dom"><a href="#Dom" class="headerlink" title="Dom"></a>Dom</h2><h3 id="Dom简介"><a href="#Dom简介" class="headerlink" title="Dom简介"></a>Dom简介</h3><p>DOM (Document Object Model，文档对象模型) 是 W3C 制定的访问、操作 HTML 和XML的标准。</p><p>DOM 节点是契合HTML标准的，可以对其细分：</p><p>整个文档是一个文档节点<br>HTML 元素内的文本是文本节点<br>每个 HTML 元素是元素节点<br>每个 HTML 属性是属性节点<br>注释为注释节点</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/5e82d6a40942890d12001242.jpg" alt=""></p><h3 id="获取与操作Dom"><a href="#获取与操作Dom" class="headerlink" title="获取与操作Dom"></a>获取与操作Dom</h3><p><strong>详细的可以看慕课网</strong></p><p>获取 DOM 节点的方式有很多，这里例举几个常用的，所有的 DOM 元素都具有以下方法：</p><p>element.getElementById<br>element.getElementByName<br>element.getElementsByTagName<br>element.getElementsByClassName<br>element.querySelector<br>element.querySelectorAll</p><h2 id="Npm"><a href="#Npm" class="headerlink" title="Npm"></a>Npm</h2><h3 id="查看包信息"><a href="#查看包信息" class="headerlink" title="查看包信息"></a>查看包信息</h3><p>方案一：<br><strong>直接看package.json，项目相关的都在里面</strong></p><p>方案二：</p><p>查看全局已安装（-g 的意思是 global 全局的意思）</p><pre class="line-numbers language-none"><code class="language-none">$ npm ls -g<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看当前项目已安装包（项目跟目录必须有 package.json 文件）<br></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>查看包本版<p></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> view <span class="token operator">&lt;</span>packagename<span class="token operator">&gt;</span> versions --json<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同样也是会把所有包的依赖显示出来。同上，加上 —depth 0 就好了。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">ls</span> --depth <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果只想显示生产环境依赖的包</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">ls</span> --depth <span class="token number">0</span> --prod<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>只显示开发环境依赖的包</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">ls</span> --depth <span class="token number">0</span> --dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="npm-与-npx"><a href="#npm-与-npx" class="headerlink" title="npm 与 npx"></a>npm 与 npx</h3><p>在npm的基础之上，npx让npm包中的命令行工具和其他可执行文件在使用上变得更加简单。它极大地简化了我们之前使用纯粹的npm时所需要的大量步骤。</p><p><strong>区别1.一个永久存在，一个临时安装，用完后删除</strong></p><pre class="line-numbers language-none"><code class="language-none">npm install -g create-react-appcreate-react-app test-app<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">npx create-react-app test-app<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>npm他会在本地全局性的安装create-react-app，这个包会存储在node目录下面去。以后创建react项目直接执行create-react-app命令就可以了。<br>npx命令他会把create-react-app安装包临时安装上，等项目初始化完成以后，他就删除掉。</p><p><strong>npx 会帮你执行依赖包里的二进制文件</strong></p><p>执行webpack里面的文件 npm执行<br></p><pre class="line-numbers language-none"><code class="language-none">npm i -D webpack ./node_modules/.bin/webpack -v结果是：6.9.0或者执行npm i -D webpack`npm bin`/webpack -v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>npx执行<br><pre class="line-numbers language-none"><code class="language-none">npm i -D webpacknpx webpack -v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br> npx 会自动查找当前依赖包中的可执行文件，如果找不到，就会去环境变量里面的 PATH 里找。如果依然找不到，就会帮你安装！<p></p><p><strong>区别3.npx可以执行文件，但是npm不可以</strong></p><h3 id="npm与yarn"><a href="#npm与yarn" class="headerlink" title="npm与yarn"></a>npm与yarn</h3><p>命令对比<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/Snipaste_2023-02-06_09-56-57.png" alt=""></p><p><a href="https://zhuanlan.zhihu.com/p/27449990">原文链接</a></p><p>“Yarn是由Facebook、Google、Exponent 和 Tilde 联合推出了一个新的 JS 包管理工具 ，正如官方文档中写的，Yarn 是为了弥补 npm 的一些缺陷而出现的。”这句话让我想起了使用npm时的坑了：</p><ul><li>npm install的时候巨慢。特别是新的项目拉下来要等半天，删除node_modules，重新install的时候依旧如此。</li><li>同一个项目，安装的时候无法保持一致性。由于package.json文件中版本号的特点，下面三个版本号在安装的时候代表不同的含义。</li></ul><pre class="line-numbers language-none"><code class="language-none">"5.0.3","~5.0.3","^5.0.3"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>“5.0.3”表示安装指定的5.0.3版本，“～5.0.3”表示安装5.0.X中最新的版本，“^5.0.3”表示安装5.X.X中最新的版本。这就麻烦了，常常会出现同一个项目，有的同事是OK的，有的同事会由于安装的版本不一致出现bug。</p><ul><li>安装的时候，包会在同一时间下载和安装，中途某个时候，一个包抛出了一个错误，但是npm会继续下载和安装包。因为npm会把所有的日志输出到终端，有关错误包的错误信息就会在一大堆npm打印的警告中丢失掉，并且你甚至永远不会注意到实际发生的错误。</li></ul><p><strong>Yarn的优点</strong><br>速度快 。速度快主要来自以下两个方面：<br>并行安装：无论 npm 还是 Yarn 在执行包的安装时，都会执行一系列任务。npm 是按照队列执行每个 package，也就是说必须要等到当前 package 安装完成之后，才能继续后面的安装。而 Yarn 是同步执行所有任务，提高了性能。<br>离线模式：如果之前已经安装过一个软件包，用Yarn再次安装时之间从缓存中获取，就不用像npm那样再从网络下载了。<br>安装版本统一：为了防止拉取到不同的版本，Yarn 有一个锁定文件 (lock file) 记录了被确切安装上的模块的版本号。每次只要新增了一个模块，Yarn 就会创建（或更新）yarn.lock 这个文件。这么做就保证了，每一次拉取同一个项目依赖时，使用的都是一样的模块版本。npm 其实也有办法实现处处使用相同版本的 packages，但需要开发者执行 npm shrinkwrap 命令。这个命令将会生成一个锁定文件，在执行 npm install 的时候，该锁定文件会先被读取，和 Yarn 读取 yarn.lock 文件一个道理。npm 和 Yarn 两者的不同之处在于，Yarn 默认会生成这样的锁定文件，而 npm 要通过 shrinkwrap 命令生成 npm-shrinkwrap.json 文件，只有当这个文件存在的时候，packages 版本信息才会被记录和更新。<br>更简洁的输出：npm 的输出信息比较冗长。在执行 npm install 的时候，命令行里会不断地打印出所有被安装上的依赖。相比之下，Yarn 简洁太多：默认情况下，结合了 emoji直观且直接地打印出必要的信息，也提供了一些命令供开发者查询额外的安装信息。<br>多注册来源处理：所有的依赖包，不管他被不同的库间接关联引用多少次，安装这个包时，只会从一个注册来源去装，要么是 npm 要么是 bower, 防止出现混乱不一致。<br>更好的语义化： yarn改变了一些npm命令的名称，比如 yarn add/remove，感觉上比 npm 原本的 install/uninstall 要更清晰。</p><h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p><a href="https://blog.csdn.net/weixin_48837605/article/details/119494467">原文链接</a></p><h3 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h3><p> 当一个请求url的<strong>协议,域名,端口</strong>三者之间任意一个与当前的url不同都即为跨域</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"> 当前页面url                  被请求页面url                是否跨域            原因http://www.test.com/    http://www.test.com/index.html    否            同源（协议、域名、端口号相同）http://www.test.com/    https://www.test.com/index.html   跨域          协议不同（http/https）http://www.test.com/    http://www.baidu.com/             跨域          主域名不同（test/baidu）http://www.test.com/    http://blog.test.com/             跨域          子域名不同（www/blog）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="为什么会出现跨域"><a href="#为什么会出现跨域" class="headerlink" title="为什么会出现跨域"></a>为什么会出现跨域</h3><p>出于浏览器的同源策略限制.同源策略是一种约定,它是浏览器最核心也是最基本的安全功能,如果缺少了同源策略,则浏览器的正常的功能可能会受到影响,跨域收是Web是构建在同源策略基础上的,浏览器只是针对同源策略的一种实现,同源策略会阻止一个域的JavaScript脚本和另一个域的内容进行交互,所谓同源(即指同一个域)就是两个页面具备同样的协议(protocol),主机(host)和端口号(port)</p><p><strong>请求是跨域的，并不一定会报错。普通的图片请求，css文件请求是不会报错的</strong></p><h3 id="跨域会阻止什么操作"><a href="#跨域会阻止什么操作" class="headerlink" title="跨域会阻止什么操作"></a>跨域会阻止什么操作</h3><p>浏览器是从两个方面去做这个同源策略的，一是针对接口的请求，二是针对Dom的查询</p><h4 id="1-阻止接口请求"><a href="#1-阻止接口请求" class="headerlink" title="1.阻止接口请求"></a>1.阻止接口请求</h4><p>比如用ajax从<a href="http://192.168.100.150:8020/实验/jsonp.html页面向http://192.168.100.150:8081/zhxZone/webmana/dict/jsonp发起请求，由于两个url端口不同，所以属于跨域，在console打印台会报No">http://192.168.100.150:8020/实验/jsonp.html页面向http://192.168.100.150:8081/zhxZone/webmana/dict/jsonp发起请求，由于两个url端口不同，所以属于跨域，在console打印台会报No</a> ‘Access-Control-Allow-Origin’ header is present on the requested resource<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20181207092232976.png" alt=""><br>值得说的是虽然浏览器禁止用户对请求返回数据的显示和操作，但浏览器确实是去请求了，如果服务器没有做限制的话会返回数据的，在调试模式的network中可以看到返回状态为200，且可看到返回数据<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20181207092757327.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20181207092820725.png" alt=""></p><h4 id="2-阻止dom获取和操作"><a href="#2-阻止dom获取和操作" class="headerlink" title="2.阻止dom获取和操作"></a>2.阻止dom获取和操作</h4><p>比如a页面中嵌入了iframe，src为不同源的b页面，则在a中无法操作b中的dom，也没有办法改变b中dom中的css样式。</p><p>而如果ab是同源的话是可以获取并操作的。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">&lt;</span>html<span class="token operator">&gt;</span><span class="token operator">&lt;</span>head<span class="token operator">&gt;</span><span class="token operator">&lt;</span>meta <span class="token assign-left variable">charset</span><span class="token operator">=</span><span class="token string">"UTF-8"</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span>title<span class="token operator">&gt;</span><span class="token operator">&lt;</span>/title<span class="token operator">&gt;</span><span class="token operator">&lt;</span>style <span class="token assign-left variable">type</span><span class="token operator">=</span><span class="token string">"text/css"</span><span class="token operator">&gt;</span>iframe<span class="token punctuation">{</span>width:100%<span class="token punctuation">;</span>height:800px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">&lt;</span>/style<span class="token operator">&gt;</span><span class="token operator">&lt;</span>/head<span class="token operator">&gt;</span><span class="token operator">&lt;</span>body<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">!</span>--<span class="token operator">&lt;</span>iframe <span class="token assign-left variable">src</span><span class="token operator">=</span><span class="token string">"http://192.168.100.150:8081/zhxZone/webmana/attachment/imageManager"</span> <span class="token assign-left variable">frameborder</span><span class="token operator">=</span><span class="token string">"0"</span> <span class="token assign-left variable">id</span><span class="token operator">=</span><span class="token string">"iframe"</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span>/iframe<span class="token operator">&gt;</span>--<span class="token operator">&gt;</span><span class="token operator">&lt;</span>iframe <span class="token assign-left variable">src</span><span class="token operator">=</span><span class="token string">"http://192.168.100.150:8020/实验/jsonp.html"</span> <span class="token assign-left variable">frameborder</span><span class="token operator">=</span><span class="token string">"0"</span> <span class="token assign-left variable">id</span><span class="token operator">=</span><span class="token string">"iframe"</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span>/iframe<span class="token operator">&gt;</span><span class="token operator">&lt;</span>script <span class="token assign-left variable">type</span><span class="token operator">=</span><span class="token string">"text/javascript"</span><span class="token operator">&gt;</span>var <span class="token assign-left variable">i</span><span class="token operator">=</span>document.getElementById<span class="token punctuation">(</span><span class="token string">"iframe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i.onload<span class="token operator">=</span><span class="token function-name function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>/*console.log<span class="token punctuation">(</span>i.contentDocument<span class="token punctuation">)</span>console.log<span class="token punctuation">(</span>i.contentWindow.document.getElementById<span class="token punctuation">(</span><span class="token string">"text"</span><span class="token punctuation">)</span>.innerHTML<span class="token punctuation">)</span>*/var <span class="token assign-left variable">b</span><span class="token operator">=</span>i.contentWindow.document.getElementsByTagName<span class="token punctuation">(</span><span class="token string">"body"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>i.contentWindow.document.getElementById<span class="token punctuation">(</span><span class="token string">"text"</span><span class="token punctuation">)</span>.style.background<span class="token operator">=</span><span class="token string">"gray"</span><span class="token punctuation">;</span>i.contentWindow.document.getElementById<span class="token punctuation">(</span><span class="token string">"text"</span><span class="token punctuation">)</span>.innerHTML<span class="token operator">=</span><span class="token string">"111"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">&lt;</span>/script<span class="token operator">&gt;</span><span class="token operator">&lt;</span>/body<span class="token operator">&gt;</span><span class="token operator">&lt;</span>/html<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>改变了iframe中的元素 </p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/8b0167fa9e5647359acc6466b8e421bd.png" alt=""></p><p>甚至是可以获取iframe中的cookie</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">var <span class="token assign-left variable">i</span><span class="token operator">=</span>document.getElementById<span class="token punctuation">(</span><span class="token string">"iframe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i.onload<span class="token operator">=</span><span class="token function-name function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>console.log<span class="token punctuation">(</span>i.contentDocument.cookie<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/681d3b6bcb6d4b039578fc23e6de073b.png" alt=""></p><p>不用说也知道这是极为危险的，所以浏览器才会阻止非同源操作dom</p><p>浏览器的这个限制虽然不能保证完全安全，但是会增加攻击的困难性</p><p>虽然安全机制挺好，可以抵御坏人入侵，但有时我们自己需要跨域请求接口数据或者操作自己的dom，也被浏览器阻止了，所以就需要跨域</p><p>跨域的前提肯定是你和服务器是一伙的，你可以控制服务器返回的数据，否则跨域是无法完成的 </p><h3 id="解决跨域的方法"><a href="#解决跨域的方法" class="headerlink" title="解决跨域的方法"></a>解决跨域的方法</h3><h4 id="前端jsp"><a href="#前端jsp" class="headerlink" title="前端jsp"></a>前端jsp</h4><h4 id="CORS方案"><a href="#CORS方案" class="headerlink" title="CORS方案"></a>CORS方案</h4><p><strong>就是通过服务器设置响应头来实现跨域</strong></p><p>CORS才是解决跨域的真正解决方案。<br>前端需要做什么？<br>无需做任何事情，正常发送Ajax请求即可。<br>后端需要做什么？<br>需要加 响应头 。或者使用第三方模块 cors 。<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20210807230949959.png" alt=""></p><h4 id="代理服务器（一般用Nginx）"><a href="#代理服务器（一般用Nginx）" class="headerlink" title="代理服务器（一般用Nginx）"></a>代理服务器（一般用Nginx）</h4><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20210807231812945.png" alt=""><br>   1).代理服务和前端服务之间由于协议域名端口三者统一不存在跨域的问题,可以直接发送请求</p><p>   2).代理服务和后端服务之间并不通过浏览器没有同源策略的限制,可以直接发送请求</p><p>这里是一个nginx启用COSR的参考配置</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#</span><span class="token comment"># Wide-open CORS config for nginx</span><span class="token comment">#</span>location / <span class="token punctuation">{</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$request_method</span> <span class="token operator">=</span> <span class="token string">'OPTIONS'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        add_header <span class="token string">'Access-Control-Allow-Origin'</span> <span class="token string">'*'</span><span class="token punctuation">;</span>        add_header <span class="token string">'Access-Control-Allow-Methods'</span> <span class="token string">'GET, POST, OPTIONS'</span><span class="token punctuation">;</span>        <span class="token comment">#</span>        <span class="token comment"># Custom headers and headers various browsers *should* be OK with but aren't</span>        <span class="token comment">#</span>        add_header <span class="token string">'Access-Control-Allow-Headers'</span> <span class="token string">'DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type'</span><span class="token punctuation">;</span>        <span class="token comment">#</span>        <span class="token comment"># Tell client that this pre-flight info is valid for 20 days</span>        <span class="token comment">#</span>        add_header <span class="token string">'Access-Control-Max-Age'</span> <span class="token number">1728000</span><span class="token punctuation">;</span>        add_header <span class="token string">'Content-Type'</span> <span class="token string">'text/plain charset=UTF-8'</span><span class="token punctuation">;</span>        add_header <span class="token string">'Content-Length'</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token builtin class-name">return</span> <span class="token number">204</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$request_method</span> <span class="token operator">=</span> <span class="token string">'POST'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        add_header <span class="token string">'Access-Control-Allow-Origin'</span> <span class="token string">'*'</span><span class="token punctuation">;</span>        add_header <span class="token string">'Access-Control-Allow-Methods'</span> <span class="token string">'GET, POST, OPTIONS'</span><span class="token punctuation">;</span>        add_header <span class="token string">'Access-Control-Allow-Headers'</span> <span class="token string">'DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type'</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$request_method</span> <span class="token operator">=</span> <span class="token string">'GET'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        add_header <span class="token string">'Access-Control-Allow-Origin'</span> <span class="token string">'*'</span><span class="token punctuation">;</span>        add_header <span class="token string">'Access-Control-Allow-Methods'</span> <span class="token string">'GET, POST, OPTIONS'</span><span class="token punctuation">;</span>        add_header <span class="token string">'Access-Control-Allow-Headers'</span> <span class="token string">'DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type'</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="调试方法"><a href="#调试方法" class="headerlink" title="调试方法"></a>调试方法</h2><p><strong>快捷键：</strong></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token constant">F8</span>：进入下一个断点<span class="token constant">F10</span>：单步执行，不进入子函数<span class="token constant">F11</span>：单步执行，遇到子函数会进入子函数shift<span class="token operator">+</span><span class="token constant">F11</span>：跳出当前函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Vue </tag>
            
            <tag> React </tag>
            
            <tag> Json </tag>
            
            <tag> Yarn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/posts/41682/"/>
      <url>/posts/41682/</url>
      
        <content type="html"><![CDATA[<h2 id="生产者和消费者"><a href="#生产者和消费者" class="headerlink" title="生产者和消费者"></a>生产者和消费者</h2><p><a href="https://www.cnblogs.com/rxysg/p/15667769.html">原链接</a></p><p>生产者消费者模式并不是GOF提出的23种设计模式之一，23种设计模式都是建立在面向对象的基础之上的，但其实面向过程的编程中也有很多高效的编程模式，生产者消费者模式便是其中之一，它是我们编程过程中最常用的一种设计模式。</p><h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>装饰模式为已有类动态附加额外的功能就像LOL、王者荣耀等类Dota游戏中，英雄升级一样。每次英雄升级都会附加一个额外技能点学习技能。具体的英雄就是ConcreteComponent，技能栏就是装饰器Decorator，每个技能就是ConcreteDecorator；</p><pre class="line-numbers language-none"><code class="language-none">//Component 英雄接口 public interface Hero {    //学习技能    void learnSkills();}//ConcreteComponent 具体英雄盲僧public class BlindMonk implements Hero {        private String name;        public BlindMonk(String name) {        this.name = name;    }    @Override    public void learnSkills() {        System.out.println(name + "学习了以上技能！");    }}//Decorator 技能栏public class Skills implements Hero{        //持有一个英雄对象接口    private Hero hero;        public Skills(Hero hero) {        this.hero = hero;    }    @Override    public void learnSkills() {        if(hero != null)            hero.learnSkills();    }    }//ConreteDecorator 技能：Qpublic class Skill_Q extends Skills{        private String skillName;    public Skill_Q(Hero hero,String skillName) {        super(hero);        this.skillName = skillName;    }    @Override    public void learnSkills() {        System.out.println("学习了技能Q:" +skillName);        super.learnSkills();    }}//ConreteDecorator 技能：Wpublic class Skill_W extends Skills{    private String skillName;    public Skill_W(Hero hero,String skillName) {        super(hero);        this.skillName = skillName;    }    @Override    public void learnSkills() {        System.out.println("学习了技能W:" + skillName);        super.learnSkills();    }}//ConreteDecorator 技能：Epublic class Skill_E extends Skills{        private String skillName;        public Skill_E(Hero hero,String skillName) {        super(hero);        this.skillName = skillName;    }    @Override    public void learnSkills() {        System.out.println("学习了技能E:"+skillName);        super.learnSkills();    }}//ConreteDecorator 技能：Rpublic class Skill_R extends Skills{            private String skillName;        public Skill_R(Hero hero,String skillName) {        super(hero);        this.skillName = skillName;    }        @Override    public void learnSkills() {        System.out.println("学习了技能R:" +skillName );        super.learnSkills();    }}//客户端：召唤师public class Player {    public static void main(String[] args) {        //选择英雄        Hero hero = new BlindMonk("李青");                Skills skills = new Skills(hero);        Skills r = new Skill_R(skills,"猛龙摆尾");        Skills e = new Skill_E(r,"天雷破/摧筋断骨");        Skills w = new Skill_W(e,"金钟罩/铁布衫");        Skills q = new Skill_Q(w,"天音波/回音击");        //学习技能        q.learnSkills();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：<br></p><pre class="line-numbers language-none"><code class="language-none">学习了技能Q:天音波/回音击学习了技能W:金钟罩/铁布衫学习了技能E:天雷破/摧筋断骨学习了技能R:猛龙摆尾李青学习了以上技能！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java框架+工具</title>
      <link href="/posts/10033/"/>
      <url>/posts/10033/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="IDEA创建spring"><a href="#IDEA创建spring" class="headerlink" title="IDEA创建spring"></a>IDEA创建spring</h3><p><a href="https://blog.csdn.net/m0_67393686/article/details/124104008">链接</a></p><h3 id="所遇错误-注意事项"><a href="#所遇错误-注意事项" class="headerlink" title="所遇错误/注意事项"></a>所遇错误/注意事项</h3><h4 id="基础包名不要设置为-org"><a href="#基础包名不要设置为-org" class="headerlink" title="基础包名不要设置为 org"></a>基础包名不要设置为 org</h4><p>这与 Spring 框架的包一致，所以会导致问题。</p><p>错误信息：<br></p><pre class="line-numbers language-none"><code class="language-none">@EnableAsync annotation metadata was not injected <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>AOP是通过代理的方式实现的，由代理对象持有原对象，在执行原对象目标方法的前后可以执行额外的增强代码。<br>代理对象需要是原对象接口的实现或原对象的子类，这样就可以在对象引用处直接替换原对象。</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/20210514185607752.png" alt=""></p><p><strong>代理方式分静态代理和动态代理，区别在于代理对象生成方式不同</strong></p><p>不论是静态代理还是动态代理<br>AOP均有三个关注点：<strong>切面增强内容、何地切入、何时切入</strong></p><ul><li>切面增强内容：切面增强逻辑的代码段</li><li>何地切入：需要给哪个类哪个方法增强</li><li>何时切入：切入发生在何时，方法执行前、执行后、还是执行前后</li></ul><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><h3 id="不使用ide创建Servlet"><a href="#不使用ide创建Servlet" class="headerlink" title="不使用ide创建Servlet"></a>不使用ide创建Servlet</h3><p><a href="http://c.biancheng.net/servlet2/deploy.html">链接</a><br>有几个事情需要注意下：</p><ol><li>各个文件夹一定要写对，之前把classes写成了class</li><li>按照上面链接的教程，用javac编译出来的是一个文件夹，里面才是class文件，要把整个文件夹复制到指定目录，不能只复制class文件。</li><li>web.xml里面的&lt; servlet-class &gt;。Testone.MyServlet 。最后那个是类名，前面是包名。如果源文件没有package，那么web.xml里面可以只写类名；如果无妨正常访问，那么就在src目录下面加一个package包，在里面再创建java文件，再编译，web.xml里面d &lt; servlet-class &gt;加上包名。</li></ol><h3 id="ide创建Servlet"><a href="#ide创建Servlet" class="headerlink" title="ide创建Servlet"></a>ide创建Servlet</h3><p><a href="https://blog.csdn.net/weixin_44107140/article/details/119618734">原链接</a></p><p><strong>注意把servlet-jar(在tomcat安装路径的lib文件夹中)放到lib文件夹下面，不要放到classes里面了。</strong></p><h2 id="SSM"><a href="#SSM" class="headerlink" title="SSM"></a>SSM</h2><p><strong>springboot 只是组装了spring和springmvc。SSM中的SS指的是Spring SpringMVC，M是指MyBatis。</strong></p><h3 id="SSM（Spring-SpringMVC-MyBatis）架构"><a href="#SSM（Spring-SpringMVC-MyBatis）架构" class="headerlink" title="SSM（Spring+SpringMVC+MyBatis）架构"></a>SSM（Spring+SpringMVC+MyBatis）架构</h3><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>1.SSM系统架构<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/fd51aa6838fd4315ac1df679eb3500e5.png" alt=""></p><p>2.执行流程<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/0a57266814cb4fe395124ce40ea590a4.png" alt=""></p><h3 id="MSCM-model-service-controller-mapper"><a href="#MSCM-model-service-controller-mapper" class="headerlink" title="MSCM(model ,service, controller ,mapper)"></a>MSCM(model ,service, controller ,mapper)</h3><p><strong><em>mapper的中文意思是映射器；mapper和dao是一个东西，叫法不同。</em></strong></p><p><strong>业务逻辑：</strong><br> Controller—&gt;service接口—&gt;serviceImpl—&gt;dao接口—&gt;daoImpl—&gt;mapper—&gt;db</p><p><strong>一：Dao(Data Access Object):数据存储对象</strong><br>       DAO = Data Access Object = 数据存取对象. 不管是什么框架，我们很多时候都会与数据库进行交互。如果遇到一个场景我们都要去写SQL语句，那么我们的代码就会很冗余。所以，我们就想到了把数据库封装一下，让我们的数据库的交道看起来像和一个对象打交道，这个对象通常就是DAO。当我们操作这个对象的时候，这个对象会自动产生SQL语句来和数据库进行交互，我们就只需要使用DAO就行了。</p><p>   通常我们在DAO层里面写接口，里面有与数据打交道的方法。SQL语句通常写在mapper文件里面的。</p><p>   优点：结构清晰，Dao层的数据源配置以及相关的有关数据库连接的参数都在Spring配置文件中进行配置。</p><p><strong>二：Service：服务</strong><br>       服务是一个相对独立的功能模块，主要负责业务逻辑应用设计。首先也要设计接口，然后再设计其实现该接口的类。这样我们就可以在应用中调用service接口进行业务处理。service层业务实现，具体调用到已经定义的DAO的接口，封装service层的业务逻辑有利于通用的业务逻辑的独立性和重复利用性 。<br>     如果把Dao层当作积木，则Service层则是对积木的搭建。</p><p><strong>三：Controller：控制器</strong><br>       主要负责具体业务模块流程的控制，此层要调用到Service层的接口去控制业务流程，控制的配置同样在Spring配置文件中配置。针对不同的业务流程有不同的控制器。在设计的过程可以设计出重复利用的子单元流程模块。</p><p> <strong>四：model：模型</strong><br> 模型就是指视图的数据Model，模型，通常来讲，我们会把模型和另一个东西放在一起来说：View，视图。</p><p>模型通常认为是视图的内核，何谓之视图？我们正在与之交互的网站的界面就是视图，而模型是指他的内核：数据。</p><p>   将Model和View的概念拆分开来，有助于我们关注不同的方面，也可以更有效的分工。有些工程师更关注于内核也就是模型，通常来说，他们被称之为后端工程师。有些工程师更关注于用户界面的交互和展示，通常来说，他们被称之为前端工程师。</p><p><strong>五: View层：</strong><br>       与Controller层关系紧密，View层主要负责前台jsp页面的表示。</p><p><strong>六: 它们之间的关系：</strong><br>      建立了DAO层后才可以建立Service层，而Service层又是在Controller层之下的，因而Service层应该既调用DAO层的接口，又要提供接口给Controller层的类来进行调用，它刚好处于一个中间层的位置。每个模型都有一个Service接口，每个接口分别封装各自的业务处理方法。</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/aHR0cHM6Ly9zczMuYmRzdGF0aWMuY29tLzcwY0Z2OFNoX1ExWW54R2twb1dLMUhGNmhoeS9pdC91PTY1ODc1NzYzNCwzMTUzMjQ0OTA1JmZtPTI2JmdwPTAuanBn.png" alt=""><br>另一个图的解释：<br>实体类这一层，有的开发写成pojo，有的写成model，也有domain，也有dto（这里做参数验证，比如password不能为空等），实体类如果你不懂什么东西的话，那你就想成是范围。</p><p>mapper 是Mybatis 操作数据库的那一层，就是dao层。</p><p>service包含了serviceImpl（service接口的实现类） 是提供给controller 使用的，针对于某些业务将 dao 的对于某些表的crud进行组合，也就是说间接的和数据库打交道。</p><p>controller 通过调用service来完成业务逻辑。<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/20190806101012614.png" alt=""></p><h3 id="JavaWeb三层架构"><a href="#JavaWeb三层架构" class="headerlink" title="JavaWeb三层架构"></a>JavaWeb三层架构</h3><p><strong>（Servlet(Controller),service,dao）</strong><br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/1f793bb259964619876d3efb18303f2e.png" alt=""></p><p>第一层Servlet,也叫controller层，处理JSP页面传输的数据，一般通过request.getParameter获取表单中属性为name参数中的value值，在Servlet层中一般会通过new的方式创建一个Service。如</p><p>UserService userService = new UserServiceimpl();因为一般Service层会创建一个接口写一些方法（userService）,并创建一个实现类实现这个接口(UserServiceImpl)。</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/a9a95bf4b1204f3cb542a1f22bb5094a.png" alt=""><br>service层用来处理一些前端传输过来一些数据进行数据库的增删改查，或者处理DAO层从数据库获取的数据，例如对数据进行分页。因为需要调用DAO层，所以也需要new一个DAO层。</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/9ef53b31f1034ac1bb14e47506482bed.png" alt=""></p><p>对数据进行分页</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/7ae167596761457c991e6dd569b2cc2b.png" alt=""></p><p>UserDao userDao = new UserDaoImpl;</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/9d1e342190fd41a7882915823fc74508.png" alt=""><br>Dao层是用来与数据库进行交互，也就是增删改查。可以通过前端传输过来的数据对用户的信息进行增删改查。</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/92f11628821e46c48e9dbedc1901b23d.png" alt=""></p><h3 id="Spring-IOC"><a href="#Spring-IOC" class="headerlink" title="Spring IOC"></a>Spring IOC</h3><p>1.xml配置文件利用反射获取class对象<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/4a0f6bab3f814b2eb88ce5bf7a0752dd.png" alt=""></p><ol><li>获取容器、获得bean对象、使用方法。<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/6a34e9ded1434451bd7a166d18c3aa5e.png" alt=""></li></ol><h3 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h3><p><a href="https://blog.51cto.com/u_14625481/3485049">原文</a></p><p><strong>IOC让模块之间解耦，AOP让JAVA动起来。</strong><br>AOP相对应的一个词叫OOP，AOP（Aspect Oriented Programming），即面向切面编程。OOP主要是为了实现编程的重用性、灵活性和扩展性。它的几个特征分别是继承、封装、多态和抽象。OOP重点体现在编程架构，强调的是类之间的层次关系。<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/0f7647b2c8414917924b5be5a50f2f69.png" alt=""><br>看到上面的图，我们暂时还不能发现有什么问题。为了大家便于理解，接下来我来给大家讲解一下上面类图的实现过程。描述如下：马戏团有一条表演的小狗，这条小狗可以跑和跳，但是它完成跑和跳两个动作之前必须是在接到驯兽师发出的命令后，同时完成跑和跳的动作之后，驯兽师会给与响应的奖励，比如一块肉。</p><p>了解了实现过程之后，我们在来看一下具体的代码。 </p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/5b3feb96c994426fbc8f89aab82a3e38.png" alt=""><br>仔细看上面的代码，我们可以看出在run方法和jump方法中，存在一些相同的内容（驯兽师发出命令和给与奖励），这些内容并不能完全进行抽象，即不能按照OOP编程思想进行处理。类似这样的情况同样会出现在我们编程中的很多地方，例如：日志记录、性能统计、安全控制、事务处理、异常处理等等。但是这样的情况该如何解决呢？这就引入了AOP编程思想。</p><p>AOP为Aspect Oriented Programming的缩写，即面向切面编程（也叫面向方面），是一种可以通过预编译方式和运行期动态代理实现在不修改源代码的情况下给程序动态统一添加功能的一种技术。</p><p><strong>AOP实现实例</strong><br>为了大家更好的理解AOP如何实现，接下来我们优化一下上述代码。<br>首先是Dog类<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/2332d45a5bb1451aa65977fca95a6f03.png" alt=""></p><p>对比之前的代码我们可以明显看出，我们将关于驯兽师的相关内容从run和jump中进行了抽取，接下来，我们如何在程序运行中将关于驯兽师的动作加入到程序中呢？这就是我们这次用到的AOP实现的核心技术动态代理（Dynamic Proxy）。具体代码如下：</p><h2 id="常见缩写"><a href="#常见缩写" class="headerlink" title="常见缩写"></a>常见缩写</h2><h3 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h3><p><a href="https://www.runoob.com/jsp/jsp-tutorial.html">详情</a><br>JSP 与 PHP、ASP、ASP.NET 等语言类似，运行在服务端的语言。</p><p>JSP（全称Java Server Pages）是由 Sun Microsystems 公司倡导和许多公司参与共同创建的一种使软件开发者可以响应客户端请求，而动态生成 HTML、XML 或其他格式文档的Web网页的技术标准。</p><p>JSP 技术是以 Java 语言作为脚本语言的，JSP 网页为整个服务器端的 Java 库单元提供了一个接口来服务于HTTP的应用程序。</p><p>JSP文件后缀名为 *.jsp 。</p><p>JSP开发的WEB应用可以跨平台使用，既可以运行在 Linux 上也能运行在 Windows 上。</p><h3 id="POJO、JAVABean、Entity"><a href="#POJO、JAVABean、Entity" class="headerlink" title="POJO、JAVABean、Entity"></a>POJO、JAVABean、Entity</h3><p><strong>1.POJO</strong><br>  （Plain Ordinary Java Object）简单的Java对象，实际就是普通JavaBeans，是为了避免和EJB混淆所创造的简称。<br>  其中有一些属性及其getter、setter方法的类，没有业务逻辑，有时可以作为VO（value-object）或DTO（Data Transfer Object）来使用。不允许有业务方法，也不能携带connection之类的方法，实际就是普通JavaBeans。POJO类中有属性和get、set方法，但是没有业务逻辑。  </p><pre class="line-numbers language-none"><code class="language-none">/** * POJO类代码示例 */  public class UserInfoPojoDemo {    private int userId;// 用户帐号    private String pwd;// 用户密码    /**     * Constructor     */    public UserInfoPojoDemo() {    }    public UserInfoPojoDemo(String pwd) {        this.pwd = pwd;    }    public UserInfoPojoDemo(int userId) {        this.userId = userId;    }    public UserInfoPojoDemo(int userId, String pwd) {        this.userId = userId;        this.pwd = pwd;    }    /**     *Access      */    public int getUserId() {        return userId;    }    public void setUserId(int userId) {        this.userId = userId;    }    public String getPwd() {        return pwd;    }    public void setPwd(String pwd) {        this.pwd = pwd;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2.JAVABean</strong><br>一种JAVA语言写成的可重用组件。JavaBean符合一定规范编写的Java类，不是一种技术，而是一种规范。大家针对这种规范，总结了很多开发技巧、工具函数。符合这种规范的类，可以被其它的程序员或者框架使用。它的方法命名，构造及行为必须符合特定的约定：</p><p>1、所有属性为private。</p><p>2、这个类必须有一个公共的缺省构造函数。即是提供无参数的构造器。</p><p>3、这个类的属性使用getter和setter来访问，其他方法遵从标准命名规范。</p><p>4、这个类应是可序列化的。实现serializable接口。</p><p>因为这些要求主要是靠约定而不是靠实现接口，所以许多开发者把JavaBean看作遵从特定命名约定的POJO。</p><pre class="line-numbers language-none"><code class="language-none">public class UserInfo implements java.io.Serializable{  //实现serializable接口。  private static final long serialVersionUID = 1L;  private String name;  private int age;  //无参构造器  public UserInfo() {  }  public String getName() {      return name;  }  public void setName(String name) {      this.name = name;  }  public int getAge() {      return age;  }  public void setAge(int age) {      this.age = age;  }  //javabean当中可以有其它的方法  public void userInfoPrint(){      System.out.println("");   } }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>区别<br>POJO其实是比javabean更纯净的简单类或接口。POJO严格地遵守简单对象的概念，而一些JavaBean中往往会封装一些简单逻辑。<br>POJO主要用于数据的临时传递，它只能装载数据， 作为数据存储的载体，而不具有业务逻辑处理的能力。<br>Javabean虽然数据的获取与POJO一样，但是javabean当中可以有其它的方法。</strong></p><p><strong>3.entity（实体类）</strong><br>对java实体类的众多理解：</p><p>A .就是属性类，通常定义在model层里面</p><p>B. 一般的实体类对应一个数据表，其中的属性对应数据表中的字段。<br>好处：<br>1.对对象实体的封装，体现OO思想。<br>2.属性可以对字段定义和状态进行判断和过滤<br>3.把相关信息用一个实体类封装后，我们在程序中可以把实体类作为参数传递，更加方便。</p><p>C. 说白了就是为了让程序员在对数据库操作的时候不用写SQL语句</p><p>D. 就是一个数据库表生成一个类<br>这样做对数据库操作起来方便<br>编写代码较少 提高效率 可以使程序员专注逻辑关系</p><p>E. 实体类就是把对某一个表的操作全写在一个类中.</p><p>F. 在Java开发中经常要定义一些实体类，这些类的定义的好坏会直接影响，编写代码的质量和难易程度，以下是别人总结的一些经验。</p><p>一、实体类的名字尽量和数据库的表的名字对应相同。</p><p>二、实体类应该实现java.io.Serializable接口。</p><p>三、实体类应该有个无参的构造方法。</p><p>四、实体类应该有个有参（所有的参数）的构造方法。</p><p>五、实体类有属性和方法，属性对应数据库中表的字段，主要有getter和setter方法。</p><p>六、实体类还应该有个属性serialVersionUID。例如：private static final long serialVersionUID = -6125297654796395674L;</p><p>七、属性一般是private类型，方法位public类型，对于数据库自动生成的ID字段对应的属性的set方法应为private。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Java </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客网</title>
      <link href="/posts/43473/"/>
      <url>/posts/43473/</url>
      
        <content type="html"><![CDATA[<h2 id="牛客网"><a href="#牛客网" class="headerlink" title="牛客网"></a>牛客网</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p><strong>1.sc.haxNext()不是必须要加的</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">while</span><span class="token punctuation">(</span>sc<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">//核心代码</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这句话可以让你一直输入，输入都行，不会因为回车就结束，一般情况下可以不加它，因为题目一般会告诉你有几组数据，外面套个while循环就好。</p><p><strong>机考测试的数据是一次性全部放入控制台，如果没说几组数据，可以加<code>sc.hasNext()</code></strong></p><p><strong>如果样例过了，但测试用例没过或之过了一部分，先去检查代码，基本就是代码问题，逻辑问题或者有bug</strong></p><p><strong>如果要说了以某个字符终止输入，那么就把这个输入放到（）里面，用双引号包括。</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StandardInput</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Scanner</span> sc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>sc<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token string">"#"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> a <span class="token operator">=</span> sc<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> #<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>2.牛客网接受控制台输入</strong></p><p><strong>next()和nextInt()方法读取到任意间隔符（如空格和回车）就结束，nextLine()读取到回车结束也就是“\r”，next()返回值为String类型，nextLine()返回值为String类型，nextInt()返回值为Int类型。</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span>返回的是<span class="token keyword">int</span>型<span class="token punctuation">,</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>返回<span class="token class-name">String</span>。二者特点很相似<span class="token number">1</span>、一定要读取到有效字符后才可以结束输入。<span class="token number">2</span>、对输入有效字符之前遇到的空白，<span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 方法会自动将其去掉。<span class="token number">3</span>、只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。<span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 不能得到带有空格的字符串。<span class="token comment">//-----------------------------------------</span><span class="token function">nextLong</span><span class="token punctuation">(</span><span class="token punctuation">)</span>、<span class="token function">nextDouble</span><span class="token punctuation">(</span><span class="token punctuation">)</span>是一样的道理<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span>：<span class="token number">1</span>、以<span class="token class-name">Enter</span>为结束符<span class="token punctuation">,</span>也就是说 <span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法返回的是输入回车之前的所有字符。<span class="token number">2</span>、可以获得空白。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>也可以全部用naxtLine()，不过数字型需要转一下</strong><br>1.读取单个整数，字符串数字转int数字，int转String<br></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//        读取单个整数，字符串数字转int数字</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>sc<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//        int转String</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">3</span>；<span class="token class-name">String</span> s<span class="token operator">=</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>2.读取一行整数，以空格分开<br></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//        读取一行整数，以空格分开</span>        <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> s <span class="token operator">=</span> sc<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> num <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>s<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            num<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>3.单个char数字转int数字,减去’0’<p></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//                单个char数字转int数字,减去'0'</span>                res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token operator">-</span><span class="token char">'0'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>4.遍历字符串的每个字符，charAt(i)<br></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//        遍历字符串的每个字符，charAt(i)</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p></p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><h4 id="数组输出"><a href="#数组输出" class="headerlink" title="数组输出"></a>数组输出</h4><p><strong>Arrays.toString（）</strong><br>这个方法是是用来将数组转换成String类型输出的，入参可以是long，float，double，int，boolean，byte，object型的数组。<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20230522150257.png" alt=""><br>如果直接i.toString()则是输出地址值<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20230522150318.png" alt=""></p><h4 id="四舍五入输出"><a href="#四舍五入输出" class="headerlink" title="四舍五入输出"></a>四舍五入输出</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//保留4位小数的输出</span><span class="token keyword">double</span> f <span class="token operator">=</span> <span class="token number">3.1415926</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%.4f"</span><span class="token punctuation">,</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><a href="https://www.jianshu.com/p/359d9001ebbc">String.format详细用法</a></p><h3 id="暴力遍历"><a href="#暴力遍历" class="headerlink" title="暴力遍历"></a>暴力遍历</h3><p>暴力有时候是一种直接明了的方法，比如三数之和，四数之和。在没有掌握到好的办法之前，暴力是一个选择。几个的遍历略有区别，需要注意。<br>1.二维数组</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>num<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>num<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.数组任意两个不同的数相加<br><strong>注意，i只能到倒数第二位，因为j=i+1</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>num<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>num<span class="token punctuation">.</span>length<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> sum <span class="token operator">=</span> num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>num<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.数组任意三个不同的数相加</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>num<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>num<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>              <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token operator">=</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>num<span class="token punctuation">.</span>length<span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                  <span class="token keyword">int</span> sum <span class="token operator">=</span> num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>num<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>num<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>              <span class="token punctuation">}</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Collections-sort-多重条件排序"><a href="#Collections-sort-多重条件排序" class="headerlink" title="Collections.sort() 多重条件排序"></a>Collections.sort() 多重条件排序</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">sort</span><span class="token punctuation">;</span> <span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">ArrayList</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Collections</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Comparator</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span><span class="token punctuation">;</span> <span class="token comment">/** * 排序规则，按照年龄排序，若年龄相同，按照工资排序，若工资相同，按照身高排序 * @author Administrator * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestObjectSort</span> <span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">&gt;</span></span> students<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>students<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"zhangsan"</span><span class="token punctuation">,</span><span class="token number">21</span><span class="token punctuation">,</span><span class="token number">3000</span><span class="token punctuation">,</span><span class="token number">180</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>students<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"zhangsan"</span><span class="token punctuation">,</span><span class="token number">27</span><span class="token punctuation">,</span><span class="token number">4000</span><span class="token punctuation">,</span><span class="token number">180</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>students<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"zhangsan"</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">,</span><span class="token number">180</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>students<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"zhangsan"</span><span class="token punctuation">,</span><span class="token number">21</span><span class="token punctuation">,</span><span class="token number">5000</span><span class="token punctuation">,</span><span class="token number">180</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>students<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"zhangsan"</span><span class="token punctuation">,</span><span class="token number">45</span><span class="token punctuation">,</span><span class="token number">4000</span><span class="token punctuation">,</span><span class="token number">180</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>students<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"zhangsan"</span><span class="token punctuation">,</span><span class="token number">21</span><span class="token punctuation">,</span><span class="token number">5000</span><span class="token punctuation">,</span><span class="token number">174</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>students<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"zhangsan"</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">4000</span><span class="token punctuation">,</span><span class="token number">180</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>students<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"zhangsan"</span><span class="token punctuation">,</span><span class="token number">33</span><span class="token punctuation">,</span><span class="token number">4000</span><span class="token punctuation">,</span><span class="token number">180</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>students<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"zhangsan"</span><span class="token punctuation">,</span><span class="token number">45</span><span class="token punctuation">,</span><span class="token number">4000</span><span class="token punctuation">,</span><span class="token number">180</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>students<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"zhangsan"</span><span class="token punctuation">,</span><span class="token number">76</span><span class="token punctuation">,</span><span class="token number">4000</span><span class="token punctuation">,</span><span class="token number">180</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>students<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"zhangsan"</span><span class="token punctuation">,</span><span class="token number">99</span><span class="token punctuation">,</span><span class="token number">4000</span><span class="token punctuation">,</span><span class="token number">180</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>students<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"zhangsan"</span><span class="token punctuation">,</span><span class="token number">21</span><span class="token punctuation">,</span><span class="token number">5000</span><span class="token punctuation">,</span><span class="token number">160</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>students<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Student</span> a1<span class="token punctuation">,</span> <span class="token class-name">Student</span> a2<span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token keyword">int</span> x <span class="token operator">=</span> a1<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> a2<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> y <span class="token operator">=</span> a1<span class="token punctuation">.</span><span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> a2<span class="token punctuation">.</span><span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token keyword">int</span> z <span class="token operator">=</span> a1<span class="token punctuation">.</span><span class="token function">getHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> a2<span class="token punctuation">.</span><span class="token function">getHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                 <span class="token keyword">if</span><span class="token punctuation">(</span>y<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        <span class="token keyword">return</span> z<span class="token punctuation">;</span>                  <span class="token punctuation">}</span>                <span class="token keyword">return</span> y<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> x<span class="token punctuation">;</span>        <span class="token punctuation">}</span>             <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">Student</span> s<span class="token operator">:</span>students<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\t"</span><span class="token operator">+</span>s<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\t"</span><span class="token operator">+</span>s<span class="token punctuation">.</span><span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\t"</span><span class="token operator">+</span>s<span class="token punctuation">.</span><span class="token function">getHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span>   <span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">{</span><span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span><span class="token keyword">int</span> age<span class="token punctuation">,</span><span class="token keyword">int</span> salary<span class="token punctuation">,</span><span class="token keyword">int</span> height<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">=</span>name<span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token operator">=</span>age<span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>salary<span class="token operator">=</span>salary<span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>height<span class="token operator">=</span>height<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">int</span>  age<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">int</span> salary<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">int</span> height<span class="token punctuation">;</span> <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> name<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> age<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> salary<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setSalary</span><span class="token punctuation">(</span><span class="token keyword">int</span> salary<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>salary <span class="token operator">=</span> salary<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> height<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setHeight</span><span class="token punctuation">(</span><span class="token keyword">int</span> height<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>height <span class="token operator">=</span> height<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="字典序排序"><a href="#字典序排序" class="headerlink" title="字典序排序"></a>字典序排序</h4><pre class="line-numbers language-none"><code class="language-none">str1.compareTo(str2);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：<br></p><pre class="line-numbers language-none"><code class="language-none">adobe454000180tom454000180zhangsan454000180<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p></p><p>这是一个多条件排序。后面三个数值相等就进行字典序排序。先比较第一个字母，从小到达排列。第一个相等就比较第二个，遇到不等的就里面出结果。<br>如果是倒着排列就是 <code>str2.compareTo(str1);</code></p><h4 id="HashMap排序"><a href="#HashMap排序" class="headerlink" title="HashMap排序"></a>HashMap排序</h4><p>先看一下遍历Map的方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"value1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"value2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"3"</span><span class="token punctuation">,</span> <span class="token string">"value3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//第一种：普遍使用，二次取值</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"通过Map.keySet遍历key和value："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> key <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"key= "</span><span class="token operator">+</span> key <span class="token operator">+</span> <span class="token string">" and value= "</span> <span class="token operator">+</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>      <span class="token comment">//第二种</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"通过Map.entrySet使用iterator遍历key和value："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> it <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> entry <span class="token operator">=</span> it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"key= "</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" and value= "</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>      <span class="token comment">//第三种：推荐，尤其是容量大时</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"通过Map.entrySet遍历key和value"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> entry <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"key= "</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" and value= "</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token comment">//第四种</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"通过Map.values()遍历所有的value，但不能遍历key"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> v <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"value= "</span> <span class="token operator">+</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为Collections.sort针对的是list，所以要对HashMap排序需要先转为List<br><strong>如果return 后面的值大于0，交换位置。所以下面的代码放回的是降序</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> font_end_list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>font_end_list<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> o1<span class="token punctuation">,</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> o2<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> o2<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>o1<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="常用数据结构及方法"><a href="#常用数据结构及方法" class="headerlink" title="常用数据结构及方法"></a>常用数据结构及方法</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h4><p>一般来说有int、double、string等类型数组，写法为<br></p><pre class="line-numbers language-none"><code class="language-none">int[] adouble[] bString[] c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p></p><p><strong>但还有一种数组比较特别，对象数组</strong><br>比如我定义了一个Studeng类，<br></p><pre class="line-numbers language-none"><code class="language-none">Student[] a <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br> a就是一个Student类数组，a[0] 就是一个Student对象。<p></p><h4 id="数组取最大-小值"><a href="#数组取最大-小值" class="headerlink" title="数组取最大/小值"></a>数组取最大/小值</h4><p><strong>Arrays.stream</strong></p><pre class="line-numbers language-none"><code class="language-none">Arrays.stream(f[m - 1]).min().orElse(-1)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>f是一个二维数组，m-1是其中一行</li><li>后面可以跟min() 或者 max()</li><li>orElse(-1) 表示没有值就返回-1，括号里面也可也填其它值</li></ol><h4 id="数组之间的赋值"><a href="#数组之间的赋值" class="headerlink" title="数组之间的赋值"></a>数组之间的赋值</h4><pre class="line-numbers language-none"><code class="language-none">int[] nums = {1,2,3,4,5,6,20,24};int[] news = {1,2,3,5}news = nums;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上面的代码，打印news输出的是nums的结果；如果写成<code>nums = news</code>。打印nums，输出的是news的结果。</p><h4 id="数组复制-扩容"><a href="#数组复制-扩容" class="headerlink" title="数组复制/扩容"></a>数组复制/扩容</h4><p>Arrays.copyOf方法是复制数组中指定范围的元素，复制的长度大于被复制数组的长度，则填充类型默认值，String得默认值是null,int的默认值是0。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a1 <span class="token operator">=</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//复制指定的数组长度</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a2 <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copeOf</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>a<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//容量翻倍</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="数组截取"><a href="#数组截取" class="headerlink" title="数组截取"></a>数组截取</h4><p><strong>2.  Arrays.copyOfRange数组截取</strong></p><p>Arrays.copyOfRange(T[ ] original,int from,int to)<br>original：第一个参数为要拷贝的数组对象<br>from：第二个参数为拷贝的开始位置（包含）<br>to：第三个参数为拷贝的结束位置（不包含）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array2 <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>array2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h4><p> 这种形式是对一个数组的所有元素进行排序，并且是按从小到大的顺序。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Arrays</span><span class="token punctuation">;</span>   <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>                   <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>         <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>     <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2、Arrays.sort(int[] a, int fromIndex, int toIndex)<br>这种形式是对数组部分排序，也就是对数组a的下标从fromIndex到toIndex-1的元素排序，注意：下标为toIndex的元素不参与排序哦！</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Arrays</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3、public static void sort(T[] a,int fromIndex,int toIndex, Comparator c)</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"> <span class="token number">1</span> <span class="token keyword">package</span> <span class="token namespace">test</span><span class="token punctuation">;</span> <span class="token number">2</span>  <span class="token number">3</span> <span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Arrays</span><span class="token punctuation">;</span> <span class="token number">4</span> <span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Comparator</span><span class="token punctuation">;</span> <span class="token number">5</span>  <span class="token number">6</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span> <span class="token number">7</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token number">8</span>         <span class="token comment">//注意，要想改变默认的排列顺序，不能使用基本类型（int,double, char）</span> <span class="token number">9</span>         <span class="token comment">//而要使用它们对应的类</span><span class="token number">10</span>         <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token number">11</span>         <span class="token comment">//定义一个自定义类MyComparator的对象</span><span class="token number">12</span>         <span class="token class-name">Comparator</span> cmp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyComparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">13</span>         <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> cmp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">14</span>         <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token number">15</span>             <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">16</span>         <span class="token punctuation">}</span><span class="token number">17</span>     <span class="token punctuation">}</span><span class="token number">18</span> <span class="token punctuation">}</span><span class="token number">19</span> <span class="token comment">//Comparator是一个接口，所以这里我们自己定义的类MyComparator要implents该接口</span><span class="token number">20</span> <span class="token comment">//而不是extends Comparator</span><span class="token number">21</span> <span class="token keyword">class</span> <span class="token class-name">MyComparator</span> <span class="token keyword">implements</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span><span class="token number">22</span>     <span class="token annotation punctuation">@Override</span><span class="token number">23</span>     <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> o1<span class="token punctuation">,</span> <span class="token class-name">Integer</span> o2<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token number">24</span>         <span class="token comment">//如果n1小于n2，我们就返回正值，如果n1大于n2我们就返回负值，</span><span class="token number">25</span>         <span class="token comment">//这样颠倒一下，就可以实现反向排序了</span><span class="token number">26</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>o1 <span class="token operator">&lt;</span> o2<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token number">27</span>             <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token number">28</span>         <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>o1 <span class="token operator">&gt;</span> o2<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token number">29</span>             <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token number">30</span>         <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token number">31</span>             <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token number">32</span>         <span class="token punctuation">}</span><span class="token number">33</span>     <span class="token punctuation">}</span><span class="token number">34</span>     <span class="token number">35</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="数组填充"><a href="#数组填充" class="headerlink" title="数组填充"></a>数组填充</h4><p><strong>3.Arrays.fill  数组</strong><br>public static void fill(int[] a, int fromIndex, int toIndex, int val)<br>用来输入给定数组中元素值的。<br>1、两个参数<br>public static void fill(int[] a， int val)：给定一个数组，一个val值<br>含义为为数组a进行赋值，使得其所有元素值都为val。</p><p>2、四个参数<br>public static void fill(int[] a, int fromIndex, int toIndex, int val)：给定一个数组，起始位置fromIndex(包含)，末尾位置toIndex(不包含)，对范围内的元素进行赋值，示例如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//此时，arr的值为[60, 60, 60, 60, 60, 60]</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//此时，arr的值为[60, 60, 60,100, 100, 60]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.二维数组赋值</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>cache<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="数组转list"><a href="#数组转list" class="headerlink" title="数组转list"></a>数组转list</h4><p><strong>4.Arrays.asList</strong><br>该方法是将数组转化成List集合的方法。</p><p> List<string> list = Arrays.asList(“a”,”b”,”c”);<br><strong>注意：<br>（1）该方法适用于对象型数据的数组（String、Integer…）<br>（2）该方法不建议使用于基本数据类型的数组（byte,short,int,long,float,double,boolean）<br>（3）该方法将数组与List列表链接起来：当更新其一个时，另一个自动更新<br>（4）不支持add()、remove()、clear()等方法<br>  （5）长度不可变</strong></string></p><p>如果你的List只是用来遍历，就用Arrays.asList()。</p><p> 如果你的List还要添加或删除元素，还是乖乖地new一个java.util.ArrayList，然后一个一个的添加元素。</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="两个字符串是否相等"><a href="#两个字符串是否相等" class="headerlink" title="两个字符串是否相等"></a>两个字符串是否相等</h4><pre class="line-numbers language-none"><code class="language-none">A.equals(B)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>相等会返回true</p><h4 id="字符串与字符之间的转换"><a href="#字符串与字符之间的转换" class="headerlink" title="字符串与字符之间的转换"></a>字符串与字符之间的转换</h4><ol><li>遍历字符串<br><code>char c : str.toCharArray()</code></li><li>字符相减<br>字符直接相减，他们对应的ascill码相减，会返回一个整数。这个一般用做数组下标。</li><li>字符与整数相加会转换为整数<br><code>25 + 'A'</code><br>A的ASCII码是65，所以最后的结果是90</li><li>整数转换为字符<br><code>(char)(25 + 'A')</code><br>Z的ASCII码是90，所以最后的结果是Z</li><li>字符转字符串<br><code>"" + (char)(25 + 'A')</code><br>前面加上空字符串即可</li><li>判断字符是大写还是小写<pre class="line-numbers language-none"><code class="language-none">Character.isUpperCase(c) // 大写返回true，一般用于判断条件Character.isLowerCase(c) //小写返回true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="String对象创建"><a href="#String对象创建" class="headerlink" title="String对象创建"></a>String对象创建</h4><pre class="line-numbers language-none"><code class="language-none">String str1 = "Hello, 慕课网";String str2 = new String("Hello, Java");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h4><pre class="line-numbers language-none"><code class="language-none">int length = str.length();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意，hello world!中的空格也算一个字符。</p><h4 id="字符串查找"><a href="#字符串查找" class="headerlink" title="字符串查找"></a>字符串查找</h4><pre class="line-numbers language-none"><code class="language-none">char c = str.charAt(7);System.out.println("索引位置为7的字符为：" + c);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>获取字符在字符串中第一次出现的位置：<br></p><pre class="line-numbers language-none"><code class="language-none">int i = str.indexOf('a');System.out.println("字符a在字符串str第一次出现的位置为：" + i);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p></p><p>获取子串在字符串中第一次出现的位置：<br></p><pre class="line-numbers language-none"><code class="language-none">int i = str.indexOf("love");System.out.println("子串love在字符串str第一次出现的位置为：" + i);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p></p><h4 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h4><pre class="line-numbers language-none"><code class="language-none">//将字符串的空格替换为%20，这是leetcode剑指offer05str.replace(" ","%20");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h4><pre class="line-numbers language-none"><code class="language-none">String substring = str.substring(2);String substring1 = str.substring(2, 6);System.out.println("从索引位置2到结束的子串为：" substring);System.out.println("从索引位置2到索引位置6的子串为：" substring1);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="字符串切割"><a href="#字符串切割" class="headerlink" title="字符串切割"></a>字符串切割</h4><pre class="line-numbers language-none"><code class="language-none">//以空格切割String str1 = "I love Java";String[] strArr = str1.split(" ");// 以*切割String str2 = "I*love*Java";String[] strArr2 = str2.split("\\*");// 以\切割String str3 = "I\\love\\Java";String[] strArr4 = str3.split("\\\\");// 以|切割String str4 = "I|love|Java";String[] strArr4 = str4.split("\\|");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="字符串与字节数组转换"><a href="#字符串与字节数组转换" class="headerlink" title="字符串与字节数组转换"></a>字符串与字节数组转换</h4><pre class="line-numbers language-none"><code class="language-none">// 将字符串转换为字节数组byte[] ascii = str2.getBytes();// 此处的ascii为上面通过字符串转换的字节数组String s = new String(ascii);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="字符串大小写转换"><a href="#字符串大小写转换" class="headerlink" title="字符串大小写转换"></a>字符串大小写转换</h4><pre class="line-numbers language-none"><code class="language-none">String str = "HELLO world";String s = str.toLowerCase();System.out.println("字符串str为转换为小写后为：" + s);String s1 = s.toUpperCase();System.out.println("字符串s为转换为大写后为：" + s1);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h4><pre class="line-numbers language-none"><code class="language-none">String str1 = "hello";String str2 = "hello";String str3 = new String("hello");System.out.println("使用equals()方法比较str1和str2的为：" + str1.equals(str2));System.out.println("使用==运算符比较str1和str2的结果" + (str1 == str2)); System.out.println("使用equals()方法比较str1和str3果为：" + str1.equals(str3));System.out.println("使用==运算符比较str1和str3的结果" + (str1 == str3));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><p>使用equals()方法比较str1和str2的结果为：true<br>使用==运算符比较str1和str2的结果为：true<br>使用equals()方法比较str1和str3的结果为：true<br>使用==运算符比较str1和str3的结果为：false</p><h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><h4 id="StringBuilder-与-String-互转"><a href="#StringBuilder-与-String-互转" class="headerlink" title="StringBuilder 与 String 互转"></a>StringBuilder 与 String 互转</h4><pre class="line-numbers language-none"><code class="language-none">StringBuilder sb = new StringBuilder();String s = sb.toString();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">String s1 = "world";StringBuilder sb1 = new StringBuilder(s);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20230522150356.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20230522150420.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20230522150441.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20230522150506.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20230522150525.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20230522150542.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20230522150600.png" alt=""></p><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>Arrays.asList的作用是将数组转化为list,一般是用于在初始化的时候,设置几个值进去,简化代码,省去add的部分。<br><strong>避免如下第一种方法太啰嗦！！！</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">&gt;</span></span> hash <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        hash<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token char">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        hash<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token char">'e'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        hash<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token char">'i'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        hash<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token char">'o'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        hash<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token char">'u'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        hash<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token char">'A'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        hash<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token char">'E'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        hash<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token char">'I'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        hash<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token char">'O'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        hash<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token char">'U'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">&gt;</span></span> hash1 <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token char">'a'</span><span class="token punctuation">,</span> <span class="token char">'e'</span><span class="token punctuation">,</span> <span class="token char">'i'</span><span class="token punctuation">,</span> <span class="token char">'o'</span><span class="token punctuation">,</span> <span class="token char">'u'</span><span class="token punctuation">,</span> <span class="token char">'A'</span><span class="token punctuation">,</span> <span class="token char">'E'</span><span class="token punctuation">,</span> <span class="token char">'I'</span><span class="token punctuation">,</span> <span class="token char">'O'</span><span class="token punctuation">,</span> <span class="token char">'U'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20230522150618.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20230522150635.png" alt=""></p><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>java当中栈和队列可以使用LinkedList，重点关注头尾的插入删除，返回。<br></p><pre class="line-numbers language-none"><code class="language-none">//表头添加sites.addFirst("Wiki");//表头移除sites.removeFirst();//获取表头System.out.println(sites.getFirst());//表尾添加sites.addLast("Wiki");//表尾移除sites.removeLast();//获取表尾System.out.println(sites.getLast());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20230522150653.png" alt=""></p><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20230522150709.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 牛客网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker</title>
      <link href="/posts/40991/"/>
      <url>/posts/40991/</url>
      
        <content type="html"><![CDATA[<h2 id="docker下载"><a href="#docker下载" class="headerlink" title="docker下载"></a>docker下载</h2><h3 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h3><p>1）卸载旧版本<br>yum list installed | grep docker 列出当前所有docker的包<br>yum -y remove docker的包名称 卸载docker包<br>rm -rf /var/lib/docker 删除docker的所有镜像和容器<br>2）安装必要的软件包<br>sudo yum install -y yum-utils \ device-mapper-persistent-data \ lvm2<br>3）设置下载的镜像仓库<br>sudo yum-config-manager \ —add-repo \ <a href="https://download.docker.com/linux/centos/docker-ce.repo">https://download.docker.com/linux/centos/docker-ce.repo</a><br>如果下载失败，采用阿里源和清华源。（详见菜鸟教程）<br>4）列出需要安装的版本列表<br>yum list docker-ce —showduplicates | sort -r<br>5）安装指定版本（这里使用18.0.1版本）<br>sudo yum install docker-ce-18.06.1.ce<br>6）查看版本<br>docker -v<br>7）启动Docker<br>sudo systemctl start docker 启动<br>sudo systemctl enable docker 设置开机启动<br></p><pre class="line-numbers language-none"><code class="language-none">yum list docker-ce --showduplicates | sort -r<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>列出版本列表，看看是否下载成功<p></p><p>添加镜像地址：</p><pre class="line-numbers language-none"><code class="language-none">vi /etc/docker/daemon.json //没有这个文件也无妨，直接创建就好<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/cecd311ce895425cafdd7a8edf9a376a.png" alt=""><br>这个地址的来源：<br>访问阿里云这个网址，要先登录：<a href="https://cr.console.aliyun.com/?spm=a2c6h.12873639.0.0.7aec4073HlA7e2#/accelerator">镜像加速页面</a></p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20230522150025.png" alt=""></p><h3 id="docker启动失败"><a href="#docker启动失败" class="headerlink" title="docker启动失败"></a>docker启动失败</h3><p><strong>错误1：</strong><br>如图所示：<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20230522150048.png" alt=""><br>原因：</p><p>当时在 /etc/docker/daemon.json  添加了一行，但是忘了在第一行后面添加 “逗号”，加上就好。<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20230522150106.png" alt=""></p><p><strong>错误2：</strong><br>docker启动失败，有一个可能就是包（jar,war）有问题。可以先单独检测下包是否可以运行。如果包不能运行，就是代码有问题。<br><strong>如果代码逻辑没有问题，甚至没有改动。可能要注意格式问题，比如少敲或多敲空格这种，这种错误往往看不出来，或者编译器没有明显的错误提示（idea对于这个问题就是标黄，但有时候又不影响，很容易不注意）</strong></p><h2 id="镜像、仓库的关系"><a href="#镜像、仓库的关系" class="headerlink" title="镜像、仓库的关系"></a>镜像、仓库的关系</h2><p>docker可以把服务和需要的库一起打包</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20230522150124.png" alt=""></p><ol><li>拉取镜像</li><li>Docker build</li><li>镜像-&gt;容器 docker run</li><li>容器-&gt;镜像 docker commit。</li></ol><p>上面这图说明了三个得到镜像的途径<br>1．    从docker官方仓库拉取。<br>2．    使用dockerfile构建。<br>3．    从已有的镜像构建容器，进入容器里面（docker -it 容器名称 /bin/bash），做修改，再提交（docker commit）。//这里面 /bin/bash 是进入容器内部，交互运行，和前面的-it也有关系。</p><p><strong>可以做什么？</strong><br>比如我拉取一个centos7镜像，进入里面把私有云那一堆东西全部装好。下次我就可以直接拿来用，把服务扔上去就好。<br>这个过程或者我可以用dockerfile来实现。</p><h2 id="docker基本操作"><a href="#docker基本操作" class="headerlink" title="docker基本操作"></a>docker基本操作</h2><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20230522150146.png" alt=""></p><h3 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> search 镜像名称<span class="token function">docker</span> pull 镜像名 <span class="token function">docker</span> pull 镜像名:tag<span class="token function">docker</span> images   //查看本地所有镜像//提交镜像<span class="token function">docker</span> commit 容器id 镜像:版本号//删除镜像<span class="token function">docker</span> rmi -f 镜像名称  <span class="token comment">##删除多个 其镜像ID或镜像用用空格隔开即可 </span><span class="token function">docker</span> rmi -f 镜像名/镜像ID 镜像名/镜像ID 镜像名/镜像ID<span class="token comment">##删除全部镜像  -a 意思为显示全部, -q 意思为只显示ID</span><span class="token function">docker</span> rmi -f <span class="token variable"><span class="token variable">$(</span><span class="token function">docker</span> images -aq<span class="token variable">)</span></span>//强制删除镜像<span class="token function">docker</span> image <span class="token function">rm</span> 镜像名称/镜像ID//保存镜像//将我们的镜像 保存为tar 压缩文件 这样方便镜像转移和保存 ,然后 可以在任何一台安装了docker的服务器上 加载这//个镜像<span class="token function">docker</span> save 镜像名/镜像ID -o 镜像保存在哪个位置与名字<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h3><p>容器是由镜像创建而来。容器是Docker运行应用的载体，每个应用都分别运行在Docker的每个 容器中</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -i 镜像名称:标签   //运行容器（默认是前台运行） <span class="token function">docker</span> <span class="token function">ps</span>  //查看运行的容器 <span class="token function">docker</span> <span class="token function">ps</span> -a  //查询所有容器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>实际命令分析：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -d -it --hostname phdev -p <span class="token number">90</span>:80 -p <span class="token number">8899</span>:8899 -v /sys/fs/cgroup:/sys/fs/cgroup --privileged “镜像名字” /usr/sbin/init//-d 容器以后台方式运行，不会直接进入到容器里面//hostname 指定主机名称；//-p 是端口映射。90:80 访问服务器90端口就是访问容器80端口//-v 是挂载到指定目录//  privileged  /usr/sbin/init  是给容器赋予更高的权限<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">//以shell方式进入到一个已经运行的容器当中，和上一条命令搭配起来使用<span class="token function">docker</span> <span class="token builtin class-name">exec</span> -it “容器id” /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="传输文件命令"><a href="#传输文件命令" class="headerlink" title="传输文件命令"></a>传输文件命令</h3><p>传输文件命令——本地传到docker</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token function">cp</span> “文件”  镜像id：“路径”<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="导出-导入镜像"><a href="#导出-导入镜像" class="headerlink" title="导出/导入镜像"></a>导出/导入镜像</h3><p>方法1：save</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">//导出<span class="token function">docker</span> save imagesID <span class="token operator">&gt;</span> /存放位置/打包文件名.tar//导入<span class="token function">docker</span> load <span class="token operator">&lt;</span> 打包文件名.tar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方法2：export</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">//导出<span class="token function">docker</span> <span class="token builtin class-name">export</span> 容器名 <span class="token operator">&gt;</span> /位置/打包名.tar//导入<span class="token function">docker</span> <span class="token function">import</span> <span class="token operator">&lt;</span> 打包名.tar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>区别：<br>(1).export导出的镜像文件大小 小于 save保存的镜像</p><p>(2).export 导出（import导入）是根据容器拿到的镜像，再导入时会丢失镜像所有的历史，所以无法进行回滚操作（docker tag ）；而save保存（load加载）的镜像，没有丢失镜像的历史，可以回滚到之前的层（layer）。（查看方式：docker images —tree）</p><h3 id="删除镜像或容器"><a href="#删除镜像或容器" class="headerlink" title="删除镜像或容器"></a>删除镜像或容器</h3><p><a href="https://blog.csdn.net/qq_42006301/article/details/105102020">原文链接</a><br>方法一：删除所有未运行的容器（已经运行的删除不了，未运行的就一起被删除了）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token function">rm</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">docker</span> <span class="token function">ps</span> -a -q<span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>方法二：根据容器的状态，删除Exited状态的容器</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token function">rm</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">docker</span> <span class="token function">ps</span> -qf <span class="token assign-left variable">status</span><span class="token operator">=</span>exited<span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>方法三：docker 1.13版本以后，可以使用 docker system 或 docker container命令清理容器。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">//docker container prune 删除已停用容器<span class="token function">docker</span> container prune//删除关闭的容器、无用的数据卷和网络，以及dangling镜像<span class="token function">docker</span> system prune //命令清理得更加彻底，可以将没有容器使用Docker的镜像都删掉<span class="token function">docker</span> system prune -a <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查看docker信息"><a href="#查看docker信息" class="headerlink" title="查看docker信息"></a>查看docker信息</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> info<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到docker的根路径是 /var/lib/docker<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20230522150209.png" alt=""><br>查看docker根路径的磁盘占用率</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">df</span> -Th /var/lib/docker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql</title>
      <link href="/posts/62688/"/>
      <url>/posts/62688/</url>
      
        <content type="html"><![CDATA[<h2 id="Mysql变量定义与赋值"><a href="#Mysql变量定义与赋值" class="headerlink" title="Mysql变量定义与赋值"></a>Mysql变量定义与赋值</h2><p><a href="https://blog.csdn.net/H900302/article/details/123735007?spm=1001.2101.3001.6650.5&amp;depth_1-utm_relevant_index=10">原链接</a></p><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><h4 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h4><pre class="line-numbers language-none"><code class="language-none">declare a int default value 0;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h4><pre class="line-numbers language-none"><code class="language-none">//法一set a=10;//法二select user_name into uname from t_user where id = 2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="用户变量"><a href="#用户变量" class="headerlink" title="用户变量"></a>用户变量</h3><p>使用set或select直接赋值，变量名以 @ 开头.</p><h4 id="变量赋值-1"><a href="#变量赋值-1" class="headerlink" title="变量赋值"></a>变量赋值</h4><pre class="line-numbers language-none"><code class="language-none">SET @a=1,@b=2;//法二select @变量名:=变量值select @变量名:=字段名 from table where ... limit 1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h3><h2 id="MySQL理论知识"><a href="#MySQL理论知识" class="headerlink" title="MySQL理论知识"></a>MySQL理论知识</h2><h3 id="事务并发异常"><a href="#事务并发异常" class="headerlink" title="事务并发异常"></a>事务并发异常</h3><p>SQL 标准共定义了 3 种并发异常，这三种异常分别是脏读（Dirty Read）、不可重复读（Nnrepeatable Read）和幻读（Phantom Read）。</p><ol><li>脏读 </li></ol><p>脏读指的是读到了其他事务未提交的数据，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。读到了并一定最终存在的数据，这就是脏读。</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/d01373f082025aaf5be5454896a1dd6d024f1a37.jpeg" alt=""></p><p><strong>脏读最大的问题就是可能会读到不存在的数据。</strong></p><ol><li>不可重复读</li></ol><p>不可重复读指的是在一个事务内，最开始读到的数据和事务结束前的任意时刻读到的同一批数据出现不一致的情况。</p><p><img src="https://pics1.baidu.com/feed/cf1b9d16fdfaaf51b5c3d1cbe318e2e7f01f7a73.jpeg?token=0a1d7df4e2f9fae479bc98bd763fd2ee" alt=""></p><p>事务 A 多次读取同一数据，但事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。</p><ol><li>幻读<br>幻读侧重的方面是某一次的 select 操作得到的结果所表征的数据状态无法支撑后续的业务操作。更为具体一些：select 某记录是否存在，不存在，准备插入此记录，但执行 insert 时发现此记录已存在，无法插入，此时就发生了幻读。</li></ol><p><strong>不可重复读侧重表达 读-读，幻读则是说 读-写，用写来证实读的是鬼影。</strong></p><p>举例：<br>假设有张用户表,这张表的 id 是主键。表中一开始有4条数据。<br><img src="https://pics6.baidu.com/feed/d52a2834349b033be131703c798240dad439bd75.jpeg?token=3e013deb540b45db9ad7ab03563d06ef" alt=""></p><p>我们再来看下出现 幻读 的场景</p><p><img src="https://pics3.baidu.com/feed/8435e5dde71190efb4aa7a77bb57eb1ffcfa609f.jpeg?token=5b271d6e820ca8770d6d6caf3955937c" alt=""></p><p>这里是在RR级别下研究(可重复读),因为 RU / RC 下还会存在脏读、不可重复读，故我们就以 RR 级别来研究 幻读，排除其他干扰。</p><p>1、事务A,查询是否存在 id=5 的记录，没有则插入，这是我们期望的正常业务逻辑。</p><p>2、这个时候 事务B 新增的一条 id=5 的记录，并提交事务。</p><p>3、事务A,再去查询 id=5 的时候,发现还是没有记录（因为这里是在RR级别下研究(可重复读)，所以读到依然没有数据）</p><p>4、事务A,插入一条 id=5 的数据。</p><p>最终 事务A 提交事务，发现报错了。这就很奇怪，查的时候明明没有这条记录，但插入的时候 却告诉我 主键冲突，这就好像幻觉一样。这才是所有的幻读。</p><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p><img src="https://s2.loli.net/2022/05/21/A3Gb6Rtfmr571yE.png" alt=""><br>上面的隔离级别由上往下，级别依次会提高，但消耗的性能也会依次提高。我们总结一下四种隔离级别：</p><ol><li>读未提交：允许读未提交数据，可能会发生脏读、不可重复读和幻读异常；</li><li>读已提交：只能读已经提交的数据，避免了脏读，但可能会出现不可重复读和幻读；</li><li>可重复读：即能保证在一个事务中多次读取，数据一致，但可能会出现幻读；</li><li>可串行化：最高的隔离级别，串行的执行事务，可以避免 3 种异常，但性能耗损最高。</li></ol><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>MySQL 支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型。</p><h4 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h4><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/c1dbf744928b4225aca0777923efbdb9.png" alt=""></p><h4 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h4><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/dca2d56f9cf9450e92c8ecec362a8d05.png" alt=""></p><h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/96f697d0ac234fb8b92b4b72a3da027e.png" alt=""></p><h2 id="Mysql语句"><a href="#Mysql语句" class="headerlink" title="Mysql语句"></a>Mysql语句</h2><h3 id="查看表结构"><a href="#查看表结构" class="headerlink" title="查看表结构"></a>查看表结构</h3><pre class="line-numbers language-none"><code class="language-none">desc tabl_name;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h3><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE table_name (column_name column_type);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>实例1：<br></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">CREATE TABLE IF NOT EXISTS <span class="token variable"><span class="token variable">`</span>runoob_tbl<span class="token variable">`</span></span><span class="token punctuation">(</span>   <span class="token variable"><span class="token variable">`</span>runoob_id<span class="token variable">`</span></span> INT UNSIGNED AUTO_INCREMENT,   <span class="token variable"><span class="token variable">`</span>runoob_title<span class="token variable">`</span></span> VARCHAR<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> NOT NULL,   <span class="token variable"><span class="token variable">`</span>runoob_author<span class="token variable">`</span></span> VARCHAR<span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span> NOT NULL,   <span class="token variable"><span class="token variable">`</span>submission_date<span class="token variable">`</span></span> DATE,   PRIMARY KEY <span class="token punctuation">(</span> <span class="token variable"><span class="token variable">`</span>runoob_id<span class="token variable">`</span></span> <span class="token punctuation">)</span><span class="token punctuation">)</span>ENGINE<span class="token operator">=</span>InnoDB DEFAULT <span class="token assign-left variable">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>如果你不想字段为 NULL 可以设置字段的属性为 NOT NULL， 在操作数据库时如果输入该字段的数据为NULL ，就会报错。<br>AUTO_INCREMENT定义列为自增的属性，一般用于主键，数值会自动加1。<br>PRIMARY KEY关键字用于定义列为主键。 您可以使用多列来定义主键，列间以逗号分隔。<br>ENGINE 设置存储引擎，CHARSET 设置编码。</p><p>实例2：<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/ff323136692f4472847f83481071002e.png" alt=""><br>int(10)的意思是假设有一个变量名为id，它的能显示的宽度能显示10位。在使用id时，假如我给id输入10，那么mysql会默认给你存储0000000010。当你输入的数据不足10位时，会自动帮你补全位数。假如我设计的id字段是int(20)，那么我在给id输入10时，mysql会自动补全18个0，补到20位为止。</p><p><strong>int(M)的作用于int的范围明显是无关的，int(M)只是用来显示数据的宽度，我们能看到的宽度。当字段被设计为int类型，那么它的范围就已经被写死了（看上面的1.1节的内容），与M无关。</strong></p><p><strong>以上面这个为例，有几个注意事项：<br>1.表名和字段名外面的符号 ` 不是单引号，而是英文输入法状态下的反单引号，也就是键盘左上角 esc 按键下面的那一个 ~ 按键。<br>2.comment 后面的字段用单引号括起来</strong></p><p>注意：MySQL命令终止符为分号 ; 。</p><h3 id="查看数据表"><a href="#查看数据表" class="headerlink" title="查看数据表"></a>查看数据表</h3><p>法一：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">DESCRIBE 表名<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或简写成：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">DESC 表名<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>法二：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">SHOW CREATE TABLE 表名<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 SHOW CREATE TABLE 语句的结尾处（分号前面）添加\g或者\G参数可以改变展示形式。</p><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><h4 id="1-插入一行"><a href="#1-插入一行" class="headerlink" title="1.插入一行"></a>1.插入一行</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">INSERT INTO table_name <span class="token punctuation">(</span> field1, field2,<span class="token punctuation">..</span>.fieldN <span class="token punctuation">)</span>                       VALUES                       <span class="token punctuation">(</span> value1, value2,<span class="token punctuation">..</span>.valueN <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>注意：这个是添加一行数据，不是添加一列。添加一列要增加新的字段。</strong></p><pre class="line-numbers language-none"><code class="language-none">INSERT INTO teacher (name,age,id_number) VALUES ('秦小贤',18,'42011720200604088X');<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>注意：表名后面的字段没有引号，插入的数据，如果是字符串，要加引号</strong></p><h4 id="2-插入多行"><a href="#2-插入多行" class="headerlink" title="2.插入多行"></a>2.插入多行</h4><pre class="line-numbers language-none"><code class="language-none">INSERT INTO teacher(name,age,id_number)VALUES('王小花',19,'42011720200604077X'),('张晓丽',18,'42011720200604099X'),('刘美丽',20,'42011720200604020X'),('吴帅',21,'42011720200604022X'),('张平',22,'42011720200604033X')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-插入一列"><a href="#3-插入一列" class="headerlink" title="3.插入一列"></a>3.插入一列</h4><p>前提是这一列已经建好（通过ALTER），如果不加where，那是这个字段（一列）全部更新。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">UPDATE table_name SET field1<span class="token operator">=</span>new<span class="token operator">-</span>value1<span class="token punctuation">,</span> field2<span class="token operator">=</span>new<span class="token operator">-</span>value2<span class="token punctuation">[</span>WHERE Clause<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="修改表名和字段（增、删、改）"><a href="#修改表名和字段（增、删、改）" class="headerlink" title="修改表名和字段（增、删、改）"></a>修改表名和字段（增、删、改）</h3><h4 id="删除、添加、修改字段"><a href="#删除、添加、修改字段" class="headerlink" title="删除、添加、修改字段"></a>删除、添加、修改字段</h4><pre class="line-numbers language-none"><code class="language-none">//删除字段i//如果数据表中只剩余一个字段则无法使用DROP来删除字段。mysql&gt; ALTER TABLE testalter_tbl  DROP i;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>添加字段：<br></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">mysql<span class="token operator">&gt;</span> ALTER TABLE testalter_tbl ADD i INT<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p><p>如果你需要指定新增字段的位置，可以使用MySQL提供的关键字 FIRST (设定位第一列)， AFTER 字段名（设定位于某个字段之后）。</p><p>尝试以下 ALTER TABLE 语句, 在执行成功后，使用 SHOW COLUMNS 查看表结构的变化：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">ALTER TABLE testalter_tbl DROP i<span class="token punctuation">;</span>ALTER TABLE testalter_tbl ADD i INT FIRST<span class="token punctuation">;</span>ALTER TABLE testalter_tbl DROP i<span class="token punctuation">;</span>ALTER TABLE testalter_tbl ADD i INT AFTER c<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>指定位置插入字段</strong><br></p><pre class="line-numbers language-none"><code class="language-none">//添加到第一个alter table 表名 add column 字段名 varchar(255) FIRST;//添加到指定字段后，记得加上符号，那个符号是esc按键下面的alter table person_param add column `module_name` VARCHAR(20) after `product_id`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="修改字段类型及名称"><a href="#修改字段类型及名称" class="headerlink" title="修改字段类型及名称"></a>修改字段类型及名称</h4><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/3b1fe134a6ee4169be9014e24667eced.png" alt=""></p><h4 id="删除的几种情况"><a href="#删除的几种情况" class="headerlink" title="删除的几种情况"></a>删除的几种情况</h4><ol><li>drop table table_name<br>删除表全部数据和表结构，立刻释放磁盘空间，不管是 Innodb 和 MyISAM;</li><li>truncate table table_name<br>删除表全部数据，保留表结构，立刻释放磁盘空间 ，不管是 Innodb 和 MyISAM;</li><li>delete from table_name<br>删除表全部数据，表结构不变，对于 MyISAM 会立刻释放磁盘空间，InnoDB 不会释放磁盘空间;</li><li>delete from table_name where xxx<br>带条件的删除，表结构不变，不管是 innodb 还是 MyISAM 都不会释放磁盘空间;</li><li>delete 操作以后，使用 optimize table table_name,会立刻释放磁盘空间，不管是 innodb 还是 myisam<pre class="line-numbers language-none"><code class="language-none">delete from student where T_name = "张三";optimize table student;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>delete from 表以后虽然未释放磁盘空间，但是下次插入数据的时候，仍然可以使用这部分空间。</li></ol><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><p>默认用户为root，但是在Linux和mysql中，可以认为root用户就是各自系统的皇帝，对其它用户的数据有生杀大权，所以最好创建其它的用户来执行。<br>1.先登录</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql -uroot -p<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2.创建一个只能在mysql服务器所在主机使用的用户，此处为localuser</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">create user <span class="token string">'用户名'</span>@<span class="token string">'localhost'</span> identified by <span class="token string">'用户的密码'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>localuser可以在mysql服务器所在主机正常使用</p><p>3.在另外一台主机登陆时，会报错</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">本机登陆：mysql -ulcocaluser -p远程登陆：mysql -h mysql服务器ip -ulocaluser -p<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>4、创建一个只能由特定远程主机使用的帐户，此处为limituser。</p><p>limituser只能在指定的主机使用。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">create user <span class="token string">'limituser'</span>@<span class="token string">'远程主机ip'</span> identified by <span class="token string">'123'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>本机登陆：mysql -ulcocaluser -p</p><p>远程登陆：mysql -h mysql服务器ip -ulocaluser -p</p><p>5、创建一个可以在本地和远程都可以登陆的用户，此处为unlimituser。</p><p>对，就是在创建用户时，host使用通配符%</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">create user <span class="token string">'unlimituser'</span>@<span class="token string">'%'</span> identified by <span class="token string">'123'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>unlimituser用户服务器主机和远程主机登陆</p><p>6.删除用户</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">drop user <span class="token string">'mysqluser'</span>@<span class="token string">'host'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="创建外键"><a href="#创建外键" class="headerlink" title="创建外键"></a>创建外键</h3><h4 id="创建表时增加外键"><a href="#创建表时增加外键" class="headerlink" title="创建表时增加外键"></a>创建表时增加外键</h4><p>首先创建第一张被关联表Vendors商品供应商表。<br></p><pre class="line-numbers language-none"><code class="language-none">-- 供应商列表CREATE TABLE Vendors (-- 供应商ID：主键列，自增长vend_id INT NOT NULL PRIMARY KEY AUTO_INCREMENT COMMENT '供应商ID',-- 供应商名：可变字符，非空vend_name VARCHAR (30) NOT NULL COMMENT '供应商名',-- 供应商地址vend_address VARCHAR (100) NOT NULL COMMENT '地址',-- 供应商城市vend_city VARCHAR (20) NOT NULL COMMENT '城市',-- 供应商州vend_state VARCHAR (20) NOT NULL COMMENT '州',-- 供应商邮编vend_zip VARCHAR (20) NOT NULL COMMENT '邮编',-- 供应商国家vend_country VARCHAR (20) NOT NULL COMMENT '国家');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>然后创建第二张关联表Products产品表。</p><pre class="line-numbers language-none"><code class="language-none">-- 产品目录表CREATE TABLE Products (-- 产品ID：主键列，自增长prod_id INT NOT NULL PRIMARY KEY AUTO_INCREMENT,-- 供应商ID：外键vend_id INT NOT NULL COMMENT '供应商ID',-- 产品名prod_name VARCHAR (30) NOT NULL COMMENT '产品名',-- 产品价格prod_price DOUBLE NOT NULL COMMENT '产品价格',-- 产品描述prod_desc VARCHAR (100) COMMENT '产品描述',FOREIGN KEY (vend_id) REFERENCES Vendors (vend_id));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="已存在表增加外键"><a href="#已存在表增加外键" class="headerlink" title="已存在表增加外键"></a>已存在表增加外键</h4><p>首先删除刚才两张表所创建的外键。<br>然后通过下面指令对已经存在的表增加外键。语法如下：<br></p><pre class="line-numbers language-none"><code class="language-none">-- 已存在表增加外键//(主键字段)和 (外键字段)没有加括号会报错ALTER TABLE ZDZ ADD FOREIGN KEY (sd) REFERENCES Ws_para (snum);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p></p><h3 id="连表查询"><a href="#连表查询" class="headerlink" title="连表查询"></a>连表查询</h3><p><a href="https://juejin.cn/post/7043811976270577672">详细介绍网址</a><br></p><pre class="line-numbers language-none"><code class="language-none">SELECT * from `products` a RIGHT JOIN `person_param` b ON a.product_id=b.product_id WHERE a.product_id=338;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>连表查的第一步就是两个表要关连起来，在上面的代码就是 ON 后面的<code>a.product_id=b.product_id</code><p></p><h3 id="复制表数据，修改后再插入"><a href="#复制表数据，修改后再插入" class="headerlink" title="复制表数据，修改后再插入"></a>复制表数据，修改后再插入</h3><pre class="line-numbers language-none"><code class="language-none">INSERT INTO basic_param (origin_name,present_name,version,project_name) SELECT origin_name,present_name,(28),'xlh' FROM basic_param<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="mysql在linux上快速导入sql文件"><a href="#mysql在linux上快速导入sql文件" class="headerlink" title="mysql在linux上快速导入sql文件"></a>mysql在linux上快速导入sql文件</h3><p>mysql导入sql文件，如果文件稍大一些，速度会非常慢，以下脚本可以借鉴：<br></p><pre class="line-numbers language-none"><code class="language-none">#!/bin/bashmysql -u root -pSBcaiyong@PASSword123 &lt;&lt;EOFset global innodb_flush_log_at_trx_commit=0;set global sync_binlog=0;use phenglei;source /home/yskj/lgf/db/xlh_dynpara/lgf.sql;set global innodb_flush_log_at_trx_commit=1;set global sync_binlog=1;EOFecho"数据库改变完成"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h2 id="Mysql常见问题"><a href="#Mysql常见问题" class="headerlink" title="Mysql常见问题"></a>Mysql常见问题</h2><h3 id="mysql官网下载老版本"><a href="#mysql官网下载老版本" class="headerlink" title="mysql官网下载老版本"></a>mysql官网下载老版本</h3><p><a href="https://dev.mysql.com/downloads/mysql/">下载网址，可选操作系统</a></p><p>进入后依次选择：DOWNLOADS（下载）——&gt;Community(社区)——MySQL Community Downloads<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/d11d8469ebcd411faf3c9b67c4f4e02b.png" alt=""><br>进入后往下拉，如下图选择Looking for previous GA versions（寻找以前的GA版本）<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/1371dd641c0e4c3ab54e10660e5907ed.png" alt=""></p><h3 id="centos安装mysql"><a href="#centos安装mysql" class="headerlink" title="centos安装mysql"></a>centos安装mysql</h3><p>本地下载mysql，但是xftp上传太慢，暂未找到解决的办法，所以尝试下面这个方法。</p><p><strong>1 下载并安装MySQL官方的 Yum Repository</strong></p><pre class="line-numbers language-none"><code class="language-none">wget -i -c http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用上面的命令就直接下载了安装用的Yum Repository，大概25KB的样子，然后就可以直接yum安装了。</p><pre class="line-numbers language-none"><code class="language-none">yum -y install mysql57-community-release-el7-10.noarch.rpm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 之后就开始安装MySQL服务器。</p><pre class="line-numbers language-none"><code class="language-none">yum -y install mysql-community-server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这步可能会花些时间，安装完成后就会覆盖掉之前的mariadb。<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/000f9e71988a495bb16d7f886050e5f7.png" alt=""><br>至此MySQL就安装完成了，然后是对MySQL的一些设置。</p><p><strong>2 MySQL数据库设置</strong></p><pre class="line-numbers language-none"><code class="language-none">systemctl start  mysqld.service // 首先启动MySQLsystemctl status mysqld.service //查看MySQL运行状态<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/acda61b3da8b4837ad7bdf9020468ea1.png" alt=""><br>此时MySQL已经开始正常运行，不过要想进入MySQL还得先找出此时root用户的密码，通过如下命令可以在日志文件中找出密码：</p><pre class="line-numbers language-none"><code class="language-none">grep "password" /var/log/mysqld.log<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 如下命令进入数据库：</p><pre class="line-numbers language-none"><code class="language-none">mysql -u root -p<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输入初始密码，此时不能做任何事情，因为MySQL默认必须修改密码之后才能操作数据库：</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; ALTER USER 'root'@'localhost' IDENTIFIED BY 'new password';//密码需要设置复杂点，不然会报错。原因是因为MySQL有密码设置的规范，具体是与validate_password_policy的值有关：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>3.密码修改</strong><br><strong><em>上面那一步修改是必须的，否则没法二次修改密码</em></strong></p><p>先进入mysql</p><p>查看 mysql 初始的密码策略<br></p><pre class="line-numbers language-none"><code class="language-none">SHOW VARIABLES LIKE 'validate_password%';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/0d3db11aae794c05adf48c94ade4094b.png" alt=""><br>首先需要设置密码的验证强度等级，设置 validate_password_policy 的全局参数为 LOW 即可<p></p><pre class="line-numbers language-none"><code class="language-none">set global validate_password_policy=LOW; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当前密码长度为 8 ，如果不介意的话就不用修改了，按照通用的来讲，设置为 6 位的密码，设置 validate_password_length 的全局参数为 6 即可</p><pre class="line-numbers language-none"><code class="language-none">set global validate_password_length=6;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在可以为 mysql 设置简单密码了，只要满足六位的长度即可</p><pre class="line-numbers language-none"><code class="language-none">ALTER USER 'root'@'localhost' IDENTIFIED BY '123456';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>注：在默认密码的长度最小值为 4 ，由 大/小写字母各一个 + 阿拉伯数字一个 + 特殊字符一个， 只要设置密码的长度小于 3<br>，都将自动设值为 4 ，如下图：</p><p><br></p><p>关于 mysql 密码策略相关参数；<br> 1）、validate_password_length  固定密码的总长度；<br>2）、validate_password_dictionary_file 指定密码验证的文件路径；<br>3）、validate_password_mixed_case_count  整个密码中至少要包含大/小写字母的总个数；<br>4）、validate_password_number_count  整个密码中至少要包含阿拉伯数字的个数；<br>5）、validate_password_policy 指定密码的强度验证等级，默认为 MEDIUM； 关于<br>validate_password_policy 的取值： 0/LOW：只验证长度； 1/MEDIUM：验证长度、数字、大小写、特殊字符；<br>2/STRONG：验证长度、数字、大小写、特殊字符、字典文件；<br>6）、validate_password_special_char_count 整个密码中至少要包含特殊字符的个数；</p></blockquote><h3 id="重置密码（centos7）"><a href="#重置密码（centos7）" class="headerlink" title="重置密码（centos7）"></a>重置密码（centos7）</h3><p><a href="https://blog.csdn.net/cgtcsdn/article/details/101530671">原文链接</a></p><h4 id="忘记密码"><a href="#忘记密码" class="headerlink" title="忘记密码"></a>忘记密码</h4><p><strong>1.设置MySQL为免密码登录</strong><br><code>vi /etc/my.cnf</code> (部分Linux安装了vim，其命令则改为<code>vim /etc/my.cnf</code>)按【i】键进入编辑模式，在[mysqld]下面加上“skip-grant-tables”，按【Esc】键，然后输入“:wq”保存并退出vi。<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20190927141449601.png" alt=""></p><p><strong>重新启动MySQL服务（使配置生效，此步骤不能省略）</strong></p><pre class="line-numbers language-none"><code class="language-none">service mysqld restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>清空旧密码</strong></p><pre class="line-numbers language-none"><code class="language-none">mysql -u root –p （无需输入密码，直接按回车键进入）use mysqlupdate user set authentication_string = '' where user = 'root';quit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>删除免密码登录代码“skip-grant-tables”</strong></p><p>vi /etc/my.cnf，按【i】键进入编辑模式，删除[mysqld]下面的代码“skip-grant-tables”，按【Esc】键，然后输入“:wq”保存并退出vi。</p><p><strong>重设密码</strong></p><pre class="line-numbers language-none"><code class="language-none">service mysqld restartmysql -u root –p （无需输入密码，直接按回车键进入）use mysqlALTER USER 'root'@'%' IDENTIFIED BY 'snaiL_12';  //密码要用引号括起来<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h4><p><strong><em>问题1</em></strong><br></p><pre class="line-numbers language-none"><code class="language-none">ALTER USER 'root'@'localhost' IDENTIFIED BY 'snaiL_123';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>报错：<code>ERROR 1819 (HY000): Your password does not satisfy the current policy requirements</code><p></p><p><strong>解决：</strong></p><pre class="line-numbers language-none"><code class="language-none">SHOW VARIABLES LIKE 'validate_password%';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>1.2调整MySQL密码验证规则，修改 policy 和 length 的值。</p><pre class="line-numbers language-none"><code class="language-none">set global validate_password——policy=0;（“0”等价于“LOW”，含义是只验证密码长度）set global validate_password.length=8;（因为我之前动过密码长度，这里我将密码长度设为8）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong><em>问题2</em></strong></p><pre class="line-numbers language-none"><code class="language-none">ALTER USER 'root'@'localhost' IDENTIFIED BY 'snaiL_123';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>报错：<code>ERROR 1396 (HY000): Operation ALTER USER failed for 'root'@'localhost'</code></p><p><strong>查看root账户的host</strong></p><pre class="line-numbers language-none"><code class="language-none">select user,host from user;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20190927141940582.png" alt=""></p><p>2.2注意看，我的host是“%”，你输入的命令可能是：</p><pre class="line-numbers language-none"><code class="language-none">ALTERUSER 'root'@'localhost' IDENTIFIED BY 'Snail@10'; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将命令改成：</p><pre class="line-numbers language-none"><code class="language-none">ALTER USER 'root'@'%' IDENTIFIED BY 'Snail@10'; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Navicat连接mysql出现1130-Host-XXX-is-not-allowed-to-connect-to-this-MySQL-server"><a href="#Navicat连接mysql出现1130-Host-XXX-is-not-allowed-to-connect-to-this-MySQL-server" class="headerlink" title="Navicat连接mysql出现1130 - Host XXX is not allowed to connect to this MySQL server"></a>Navicat连接mysql出现1130 - Host XXX is not allowed to connect to this MySQL server</h3><p>接上一条，安装完成后，navicat无法正常连接，这是由于Mysql配置了不支持远程连接引起的。</p><p><strong>1.在安装Mysql数据库的主机上登录root用户</strong></p><pre class="line-numbers language-none"><code class="language-none">mysql -u root -p<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2.依次执行如下命令：</p><pre class="line-numbers language-none"><code class="language-none">use mysql; select host from user where user='root';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以看到当前主机配置信息为localhost.<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/e4dee3a582374c6eba09244e9b947247.png" alt=""><br>3.将Host设置为通配符%</p><p>Host列指定了允许用户登录所使用的IP，比如user=root Host=192.168.1.1。这里的意思就是说root用户只能通过192.168.1.1的客户端去访问。 user=root Host=localhost，表示只能通过本机客户端去访问。而%是个通配符，如果Host=192.168.1.%，那么就表示只要是IP地址前缀为“192.168.1.”的客户端都可以连接。如果Host=%，表示所有IP都有连接权限。 </p><p><strong>注意：在生产环境下不能为了省事将host设置为%，这样做会存在安全问题，具体的设置可以根据生产环境的IP进行设置；</strong></p><pre class="line-numbers language-none"><code class="language-none">update user set host = '%' where user ='root';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Host设置了“%”后便可以允许远程访问。</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/8a3b8bb5074a4f8b9132a2eebdec3301.png" alt=""></p><p>4..Host修改完成后记得执行flush privileges使配置立即生效</p><pre class="line-numbers language-none"><code class="language-none">flush privileges;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="批量插入数据很慢"><a href="#批量插入数据很慢" class="headerlink" title="批量插入数据很慢"></a>批量插入数据很慢</h3><p><a href="https://www.jianshu.com/p/127e79e20d1b">原文链接</a></p><h4 id="批量提交事务"><a href="#批量提交事务" class="headerlink" title="批量提交事务"></a>批量提交事务</h4><pre class="line-numbers language-none"><code class="language-none">## 3、批量提交事务drop procedure if exists insertIntoUser;delimiter $$ create procedure insertIntoUser(in num int, in batchNum int)    begin        declare i int default 0;                while i &lt; num do            set i = i + 1;            set @username = concat('beigua', LPAD(i, 9, 0));            set @nickname = concat('北瓜', LPAD(i, 9, 0));            set @password = replace(uuid(), "-", "");            set @password_salt = replace(uuid(), "-", "");            set @user_no = i;            set autocommit = 0;            INSERT INTO user(username, password, password_salt, nickname, user_no, ip, mobile, mail, gender, type, status, is_deleted, created_time, updated_time)             VALUES (@username, @password, @password_salt, @nickname, @user_no, '192.168.1.1', '18888888888', '18888888888@163.com', '0', '0', '0', '0', now(), now());                    if i mod batchNum = 0 then                commit;            end if;        end while;    end $$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="一次性提交所有事务"><a href="#一次性提交所有事务" class="headerlink" title="一次性提交所有事务"></a>一次性提交所有事务</h4><pre class="line-numbers language-none"><code class="language-none">## 4、一次性提交事务drop procedure if exists insertIntoUser;delimiter $$ create procedure insertIntoUser(in num int)    begin        declare i int default 0;        set autocommit = 0;                while i &lt; num do            set i = i + 1;            set @username = concat('beigua', LPAD(i, 9, 0));            set @nickname = concat('北瓜', LPAD(i, 9, 0));            set @password = replace(uuid(), "-", "");            set @password_salt = replace(uuid(), "-", "");            set @user_no = i;            INSERT INTO user(username, password, password_salt, nickname, user_no, ip, mobile, mail, gender, type, status, is_deleted, created_time, updated_time)             VALUES (@username, @password, @password_salt, @nickname, @user_no, '192.168.1.1', '18888888888', '18888888888@163.com', '0', '0', '0', '0', now(), now());        end while;                commit;    end $$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="数据插入前加索引与数据插入后加索引对比"><a href="#数据插入前加索引与数据插入后加索引对比" class="headerlink" title="数据插入前加索引与数据插入后加索引对比"></a>数据插入前加索引与数据插入后加索引对比</h4><p>在插入数据的时候不要加过多索引，插完再加</p><h4 id="修改参数"><a href="#修改参数" class="headerlink" title="修改参数"></a>修改参数</h4><p>set global innodb_flush_log_at_trx_commit = 0;</p><p><br></p><h2 id="如何设计数据库"><a href="#如何设计数据库" class="headerlink" title="如何设计数据库"></a>如何设计数据库</h2><p><a href="https://blog.csdn.net/LLLLQZ/article/details/110231569">原文链接</a></p><h2 id="游标、存储过程、函数"><a href="#游标、存储过程、函数" class="headerlink" title="游标、存储过程、函数"></a>游标、存储过程、函数</h2><p>存储过程是为了完成特定功能的SQL语句集，经编译创建并保存在数据库中，用户可通过指定存储过程的名字并给定参数(需要时)来调用执行。</p><p>存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用。</p><p><strong>使用存储过程需要注意一些问题</strong></p><ol><li>注意分号的使用，语句后面没加分号会报错</li><li>存储过程既可以放查询里面，也可以放存储里面（工具栏-》函数-》存储）</li><li>mysql存储过程每一句后面必须用;结尾，使用的<strong>临时字段</strong>需要在定义游标之前进行声明。</li></ol><p>上面第三点的解释如下：<br></p><pre class="line-numbers language-none"><code class="language-none">DECLARE s int DEFAULT 0;declare p_t_id bigint(20);declare varmodule int DEFAULT 0;declare varparam int DEFAULT 0; declare pid cursor for select product_id from products;DECLARE CONTINUE HANDLER FOR NOT FOUND SET s=1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>所有的declare必须放在游标声明前面（declare pid cursor这句）<p></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> Linux </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux知识点+问题</title>
      <link href="/posts/54220/"/>
      <url>/posts/54220/</url>
      
        <content type="html"><![CDATA[<h2 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h2><h3 id="error-while-loading-shared-libraries错误解决办法"><a href="#error-while-loading-shared-libraries错误解决办法" class="headerlink" title="error while loading shared libraries错误解决办法"></a>error while loading shared libraries错误解决办法</h3><p><strong>背景：求解器执行的适合报找不到libmpiexec.so.12这个东西，但是在/opt/mpich/lib下面有这个东西。路径什么的也都加入到了 环境变量里面 （~/.bash_profile或~/.bashrc）。还是无法解决问题</strong><br><a href="https://blog.csdn.net/dumeifang/article/details/2963223?spm=1001.2101.3001.6650.1&amp;depth_1-utm_relevant_index=2">原文链接</a><br>出现这类错误表示，系统不知道xxx.so放在哪个目录下，这时候就要在/etc/ld.so.conf中加入xxx.so所在的目录。</p><p>运行命令 <code>sudo gedit /etc/ld.so.conf</code> 在第一行后面空一格 添加/usr/local/lib 保存。运行<code>sudo /sbin/ldconfig</code>更新</p><h3 id="新建用户之后不显示用户名和路径问题解决"><a href="#新建用户之后不显示用户名和路径问题解决" class="headerlink" title="新建用户之后不显示用户名和路径问题解决"></a>新建用户之后不显示用户名和路径问题解决</h3><p>先说一下如何新建用户并指定目录为根目录:</p><ol><li>新建用户，当前用户必须为root用户<pre class="line-numbers language-none"><code class="language-none">useradd -d /home/cron/log -m bbee<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p>-d指定目录文件夹</p><p>-m新账号名</p><p>-c comment 指定一段注释性描述。<br>-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。<br>-g 用户组 指定用户所属的用户组。<br>-G 用户组，用户组 指定用户所属的附加组。<br>-s Shell文件 指定用户的登录Shell。<br>-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。</p><ol><li>设置密码<br><code>passwd bbee</code><br>接下来会提示你输入两次密码</li></ol><p><strong>使用新用户登录的时候，出现了问题</strong><br>在Linux下新增的用户登录后只有一个$，没有显示用户名和主机名，如下：<br></p><pre class="line-numbers language-none"><code class="language-none">$ cd ~    $ ls$ ls -a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p></p><p>原因是新建的用户未指定shell。我们只需将其指定为一个shell即可。下面提供两种办法：<br><strong>方法一（成功）</strong><br>查看下当前用户使用的是什么shell<br><code>echo $SHELL</code><br>查看系统支持shell类型<br><code>cat /etc/shells</code></p><p>使用usermod命令修改shell类型<br><code>root@iZ2zeijeb6un95h:~# usermod -s /bin/bash bbee</code></p><p><strong>方法二（为尝试）</strong></p><p>在新建用户的时候指定shell<br><code>useradd -d /home/cron/log -s /bin/bash -m bbee</code></p><h2 id="make命令"><a href="#make命令" class="headerlink" title="make命令"></a>make命令</h2><p><a href="https://www.ruanyifeng.com/blog/2015/02/make.html">原文链接</a></p><h2 id="make-和-cmake"><a href="#make-和-cmake" class="headerlink" title="make 和 cmake"></a>make 和 cmake</h2><p><a href="https://blog.csdn.net/KP1995/article/details/109569787">原文链接</a></p><h3 id="什么是make"><a href="#什么是make" class="headerlink" title="什么是make"></a>什么是make</h3><p>make工具可以看成是一个智能的批处理工具，它本身并没有编译和链接的功能，而是用类似于批处理的方式—通过调用makefile文件中用户指定的命令来进行编译和链接。</p><h3 id="什么是Makefile"><a href="#什么是Makefile" class="headerlink" title="什么是Makefile"></a>什么是Makefile</h3><p>简单的说就像一首歌的乐谱，make工具就像指挥家，指挥家根据乐谱指挥整个乐团怎么样演奏，make工具就根据makefile中的命令进行编译和链接。makefile命令中就包含了调用gcc（也可以是别的编译器）去编译某个源文件的命令。makefile在一些简单的工程完全可以用人工手写，但是当工程非常大的时候，手写makefile也是非常麻烦的，如果换了个平台makefile又要重新修改。这时候就出现了Cmake工具。</p><h3 id="什么是Cmake"><a href="#什么是Cmake" class="headerlink" title="什么是Cmake"></a>什么是Cmake</h3><p>cmake可以更加简单的生成makefile文件给上面那个make用。当然cmake还有其他功能，就是可以跨平台生成对应平台能用的makefile，你就不用再自己去修改了。cmake根据什么生成makefile呢？它又要根据一个叫CMakeLists.txt文件（学名：组态档）去生成makefile。到最后CMakeLists.txt文件谁写啊？亲，是你自己手写的。</p><p>当然如果你用IDE，类似VS这些一般它都能帮你弄好了，你只需要按一下那个三角形。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">简单总结cmake用来转译CMakeLists.txt，在linux下它会生成Makefile，来给make执行。Makefile+make可理解为类unix环境下的项目管理工具， 而cmake是抽象层次更高的项目管理工具。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>下面给出其关系图：<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20201109214319194.png" alt=""></p><h2 id="configure-amp-amp-make-amp-amp-make-install"><a href="#configure-amp-amp-make-amp-amp-make-install" class="headerlink" title="./configure &amp;&amp; make &amp;&amp; make install"></a>./configure &amp;&amp; make &amp;&amp; make install</h2><h3 id="configure"><a href="#configure" class="headerlink" title="./configure"></a>./configure</h3><p>源码的安装一般由3个步骤组成：<strong>配置(configure)、编译(make)、安装(make install)</strong>。</p><p>configure文件是一个可执行的脚本文件,是用来检测你的安装平台的目标特征的。比如它会检测你是不是有CC或GCC，并不是需要CC或GCC.<br>它有很多选项，在待安装的源码目录下使用命令<code>./configure –help</code>可以输出详细的选项列表。</p><p>其中—prefix选项是配置安装目录，如果不配置该选项，安装后可执行文件默认放在/usr /local/bin，库文件默认放在/usr/local/lib，配置文件默认放在/usr/local/etc，其它的资源文件放在/usr /local/share，比较凌乱。</p><p>如果配置了—prefix，如：</p><p>$ ./configure —prefix=/usr/local/test</p><p>安装后的所有资源文件都会被放在/usr/local/test目录中，不会分散到其他目录。</p><p>使用—prefix选项的另一个好处是方便卸载软件或移植软件；当某个安装的软件不再需要时，只须简单的删除该安装目录，就可以把软件卸载得干干净净；而移植软件只需拷贝整个目录到另外一个机器即可（相同的操作系统下）。</p><p>当然要卸载程序，也可以在原来的make目录下用一次make uninstall，但前提是Makefile文件有uninstall命令（nodejs的源码包里有uninstall命令，测试版本v0.10.35）。</p><p><strong>关于卸载：</strong><br>如果没有配置—prefix选项，源码包也没有提供make uninstall，则可以通过以下方式可以完整卸载：</p><p>找一个临时目录重新安装一遍，如：<br>$ ./configure —prefix=/tmp/to_remove &amp;&amp; make install</p><p>然后遍历/tmp/to_remove的文件，删除对应安装位置的文件即可（因为/tmp/to_remove里的目录结构就是没有配置—prefix选项时的目录结构）。</p><h3 id="make"><a href="#make" class="headerlink" title="make"></a>make</h3><p>make 是用来编译的，它从Makefile中读取指令，然后编译。可以使用多核来make。<code>make -j2</code><br>如果是8核，那就用make -j8。<br>这一步就是编译，大多数的源代码包都经过这一步进行编译（当然有些perl或python编写的软件需要调用perl或python来进行编译）。如果 在 make 过程中出现 error ，你就要记下错误代码（注意不仅仅是最后一行），然后你可以向开发者提交 bugreport（一般在 INSTALL 里有提交地址），或者你的系统少了一些依赖库等，这些需要自己仔细研究错误代码。</p><p>可能遇到的错误：make <em>*</em> 没有指明目标并且找不到 makefile。 停止。问题很明了，没有Makefile，怎么办，原来是要先./configure 一下，再make。</p><h3 id="make-install"><a href="#make-install" class="headerlink" title="make install"></a>make install</h3><p>可以使用多核安装 make -j2 install</p><p>这条命令来进行安装（当然有些软件需要先运行 make check 或 make test 来进行一些测试），这一步一般需要你有 root 权限（因为要向系统写入文件）。</p><p>这个命令用与安装，可以携带一个参数。<code>PREFIX=/home/lgf</code><br>表示安装路径，在安装mpi的时候出现过这个参数。</p><h2 id="Linux-权限"><a href="#Linux-权限" class="headerlink" title="Linux 权限"></a>Linux 权限</h2><h3 id="目录、文件夹的权限如何分配"><a href="#目录、文件夹的权限如何分配" class="headerlink" title="目录、文件夹的权限如何分配"></a>目录、文件夹的权限如何分配</h3><p>linux系统上面权限是一个很重要的问题，每一个目录(/opt,/home,/usr)权限到底该如何设置，什么时候使用sudo。</p><p>以单个用户(以yskj为例)为例，每一个用户自能在指定的目录拥有读、写、执行权限，不能访问别人的目录。一般来说是在/home/yskj/</p><p>/opt等目录拥有者和组几乎全是root。比如mpi在/opt，普通用户登录可以使用吗？答案是可以的。<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/cfa86e15e98542dd9f83683b8ac5a85f.png" alt=""></p><p>上图看出两个事情。</p><ol><li>拥有者和组都是root</li><li>其他用户（yskj）是拥有读和执行权限</li></ol><h3 id="使用者、目录、文件"><a href="#使用者、目录、文件" class="headerlink" title="使用者、目录、文件"></a>使用者、目录、文件</h3><p><a href="https://blog.csdn.net/sinat_36118270/article/details/63683393">原文链接</a></p><p>首先，我们需要知道Linux中的权限是十分重要的，而且权限分为两类：一类是使用者的权限，一类是文件以及目录的是否可读、写、执行的权限。</p><ol><li><p>拥有者–所属组–other</p><p>首先很多人不明白这三个使用者的权限是什么意思。一般情况下，拥有者是这个文件的创建者，即哪个用户创建的这个文件。并且在创建新用户的时候会创建出一个同名的组，这个拥有者默认包含在这个所属组中。我们先来理一理这三者的联系去区别，对于初学者来说，我们可以把这三者想象成数学中的集合，拥有者是元素，整个Linux大环境是全集，而所属组是一个一个的小集合，看张图吧。<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/df5e37bc8da24291985501de3a71f207.png" alt=""></p></li></ol><p>拥有者就是一个一个的小红点，每个都在自己的所属组里，而且一个拥有者可以在多个所属组里。例如：1可以在所属组1，也可以在所属组2，也可以在所属组3…可以自定义设置。other就是对于所属组1来说，除所属组1中的所有拥有者外，其他的拥有者、所属组都是other。<br>　　值得注意的是，在Linux下，有一个超级用户–root，有全部的权限，凌驾一切之上。<br>　　下面是刚才所讲操作的具体命令：</p><pre class="line-numbers language-none"><code class="language-none">## user1是生成的用户名创建一个用户：useradd user给他加上密码：password user1删除一个用户：userdel user1写作 userdel -r user1  时会删除user1上的文件创建新增组：groupadd group1删除组：groupdel group1让user1用户归为usergroup1组：useradd -g usergroup1 user1让user1用户也归为usergroup2组：useradd -G usergroup2 user1切换用户：su user1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有时，可能我们会需要更改一个用户，或者更改一个所属组，以使其他拥有者或者其他所属组没有权限打开读写执行这个文件或目录。这时我们需要拥戴的命令是：</p><pre class="line-numbers language-none"><code class="language-none">修改拥有者：chmod 用户名 文件名/目录名   但注意：普通用户的操作命令要加上sudo chmod 用户名 文件名sudo的作用是仅当前操作暂时为超级权限。当然，回车过后要输入当前拥有者的密码修改所属组：普通用户--sudo chgrp 所属组名 文件名/目录名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Linux中，输入”ll”（小写L）或者”ls -l”可以显示文件的详细信息。<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/1169c2fb3ee24cf7bc749ce312dfc6a4.png" alt=""></p><p>若sudo失败，则进入超级用户权限，再执行chown root test.c<br>sudo失败的原因，需要将用户添加进sudoers文件:<br>报错信息为：dlm is not in the sudoers file. This incident will be reported.<br>解决方法可以看我的另一篇博客：<br><a href="http://blog.csdn.net/sinat_36118270/article/details/62899093">http://blog.csdn.net/sinat_36118270/article/details/62899093</a></p><p><strong>2.读、写、执行</strong><br>　　Linux中，一个文件或目录的权限有四种<br>　　分别是无、读、写、执行权限<br>　　分别用“-”“r”“w”“x”表示<br>　　在文件列表中，使用”ll”或者”ls -l”命令查看文件详细信息，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/d56f4f128b6949d3b4707ec5dab42696.png" alt=""></p><p>一个文件或者目录前面共有10位前置字符，第一位表示文件类型，说到这，插一句，在Linux中可以认为“一切皆文件”，且Linux下文件不以文件后缀名区分，而是以第一个字符区分。在细分一下，文件分为:</p><pre class="line-numbers language-none"><code class="language-none">普通文件：第一个字符为“ -  ”；目录：第一个字符为“d”；---directory链接文件：第一个字符为“l”，常见的有两类：软链接(相当于windows中的快捷方式)、硬链接；   ---link设备和设备文件　　块设备（硬盘）：第一个字符为“b”，最小单位为块（字节），支持随机访问。　　字符设备（键盘，显示器）：第一个字符为“c”，最小单位为字节，只允许按顺序读取。---char套接字：第一个字符为“s”；---sockets管道：第一个字符为“p”；---pine<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>图中所示，一个文件前有10个前缀字符，除第一个为文件类型外，剩下的9个都是文件的权限<br>　　三三一组，分别对应拥有者、所属组、other<br>　　即拥有者拥有三个权限，读写执行，所属组和other也相同<br>　　排列顺序为：读写执行<br>　　每个权限有则用对应的字母表示，无则使用“-”<br>　　例如：读写权限：“rw-”；写执行权限：“-wx”<br>　　且权限也可使用数字表示：每个位就相当于一个2进制数字，有此权限则为“1”，无则为“0”<br>　　例如：读写权限：“rw-”= 6；写执行权限：“-wx”= 3；<br>　　在命令输入时，更改拥有者的权限为“u (+/-) (r/w/x)”,括号是为了区分，“+”为增加权限，“-”为去除权限，还可对一个文件或者目录的不同权限修改“u+r-w+x”即为增加读、执行权限，去除写权限。<br>　　相关命令为：</p><pre class="line-numbers language-none"><code class="language-none">首先，给定一个文件，默认权限为"rw- rw- r--",即为"664"增加拥有者的执行权限：chmod u+x file(file为文件名)                  chmod 764 file增加other的写权限：chmod o+w file                chmod 666 file去除所属组的读权限：chmod o-r file                chmod 624 file增加拥有者的读权限，去除写。执行权限：chmod u+r-w-x file                               chmod 464 file<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么对于目录呢？对于一个目录来说，照上图来看，也有拥有者、 所素组、other，而每一个也有自己的读、写、执行权限，有什么用呢？<br>　　目录的读权限决定进入这个目录后，使用“ls”、“ll”以及这个家族的命令是否可以显示该目录的内容；<br>　　目录的写权限决定进入这个目录后，是否可以使用“mkdir”创建目录，是否可以使用“touch”创建文件…;<br>　　目录的执行权限决定是否可以进入这个目录。</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/0f4aa69a622d433392e9bbad7f6e347b.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/a0b3663e0d2b4875a0b233142dcf8ea4.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/7484fbcf90034a62801d298698bc0629.png" alt=""></p><p>那么，剩下的对于一个目录权限的多种操作就不用多少了吧。</p><p><strong>umask</strong><br>　　最后，还有个umask很重要，需要我们去理解记忆<br>　　umask是我们linux系统里面的默认权限的补集，一般在我们的系统中，umask=002。表示我们创建的文件的默认权限是664。<br>　　注意，我们创建的所有文件的默认权限为664，即“rw-rw-r–”。<br>　　不包含拥有者和所属组的执行权限以及other的写和执行权限。<br>　　所以我们要在更改umask后，计算文件权限时，基础上也不能加上拥有者和所属组的执行权限以及other的写和执行权限，除非更改的权限值给他们中的一个或多个赋上了相应的权限。<br>　　umask可以自己更改，直接敲出来umask “0xxx”就ok。此后，我们的权限就为“664-xxx”<br>　　<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/3de223ac270642e6a5781b23c68da8d1.png" alt=""></p><p>初始值为：“rw-rw-r–”即为“664”<br>　　我们设置的umask=032，即为“— -wx -w- ”,<br>　　因为二者是互补的关系，所以umask中出现的权限不能出现在新创建的文件中，又因为默认情况下新创建的文件没有拥有者和所属组的执行权限以及other的写和执行权限。<br>　　所以file_1的文件权限为：“rw- r– r–”。</p><h3 id="文件权限符含义"><a href="#文件权限符含义" class="headerlink" title="文件权限符含义"></a>文件权限符含义</h3><ol><li><p>文件权限符以 d 开头的代表是文件夹<br>drwxrwxrwx</p></li><li><p>文件权限符以 - 开头的代表是文件（包括硬链接文件，硬链接文件相当于原文件的备份，可以与原文件做到同步更新）也有可能是可执行程序<br>-rwxrwxrwx</p></li><li><p>文件权限符以 l 开头的代表是软链接文件，软链接文件相当于原文件的快捷方式</p></li><li>文件权限符以 c 开头的代表是字符设备文件，例：鼠标、键盘；</li><li>文件权限符以 b 开头的代表是块设备文件，例：硬盘；</li></ol><h2 id="gcc升级到最新版本"><a href="#gcc升级到最新版本" class="headerlink" title="gcc升级到最新版本"></a>gcc升级到最新版本</h2><h3 id="Centos7"><a href="#Centos7" class="headerlink" title="Centos7"></a>Centos7</h3><p>Centos 7默认gcc版本为4.8，有时需要更高版本的，这里以升级至8.3.1版本为例，分别执行下面三条命令即可，无需手动下载源码编译</p><p>1、安装centos-release-scl</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> yum <span class="token function">install</span> centos-release-scl<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2、安装devtoolset，注意，如果想安装7.<em>版本的，就改成devtoolset-7-gcc</em>，以此类推</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> yum <span class="token function">install</span> devtoolset-8-gcc*<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3、激活对应的devtoolset，所以你可以一次安装多个版本的devtoolset，需要的时候用下面这条命令切换到对应的版本</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">scl <span class="token builtin class-name">enable</span> devtoolset-8 <span class="token function">bash</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>大功告成，查看一下gcc版本</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>显示为 gcc version 8.3.1 20190311 (Red Hat 8.3.1-3) (GCC)</p><p>补充：这条激活命令只对本次会话有效，重启会话后还是会变回原来的4.8.5版本，要想随意切换可按如下操作。</p><p>首先，安装的devtoolset是在 /opt/rh 目录下的，如图</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/ffc7754914805bcf1ad41891e9405fa5.png" alt=""><br>每个版本的目录下面都有个 enable 文件，如果需要启用某个版本，只需要执行</p><pre class="line-numbers language-none"><code class="language-none">source ./enable<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>所以要想切换到某个版本，只需要执行</p><pre class="line-numbers language-none"><code class="language-none">source /opt/rh/devtoolset-8/enable<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以将对应版本的切换命令写个shell文件放在配了环境变量的目录下，需要时随时切换，或者开机自启</p><p>4、直接替换旧的gcc<br>旧的gcc是运行的 /usr/bin/gcc，所以将该目录下的gcc/g++替换为刚安装的新版本gcc软连接，免得每次enable</p><pre class="line-numbers language-none"><code class="language-none">mv /usr/bin/gcc /usr/bin/gcc-4.8.5ln -s /opt/rh/devtoolset-8/root/bin/gcc /usr/bin/gccmv /usr/bin/g++ /usr/bin/g++-4.8.5ln -s /opt/rh/devtoolset-8/root/bin/g++ /usr/bin/g++gcc --versiong++ --version<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="分区-挂载"><a href="#分区-挂载" class="headerlink" title="分区+挂载"></a>分区+挂载</h2><h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><p>详细信息：<a href="https://blog.csdn.net/qq_30604989/article/details/81163270">来源该博客</a><br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/edd06e4319f24f1092d6f7bba9955937.png" alt=""></p><ol><li><p>在linux下，一个硬盘要先分区，然后才能挂载到目录上。和windows相同。</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/a8ef1355fa2f4595a7b69da0b0bb50ec.png" alt=""></p></li></ol><p><strong>问题：如何确定文件或目录在那个磁盘分区？</strong></p><pre class="line-numbers language-none"><code class="language-none">df -h /homedf -h /home/test.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>通过上面的命令就可以看出文件或目录是在那个磁盘分区里面</p><p><img src="https://s2.loli.net/2022/05/19/8UEfapmwxb6zjSu.png" alt=""></p><h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/0189f5afb0f24dde85c540fc5b8c887f.png" alt=""></p><pre class="line-numbers language-none"><code class="language-none">fdisk /dev/sdb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这一步是对sdb这个磁盘分区。<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/bde5f9eba20b477bbeb551a9cb4bc246.png" alt=""><br>接下来是格式化：</p><pre class="line-numbers language-none"><code class="language-none">mkfs -t ext4 /dev/sdb1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>挂载：将分区和目录联系起来</p><pre class="line-numbers language-none"><code class="language-none">mount 设备名 目录名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">mount /dev/sdb1 /home/newdisk<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个方法重启会失效，设置永久挂载。</p><pre class="line-numbers language-none"><code class="language-none">vim /etc/fstab<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="解除挂载"><a href="#解除挂载" class="headerlink" title="解除挂载"></a>解除挂载</h3><pre class="line-numbers language-none"><code class="language-none">umount 设备名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/d9ca57a5c9bf44589498a26a8baea9e5.png" alt=""></p><h2 id="远程调用shell脚本找不到库"><a href="#远程调用shell脚本找不到库" class="headerlink" title="远程调用shell脚本找不到库"></a>远程调用shell脚本找不到库</h2><p><a href="http://t.zoukankan.com/GatsbyNewton-p-4776682.html">原文链接1</a><br><a href="https://feihu.me/blog/2014/env-problem-when-ssh-executing-command-on-remote/#userconsent#">原文链接2</a></p><p>背景：本地把服务编译完成，通过git bash传到服务器，然后ssh调用服务器上写好的脚本，显示找不到某个库（以安装）。以mobaxterm方式登录服务器，执行脚本没有问题。</p><p>原因：配置文件没有被加载</p><p>解决方法：</p><ol><li>在Remote机上的shell脚本的开头重新配置“需要用到”的环境变量（本文所遇到的是mpi的一个库）</li><li>在Remote shell的开头设置，用source使.basn_profile文件生效</li></ol><h2 id="shell脚本中export无效的原分析和解决方法"><a href="#shell脚本中export无效的原分析和解决方法" class="headerlink" title="shell脚本中export无效的原分析和解决方法"></a>shell脚本中export无效的原分析和解决方法</h2><p><a href="https://blog.csdn.net/fadai1993/article/details/109085231">原链接</a></p><h3 id="问题场景：shell脚本中的export怎么都无法起作用"><a href="#问题场景：shell脚本中的export怎么都无法起作用" class="headerlink" title="问题场景：shell脚本中的export怎么都无法起作用"></a>问题场景：shell脚本中的export怎么都无法起作用</h3><p>测试需要导入大量临时的环境变量，单个export又比较麻烦，因此创建shell脚本简化场景：<br></p><pre class="line-numbers language-none"><code class="language-none">#!bin/bash  export PATH=$PATH:/usr/lib/java/jre  export PATH=$PATH:/usr/lib/java/bin <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p></p><p>就这么个系统环境变量配置，通过./path.sh 或者 sh path.sh怎么执行都无法设置成功，为什么单独执行export一点问题都没有，但是写到shell脚本中执行，export却怎么都不起作用？</p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ol><li>shell是一个进程，每个进程拥有独立的存储空间，进程间数据不可见<br>一个shell中的系统环境变量（用export定义的变量）只会对当前shell或者他的子shell有效，该shell结束之后，变量生命周期结束（并不能返回到父shell中）</li><li>export定义的变量，对当前shell及子shell有效；不用export定义的变量，仅对本shell有效</li><li>执行脚本时，是创建了一个新的子shell进程运行，脚本执行完成后，该子shell进程自动退出<br>因此，子shell中定义的系统环境变量是无法作用于父shell的。</li></ol><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>上文可知，父shell可将自己的环境变量写入子shell，但子shell无法将自己空间中的数据写入父shell（至少export不行），如何达到我们的需求，那就不要创建子shell，仅导入shell文件内的内容<br></p><pre class="line-numbers language-none"><code class="language-none">. path.th<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p><p>或者<br></p><pre class="line-numbers language-none"><code class="language-none">source path.th<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p><h3 id="“-”、“source”、“sh”、“-”、“export”的区别"><a href="#“-”、“source”、“sh”、“-”、“export”的区别" class="headerlink" title="“.”、“source”、“sh”、“./”、“export”的区别"></a>“.”、“source”、“sh”、“./”、“export”的区别</h3><ol><li>source 同“.”， 用于使shell读入指定的shell文件，并依次执行文件中的所有语句（当前shell）</li><li>sh 创建一个子shell，继承父shell的环境变量，同时在子shell中执行脚本里面的语句</li><li>./ 当脚本文件具有可执行属性时，与sh无异，./filename是因为当前目录并未在PATH中</li><li>export 设置或显示环境变量，临时作用于当前shell</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> 持续集成 </tag>
            
            <tag> Linux </tag>
            
            <tag> gcc </tag>
            
            <tag> Linux权限用法 </tag>
            
            <tag> make&amp;cmake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell 命令</title>
      <link href="/posts/20005/"/>
      <url>/posts/20005/</url>
      
        <content type="html"><![CDATA[<h2 id="基本知识-命令"><a href="#基本知识-命令" class="headerlink" title="基本知识/命令"></a>基本知识/命令</h2><h3 id="变量赋值语句不能有空格"><a href="#变量赋值语句不能有空格" class="headerlink" title="变量赋值语句不能有空格"></a>变量赋值语句不能有空格</h3><p><strong>1、shell脚本变量名和等号及等号和值之间不能有空格，这可能和我们熟悉的所有编程语言都不一样，变量命名须遵循如下规则：</strong><br>•首个字符必须为字母（a-z，A-Z）。<br>•中间不能有空格，可以使用下划线（_）。<br>•不能使用标点符号。<br>•不能使用bash里的关键字（可用help命令查看保留关键字）。</p><p>赋值语句等号两边不能有空格，中间有空格时，shell是把变量当一个命令执行的，如：</p><p>PROV = anhui</p><p>执行时会提示：./tt.sh: line 14: PROV: command not found</p><p>正确的写法是：</p><p>PROV=anhui</p><p>如果所赋的值包含空格，可以用引号括起来（没有空格时也可以用引号，效果和不用一样），例如：</p><p>PROV=”anhui province”</p><p><strong>2、变量的引用是用$符号加上变量名，例如：</strong></p><p>echo  ../${PROV}/${DATDIR}</p><p>变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，建议给所有变量加上花括号，这是个好习惯，既便于阅读，又不易出错。 </p><p><strong>最后想说明一下，shell脚本对空格有严格的规定，赋值语句等号两边不能有空格，而字符串比较，等号两边必须有空格，如：</strong></p><p>if [ “${sdpt}” = “sdpt_js” ]; then</p><h3 id="将命令的输出结果赋值给变量"><a href="#将命令的输出结果赋值给变量" class="headerlink" title="将命令的输出结果赋值给变量"></a>将命令的输出结果赋值给变量</h3><p>Shell 中有两种方式可以完成命令替换，一种是反引号<code> </code>，一种是$()，使用方法如下：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">variable<span class="token operator">=</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">commands</span><span class="token template-punctuation string">`</span></span>variable<span class="token operator">=</span><span class="token function">$</span><span class="token punctuation">(</span>commands<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>但有种情况比较特殊</strong></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">file_path<span class="token operator">=</span><span class="token string">"/home/yskj/phopt/work/2/100/209/Ma0.8395H0α3.06"</span>version_num<span class="token operator">=</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">echo </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>file_path<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> | cut -d / -f 8</span><span class="token template-punctuation string">`</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>version_num 那一行是一个字符串的分割，最终得到209，我想把这个值作为变量。<br>如果不加echo是会报错，因为单独运行，会去执行<code>${file_path}这条命令，因为后面是管道</code>，而加上echo，就是输出，是一个正常的命令。<br>最后相当于把输出的结果赋值给了version_num这个变量</p><h3 id="shell脚本中登录mysql-执行sql"><a href="#shell脚本中登录mysql-执行sql" class="headerlink" title="shell脚本中登录mysql,执行sql"></a>shell脚本中登录mysql,执行sql</h3><p><strong>方式一：mysql -u root -pmysql &lt;&lt;EOF sql语句 EOF</strong><br>注：密码与-p之间不能有空格，否则不能识别密码，EOF中间的sql语句，与mysql正常语句无异</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span> <span class="token comment">#!/bin/bash</span><span class="token number">2</span> <span class="token builtin class-name">echo</span> <span class="token string">"链接mysql"</span><span class="token number">3</span> mysql -u root -pmysql <span class="token operator">&lt;&lt;</span>EOF<span class="token number">4</span> use shelltest<span class="token punctuation">;</span><span class="token number">5</span> <span class="token keyword">select</span> * from student<span class="token punctuation">;</span><span class="token number">6</span> EOF<span class="token number">7</span> <span class="token builtin class-name">echo</span> <span class="token string">"连接成功"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python@ubuntu:~/shellscrip$ ./mys_connec.sh 链接mysqlmysql: <span class="token punctuation">[</span>Warning<span class="token punctuation">]</span> Using a password on the <span class="token builtin class-name">command</span> line interface can be insecure.<span class="token function">id</span>name<span class="token number">1</span>tom连接成功<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方式二：mysql -u root -pmysql -e “${sql}”</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span> <span class="token comment">#!/bin/bash</span><span class="token number">2</span> <span class="token builtin class-name">echo</span> <span class="token string">"链接mysql"</span><span class="token number">3</span> <span class="token assign-left variable">sql</span><span class="token operator">=</span><span class="token string">"use shelltest;4 select * from student;"</span><span class="token number">5</span> mysql -u root -pmysql -e <span class="token string">"<span class="token variable">${sql}</span>"</span><span class="token number">6</span> <span class="token builtin class-name">echo</span> <span class="token string">"连接成功"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python@ubuntu:~/shellscrip$ ./mys_connec.sh 链接mysqlmysql: <span class="token punctuation">[</span>Warning<span class="token punctuation">]</span> Using a password on the <span class="token builtin class-name">command</span> line interface can be insecure.+------+------+<span class="token operator">|</span> <span class="token function">id</span>   <span class="token operator">|</span> name <span class="token operator">|</span>+------+------+<span class="token operator">|</span>    <span class="token number">1</span> <span class="token operator">|</span> tom  <span class="token operator">|</span>+------+------+连接成功<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="读取文件每一行并输出"><a href="#读取文件每一行并输出" class="headerlink" title="读取文件每一行并输出"></a>读取文件每一行并输出</h3><p>方案一：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">##!/bin/bash</span><span class="token keyword">while</span> <span class="token builtin class-name">read</span> line<span class="token keyword">do</span>    <span class="token builtin class-name">echo</span> <span class="token variable">$line</span><span class="token keyword">done</span> <span class="token operator">&lt;</span> test.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方案二：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">##!/bin/bash</span><span class="token function">cat</span> test.txt <span class="token operator">|</span> <span class="token keyword">while</span> <span class="token builtin class-name">read</span> line<span class="token keyword">do</span>    <span class="token builtin class-name">echo</span> <span class="token variable">$line</span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方案三：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">for</span> <span class="token for-or-select variable">line</span> <span class="token keyword">in</span> <span class="token variable"><span class="token variable">`</span><span class="token function">cat</span>  test.txt<span class="token variable">`</span></span><span class="token keyword">do</span>    <span class="token builtin class-name">echo</span> <span class="token variable">$line</span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>for 逐行读和 while 逐行读是有区别的，如:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> test.txtGoogleRunoobTaobao$ <span class="token function">cat</span> test.txt <span class="token operator">|</span> <span class="token keyword">while</span> <span class="token builtin class-name">read</span> line<span class="token punctuation">;</span> <span class="token keyword">do</span> <span class="token builtin class-name">echo</span> <span class="token variable">$line</span><span class="token punctuation">;</span> <span class="token keyword">done</span>GoogleRunoobTaobao$ <span class="token keyword">for</span> <span class="token for-or-select variable">line</span> <span class="token keyword">in</span> <span class="token variable"><span class="token variable">$(</span><span class="token operator">&lt;</span>test.txt<span class="token variable">)</span></span><span class="token punctuation">;</span> <span class="token keyword">do</span> <span class="token builtin class-name">echo</span> <span class="token variable">$line</span><span class="token punctuation">;</span> <span class="token keyword">done</span>GoogleRunoobTaobao<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="if-与-for-循环"><a href="#if-与-for-循环" class="headerlink" title="if 与 for 循环"></a>if 与 for 循环</h3><pre class="line-numbers language-none"><code class="language-none">getfilesordir(){    for file in `ls $1`    do        if test -f $file        then            echo "file:  $file"        elif test -d $file        then            echo "path: $file"        fi    done} path="./"getfilesordir $path<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="遍历文件夹"><a href="#遍历文件夹" class="headerlink" title="遍历文件夹"></a>遍历文件夹</h3><p><strong>遍历文件夹下所有文件，不包含子目录：</strong><br></p><pre class="line-numbers language-none"><code class="language-none">getfilesordir(){    for file in `ls $1`    do        if test -f $file        then            echo "file:  $file"        elif test -d $file        then            echo "path: $file"        fi    done} path="./"getfilesordir $path<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p><strong>遍历文件夹下所有文件不包含子目录</strong><br></p><pre class="line-numbers language-none"><code class="language-none">dir="/home/fut/Desktop/"ls $dir | while read linedo     file=${dir}${line}    echo file  fidone<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p><strong>遍历目录包含子目录</strong><br></p><pre class="line-numbers language-none"><code class="language-none">##!/bin/bashfunction getdir(){    for element in `ls $1`    do          dir_or_file=$1"/"$element        if [ -d $dir_or_file ]        then             getdir $dir_or_file        else            echo $dir_or_file        fi      done}root_dir="/home/test"getdir $root_dir<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>以下命令均不包含”.”，”..”目录，以及”.”开头的隐藏文件，如需包含，ll 需要加上 -a参数#当前目录下文件个数，不包含子目录ll |grep “^-“|wc -l#当前目录下目录个数，不包含子目录ll |grep “^d”|wc -l#当前目录下文件个数，包含子目录ll -R|grep “^-“|wc -l#当前目录下目录个数，包含子目录ll -R|grep “^d”|wc -l<p></p><h3 id="字符串与整数比较"><a href="#字符串与整数比较" class="headerlink" title="字符串与整数比较"></a>字符串与整数比较</h3><pre class="line-numbers language-none"><code class="language-none">##!/bin/sh##字符串比较(比较大小以及是否相等)a=hellob=helloc=howif [[ "$a" == "$b" ]];then  #注意对于字符串的相等比较，使用=或==都可以，二者是等价的echo 'same'elseecho not samefiif [[ "$a"!="$c" ]];thenecho "a!=c"fiif [[ "$a" &lt; "$c" ]];thenecho "a&lt;c"fi##整数比较a=1b=2if(($a&lt;=$b));thenecho "a&lt;=b"fiif((a&lt;=b));thenecho "a&lt;=b"fi## 整数运算d=$(($a+$b))echo $dc=$((a+b))echo $c## 整数运算c=$((a+b))echo $c##浮点数运算a=1.223b=2.3c=$(echo $a+$b|bc)echo $c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="将shell命令的执行结果放入数组"><a href="#将shell命令的执行结果放入数组" class="headerlink" title="将shell命令的执行结果放入数组"></a>将shell命令的执行结果放入数组</h3><pre class="line-numbers language-none"><code class="language-none">arr=( `git branch | xargs` )echo ${arr[@]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="自动填充密码"><a href="#自动填充密码" class="headerlink" title="自动填充密码"></a>自动填充密码</h3><p>有时候执行一些命令会要求输入密码，但是比较麻烦，想把密码放在命令中。</p><p><strong>法一：</strong><br></p><pre class="line-numbers language-none"><code class="language-none">echo "123" | sudo -S sntp -sS 182.92.12.11<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br><strong>法二：</strong><br><pre class="line-numbers language-none"><code class="language-none">sudo -S sntp -sS 182.92.12.11 &lt;&lt; EOF 123EOF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p></p><p>注意点：</p><ol><li>sudo -S不能少</li><li>使用EOF要小心，最后一个EOF要贴紧，否则会报错</li></ol><h3 id="ssh密钥登录并执行脚本"><a href="#ssh密钥登录并执行脚本" class="headerlink" title="ssh密钥登录并执行脚本"></a>ssh密钥登录并执行脚本</h3><pre class="line-numbers language-none"><code class="language-none">ssh -t username@ip -i C:/Users/76585/.ssh/phcloudYSKJ "/home/yskj/lgf/cfdplatform/change_cfdplatform.sh"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>usernam和ip要换成实际的</li><li>-i后面的是本地的密钥文件全路径</li></ol><h3 id="scp加速传输与下载"><a href="#scp加速传输与下载" class="headerlink" title="scp加速传输与下载"></a>scp加速传输与下载</h3><p>本地传输至服务器：<br></p><pre class="line-numbers language-none"><code class="language-none">scp -i "这是本地密钥全路径" -c aes192-cbc -o "Compression yes" "本地要上传的东西的全路径" username@ip:"上传到服务器那个位置"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p><ol><li>上述目录引号里面的内容换位实际的后，不要引号。关键在于 -c aes192-cbc -o “Compression yes” 。-c后面的是压缩算法，自己也是试了几个选了个最快的。可以google搜索下scp下载慢</li></ol><p>服务下载至本地：<br>上面命令把username@ip:xxx与本地路径交换即可。<br></p><pre class="line-numbers language-none"><code class="language-none">scp -i C:/Users/76585/.ssh/phcloudYSKJ -c aes192-cbc username@ip:/home/yskj/phserver/cfdplatform.log C:/Users/76585/Desktop<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p><h3 id="判断上一条命令是否执行成功"><a href="#判断上一条命令是否执行成功" class="headerlink" title="判断上一条命令是否执行成功"></a>判断上一条命令是否执行成功</h3><pre class="line-numbers language-none"><code class="language-none">##!/bin/bashCGO_ENABLED=0 GOOS=GOARCH=amd64 go buicfdplatform main.go if [[ $? -eq $'\n' ]]; thenecho "编译成功"elseecho "编译失败"    exit 1fi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="实际命令分析"><a href="#实际命令分析" class="headerlink" title="实际命令分析"></a>实际命令分析</h2><h3 id="shell脚本登录mysql并执行语句"><a href="#shell脚本登录mysql并执行语句" class="headerlink" title="shell脚本登录mysql并执行语句"></a>shell脚本登录mysql并执行语句</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">##!/bin/bash</span><span class="token comment">## get 7 days ago according to input date. e.g. if input date is 20180410,it will delete those records on or before 20180403</span><span class="token assign-left variable">wanted_date</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">date</span> -d <span class="token string">"<span class="token variable">$1</span> 7 days ago"</span> +%Y%m%d<span class="token variable">`</span></span><span class="token builtin class-name">echo</span> <span class="token string">"0==}=========&gt; CAUTION! Those records on or before <span class="token variable">$wanted_date</span> will be removed!"</span><span class="token builtin class-name">echo</span> <span class="token string">"0==}=========&gt; Are you sure to continue? yes/no"</span><span class="token builtin class-name">read</span> option<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$option</span>"</span> <span class="token operator">==</span> <span class="token string">"yes"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>  <span class="token builtin class-name">echo</span> You made a good choice.  <span class="token builtin class-name">echo</span> ----------<span class="token keyword">elif</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$option</span>"</span> <span class="token operator">==</span> <span class="token string">"no"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">then</span>  <span class="token builtin class-name">echo</span> Goodbye~  <span class="token builtin class-name">exit</span> <span class="token number">0</span><span class="token keyword">else</span>  <span class="token builtin class-name">echo</span> PLASE INPUT <span class="token function">yes</span> OR no THEN TRY AGAIN<span class="token operator">!</span>  <span class="token builtin class-name">exit</span> <span class="token number">0</span><span class="token keyword">fi</span><span class="token comment">## to call SQL statement at MySQL prompt</span>mysql -h <span class="token number">172.33</span>.101.123 -P <span class="token number">3306</span> -u tony -pYourPassword -D YourDbName <span class="token operator">&lt;&lt;</span><span class="token string">EOFselect current_date();use tony_db;desc confirmed_order_data;select count(*) from confirmed_order_data where paid_date&lt;="<span class="token variable">$wanted_date</span>";delete from confirmed_order_data WHERE paid_date&lt;="<span class="token variable">$wanted_date</span>";select count(*) from confirmed_order_data where paid_date&lt;="<span class="token variable">$wanted_date</span>";EOF</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="提取git中某个文件的所有版本并按顺序命名"><a href="#提取git中某个文件的所有版本并按顺序命名" class="headerlink" title="提取git中某个文件的所有版本并按顺序命名"></a>提取git中某个文件的所有版本并按顺序命名</h3><pre class="line-numbers language-none"><code class="language-none">git log --follow --pretty=format:%H 文件名 | xargs -I{} sh -c 'git show {}:文件名 &gt; 文件名.{}'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>简略解释版本：</p><pre class="line-numbers language-none"><code class="language-none">git log --follow --pretty=format:%H //按照一定的格式输出 ，--pretty=format:%H 输出某个文件的历史提交哈希值。//如果不加--pretty=format:%H，会输出哈希值，作者，时间等信息。//--pretty=format后面还可以跟其它值，//'%H': commit hash//'%h':abbreviated commit hash//'%T': tree hash| xargs -I{} //xargs 一般是和管道(I)一起使用 //-I{} //xargs 的一个选项 -I，使用 -I 指定一个替换字符串 {}，这个字符串在 xargs 扩展时会被替换掉；对应这里，前面输出的是哈希值，这里面"{}"代表的就是哈希值，后面的"{}"也是前面的哈希值。sh -c //暂时不清，下面有解释git show {}:文件名 &gt; 文件名.{}  //git show '哈希值':文件名：输出这次提交，这个文件夹的内容， "&gt;" 将内容输出到 后面的文件中，并覆盖后面文件内容。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><ol><li>| xargs -I{} sh c</li></ol></blockquote><pre class="line-numbers language-none"><code class="language-none">|  //表示管道，上一条命令的输出，作为下一条命令参数，如 echo ‘yes’ | wc -lxargs -I //<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">sh -cLinux使用 echo 并配合命令重定向是实现向文件中写入信息的快捷方式。【新建空文件】方式一 : $ touch test.sh方式二 : $ echo “” &gt; test.sh【写内容到文件】如 test.sh 文件中内容：$ echo “信息” &gt; test.sh但有时会出现权限不够的问题，这时就可以使用 sh -c利用 “sh -c” 命令，它可以让 bash 将一个字串作为完整的命令来执行，这样就可以将 sudo 的影响范围扩展到整条命令。具体用法如下：$ sudo sh -c ‘echo “第二条内容” &gt;&gt; test.sh’<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="给每一个远程分支在本地建立单独的文件夹，文件名就是分支名"><a href="#给每一个远程分支在本地建立单独的文件夹，文件名就是分支名" class="headerlink" title="给每一个远程分支在本地建立单独的文件夹，文件名就是分支名"></a>给每一个远程分支在本地建立单独的文件夹，文件名就是分支名</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> branch -r <span class="token operator">|</span> <span class="token function">xargs</span> -d/ -n1 <span class="token operator">|</span> <span class="token function">grep</span> -v <span class="token string">'origin'</span> <span class="token operator">|</span> <span class="token function">xargs</span> -I<span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token function">sh</span> -c <span class="token string">'mkdir "C:\Users\76585\Desktop\try\{}" '</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>分析：</p><pre class="line-numbers language-none"><code class="language-none">1.  git branch -r //显示远程分支。注意，本地分支可能只有一个，master这种。但远程分支可能有很多个。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">2. | xargs -d/ -n1 // -d -n都是xargs的参数，详细可以去查文档。-d/  以"/"为分隔符；-n1，每行输出一个。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">3. grep -v 'origin' // 遇到origin就不显示（删除这个字符串）。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>冷知识：在Windows下运行sh文件，在当前路径下，<code>./</code>;<br>如果是非当前路径，<code>c/xx/xxx/1.sh  //绝对路径到sh文件就好，前面不用加./</code> </p><h3 id="按提交信息来过滤提交-—grep"><a href="#按提交信息来过滤提交-—grep" class="headerlink" title="按提交信息来过滤提交 —grep"></a>按提交信息来过滤提交 —grep</h3><p>按提交信息来过滤提交，你可以使用—grep标记。它和上面的—author标记差不多，只不过它搜索的是提交信息而不是作者。</p><p>背景：提取主干某文件的提交，因为主干都是其它author合并上去的，所有没有主干这个author，无法使用—author这个参数来过滤。但是每次合并到主干的commit 都有一句 “into avtivebranch”，根据这一句筛选即可。</p><p>例子：<br></p><pre class="line-numbers language-none"><code class="language-none">git log --grep="JRA-224:" //也可以传入-i参数来忽略大小写匹配<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p></p><h3 id="获取for循环中按条件筛选出的变量值"><a href="#获取for循环中按条件筛选出的变量值" class="headerlink" title="获取for循环中按条件筛选出的变量值"></a>获取for循环中按条件筛选出的变量值</h3><p><strong>将这个功能写成一个函数，函数内部用echo输出这个值，外部用一个变量接受这个值。</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">##!/bin/bash</span><span class="token keyword">function</span> <span class="token function-name function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">cat</span> cfd.log <span class="token operator">|</span> <span class="token keyword">while</span> <span class="token builtin class-name">read</span> line<span class="token keyword">do</span>    <span class="token assign-left variable">OLD_IFS</span><span class="token operator">=</span><span class="token string">"<span class="token environment constant">$IFS</span>"</span>    <span class="token assign-left variable"><span class="token environment constant">IFS</span></span><span class="token operator">=</span><span class="token string">" "</span>    <span class="token assign-left variable">array</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token variable">$line</span><span class="token punctuation">)</span>    <span class="token assign-left variable"><span class="token environment constant">IFS</span></span><span class="token operator">=</span><span class="token string">"<span class="token variable">$OLD_IFS</span>"</span>    <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">${array<span class="token punctuation">[</span>0<span class="token punctuation">]</span>}</span>"</span> <span class="token operator">=</span> <span class="token string">"cfdversion"</span> <span class="token punctuation">]</span> <span class="token punctuation">;</span> <span class="token keyword">then</span>       <span class="token builtin class-name">echo</span> <span class="token variable">${array<span class="token punctuation">[</span>2<span class="token punctuation">]</span>}</span>       <span class="token builtin class-name">break</span>    <span class="token keyword">fi</span><span class="token keyword">done</span><span class="token punctuation">}</span><span class="token assign-left variable">res</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span>func<span class="token variable">)</span></span><span class="token builtin class-name">echo</span> <span class="token variable">$res</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="whlie循环菜单"><a href="#whlie循环菜单" class="headerlink" title="whlie循环菜单"></a>whlie循环菜单</h3><pre class="line-numbers language-none"><code class="language-none">#!/bin/bashwhile :do    echo "--------------------cfdplatform------------------"    echo '输入 1 到 4 之间的数字:'    echo '1: 编译'    echo '2: 编译 + 传输'    echo '3: 传输'    echo '4: 下载日志到本地'    echo '5: 执行远程脚本'    echo '6: 退出'    echo '你输入的数字为:'    read aNum    case $aNum in        1)              echo '你选择了 "编译"'            ;;        2)              echo '你选择了 "编译 + 传输"'            ;;        3)              echo '你选择了 "传输"'            ;;        4)              echo '你选择了 "下载日志到本地"'            ;;        5)              echo '你选择了 "执行远程脚本"'            ;;        6)              echo '你选择了 "退出"'            exit 1            ;;        *)              echo '你没有输入 1 到 5 之间的数字，请重新输入'            ;;    esac    echo -e "\n"done<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><h3 id="读取文件夹中的文件名，并存入列表"><a href="#读取文件夹中的文件名，并存入列表" class="headerlink" title="读取文件夹中的文件名，并存入列表"></a>读取文件夹中的文件名，并存入列表</h3><pre class="line-numbers language-none"><code class="language-none">##!/bin/bash##读取文件夹中的文件名，并存入列表i=0for dir in $(ls 'C:\Users\76585\Desktop\cfdname1')do        # echo $dir &gt;&gt; arr[$i]    arr[$i]=$dir    i=$(($i+1))doneecho "${arr[@]}"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意的点：</strong></p><pre class="line-numbers language-none"><code class="language-none">1.for 循环循环体只能卸载do done之间，之前把 i 写在了for 和 do之间报错2.变量初始化不要放在函数体，不然每次循环都清 0 了。3.变量自增加方法：a=\$(($a+1))a=$[$a+1]a=\`expr $a + 1`let a++let a+=1((a++))4.打印数组的方法：${my_array[*]} 或者 ${my_array[@]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h2><h3 id="获取变量字符串长度"><a href="#获取变量字符串长度" class="headerlink" title="获取变量字符串长度"></a>获取变量字符串长度</h3><p>想要知道 “www.baidu.com” 的变量net的长度十分简单。</p><pre class="line-numbers language-none"><code class="language-none">[Neptuneyt]$ net="www.baidu.com"[Neptuneyt]$ echo ${#net}13<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当然，在Shell中获取字符串变量的长度的方法有许多种，但是下图法一作为一种系统内建的方法是最快的。</p><pre class="line-numbers language-none"><code class="language-none">[Neptuneyt]$ echo ${#net}13[Neptuneyt]$ echo ${net}|wc -L13[Neptuneyt]$ expr length ${net}13[Neptuneyt]$ echo ${net}|awk '{print length($0)}'13<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="变量截取"><a href="#变量截取" class="headerlink" title="变量截取"></a>变量截取</h3><p><strong>1.指定位置截取字符串</strong></p><pre class="line-numbers language-none"><code class="language-none">[Neptuneyt]$ net="www.baidu.com"[Neptuneyt]$ # 从第4个字符截取到baidu[Neptuneyt]$ echo ${net:4:5} #从第4个字符.开始截取5个字符baidu[Neptuneyt]$ # 截取baidu.com[Neptuneyt]$ echo ${net:4}   #起始位置后不接截取字符长度则默认截取之后所有的baidu.com[Neptuneyt]$ # 用倒数截取com[Neptuneyt]$ echo ${net:0-3} #从倒数第三个字符截取到末尾com[Neptuneyt]$ echo ${net: -3} #另外的写法，一定要注意冒号和-3之间有空格com[Neptuneyt]$ echo ${net:-3}  #不加空格，截取失败www.baidu.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2.匹配字符串截取</strong></p><pre class="line-numbers language-none"><code class="language-none">[Neptuneyt]$ echo $netwww.baidu.com## 删除匹配字符串的左边，留下剩余部分[Neptuneyt]$ echo ${net#*.} #这里用*.表示匹配到www.，用一个#表示删除匹配到的字符串，留下剩余的部分baidu.com## 用2个#号表示尽可能多的删除匹配到的字符串[Neptuneyt]$ echo ${net##*.}com## 同理也可以匹配字符串的右边，留下剩余部分[Neptuneyt]$ echo ${net%.*} #用.*匹配到.com,用%删除www.baidu## 用2个%号表示尽可能多的删除匹配到的字符串[Neptuneyt]$ echo ${net%%.*}    #因为2个%，这里.*表示匹配到最长的.baidu.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总的来说:<br><code>#*chr</code>表示删除从左到右第一个遇到的字符chr及其左侧的字符<br><code>##*chr</code>表示删除从左到右最后一个遇到的字符chr及其左侧的字符（贪婪模式）<br><code>%chr*</code>表示删除从右向左第一个遇到的字符chr及其右侧的字符<br><code>%%chr*</code>表示删除从右到左最后一个遇到的字符chr及其右侧的字符（贪婪模式）<br>在键盘上，#在$符的左边，%号在$符的右边，为了便于记忆，大家因此可以记住#删除左边字符，%删除右边字符</p><p><strong>3.窃取字符串</strong></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token number">1</span><span class="token punctuation">.</span>cut<span class="token operator">-</span>b ：以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 <span class="token operator">-</span>n 标志。<span class="token operator">-</span>c ：以字符为单位进行分割。<span class="token operator">-</span>d：自定义分隔符，默认为制表符。<span class="token operator">-</span>f：与<span class="token operator">-</span>d一起使用，指定显示哪个区域。<span class="token operator">-</span>n：取消分割多字节字符。仅和<span class="token operator">-</span>b标志一起使用。如果字符的最后一个字节落在由<span class="token operator">-</span>b标志的List参数指示的范围之内，该字符将被写出；否则，该字符将被排除。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>-d</strong></p><p> cut命令用于列提取，默认分隔符是tab键。</p><p>选项：-d指定分隔符，-f指定提取第几列</p><p>eg1： 以%作为分隔符 输出第一个%前的区域1的东西，输出区域2的东西     </p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">root@<span class="token constant">ROUTER</span><span class="token operator">:</span><span class="token operator">~</span># echo <span class="token string">"CPU:  busy 14%  (system=10% user=3% nice=0% idle=85%)"</span> <span class="token operator">|</span> cut <span class="token operator">-</span>d \<span class="token operator">%</span> <span class="token operator">-</span>f <span class="token number">1</span><span class="token constant">CPU</span><span class="token operator">:</span>  busy <span class="token number">14</span>root@<span class="token constant">ROUTER</span><span class="token operator">:</span><span class="token operator">~</span># echo <span class="token string">"CPU:  busy 14%  (system=10% user=3% nice=0% idle=85%)"</span> <span class="token operator">|</span> cut <span class="token operator">-</span>d \<span class="token operator">%</span> <span class="token operator">-</span>f <span class="token number">2</span>  <span class="token punctuation">(</span>system<span class="token operator">=</span><span class="token number">10</span>root@<span class="token constant">ROUTER</span><span class="token operator">:</span><span class="token operator">~</span># echo <span class="token string">"CPU:  busy 14%  (system=10% user=3% nice=0% idle=85%)"</span> <span class="token operator">|</span> cut <span class="token operator">-</span>b <span class="token number">11</span><span class="token operator">-</span><span class="token number">14</span> <span class="token operator">|</span> cut <span class="token operator">-</span>d \<span class="token operator">%</span> <span class="token operator">-</span>f <span class="token number">1</span> <span class="token number">14</span>root@<span class="token constant">ROUTER</span><span class="token operator">:</span><span class="token operator">~</span># echo <span class="token string">"CPU:  busy 14%  (system=10% user=3% nice=0% idle=85%)"</span> <span class="token operator">|</span> cut <span class="token operator">-</span>b <span class="token number">11</span><span class="token operator">-</span><span class="token number">14</span>  <span class="token number">14</span><span class="token operator">%</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>-b</strong><br>.eg1：然后调用cut，即剪切字符串中的第2和第5个字节。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">echo<span class="token string">"123abc"</span><span class="token operator">|</span>cut <span class="token operator">-</span>b <span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>先输出123abc</p><p>输出为2b</p><p><strong>-c</strong></p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20230522151027.png" alt=""></p><h3 id="变量的字符串替换"><a href="#变量的字符串替换" class="headerlink" title="变量的字符串替换"></a>变量的字符串替换</h3><p>想要将net的 baidu替换成google怎么写呢？只需<code>${net/baidu/google}</code>即可，需要注意的是原变量并未修改</p><pre class="line-numbers language-none"><code class="language-none">[Neptuneyt]$ echo ${net/baidu/google} #/匹配字符/替换字符www.google.com[Neptuneyt]$ echo $net  #原变量并未修改www.baidu.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果是替换所有匹配到的字符，应该通过<code>${variable//pattern/sub}</code><br>例如将net的.替换为-或/：</p><pre class="line-numbers language-none"><code class="language-none">[Neptuneyt]$ echo ${net//./-}www-baidu-com[Neptuneyt]$ echo ${net//.//}www/baidu/com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>除此之外，还有两种专门针对字符串开头和结尾的替换方式<br>只替换开头匹配的字符串<code>${variable/#pattern/sub}</code><br>只替换结尾匹配的字符串<code>${variable/%pattern/sub}</code><br>例如对于<code>add=www.xiaomi.com.www</code>的开头或者结尾的<code>www</code>替换为<code>-</code>：</p><pre class="line-numbers language-none"><code class="language-none">[Neptuneyt]$ add=www.xiaomi.com.www[Neptuneyt]$ echo ${add/#www/-}-.xiaomi.com.www[Neptuneyt]$ echo ${add/%www/-}www.xiaomi.com.-<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除字符串"><a href="#删除字符串" class="headerlink" title="删除字符串"></a>删除字符串</h3><p>其实学会了替换字符串删除字符串就更简单了，只需将替换部分写成空即可，即<code>${variable/pattern/null}</code>，例如将net的第一个.删除，只需</p><pre class="line-numbers language-none"><code class="language-none">[Neptuneyt]$ echo ${net/./}wwwbaidu.com[Neptuneyt]$ echo ${net/.}  #最后一个/可以不用写wwwbaidu.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>若要删除所有匹配到的只需即<code>${variable//pattern}</code>，例如将<code>net</code>的.都删除，只需</p><pre class="line-numbers language-none"><code class="language-none">[Neptuneyt]$ echo ${net//.}wwwbaiducom<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="变量为空时赋默认值"><a href="#变量为空时赋默认值" class="headerlink" title="变量为空时赋默认值"></a>变量为空时赋默认值</h3><p>当我们在写脚本时往往需要给脚本传递一些参数，在Shell中传递参数十分简单，只需利用特殊的位置参数变量诸如<code>$1,$2,$3...${10}...</code>即可，例如，以下脚本传递2个参数：</p><pre class="line-numbers language-none"><code class="language-none">## PassArgument.sh##!/bin/env bash## pass 2 argumentsarg1=$1arg2=$2echo $arg1 $arg2[Neptuneyt]$ bash PassArgument.sh Hello word #参数以空格隔开Hello word<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有时候，我们想省掉最后一个参数，让它使用默认值，这个时候只需通过<code>${variable:='default value'}</code>即可，即当变量有值的时候则使用原值，若没有值则使用括号中默认定义好的值。例如，如下脚本表示当第二个参数为空时默认使用定义好的值“word”,否则是用户自己传递的参数：</p><pre class="line-numbers language-none"><code class="language-none">## PassArgument.sh##!/bin/env basharg1=$1arg2=$2echo $arg1 ${arg2:='word'}  #第二个参数设置默认值[Neptuneyt]$ bash PassArgument.sh Hello #第二个参数为空时使用默认值Hello word[Neptuneyt]$ bash PassArgument.sh Hello Shell   #第二个参数不为空时使用参数传递的值Hello Shell<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了<code>${variable:='default value'}</code>外，还有<code>${variable:-'default value'}</code>,<code>${variable:+'default value'}</code>和<code>${variable:？'default value'}</code>，它们有什么区别呢？<br>对于<code>${variable:='default value'}</code>，表示变量为空时把默认值赋值给该变量，例如：</p><pre class="line-numbers language-none"><code class="language-none">[Neptuneyt]$ net=[Neptuneyt]$ echo ${net:='www.baidu.com'}www.baidu.com[Neptuneyt]$ echo $netwww.baidu.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于<code>${variable:-'default value'}</code>,表示变量为空时返回默认值<strong>但是并不把默认值赋值给该变量</strong>， 例如：</p><pre class="line-numbers language-none"><code class="language-none">[Neptuneyt]$ net=[Neptuneyt]$ echo ${net:-'www.baidu.com'}www.baidu.com[Neptuneyt]$ echo $net  #此时，变量依旧为空<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>对于<code>${variable:+'default value'}</code>,则表示变量不为空时，返回默认值，并且也不重新赋值，例如：</p><pre class="line-numbers language-none"><code class="language-none">[Neptuneyt]$ net=www.baidu.com[Neptuneyt]$ echo ${net:+'www.google.com'}www.google.com[Neptuneyt]$ echo $net  #不改变变量原值www.baidu.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后，对于<code>${variable:？'default value'}</code>,则表示当变量为空时，使用bash风格的报错，例如：</p><pre class="line-numbers language-none"><code class="language-none">[Neptuneyt]$ net=[Neptuneyt]$ echo ${net:?'error:null value'}-bash: net: error:null value<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p>在 PHP 中，使用.即可连接两个字符串；<br>在 JavaScript 中，使用+即可将两个字符串合并为一个。<br>在 Shell 中你不需要使用任何运算符，将两个字符串并排放在一起就能实现拼接，非常简单粗暴。请看下面的例子：</p><pre class="line-numbers language-none"><code class="language-none">##!/bin/bashname="Shell"url="http://c.biancheng.net/shell/"str1=$name$url  #中间不能有空格str2="$name $url"  #如果被双引号包围，那么中间可以有空格str3=$name": "$url  #中间可以出现别的字符串str4="$name: $url"  #这样写也可以str5="${name}Script: ${url}index.html"  #这个时候需要给变量名加上大括号echo $str1echo $str2echo $str3echo $str4echo $str5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">运行结果：Shellhttp://c.biancheng.net/shell/Shell http://c.biancheng.net/shell/Shell: http://c.biancheng.net/shell/Shell: http://c.biancheng.net/shell/ShellScript: http://c.biancheng.net/shell/index.html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于第 7 行代码，$name 和 $url 之间之所以不能出现空格，是因为当字符串不被任何一种引号包围时，遇到空格就认为字符串结束了，空格后边的内容会作为其他变量或者命令解析，这一点在《Shell字符串》中已经提到。</p><p>对于第 10 行代码，加{ }是为了帮助解释器识别变量的边界，这一点在《Shell变量》中已经提到。</p><h3 id="单引号内引入变量"><a href="#单引号内引入变量" class="headerlink" title="单引号内引入变量"></a>单引号内引入变量</h3><p><strong>方法：单引号内嵌套单引号即可使用变量</strong></p><pre class="line-numbers language-none"><code class="language-none">##!/bin/bashi=10echo $iecho '$i'echo '$i is : '$i''执行结果## ./test.sh 10$i$i is : 10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="shell中判断两个字符串相等"><a href="#shell中判断两个字符串相等" class="headerlink" title="shell中判断两个字符串相等"></a>shell中判断两个字符串相等</h3><pre class="line-numbers language-none"><code class="language-none">##! /bin/bashread -p "If you want to clean the trash?(y/n):" selectstr=yif [ "$select" = "y" ]then    rm -fr $HOME/.local/share/Trash/files/*    echo "Deleted successfully!"else    echo "Undelete!"fi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意的几点：</strong><br><strong>1、if和[ ]之间要空格。</strong></p><p><strong>2、[ ]和“ ”之间要空格</strong></p><p><strong>3、“ ”和=之间要空格，</strong></p><h3 id="实战：统计文章单词情况"><a href="#实战：统计文章单词情况" class="headerlink" title="实战：统计文章单词情况"></a>实战：统计文章单词情况</h3><p>这里想要统计Martin Luther King在1963年著名的<strong>I have a dream</strong>演讲中都使用了哪些词，哪些是高频词，单词字长如何。<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20230522151123.png" alt=""><br>思路：<br>高频词统计：将所有单词单行输出，删除空行，删除<code>,./?</code>等非字母符号，用sort排序后使用uniq统计即可。<br>字长频数统计：将所有单词单行输出，删除空行，删除<code>,./?</code>等非字母符号，使用while循环遍历每个单词，使用<br></p><pre class="line-numbers language-none"><code class="language-none">${#variable} //统计单词长读频数。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p><pre class="line-numbers language-none"><code class="language-none">## 高频词统计echo "高频词统计："echo "频数" "单词"tr " " "\n" &lt;IHaveADream.txt | \##使用tr将空格转换成换行符，使得每行一个单词，\续行符表示一行命令未写完可换行书写，切记其后什么字符也不能接，包括空格和注释sed -e "/[^a-Z]/d;/^$/d" | \##使用sed匹配非字母字符和空行并删除：-e 表示执行多个操作； /[^a-Z]/，双斜线//表示匹配部分，^表示匹配除开后面a-Z的所有字符，d表示对前面匹配部分删除；/^$/表示匹配空行，^、$分别表示行首和行尾sort |uniq -c |    \##排序之后使用uniq统计，-c表示统计单词出现的次数sort -nr | column -t|head #将次数最多的单词排在前面，-n表示按数值排序，-r从大到小倒序排，column -t表格式输出## 字长频数统计echoecho "字长频数统计："echo "频数" "单词长度"tr " " "\n" &lt;IHaveADream.txt | \sed -e "/[^a-Z]/d;/^$/d" | \while read worddo  echo ${#word}done |\## 用while和read每次读入一个单词，使用${#word}统计单词长度sort |uniq -c|sort -nr|column -t|head<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20230522151139.png" alt=""></p><h2 id="字符串切割"><a href="#字符串切割" class="headerlink" title="字符串切割"></a>字符串切割</h2><p>将用到字符串切割，即将字符串切割为一个数组<br><a href="https://blog.csdn.net/u010003835/article/details/80750003?spm=1001.2101.3001.6650.5&amp;depth_1-utm_relevant_index=10">原文链接</a></p><h3 id="利用shell-中-变量-的字符串替换"><a href="#利用shell-中-变量-的字符串替换" class="headerlink" title="利用shell 中 变量 的字符串替换"></a>利用shell 中 变量 的字符串替换</h3><p>原理：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">${parameter<span class="token operator">/</span><span class="token operator">/</span>pattern<span class="token operator">/</span>string}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>用string来替换parameter变量中所有匹配的pattern</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">##!/bin/bash</span> <span class="token assign-left variable">string</span><span class="token operator">=</span><span class="token string">"hello,shell,split,test"</span>  <span class="token assign-left variable">array</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token variable">${string<span class="token operator">/</span><span class="token operator">/</span><span class="token operator">,</span><span class="token operator">/</span> }</span><span class="token punctuation">)</span>   <span class="token keyword">for</span> <span class="token for-or-select variable">var</span> <span class="token keyword">in</span> <span class="token variable">${array<span class="token punctuation">[</span>@<span class="token punctuation">]</span>}</span><span class="token keyword">do</span>   <span class="token builtin class-name">echo</span> <span class="token variable">$var</span><span class="token keyword">done</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20230522151159.png" alt=""></p><h3 id="设置分隔符，通过-IFS-变量"><a href="#设置分隔符，通过-IFS-变量" class="headerlink" title="设置分隔符，通过 IFS 变量"></a>设置分隔符，通过 IFS 变量</h3><p>原理</p><p>自定义IFS变量, 改变分隔符, 对字符串进行切分</p><p>IFS介绍<br> Shell 脚本中有个变量叫 IFS(Internal Field Seprator) ，内部域分隔符。完整定义是The shell uses the value stored in IFS, which is the space, tab, and newline characters by default, to delimit words for the read and set commands, when parsing output from command substitution, and when performing variable substitution.</p><pre><code> Shell 的环境变量分为 set, env 两种，其中 set 变量可以通过 export 工具导入到 env 变量中。其中，set 是显示设置shell变量，仅在本 shell 中有效；env 是显示设置用户环境变量 ，仅在当前会话中有效。换句话说，set 变量里包含了 env 变量，但 set 变量不一定都是 env 变量。这两种变量不同之处在于变量的作用域不同。显然，env 变量的作用域要大些，它可以在 subshell 中使用。 而 IFS 是一种 set 变量，当 shell 处理"命令替换"和"参数替换"时，shell 根据 IFS 的值，默认是 space, tab, newline 来拆解读入的变量，然后对特殊字符进行处理，最后重新组合赋值给该变量。</code></pre><p>IFS 简单实例</p><p>1、查看变量 IFS 的值。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token environment constant">$IFS</span>    $ <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token environment constant">$IFS</span>"</span> <span class="token operator">|</span> od -b  0000000 040 011 012 012  0000004  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>直接输出IFS是看不到的，把它转化为二进制就可以看到了，”040”是空格，”011”是Tab，”012”是换行符”\n” 。最后一个 012 是因为 echo 默认是会换行的。</p><p><strong>示例：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">##!/bin/bash</span> <span class="token assign-left variable">string</span><span class="token operator">=</span><span class="token string">"hello,shell,split,test"</span>   <span class="token comment">##对IFS变量 进行替换处理</span><span class="token assign-left variable">OLD_IFS</span><span class="token operator">=</span><span class="token string">"<span class="token environment constant">$IFS</span>"</span><span class="token assign-left variable"><span class="token environment constant">IFS</span></span><span class="token operator">=</span><span class="token string">","</span><span class="token assign-left variable">array</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token variable">$string</span><span class="token punctuation">)</span><span class="token assign-left variable"><span class="token environment constant">IFS</span></span><span class="token operator">=</span><span class="token string">"<span class="token variable">$OLD_IFS</span>"</span> <span class="token keyword">for</span> <span class="token for-or-select variable">var</span> <span class="token keyword">in</span> <span class="token variable">${array<span class="token punctuation">[</span>@<span class="token punctuation">]</span>}</span><span class="token keyword">do</span>   <span class="token builtin class-name">echo</span> <span class="token variable">$var</span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20230522151216.png" alt=""></p><h3 id="利用tr-指令实现字符替换"><a href="#利用tr-指令实现字符替换" class="headerlink" title="利用tr 指令实现字符替换"></a>利用tr 指令实现字符替换</h3><p>详细内容可自行查看</p><h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><h2 id="sed脚本命令"><a href="#sed脚本命令" class="headerlink" title="sed脚本命令"></a>sed脚本命令</h2><p><a href="http://c.biancheng.net/view/4028.html">原文链接</a><br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20230522151235.png" alt=""></p><h3 id="sed-s-替换脚本命令"><a href="#sed-s-替换脚本命令" class="headerlink" title="sed s 替换脚本命令"></a>sed s 替换脚本命令</h3><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20230522151254.png" alt=""></p><h3 id="sed-d-替换脚本命令"><a href="#sed-d-替换脚本命令" class="headerlink" title="sed d 替换脚本命令"></a>sed d 替换脚本命令</h3><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20230522151312.png" alt=""></p><h3 id="sed-a-和-i-脚本命令-（插入）"><a href="#sed-a-和-i-脚本命令-（插入）" class="headerlink" title="sed a 和 i 脚本命令 （插入）"></a>sed a 和 i 脚本命令 （插入）</h3><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20230522151328.png" alt=""></p><h3 id="sed-c-替换"><a href="#sed-c-替换" class="headerlink" title="sed c 替换"></a>sed c 替换</h3><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20230522151344.png" alt=""></p><h3 id="sed-y-转换"><a href="#sed-y-转换" class="headerlink" title="sed y 转换"></a>sed y 转换</h3><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20230522151402.png" alt=""></p><h3 id="sed-w-文本指定内容写入文件"><a href="#sed-w-文本指定内容写入文件" class="headerlink" title="sed w 文本指定内容写入文件"></a>sed w 文本指定内容写入文件</h3><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20230522151419.png" alt=""></p><h3 id="sed-p-搜索符号条件的行，并输出该行的内容"><a href="#sed-p-搜索符号条件的行，并输出该行的内容" class="headerlink" title="sed p 搜索符号条件的行，并输出该行的内容"></a>sed p 搜索符号条件的行，并输出该行的内容</h3><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20230522151435.png" alt=""></p><h3 id="sed-r-将一个独立文件的数据插入到当前数据流的指定位置"><a href="#sed-r-将一个独立文件的数据插入到当前数据流的指定位置" class="headerlink" title="sed r 将一个独立文件的数据插入到当前数据流的指定位置"></a>sed r 将一个独立文件的数据插入到当前数据流的指定位置</h3><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20230522151451.png" alt=""></p><h3 id="sed-q-使-sed-命令在第一次匹配任务结束后，退出-sed-程序，不再进行对后续数据的处理"><a href="#sed-q-使-sed-命令在第一次匹配任务结束后，退出-sed-程序，不再进行对后续数据的处理" class="headerlink" title="sed q 使 sed 命令在第一次匹配任务结束后，退出 sed 程序，不再进行对后续数据的处理"></a>sed q 使 sed 命令在第一次匹配任务结束后，退出 sed 程序，不再进行对后续数据的处理</h3><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20230522151508.png" alt=""></p><h2 id="sed-address-寻址方式"><a href="#sed-address-寻址方式" class="headerlink" title="sed address 寻址方式"></a>sed address 寻址方式</h2><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20230522151525.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> Linux </tag>
            
            <tag> sed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang</title>
      <link href="/posts/56435/"/>
      <url>/posts/56435/</url>
      
        <content type="html"><![CDATA[<h2 id="查看环境变量"><a href="#查看环境变量" class="headerlink" title="查看环境变量"></a>查看环境变量</h2><pre class="line-numbers language-none"><code class="language-none">go version  //查看版本go env   //查看环境变量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="安装golang、gopath、goroot"><a href="#安装golang、gopath、goroot" class="headerlink" title="安装golang、gopath、goroot"></a>安装golang、gopath、goroot</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>windows安装一路点击ok就好。</p><p>Linux安装：</p><ol><li>wget <a href="https://dl.google.com/go/go1.14.1.linux-amd64.tar.gz">https://dl.google.com/go/go1.14.1.linux-amd64.tar.gz</a></li><li>tar -zxvf go1.14.1.linux-amd64.tar.gz -C /usr/local  # 解压</li><li><p>配置环境变量： Linux下有两个文件可以配置环境变量，其中/etc/profile是对所有用户生效的；$HOME/.profile是对当前用户生效的，根据自己的情况自行选择一个文件打开，添加如下两行代码，保存退出。</p><pre class="line-numbers language-none"><code class="language-none">export GOROOT=/usr/local/goexport PATH=$PATH:$GOROOT/bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>修改/etc/profile后要重启生效，修改$HOME/.profile后使用source命令加载$HOME/.profile文件即可生效。 检查：</p><pre class="line-numbers language-none"><code class="language-none">go version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="gopath、goroot"><a href="#gopath、goroot" class="headerlink" title="gopath、goroot"></a>gopath、goroot</h3></li></ol><ul><li><p>goroot:<br>其实就是golang 的安装路径<br>当你安装好golang之后其实这个就已经有了</p></li><li><p>gopath:<br>作用：</p></li></ul><p>存放sdk以外的第三方类库<br>自己收藏的可复用的代码<br>目录结构：$GOPATH目录约定有三个子目录<br>   src存放源代码(比如：.go .c .h .s等) 按照golang默认约定，go run，go install等命令的当前工作路径（即在此路径下执行上述命令）。</p><p>   pkg编译时生成的中间文件（比如：.a）　　golang编译包时</p><p>   bin编译后生成的可执行文件（为了方便，可以把此目录加入到 P A T H 变 量 中 ， 如 果 有 多 个 g o p a t h ， 那 么 使 用 PATH 变量中，如果有多个gopath，那么使用PATH变量中，如果有多个gopath，那么使用{GOPATH/bin:}/bin添加所有的bin目录）</p><h2 id="package"><a href="#package" class="headerlink" title="package"></a>package</h2><h3 id="包的定义"><a href="#包的定义" class="headerlink" title="包的定义"></a>包的定义</h3><pre class="line-numbers language-none"><code class="language-none">package 包名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意事项：</p><ul><li>一个文件夹下直接包含的文件只能归属于一个package，同样一个package的文件不能在多个文件夹下。</li><li>包名可以不和文件夹的名字一样。</li><li>包名为<code>main</code>的包为应用程序的入口包，这种包编译后会得到一个可执行文件，而编译不含main包的源代码则不会得到可执行文件</li></ul><h3 id="包的使用"><a href="#包的使用" class="headerlink" title="包的使用"></a>包的使用</h3><ol><li>有时候我们单独写一个go文件，测试或验证某个功能，包名都写main就好</li><li>如果要引入自定义的包。如果import失败，看一下保存的信息。一般会提示GOROOT GOPATH找不到这个包，这个时候把这个文件夹放到上面的目录里面就可以导入了。</li></ol><p>举例：<br>我目前的GOROOT是在这个目录下面，把文件夹放进去，里面是go文件，就可以引入了。<br><img src="https://s2.loli.net/2022/05/25/sy6aYNIOjX5dfuM.png" alt="03.png"></p><h3 id="go-mod配置"><a href="#go-mod配置" class="headerlink" title="go mod配置"></a>go mod配置</h3><p>go mod 主要用于管理第三方包，可以自动进行下载。要使用go mod，需要一些配置。<br><strong>需要配置GO111MODULE 、GOPROXY</strong></p><p><img src="https://s2.loli.net/2022/05/25/N4dmhtb628iVPyK.png" alt="01.png"></p><p><img src="https://s2.loli.net/2022/05/25/QDjPKNHc2pI8Mn3.png" alt="02.png"></p><h3 id="go-mod使用"><a href="#go-mod使用" class="headerlink" title="go mod使用"></a>go mod使用</h3><p>首先：<br></p><pre class="line-numbers language-none"><code class="language-none">go mod init "modname"//modname一般是文件所处文件夹的名字//go mod init dynamic<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>如果要某文件要引入一些包，在import处写入，然后执行下面命令：<br></p><pre class="line-numbers language-none"><code class="language-none">go mod tidy//或者go get -u<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p></p><h3 id="导入第三方包"><a href="#导入第三方包" class="headerlink" title="导入第三方包"></a>导入第三方包</h3><p>背景：和公司合作开发，但是没有他们内部的开发环境，只能让他们把包单独抽出来<br><img src="https://s2.loli.net/2022/08/30/dSVhiE5IgfTzRls.png" alt=""></p><p><strong>核心就是这里的replace，不用修改goproxy或者go111module等环境变量</strong></p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p><a href="https://hujingnb.com/archives/825">Context 简介</a></p><p><a href="https://murphypei.github.io/blog/2021/06/go-context">Context 使用例子</a></p><p>Context主要做两件事情：</p><ol><li>通知子协程提前退出</li><li>携带环境变量</li></ol><h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><p><a href="https://blog.csdn.net/tool007/article/details/124329558?spm=1001.2101.3001.6661.1&amp;depth_1-utm_relevant_index=1">channel详细使用</a></p><p>Goroutine(协程) 使用 Channel 传递数据</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/d8fae620e5a541b49f01e27bec502bbf.png" alt=""></p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><pre class="line-numbers language-none"><code class="language-none">// 只读 channelvar readOnlyChan &lt;-chan int  // channel 的类型为 int// 只写 channelvar writeOnlyChan chan&lt;- int// 可读可写var ch chan int// 或者使用 make 直接初始化readOnlyChan1 := make(&lt;-chan int, 2)  // 只读且带缓存区的 channelreadOnlyChan2 := make(&lt;-chan int)   // 只读且不带缓存区 channelwriteOnlyChan3 := make(chan&lt;- int, 4) // 只写且带缓存区 channelwriteOnlyChan4 := make(chan&lt;- int) // 只写且不带缓存区 channelch := make(chan int, 10)  // 可读可写且带缓存区ch &lt;- 20  // 写数据i := &lt;-ch  // 读数据i, ok := &lt;-ch  // 还可以判断读取的数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="操作channel"><a href="#操作channel" class="headerlink" title="操作channel"></a>操作channel</h4><p>操作 channel 一般有如下三种方式：</p><p>读 &lt;-ch</p><p>写 ch&lt;-</p><p>关闭 close(ch)</p><h3 id="go-func"><a href="#go-func" class="headerlink" title="go func(){}()"></a>go func(){}()</h3><pre class="line-numbers language-none"><code class="language-none">go func() {.....}()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以并发的方式调用匿名函数func</p><p>详细解释：<br></p><pre class="line-numbers language-none"><code class="language-none">func(name string) {       fmt.Println("Your name is", name)   } (str)   //这里的(str)是？<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p></p><p>其实，这就是在调用这个函数，这种写法等同于：<br></p><pre class="line-numbers language-none"><code class="language-none">f := func(name string) {        fmt.Println("Your name is", name)    }    f(str) //看吧，就是把函数复制给变量，变量（函数）传参<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p></p><p><strong>以下两段代码执行结果等同：</strong><br></p><pre class="line-numbers language-none"><code class="language-none">代码一：package mainimport (  "fmt")func main() {    str := "xulinlin"    func(name string) {        fmt.Println("Your name is", name)    }(str)}代码二：package mainimport (  "fmt")func main() {    f := func(name string) {        fmt.Println("Your name is", name)    }    f(str)}输出都是：Your name is xulinlin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><p>defer后面的函数在defer语句所在的函数执行结束的时候会被调用，用来做一些收尾工作</p><p><a href="[http://](https://blog.csdn.net/raoxiaoya/article/details/109428392?spm=1001.2101.3001.6661.1&amp;depth_1-utm_relevant_index=1">原文链接</a>)</p><h3 id="Println-与-Printf-的区别"><a href="#Println-与-Printf-的区别" class="headerlink" title="Println 与 Printf 的区别"></a>Println 与 Printf 的区别</h3><ol><li>Println :可以打印出字符串，和变量</li><li>Printf : 只可以打印出格式化的字符串,可以输出字符串类型的变量，不可以输出整形变量和整形</li></ol><p>也就是说，当需要格式化输出信息时一般选择 Printf，其他时候用 Println 就可以了，比如：</p><pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">a := 10fmt.Println(a)　　//rightfmt.Println("abc")　　//rightfmt.Printf("%d",a)　　//rightfmt.Printf(a)　　//error<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="printf格式化输出"><a href="#printf格式化输出" class="headerlink" title="printf格式化输出"></a>printf格式化输出</h3><ol><li><p>通用输出</p><pre class="line-numbers language-none"><code class="language-none">%v     #仅输出该变量的值%+v    #输出 该变量的值，如果是数组k/v  则将k/v都输出%#v    #先输出结构体名字值,再输出结构体（字段名字+字段的值）%T   #输出结构体名称%%   #百分号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">package main import ("fmt") type student struct {id   intname string}func main()  { ss := student{id: 1,name: "test"}fmt.Printf("%v \n",ss)     //%v  当碰到数组时，仅输出value，不输出keyfmt.Printf("%+v \n",ss)    //%+v  当碰到数组时，将key-value 都输出fmt.Printf("%#v \n",ss)    //%#v  输出时，会将方法名 +k/v都输出fmt.Printf("%T \n",ss)     //%T   输出结构体名称()fmt.Printf("%% \n")        //%%   没有意义，只是输出一个%}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>整数类型</p><pre class="line-numbers language-none"><code class="language-none">%b     二进制表示 %c     相应Unicode码点所表示的字符 %d     十进制表示 %o     八进制表示 %q     单引号围绕的字符字面值，由Go语法安全地转义 %x     十六进制表示，字母形式为小写 a-f %X     十六进制表示，字母形式为大写 A-F %U     Unicode格式：123，等同于 "U+007B"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><pre class="line-numbers language-none"><code class="language-none">package main import (    "fmt") func main()  {    ss := 68    fmt.Printf("%b \n",ss)      //二进制表示    fmt.Printf("%c \n",ss)      //Unicode码表示的字符    fmt.Printf("%d \n",ss)      //十进制表示    fmt.Printf("%o \n",ss)      //八进制    fmt.Printf("%q \n",ss)      //输出字符，单引号包裹    fmt.Printf("%x \n",ss)      //十六进制输出  小写    fmt.Printf("%X \n",ss)      //十六进制输出  大写    fmt.Printf("%U \n",ss)      //Unicode格式}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>浮点数<pre class="line-numbers language-none"><code class="language-none">%b无小数部分、二进制指数的科学计数法，如-123456p-78；参见strconv.FormatFloat%e科学计数法，如-1234.456e+78%E科学计数法，如-1234.456E+78%f有小数部分但无指数部分，如123.456%F等价于%f%g根据实际情况采用%e或%f格式（以获得更简洁、准确的输出）%G根据实际情况采用%E或%F格式（以获得更简洁、准确的输出）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><pre class="line-numbers language-none"><code class="language-none">package main import (    "fmt") func main()  {    fmt.Printf("%b \n",68.10)   //二进制输出    fmt.Printf("%e \n",68.10)   //科学计数法 e    fmt.Printf("%E \n",68.10)   //科学计数法 E    fmt.Printf("%f \n",68.10)    fmt.Printf("%g \n",68.10)    fmt.Printf("%G \n",68.10)  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>//结果<br>4792111478498918p-46<br>6.810000e+01<br>6.810000E+01<br>68.100000<br>68.1<br>68.1<br></p><pre class="line-numbers language-none"><code class="language-none"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p><ol><li>布尔<pre class="line-numbers language-none"><code class="language-none">%t   true 或 false<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>字符串<pre class="line-numbers language-none"><code class="language-none">%s     字符串或切片的无解译字节 %q     双引号围绕的字符串，由Go语法安全地转义 %x     十六进制，小写字母，每字节两个字符 %X     十六进制，大写字母，每字节两个字符<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">package main import ("fmt")  func main() {fmt.Printf("%s","I'm a girl")fmt.Println()fmt.Printf("%q","I'm a girl")fmt.Println()fmt.Printf("%x","I'm a girl")fmt.Println()fmt.Printf("%X","I'm a girl")fmt.Println()}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><pre class="line-numbers language-none"><code class="language-none">//结果I'm a girl"I'm a girl"49276d2061206769726c49276D2061206769726C<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h3><p><a href="https://zhuanlan.zhihu.com/p/139758275">原文链接</a><br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20230522150808.png" alt=""><br>输出为：</p><pre class="line-numbers language-none"><code class="language-none">{Aric 21 3-1}{Name:Aric Age:21 Class:3-1}main.Student{Name:"Aric", Age:21, Class:"3-1"}main.Student676f6c616e67676F6C616E670xc000062150<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20230522150829.png" alt=""></p><h3 id="下划线-“-”"><a href="#下划线-“-”" class="headerlink" title="下划线  “_”"></a>下划线  “_”</h3><p>“_”是特殊标识符，用来忽略结果。</p><p><strong>1.下划线在import中</strong></p><p>在Golang里，import的作用是导入其他package。<br>　　 import 下划线（如：import <em> hello/imp）的作用：当导入一个包时，该包下的文件里所有init()函数都会被执行，然而，有些时候我们并不需要把整个包都导入进来，仅仅是是希望它执行init()函数而已。这个时候就可以使用 import </em> 引用该包。即使用【import _ 包路径】只是引用该包，仅仅是为了调用init()函数，所以无法通过包名来调用包中的其他函数。<br>示例：</p><pre class="line-numbers language-none"><code class="language-none">src |+--- main.go            |+--- hello       |       +--- hello.go<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>main.go</p><pre class="line-numbers language-none"><code class="language-none">package mainimport _ "./hello"func main() {    // hello.Print()     //编译报错：./main.go:6:5: undefined: hello}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>hello.go</p><pre class="line-numbers language-none"><code class="language-none">package helloimport "fmt"func init() {    fmt.Println("imp-init() come here.")}func Print() {    fmt.Println("Hello!")}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：</p><pre class="line-numbers language-none"><code class="language-none">imp-init() come here.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>2.下划线在代码中</strong></p><pre class="line-numbers language-none"><code class="language-none">package mainimport (    "os")func main() {    buf := make([]byte, 1024)    f, _ := os.Open("/Users/***/Desktop/text.txt")    defer f.Close()    for {        n, _ := f.Read(buf)        if n == 0 {            break            }        os.Stdout.Write(buf[:n])    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解释1：</p><pre class="line-numbers language-none"><code class="language-none">下划线意思是忽略这个变量.比如os.Open，返回值为*os.File，error普通写法是f,err := os.Open("xxxxxxx")如果此时不需要知道返回的错误值就可以用f, _ := os.Open("xxxxxx")如此则忽略了error变量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解释2：</p><pre class="line-numbers language-none"><code class="language-none">占位符，意思是那个位置本应赋给某个值，但是咱们不需要这个值。所以就把该值赋给下划线，意思是丢掉不要。这样编译器可以更好的优化，任何类型的单个值都可以丢给下划线。这种情况是占位用的，方法返回两个结果，而你只想要一个结果。那另一个就用 "_" 占位，而如果用变量的话，不使用，编译器是会报错的。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>补充：</p><pre class="line-numbers language-none"><code class="language-none">import "database/sql"import _ "github.com/go-sql-driver/mysql"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>第二个import就是不直接使用mysql包，只是执行一下这个包的init函数，把mysql的驱动注册到sql包里，然后程序里就可以使用sql包来访问mysql数据库了。</p><h3 id="和-的区别"><a href="#和-的区别" class="headerlink" title="= 和 :=的区别"></a>= 和 :=的区别</h3><pre class="line-numbers language-none"><code class="language-none">// = 使用必须使用先var声明例如：var aa=100//或var b = 100//或var c int = 100 // := 是声明并赋值，并且系统自动推断类型，不需要var关键字d := 100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="String-方法"><a href="#String-方法" class="headerlink" title="String()方法"></a>String()方法</h3><p>对于定于了String()方法的类型，默认输出的时候会调用该方法，实现字符串的打印。例如下面代码：</p><pre class="line-numbers language-none"><code class="language-none">package main import "fmt" type Man struct {    name string} func (m Man) String() string {    return "My name is :" + m.name} func main() {    var m Man    m.name = "SNS"    fmt.Println(m)} 输出：My name is :SNS<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>使用指针</strong><br>然而，如果使用func (m *Man) String() string方式定义函数，那么就不会自动调用该函数输出（go version go1.12.1 windows/amd64）。</p><pre class="line-numbers language-none"><code class="language-none">package main import "fmt" type Man struct {    name string} func (m *Man) String() string {    return "My name is :" + m.name} func main() {    var m Man    m.name = "SNS"    fmt.Println(m)} 输出:{SNS}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>String方法是接口方法，存在于fmt包里print.go文件下的Stringer接口。go使用fmt包的输出方法会自动调用String()方法。当重写的String是指针方法时，只有指针类型调用的时候才会正常调用，值类型调用的时候实际上没有执行重写的String方法；当重写的String方法是值方法时，无论指针类型和值类型均可调用重写的String方法。其实跟接口的实现有关，当值类型实现接口的时候，相当于值类型和该值的指针类型均实现了该接口；相反，当指针类型实现了该接口的时候，只有指针类型实现了接口，值类型是没有实现的。</p><p>最后一句改成<code>fmt.Println(&amp;m)</code><br>因为你只为<code>*Man</code>这个Man的指针类型重新定义了String()方法，所以只有在输出<code>*Man</code>类型的数据时才会调用自定义的String()方法。<br>而你定义的m是Man类型的，所以才不会调用你定义的String方法。<br>所要么向楼上那位一样定义<em>Man类型。要么就是在输出时，向Print函数传递</em>Man类型的数据(改成<code>fmt.Println(&amp;m)</code>)</p></blockquote><h3 id="方法接受者"><a href="#方法接受者" class="headerlink" title="方法接受者"></a>方法接受者</h3><p><a href="https://www.jianshu.com/p/316617954070">原文链接</a><br>在go语言中，没有类的概念但是可以给类型（结构体，自定义类型）定义方法。所谓方法就是定义了接受者的函数。接受者定义在func关键字和函数名之间:</p><pre class="line-numbers language-none"><code class="language-none">type Person struct {    name string    age int}func (p Person) say() {    fmt.Printf("I'm %s,%d years old\n",p.name,p.age)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有了对方法及接受者的简单认识之后，接下来主要谈一下接受者的类型问题。<br>接受者类型可以是struct,也可以是指向struc的指针。<br><strong>情况一：接受者是struct</strong></p><pre class="line-numbers language-none"><code class="language-none">package mainimport "fmt"type Person struct {name stringage int}func (p Person) say() {fmt.Printf("I'm %s,%d years old\n",p.name,p.age)}func (p Person) older(){    p.age = p.age +1}func main() {    var p1 Person = Person{"zhansan",16}    p1.older()    p1.say()    //output: I'm zhangsan，16 years old    var p2 *Person = &amp;Person{"lisi",17}    p2.older()    p2.say()    //output: I'm lisi，17 years old}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于p1的调用，读者应该不会有什么疑问。<br>对于p2的调用可能存在这样的疑问，p2明明是个指针，为什么再调用了older方法之后，打印结果还是17 years old?<br>方法的接受者是Person而调用者是<em>Person ，其实在p2调用时存在一个转换p2.older() -&gt; </em>p2.older(); p2.say() -&gt; <em>p2.say()</em>p2是什么想必读者也是明白的（就一个p2指向Person实例）。那么疑问也就自然的解开了,方法执行时的接受者实际上还是一个值而非引用。</p><p><strong>情况二：接受者是指针</strong></p><pre class="line-numbers language-none"><code class="language-none">package mainimport "fmt"type Person struct {name stringage int}func (p *Person) say() {fmt.Printf("I'm %s,%d years old\n",p.name,p.age)}func (p *Person) older(){    p.age = p.age +1}func main() {    var p1 Person = Person{"zhansan",16}    p1.older()    p1.say()    //output: I'm zhangsan，17 years old    var p2 *Person = &amp;Person{"lisi",17}    p2.older()    p2.say()    //output: I'm lisi，18 years old}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>p1的调用中也存在一个转换，<br>p1.older -&gt; <em>p1.older<br>p1.say() -&gt; </em>p1.say()</p><p><strong>用例：</strong></p><pre class="line-numbers language-none"><code class="language-none">package mainimport (    "fmt")//面向对象//go仅支持封装，不支持继承和多态//go语言中没有class，只要struct//不论地址还是结构本身，一律使用.来访问成员//要改变内容必须使用指针接收者//结构过大考虑指针接收者//值接收者是go语言特有//封装//名字一般使用CamelCase//首字母大写： public//首字母小写：private//包//每个目录一个包，包名可以与目录不一样//main包包含可执行入口，只有一个main包//为结构定义的方法必须放在同一个包内，但是可以是不同文件type treeNode struct {    value int    left, right *treeNode}func (node treeNode) print() {  //显示定义和命名方法接收者（括号里）    fmt.Print(node.value)  //只有使用指针才可以改变结构内容    fmt.Println()}func (node *treeNode) setValue ( value int) {  //使用指针作为方法接收者    if node == nil {        fmt.Println("setting value to nil node") //nil指针也可以调用方法        return    }    node.value = value}func (node *treeNode ) traverse(){    if node == nil{        return    }    node.left.traverse()    node.print()    node.right.traverse()}func main() {    var  root  treeNode    fmt.Println(root)  //{0 &lt;nil&gt; &lt;nil&gt;}    root = treeNode{value:3}    root.left = &amp;treeNode{}    root.right = &amp;treeNode{5,nil,nil}    root.right.left = new(treeNode)    nodes := []treeNode {        {value: 3},        {},        {6,nil,&amp;root},    }    fmt.Println(nodes)  //[{3 &lt;nil&gt; &lt;nil&gt;} {0 &lt;nil&gt; &lt;nil&gt;} {6 &lt;nil&gt; 0xc04205a3e0}]    root.print()  // 3    fmt.Println()    root.right.left.setValue(100)    root.right.left.print()  //100    fmt.Println()    var pRoot *treeNode    pRoot.setValue(200)   //setting value to nil node    pRoot = &amp;root    pRoot.setValue(300)    pRoot.print()  //300    root.traverse()  //300 0 300 100 5}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="结构体定义中的-json-单引号（-）"><a href="#结构体定义中的-json-单引号（-）" class="headerlink" title="结构体定义中的 json 单引号（``）"></a>结构体定义中的 json 单引号（``）</h3><pre class="line-numbers language-none"><code class="language-none">package mainimport (    "encoding/json"    "fmt")//在处理json格式字符串的时候，经常会看到声明struct结构的时候，属性的右侧还有小米点括起来的内容。`TAB键左上角的按键，～线同一个键盘`type Student struct {    StudentId      string `json:"sid"`    StudentName    string `json:"sname"`    StudentClass   string `json:"class"`    StudentTeacher string `json:"teacher"`}type StudentNoJson struct {    StudentId      string    StudentName    string    StudentClass   string    StudentTeacher string}//可以选择的控制字段有三种：// -：不要解析这个字段// omitempty：当字段为空（默认值）时，不要解析这个字段。比如 false、0、nil、长度为 0 的 array，map，slice，string// FieldName：当解析 json 的时候，使用这个名字type StudentWithOption struct {    StudentId      string //默认使用原定义中的值    StudentName    string `json:"sname"`           // 解析（encode/decode） 的时候，使用 `sname`，而不是 `Field`    StudentClass   string `json:"class,omitempty"` // 解析的时候使用 `class`，如果struct 中这个值为空，就忽略它    StudentTeacher string `json:"-"`               // 解析的时候忽略该字段。默认情况下会解析这个字段，因为它是大写字母开头的}func main() {    //NO.1 with json struct tag    s := &amp;Student{StudentId: "1", StudentName: "fengxm", StudentClass: "0903", StudentTeacher: "feng"}    jsonString, _ := json.Marshal(s)    fmt.Println(string(jsonString))    //{"sid":"1","sname":"fengxm","class":"0903","teacher":"feng"}    newStudent := new(Student)    json.Unmarshal(jsonString, newStudent)    fmt.Println(newStudent)    //&amp;{1 fengxm 0903 feng}    //Unmarshal 是怎么找到结构体中对应的值呢？比如给定一个 JSON key Filed，它是这样查找的：    // 首先查找 tag 名字（关于 JSON tag 的解释参看下一节）为 Field 的字段    // 然后查找名字为 Field 的字段    // 最后再找名字为 FiElD 等大小写不敏感的匹配字段。    // 如果都没有找到，就直接忽略这个 key，也不会报错。这对于要从众多数据中只选择部分来使用非常方便。    //NO.2 without json struct tag    so := &amp;StudentNoJson{StudentId: "1", StudentName: "fengxm", StudentClass: "0903", StudentTeacher: "feng"}    jsonStringO, _ := json.Marshal(so)    fmt.Println(string(jsonStringO))    //{"StudentId":"1","StudentName":"fengxm","StudentClass":"0903","StudentTeacher":"feng"}    //NO.3 StudentWithOption    studentWO := new(StudentWithOption)    js, _ := json.Marshal(studentWO)    fmt.Println(string(js))    //{"StudentId":"","sname":""}    studentWO2 := &amp;StudentWithOption{StudentId: "1", StudentName: "fengxm", StudentClass: "0903", StudentTeacher: "feng"}    js2, _ := json.Marshal(studentWO2)    fmt.Println(string(js2))    //{"StudentId":"1","sname":"fengxm","class":"0903"}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="基本数据类型操作"><a href="#基本数据类型操作" class="headerlink" title="基本数据类型操作"></a>基本数据类型操作</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><pre class="line-numbers language-none"><code class="language-none"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="map相关操作"><a href="#map相关操作" class="headerlink" title="map相关操作"></a>map相关操作</h3><h4 id="创建map"><a href="#创建map" class="headerlink" title="创建map"></a>创建map</h4><pre class="line-numbers language-none"><code class="language-none">//初始化空mapprevNums := map[int]int{}//初始化countryCapitalMap := map[string]string{"France": "Paris", "Italy": "Rome", "Japan": "Tokyo", "India": "New delhi"}//value接收任意数据类型，用interfaceresMap := make(map[string]interface{})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="查看元素在集合中是否存在"><a href="#查看元素在集合中是否存在" class="headerlink" title="查看元素在集合中是否存在"></a>查看元素在集合中是否存在</h4><pre class="line-numbers language-none"><code class="language-none">capital, ok := countryCapitalMap [ "American" ] /*如果确定是真实的,则存在,否则不存在 */    /*fmt.Println(capital) */    /*fmt.Println(ok) */    if (ok) {        fmt.Println("American 的首都是", capital)    } else {        fmt.Println("American 的首都不存在")    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="判断key是否存在"><a href="#判断key是否存在" class="headerlink" title="判断key是否存在"></a>判断key是否存在</h4><pre class="line-numbers language-none"><code class="language-none">package main import "fmt" func main() {    demo := map[string]bool{        "a": false,    }     //错误，a存在，但是返回false    fmt.Println(demo["a"])     //正确判断方法    _, ok := demo["a"]    fmt.Println(ok)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">if _, ok := map[key]; ok {    // 存在}if _, ok := map[key]; !ok {    // 不存在}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="快速删除所有元素"><a href="#快速删除所有元素" class="headerlink" title="快速删除所有元素"></a>快速删除所有元素</h4><p><strong>直接重新生成map，名字相同</strong></p><h4 id="Map-实现去重与-set-的功能"><a href="#Map-实现去重与-set-的功能" class="headerlink" title="Map 实现去重与 set 的功能"></a>Map 实现去重与 set 的功能</h4><pre class="line-numbers language-none"><code class="language-none">package main var set = map[string]bool { } func main() {    ...    url := xxx    if set[url] {        // 表示集合中已经存在        return    }     set[url] = true           // 否则如果不存在，设置为true} // 完成后，set的所有的key值为不重复的值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="map转json"><a href="#map转json" class="headerlink" title="map转json"></a>map转json</h4><pre class="line-numbers language-none"><code class="language-none">// map to jsonpackage mainimport (    "encoding/json"    "fmt")func main() {    s := []map[string]interface{}{}    m1 := map[string]interface{}{"name": "John", "age": 10}    m2 := map[string]interface{}{"name": "Alex", "age": 12}    s = append(s, m1, m2)    s = append(s, m2)    b, err := json.Marshal(s)    if err != nil {        fmt.Println("json.Marshal failed:", err)        return    }    fmt.Println("b:", string(b))}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>切片是动态数组，可以搭配结构体或map形成多重嵌套<br></p><pre class="line-numbers language-none"><code class="language-none">var projects = make([]models.Project, 0)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>上面的<code>models.Project</code>是一个结构体，前面加一个[]就变成了接片，用make生成，指定初始长度为0（必须要指定一个值，反正自动增加）。<br>这样这个projects变量是切片，里面的数据类型是models.Project结构体<p></p><p><a href="https://blog.csdn.net/youngwhz1/article/details/83026263?spm=1001.2101.3001.6661.1&amp;depth_1-utm_relevant_index=1">去重、插入、删除、清空原链接</a></p><h4 id="切片去重"><a href="#切片去重" class="headerlink" title="切片去重"></a>切片去重</h4><pre class="line-numbers language-none"><code class="language-none">/* 在slice中去除重复的元素，其中a必须是已经排序的序列。 * params: *   a: slice对象，如[]string, []int, []float64, ... * return: *   []interface{}: 已经去除重复元素的新的slice对象 */func SliceRemoveDuplicate(a interface{}) (ret []interface{}) {if reflect.TypeOf(a).Kind() != reflect.Slice {fmt.Printf("&lt;SliceRemoveDuplicate&gt; &lt;a&gt; is not slice but %T\n", a)return ret} va := reflect.ValueOf(a)for i := 0; i &lt; va.Len(); i++ {if i &gt; 0 &amp;&amp; reflect.DeepEqual(va.Index(i-1).Interface(), va.Index(i).Interface()) {continue}ret = append(ret, va.Index(i).Interface())} return ret}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试代码：<br></p><pre class="line-numbers language-none"><code class="language-none">func test_SliceRemoveDuplicate() {slice_string := []string{"a", "b", "c", "d", "a", "b", "c", "d"}slice_int := []int{1, 2, 3, 4, 5, 1, 2, 3, 4, 5}slice_float := []float64{1.11, 2.22, 3.33, 4.44, 1.11, 2.22, 3.33, 4.44} sort.Strings(slice_string)sort.Ints(slice_int)sort.Float64s(slice_float) fmt.Printf("slice_string = %v, %p\n", slice_string, slice_string)fmt.Printf("slice_int = %v, %p\n", slice_int, slice_int)fmt.Printf("slice_float = %v, %p\n", slice_float, slice_float) ret_slice_string := SliceRemoveDuplicate(slice_string)ret_slice_int := SliceRemoveDuplicate(slice_int)ret_slice_float := SliceRemoveDuplicate(slice_float) fmt.Printf("ret_slice_string = %v, %p\n", ret_slice_string, ret_slice_string)fmt.Printf("ret_slice_int = %v, %p\n", ret_slice_int, ret_slice_int)fmt.Printf("ret_slice_float = %v, %p\n", ret_slice_float, ret_slice_float) fmt.Printf("&lt;after&gt; slice_string = %v, %p\n", slice_string, slice_string)fmt.Printf("&lt;after&gt; slice_int = %v, %p\n", slice_int, slice_int)fmt.Printf("&lt;after&gt; slice_float = %v, %p\n", slice_float, slice_float)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>结果：<br></p><pre class="line-numbers language-none"><code class="language-none">slice_string = [a a b b c c d d], 0xc042088000slice_int = [1 1 2 2 3 3 4 4 5 5], 0xc04200e1e0slice_float = [1.11 1.11 2.22 2.22 3.33 3.33 4.44 4.44], 0xc042014200 ret_slice_string = [a b c d], 0xc042034100ret_slice_int = [1 2 3 4 5], 0xc042088080ret_slice_float = [1.11 2.22 3.33 4.44], 0xc042034180 &lt;after&gt; slice_string = [a a b b c c d d], 0xc042088000&lt;after&gt; slice_int = [1 1 2 2 3 3 4 4 5 5], 0xc04200e1e0&lt;after&gt; slice_float = [1.11 1.11 2.22 2.22 3.33 3.33 4.44 4.44], 0xc042014200<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><pre class="line-numbers language-none"><code class="language-none">/* * 在Slice指定位置插入元素。 * params: *   s: slice对象，类型为[]interface{} *   index: 要插入元素的位置索引 *   value: 要插入的元素 * return: *   已经插入元素的slice，类型为[]interface{} */func SliceInsert(s []interface{}, index int, value interface{}) []interface{} {rear := append([]interface{}{}, s[index:]...)return append(append(s[:index], value), rear...)} /* * 在Slice指定位置插入元素。 * params: *   s: slice对象指针，类型为*[]interface{} *   index: 要插入元素的位置索引 *   value: 要插入的元素 * return: *   无 */func SliceInsert2(s *[]interface{}, index int, value interface{}) {rear := append([]interface{}{}, (*s)[index:]...)*s = append(append((*s)[:index], value), rear...)} /* * 在Slice指定位置插入元素。 * params: *   s: slice对象的指针，如*[]string, *[]int, ... *   index: 要插入元素的位置索引 *   value: 要插入的元素 * return: *   true: 插入成功 *   false: 插入失败（不支持的数据类型） */func SliceInsert3(s interface{}, index int, value interface{}) bool {if ps, ok := s.(*[]string); ok {if val, ok := value.(string); ok {rear := append([]string{}, (*ps)[index:]...)*ps = append(append((*ps)[:index], val), rear...)return true}} else if ps, ok := s.(*[]int); ok {if val, ok := value.(int); ok {rear := append([]int{}, (*ps)[index:]...)*ps = append(append((*ps)[:index], val), rear...)}} else if ps, ok := s.(*[]float64); ok {if val, ok := value.(float64); ok {rear := append([]float64{}, (*ps)[index:]...)*ps = append(append((*ps)[:index], val), rear...)}} else {fmt.Printf("&lt;SliceInsert3&gt; Unsupported type: %T\n", s)} return false}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：</p><ol><li>SliceInsert()方法是传入一个[]interface{}类型的slice对象，返回的也是一个[]interface{}类型的slice对象。</li><li>SliceInsert2()方法是传入一个[]interface{}类型的slice对象指针，直接修改这个slice对象。</li><li>SliceInsert3()方法是传入一个具体类型的slice对象指针（如<em>[]string, </em>[]int等），方法中直接修改这个slice对象，返回操作是否成功的状态(bool)。</li></ol><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><pre class="line-numbers language-none"><code class="language-none">/* * 删除Slice中的元素。 * params: *   s: slice对象，类型为[]interface{} *   index: 要删除元素的索引 * return: *   已经删除指定元素的slice，类型为[]interface{} * 说明：返回的序列与传入的序列地址不发生变化(但是传入的序列内容已经被修改，不能再使用) */func SliceRemove(s []interface{}, index int) []interface{} {return append(s[:index], s[index+1:]...)} /* * 删除Slice中的元素。 * params: *   s: slice对象指针，类型为*[]interface{} *   index: 要删除元素的索引 * return: *   无 * 说明：直接操作传入的Slice对象，传入的序列地址不变，但内容已经被修改 */func SliceRemove2(s *[]interface{}, index int) {*s = append((*s)[:index], (*s)[index+1:]...)} /* * 删除Slice中的元素。 * params: *   s: slice对象的指针，如*[]string, *[]int, ... *   index: 要删除元素的索引 * return: *   true: 删除成功 *   false: 删除失败（不支持的数据类型） * 说明：直接操作传入的Slice对象，不需要转换为[]interface{}类型。 */func SliceRemove3(s interface{}, index int) bool {if ps, ok := s.(*[]string); ok {*ps = append((*ps)[:index], (*ps)[index+1:]...)} else if ps, ok := s.(*[]int); ok {*ps = append((*ps)[:index], (*ps)[index+1:]...)} else if ps, ok := s.(*[]float64); ok {*ps = append((*ps)[:index], (*ps)[index+1:]...)} else {fmt.Printf("&lt;SliceRemove3&gt; Unsupported type: %T\n", s)return false} return true}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="清空"><a href="#清空" class="headerlink" title="清空"></a>清空</h4><pre class="line-numbers language-none"><code class="language-none">/* * 清空Slice，传入的slice对象地址发生变化。 * params: *   s: slice对象指针，类型为*[]interface{} * return: *   无 */func SliceClear(s *[]interface{}) {*s = append([]interface{}{})} /* * 清空Slice，传入的slice对象地址不变。 * params: *   s: slice对象指针，类型为*[]interface{} * return: *   无 */func SliceClear2(s *[]interface{}) {*s = (*s)[0:0]} /* * 清空Slice，传入的slice对象地址不变。 * params: *   s: slice对象的指针，如*[]string, *[]int, ... * return: *   true: 清空成功 *   false: 清空失败（不支持的数据类型） */func SliceClear3(s interface{}) bool {if ps, ok := s.(*[]string); ok {*ps = (*ps)[0:0]//*ps = append([]string{})} else if ps, ok := s.(*[]int); ok {*ps = (*ps)[0:0]//*ps = append([]int{})} else if ps, ok := s.(*[]float64); ok {*ps = (*ps)[0:0]//*ps = append([]float64{})} else {fmt.Printf("&lt;SliceClear3&gt; Unsupported type: %T\n", s)return false} return true}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><h3 id="查看程序运行时间"><a href="#查看程序运行时间" class="headerlink" title="查看程序运行时间"></a>查看程序运行时间</h3><pre class="line-numbers language-none"><code class="language-none">import "time" // 引用time库函数start := time.Now() // 获取当前时间// 被测代码cost := time.Since(start) // 计算此时与start的时间差// time.Now().Sub(start)也可<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查看当前go版本号"><a href="#查看当前go版本号" class="headerlink" title="查看当前go版本号"></a>查看当前go版本号</h3><pre class="line-numbers language-none"><code class="language-none">go version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果要升级版本，直接去官网下载对应的版本就好。但是会直接卸载之前的版本。环境变量一般会自动处理，关闭窗口（vscode,git bash之类的），再打开就能看到已经好了。</p><h3 id="单引号、双引号、反引号"><a href="#单引号、双引号、反引号" class="headerlink" title="单引号、双引号、反引号"></a>单引号、双引号、反引号</h3><p><strong>Golang限定字符或者字符串一共三种引号，单引号（’’)，双引号(“”) 以及反引号(``)。反引号就是标准键盘“Esc”按钮下面的那个键。</strong></p><ul><li><p>单引号，表示byte类型或rune类型，对应 uint8和int32类型，默认是 rune 类型。byte用来强调数据是raw data，而不是数字；而rune用来表示Unicode的code point。</p></li><li><p>双引号，才是字符串，实际上是字符数组。可以用索引号访问某字节，也可以用len()函数来获取字符串所占的字节长度。</p></li><li><p>反引号，表示字符串字面量，但不支持任何转义序列。字面量 raw literal string 的意思是，你定义时写的啥样，它就啥样，你有换行，它就换行。你写转义字符，它也就展示转义字符。</p></li></ul><p><strong>反引号有时候能起到很好的作用，比如一个字符串里面有双引号，分号这种，并且分布的还不规律，用反引号括起来就好</strong></p><h3 id="字符串中包含双引号"><a href="#字符串中包含双引号" class="headerlink" title="字符串中包含双引号"></a>字符串中包含双引号</h3><ol><li><p>反引号</p><pre class="line-numbers language-none"><code class="language-none">str2 := `"www.hewe.vip"`fmt.Println(len(str2))fmt.Println(str2)//输出结果14"www.hewe.vip"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>转义</p><pre class="line-numbers language-none"><code class="language-none">str3 := "\"www.hewe.vip\""fmt.Println(len(str3))fmt.Println(str3)//输出结果14"www.hewe.vip"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>使用strconv包</p><pre class="line-numbers language-none"><code class="language-none">str := strconv.Quote("www.hewe.vip")fmt.Println(len(str))fmt.Println(str1)//输出结果14"www.hewe.vip"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="变量类型转换"><a href="#变量类型转换" class="headerlink" title="变量类型转换"></a>变量类型转换</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">string转成<span class="token keyword">int</span>：<span class="token keyword">int</span><span class="token punctuation">,</span> err <span class="token operator">:</span><span class="token operator">=</span> strconv<span class="token punctuation">.</span><span class="token function">Atoi</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span>string转成int64：int64<span class="token punctuation">,</span> err <span class="token operator">:</span><span class="token operator">=</span> strconv<span class="token punctuation">.</span><span class="token function">ParseInt</span><span class="token punctuation">(</span>string<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">)</span><span class="token keyword">int</span>转成string：string <span class="token operator">:</span><span class="token operator">=</span> strconv<span class="token punctuation">.</span><span class="token function">Itoa</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>int64转成string：string <span class="token operator">:</span><span class="token operator">=</span> strconv<span class="token punctuation">.</span><span class="token function">FormatInt</span><span class="token punctuation">(</span>int64<span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体例子：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">package main<span class="token function">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"strconv"</span><span class="token punctuation">)</span>func <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>cfdversion <span class="token operator">:</span><span class="token operator">=</span><span class="token string">"100"</span>newcfd<span class="token punctuation">,</span>_ <span class="token operator">:</span><span class="token operator">=</span>strconv<span class="token punctuation">.</span><span class="token function">Atoi</span><span class="token punctuation">(</span>cfdversion<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>newcfd<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意事项：<br>1.要导入包<br>2.转换变量类型后要重新用一个名字，不能用之前的变量名<br>3.下划线那个地方是err，被省略了</strong></p><h3 id="判断变量类型"><a href="#判断变量类型" class="headerlink" title="判断变量类型"></a>判断变量类型</h3><p>方法一：</p><pre class="line-numbers language-none"><code class="language-none">package mainimport ( "fmt")func main() {        v1 := "123456"        v2 := 12        fmt.Printf("v1 type:%T\n", v1)        fmt.Printf("v2 type:%T\n", v2)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方法二：</p><pre class="line-numbers language-none"><code class="language-none">package mainimport ( "fmt" "reflect")func main() {        v1 := "123456"        v2 := 12        // reflect        fmt.Println("v1 type:", reflect.TypeOf(v1))        fmt.Println("v2 type:", reflect.TypeOf(v2))}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="判断类型是否为map"><a href="#判断类型是否为map" class="headerlink" title="判断类型是否为map"></a>判断类型是否为map</h3><pre class="line-numbers language-none"><code class="language-none">if reflect.ValueOf(map1).Kind() == reflect.Map {    } else {    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="json相关操作"><a href="#json相关操作" class="headerlink" title="json相关操作"></a>json相关操作</h3><h4 id="发送json格式的http请求"><a href="#发送json格式的http请求" class="headerlink" title="发送json格式的http请求"></a>发送json格式的http请求</h4><p><a href="https://blog.csdn.net/springlustre/article/details/88703851">原链接</a></p><p>发送json为参数的post请求，以结构体为载体<br></p><pre class="line-numbers language-none"><code class="language-none">type RequestBody struct { Id int `json:"id"` Name string `json:"name"` }   func testPost(id int, name string) { request := RequestBody{ Id: id, Name: name, } requestBody := new(bytes.Buffer) json.NewEncoder(requestBody).Encode(request) url := "https://test.com" req, err := http.NewRequest("POST", url, requestBody) req.Header.Set("Content-Type", "application/json") client := &amp;http.Client{} resp, err := client.Do(req) if err != nil { panic(err) } defer resp.Body.Close()   fmt.Println("response Status:", resp.Status) fmt.Println("response Headers:", resp.Header) body, _ := ioutil.ReadAll(resp.Body) fmt.Println("response Body:", string(body)) }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="解析json文件"><a href="#解析json文件" class="headerlink" title="解析json文件"></a>解析json文件</h4><pre class="line-numbers language-none"><code class="language-none">package mainimport (// "bytes""encoding/json""fmt""io/ioutil"// "reflect")func con_var_name (key string) string {var res stringbytes,_:=ioutil.ReadFile("C:/Users/76585/Desktop/para_compare_ver2.json")m :=make(map[string]interface{})err := json.Unmarshal([]byte(bytes),&amp;m)if err != nil {fmt.Println("err=",err)return ""}for _, value :=range m{// fmt.Println(reflect.TypeOf(value.([]interface{})[1].(map[string]interface{})["name"]))if key==value.([]interface{})[0].(map[string]interface{})["name"]{res=keyreturn res}if key==value.([]interface{})[1].(map[string]interface{})["name"]{tmp :=value.([]interface{})[0].(map[string]interface{})["name"]res=tmp.(string)return res}}res=keyreturn res}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="解析json文件，interface转int"><a href="#解析json文件，interface转int" class="headerlink" title="解析json文件，interface转int"></a>解析json文件，interface转int</h4><p><strong>因为json解析得到的数据是map[string]interface，里面的字段可能是数字，有时候需要取出来比较，<br>就需要将interface转为int。</strong><br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20230522150849.png" alt=""><br>需要先转为string，再用 <code>strconv.Atoi</code>，将string转为int。</p><h4 id="结构体解析为json"><a href="#结构体解析为json" class="headerlink" title="结构体解析为json"></a>结构体解析为json</h4><p>先上代码</p><p><strong>最为关键的是结构体里面的成员变量名，首字母必须是大写，否则无法解析，解析出来的是空。</strong></p><pre class="line-numbers language-none"><code class="language-none">package mainimport ("encoding/json""fmt")type Product struct {Name stringProductId int64Number intPrice float64IsOnSale bool}func main()  {var p Product// p := Product{}p.Name="apple"p.ProductId=1p.Number=100p.Price=3.45p.IsOnSale=falsedata, _ := json.Marshal(&amp;p)fmt.Println(string(data))}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="将json字符串解码到相应的数据结构"><a href="#将json字符串解码到相应的数据结构" class="headerlink" title="将json字符串解码到相应的数据结构"></a>将json字符串解码到相应的数据结构</h4><pre class="line-numbers language-none"><code class="language-none">type StuRead struct {    Name  interface{} `json:"name"`    Age   interface{}    HIgh  interface{}    sex   interface{}    Class interface{} `json:"class"`    Test  interface{}}type Class struct {    Name  string    Grade int}func main() {    //json字符中的"引号，需用\进行转义，否则编译出错    //json字符串沿用上面的结果，但对key进行了大小的修改，并添加了sex数据    data:="{\"name\":\"张三\",\"Age\":18,\"high\":true,\"sex\":\"男\",\"CLASS\":{\"naME\":\"1班\",\"GradE\":3}}"    str:=[]byte(data)    //1.Unmarshal的第一个参数是json字符串，第二个参数是接受json解析的数据结构。    //第二个参数必须是指针，否则无法接收解析的数据，如stu仍为空对象StuRead{}    //2.可以直接stu:=new(StuRead),此时的stu自身就是指针    stu:=StuRead{}    err:=json.Unmarshal(str,&amp;stu)    //解析失败会报错，如json字符串格式不对，缺"号，缺}等。    if err!=nil{        fmt.Println(err)    }    fmt.Println(stu)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="map转json-1"><a href="#map转json-1" class="headerlink" title="map转json"></a>map转json</h4><p>例子在前面 <strong>基本数据类型操作-》map相关操作</strong></p><h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><pre class="line-numbers language-none"><code class="language-none">package main​import (    "fmt"    "strings")​func main() {    s := "smallming"    //第一次出现的索引    fmt.Println(strings.Index(s, "l"))    //最后一次出现的索引    fmt.Println(strings.LastIndex(s, "l"))    //是否以指定内容开头    fmt.Println(strings.HasPrefix(s, "small"))    //是否以指定内容结尾    fmt.Println(strings.HasSuffix(s, "ming"))    //是否包含指定字符串    fmt.Println(strings.Contains(s, "mi"))    //全变小写    fmt.Println(strings.ToLower(s))    //全大写    fmt.Println(strings.ToUpper(s))    //把字符串中前n个old子字符串替换成new字符串,如果n小于0表示全部替换.    //如果n大于old个数也表示全部替换    fmt.Println(strings.Replace(s, "m", "k", -1))    //把字符串重复count遍    fmt.Println(strings.Repeat(s, 2))    //去掉字符串前后指定字符    fmt.Println(strings.Trim(s, " ")) //去空格可以使用strings.TrimSpace(s)    //根据指定字符把字符串拆分成切片    fmt.Println(strings.Split(s, "m"))    //使用指定分隔符把切片内容合并成字符串    arr := []string{"small", "ming"}    fmt.Println(strings.Join(arr, ""))}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h3><pre class="line-numbers language-none"><code class="language-none">str = strings.Replace(str, " ", "", -1)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>func Replace(s, old, new string, n int) string</p><p><strong>返回将s中前n个不重叠old子串都替换为new的新字符串，如果n&lt;0会替换所有old子串</strong></p><h3 id="字符串处理函数"><a href="#字符串处理函数" class="headerlink" title="字符串处理函数"></a>字符串处理函数</h3><p>Golang中的strings包：<br></p><pre class="line-numbers language-none"><code class="language-none">Count(s string, str string) int：计算字符串str在s中的非重叠个数。如果str为空串则返回s中的字符（非字节）个数+1。Index(s string, str string) int ：返回子串str在字符串s中第一次出现的位置。如果找不到则返回-1；如果str为空，则返回0。LastIndex(s string, str string) int： 返回子串str在字符串s中最后一次出现的位置。如果找不到则返回-1；如果str为空则返回字符串s的长度。IndexRune(s string, r rune) int ：返回字符r在字符串s中第一次出现的位置。如果找不到则返回-1。IndexAny(s string, str string) int ：返回字符串str中的任何一个字符在字符串s中第一次出现的位置。如果找不到或str为空则返回-1。LastIndexAny(s string, str string) int： 返回字符串str中的任何一个字符在字符串s中最后一次出现的位置。如果找不到或str为空则返回-1。Contains(s string, str string) bool：判断字符串s中是否包含个子串str。包含或者str为空则返回true。ContainsAny(s string, str string) bool：判断字符串s中是否包含个子串str中的任何一个字符。包含则返回true，如果str为空则返回false。ContainsRune(s string, r rune) bool：判断字符串s中是否包含字符r。SplitN(s, str string, n int) []string：以str为分隔符，将s切分成多个子串，结果中**不包含**str本身。如果str为空则将s切分成Unicode字符列表。如果s中没有str子串，则将整个s作为[]string的第一个元素返回。参数n表示最多切分出几个子串，超出的部分将不再切分，最后一个n包含了所有剩下的不切分。如果n为0，则返回nil；如果n小于0，则不限制切分个数，全部切分。SplitAfterN(s, str string, n int) []string：以str为分隔符，将s切分成多个子串，结果中**包含**str本身。如果str为空，则将s切分成Unicode字符列表。如果s 中没有str子串，则将整个s作为 []string 的第一个元素返回。参数n表示最多切分出几个子串，超出的部分将不再切分。如果n为0，则返回 nil；如果 n 小于 0，则不限制切分个数，全部切分。Split(s, str string) []string：以str为分隔符，将s切分成多个子切片，结果中**不包含**str本身。如果str为空，则将s切分成Unicode字符列表。如果s中没有str子串，则将整个s作为[]string的第一个元素返回。SplitAfter(s, str string) []string：以str为分隔符，将s切分成多个子切片，结果中**包含**str本身。如果 str 为空，则将 s 切分成Unicode字符列表。如果s中没有str子串，则将整个s作为[]string的第一个元素返回。Fields(s string) []string：以连续的空白字符为分隔符，将s切分成多个子串，结果中不包含空白字符本身。空白字符有：\t, \n, \v, \f, \r, ’ ‘, U+0085 (NEL), U+00A0 (NBSP) 。如果 s 中只包含空白字符，则返回一个空列表。FieldsFunc(s string, f func(rune) bool) []string：以一个或多个满足f(rune)的字符为分隔符，将s切分成多个子串，结果中不包含分隔符本身。如果s中没有满足f(rune)的字符，则返回一个空列表。Join(s []string, str string) string：将s中的子串连接成一个单独的字符串，子串之间用str分隔。HasPrefix(s string, prefix string) bool：判断字符串s是否以prefix开头。HasSuffix(s, suffix string) bool ：判断字符串s是否以prefix结尾。Map(f func(rune) rune, s string) string：将s中满足f(rune)的字符替换为f(rune)的返回值。如果f(rune)返回负数，则相应的字符将被删除。Repeat(s string, n int) string：将n个字符串s连接成一个新的字符串。ToUpper(s string) string：将s中的所有字符修改为其大写格式。对于非ASCII字符，它的大写格式需要查表转换。ToLower(s string) string：将s中的所有字符修改为其小写格式。对于非ASCII字符，它的小写格式需要查表转换。ToTitle(s string) string：将s中的所有字符修改为其Title格式，大部分字符的Title格式就是Upper格式，只有少数字符的Title格式是特殊字符。这里的ToTitle主要给Title函数调用。TrimLeftFunc(s string, f func(rune) bool) string：删除s头部连续的满足f(rune)的字符。TrimRightFunc(s string, f func(rune) bool) string：删除s尾部连续的满足f(rune)的字符。TrimFunc(s string, f func(rune) bool) string：删除s首尾连续的满足f(rune)的字符。IndexFunc(s string, f func(rune) bool) int：返回s中第一个满足f(rune) 的字符的字节位置。如果没有满足 f(rune) 的字符，则返回 -1。LastIndexFunc(s string, f func(rune) bool) int：返回s中最后一个满足f(rune)的字符的字节位置。如果没有满足 f(rune) 的字符，则返回 -1。Trim(s string, str string) string：删除s首尾连续的包含在str中的字符。TrimLeft(s string, str string) string：删除s头部连续的包含在str中的字符串。TrimRight(s string, str string) string：删除s尾部连续的包含在str中的字符串。TrimSpace(s string) string：删除s首尾连续的的空白字符。TrimPrefix(s, prefix string) string：删除s头部的prefix字符串。如果s不是以prefix开头，则返回原始s。TrimSuffix(s, suffix string) string：删除s尾部的suffix字符串。如果s不是以suffix结尾，则返回原始s。（只去掉一次，注意和TrimRight区别）Replace(s, old, new string, n int) string：返回s的副本，并将副本中的old字符串替换为new字符串，替换次数为n次，如果n为-1，则全部替换；如果 old 为空，则在副本的每个字符之间都插入一个new。EqualFold(s1, s2 string) bool：比较UTF-8编码在小写的条件下是否相等，不区分大小写，同时它还会对特殊字符进行转换。比如将“ϕ”转换为“Φ”、将“Ǆ”转换为“ǅ”等，然后再进行比较。“==”比较字符串是否相等，区分大小写，返回bool。Compare(s1 string, s2 string) int1：比较字符串，区分大小写，比”==”速度快。相等为0，不相等为-1。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><h4 id="常用的元字符："><a href="#常用的元字符：" class="headerlink" title="常用的元字符："></a>常用的元字符：</h4><pre class="line-numbers language-none"><code class="language-none">. 匹配除换行符以外的任意字符\w 匹配字母或数字或下划线或汉字\s 匹配任意的空白符\d 匹配数字\b 匹配单词的开始或结束^ 匹配字符串的开始$ 匹配字符串的结束<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>字符转义：</p><p>如果你想查找元字符本身的话，比如你查找.,或者<em>,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时你就得使用\来取消这些字符的特殊意义。因此，你应该使用.和\</em>。当然，要查找\本身，你也得用\。</p><h4 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h4><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20230522150907.png" alt=""></p><p>如果你想匹配没有预定义元字符的字符集合(比如元音字母a,e,i,o,u),应该怎么办？</p><p>很简单，你只需要在方括号里列出它们就行了，像[aeiou]就匹配任何一个英文元音字母，[.?!]匹配标点符号(.或?或!)。</p><p><strong>分枝条件：</strong></p><p>正则表达式里的分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用 “|”  把不同的规则分隔开。</p><p><strong>分组：</strong></p><p>重复单个字符（直接在字符后面加上限定符就行了）；但如果想要重复多个字符又该怎么办？你可以用小括号来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作。</p><h4 id="反义字符"><a href="#反义字符" class="headerlink" title="反义字符"></a>反义字符</h4><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20230522150926.png" alt=""><br>例子：\S+匹配不包含空白符的字符串。</p><p><a[^>]+&gt;匹配用尖括号括起来的以a开头的字符串。</a[^></p><h4 id="常用的正则表达式函数："><a href="#常用的正则表达式函数：" class="headerlink" title="常用的正则表达式函数："></a>常用的正则表达式函数：</h4><pre class="line-numbers language-none"><code class="language-none">reg = regexp.MustCompile(`匹配模式`)reg.FindAllString( )reg.ReplaceAllString(）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><pre class="line-numbers language-none"><code class="language-none">func main() {text := `Hello 世界！123 Go.` // 查找连续的小写字母reg := regexp.MustCompile(`[a-z]+`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["ello" "o"] // 查找连续的非小写字母reg = regexp.MustCompile(`[^a-z]+`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["H" " 世界！123 G" "."] // 查找连续的单词字母reg = regexp.MustCompile(`[\w]+`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["Hello" "123" "Go"] // 查找连续的非单词字母、非空白字符reg = regexp.MustCompile(`[^\w\s]+`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["世界！" "."] // 查找连续的大写字母reg = regexp.MustCompile(`[[:upper:]]+`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["H" "G"] // 查找连续的非 ASCII 字符reg = regexp.MustCompile(`[[:^ascii:]]+`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["世界！"] // 查找连续的标点符号reg = regexp.MustCompile(`[\pP]+`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["！" "."] // 查找连续的非标点符号字符reg = regexp.MustCompile(`[\PP]+`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["Hello 世界" "123 Go"] // 查找连续的汉字reg = regexp.MustCompile(`[\p{Han}]+`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["世界"] // 查找连续的非汉字字符reg = regexp.MustCompile(`[\P{Han}]+`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["Hello " "！123 Go."] // 查找 Hello 或 Goreg = regexp.MustCompile(`Hello|Go`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["Hello" "Go"] // 查找行首以 H 开头，以空格结尾的字符串reg = regexp.MustCompile(`^H.*\s`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["Hello 世界！123 "] // 查找行首以 H 开头，以空白结尾的字符串（非贪婪模式）reg = regexp.MustCompile(`(?U)^H.*\s`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["Hello "] // 查找以 hello 开头（忽略大小写），以 Go 结尾的字符串reg = regexp.MustCompile(`(?i:^hello).*Go`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["Hello 世界！123 Go"] // 查找 Go.reg = regexp.MustCompile(`\QGo.\E`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["Go."] // 查找从行首开始，以空格结尾的字符串（非贪婪模式）reg = regexp.MustCompile(`(?U)^.* `)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["Hello "] // 查找以空格开头，到行尾结束，中间不包含空格字符串reg = regexp.MustCompile(` [^ ]*$`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// [" Go."] // 查找“单词边界”之间的字符串reg = regexp.MustCompile(`(?U)\b.+\b`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["Hello" " 世界！" "123" " " "Go"] // 查找连续 1 次到 4 次的非空格字符，并以 o 结尾的字符串reg = regexp.MustCompile(`[^ ]{1,4}o`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["Hello" "Go"] // 查找 Hello 或 Goreg = regexp.MustCompile(`(?:Hell|G)o`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["Hello" "Go"] // 查找 Hello 或 Go，替换为 Hellooo、Goooreg = regexp.MustCompile(`(?PHell|G)o`)fmt.Printf("%q\n", reg.ReplaceAllString(text, "${n}ooo"))// "Hellooo 世界！123 Gooo." // 交换 Hello 和 Goreg = regexp.MustCompile(`(Hello)(.*)(Go)`)fmt.Printf("%q\n", reg.ReplaceAllString(text, "$3$2$1"))// "Go 世界！123 Hello." // 特殊字符的查找reg = regexp.MustCompile(`[\f\t\n\r\v\123\x7F\x{10FFFF}\\\^\$\.\*\+\?\{\}\(\)\[\]\|]`)fmt.Printf("%q\n", reg.ReplaceAllString("\f\t\n\r\v\123\x7F\U0010FFFF\\^$.*+?{}()[]|", "-"))// "----------------------"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="按行读文件"><a href="#按行读文件" class="headerlink" title="按行读文件"></a>按行读文件</h3><p><strong>注意下这里的第二个方法，读到最后字符串为空，有时候可能会报错（被坑过），加一个判断条件，判断长度是否为0。（代码里面自己已经加了）</strong><br></p><pre class="line-numbers language-none"><code class="language-none">func Readlines(filename string) {// go 按行读取文件的方式有两种，// 第一 将读取到的整个文件内容按照 \n 分割// 使用bufio// 第一种lines, err := ioutil.ReadFile(filename)if err != nil {fmt.Println(err)} else {contents := string(lines)lines := strings.Split(contents, "\n")for _, line := range lines {fmt.Println(line)}}// 第二种fd, err := os.Open(filename)defer fd.Close()if err != nil {fmt.Println("read error:", err)}buff := bufio.NewReader(fd)for {data, _, eof := buff.ReadLine()if eof == io.EOF {break}if(len(data)==0){           break        }fmt.Println(string(data))}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h3 id="字符串与切片的转换"><a href="#字符串与切片的转换" class="headerlink" title="字符串与切片的转换"></a>字符串与切片的转换</h3><pre class="line-numbers language-none"><code class="language-none">package mainimport ("fmt""strings")func main() {s := []string{"1", "2", "3"}ss := fmt.Sprintf(strings.Join(s, ","))fmt.Println(ss)slice := strings.Split(ss, ",")fmt.Println(slice)//r := gin.Default()//r.GET("/", func(context *gin.Context) {//context.JSON(http.StatusOK,gin.H{//"message":"demo",//})//})//r.Run()}//D:\GoProject\gin-demo&gt;go run main.go//1,2,3//[1 2 3]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><p><a href="https://www.cnblogs.com/believepd/p/10951763.html">原文链接</a></p><h4 id="打开关闭文件"><a href="#打开关闭文件" class="headerlink" title="打开关闭文件"></a>打开关闭文件</h4><pre class="line-numbers language-none"><code class="language-none">import (    "fmt"    "os")func main() {    // 打开文件    file, err := os.Open("e:/a.txt")    if err != nil {        fmt.Printf("打开文件出错：%v\n", err)    }    fmt.Println(file) // &amp;{0xc00006a780}    // 关闭文件    err = file.Close()    if err != nil {        fmt.Printf("关闭文件出错：%v\n", err)    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h4><p><strong>法一：带缓冲</strong></p><pre class="line-numbers language-none"><code class="language-none">import (    "bufio"    "fmt"    "io"    "os")func main() {    // 打开文件    file, err := os.Open("e:/a.txt")    if err != nil {        fmt.Printf("打开文件出错：%v\n", err)    }    // 及时关闭文件句柄    defer file.Close()    // bufio.NewReader(rd io.Reader) *Reader    reader := bufio.NewReader(file)    // 循环读取文件的内容    for {        line, err := reader.ReadString('\n') // 读到一个换行符就结束        if err == io.EOF { // io.EOF表示文件的末尾            break        }        // 输出内容        fmt.Print(line)    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>法二：一次性读入，不适用于大文件</strong></p><pre class="line-numbers language-none"><code class="language-none">import (    "fmt"    "io/ioutil")func main() {    // 使用 io/ioutil.ReadFile 方法一次性将文件读取到内存中    filePath := "e:/.txt"    content, err := ioutil.ReadFile(filePath)    if err != nil {        // log.Fatal(err)        fmt.Printf("读取文件出错：%v", err)    }    fmt.Printf("%v\n", content)    fmt.Printf("%v\n", string(content))}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h4><p>示例1：<br>创建一个新文件，写入3行：”Hello World”<br>打开一个存在的文件，将原来的内容覆盖成新的内容，3行：”你好，世界”<br>打开一个存在的文件，在原来的内容基础上，追加3行：”你好，Golang”<br>打开一个存在的文件，将原来的内容读出显示在终端，并且追加3行：”你好，World”</p><pre class="line-numbers language-none"><code class="language-none">import (    "bufio"    "fmt"    "os")func main() {    filePath := "e:/a.txt" // 此文件事先不存在    file, err := os.OpenFile(filePath, os.O_WRONLY | os.O_CREATE, 0666) // O_CREATE 能创建文件    if err != nil {        fmt.Printf("打开文件出错：%v", err)        return    }    // 及时关闭文件句柄    defer file.Close()    // 准备写入的内容    str := "Hello World\r\n"    // 写入时，使用带缓冲方式的 bufio.NewWriter(w io.Writer) *Writer    writer := bufio.NewWriter(file)    // 使用for循环写入内容    for i := 0; i &lt; 3; i++ {        _, err := writer.WriteString(str) // func (b *Writer) WriteString(s string) (int, error)        if err != nil {            fmt.Printf("文件写入出错：%s", err)        }    }    // 因为 writer 是带缓存的，所以需要 Flush 方法将缓冲中的数据真正写入到文件中    _ = writer.Flush()}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将 O_CREATE 修改为 O_TRUNC 模式即可，表示：打开文件并清空内容<br>将 O_TRUNC 修改为 O_APPEND 模式即可，表示：打开文件并在最后追加内容</p><pre class="line-numbers language-none"><code class="language-none">import (    "bufio"    "fmt"    "io"    "os")func main() {    filePath := "e:/a.txt"    file, err := os.OpenFile(filePath, os.O_RDWR | os.O_APPEND, 0666)    if err != nil {        fmt.Printf("打开文件出错：%v", err)        return    }    defer file.Close()    // 先读取原来文件的内容，并显示在终端    reader := bufio.NewReader(file)    for {        str, err := reader.ReadString('\n') // 读到一个换行符就结束        if err == io.EOF { // io.EOF表示文件的末尾            break        }        // 输出内容        fmt.Print(str)    }    // 准备写入的内容    str := "你好，World\r\n"    // 写入时，使用带缓冲方式的 bufio.NewWriter(w io.Writer) *Writer    writer := bufio.NewWriter(file)    // 使用for循环写入内容    for i := 0; i &lt; 3; i++ {        _, err := writer.WriteString(str) // func (b *Writer) WriteString(s string) (int, error)        if err != nil {            fmt.Printf("文件写入出错：%s", err)        }    }    // 因为 writer 是带缓存的，所以需要 Flush 方法将缓冲中的数据真正写入到文件中    _ = writer.Flush()}4：读写模式（O_RDWR）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例二：将一个文件写道另一个文件（两个文件均存在）</p><pre class="line-numbers language-none"><code class="language-none">import (    "fmt"    "io/ioutil")func main() {    filePath1 := "e:/a.txt"    filePath2 := "e:/b.txt"    content, err := ioutil.ReadFile(filePath1)    if err != nil {        fmt.Printf("读取文件出错：%v", err)        return    }    err = ioutil.WriteFile(filePath2, content, 0666)    if err != nil {        fmt.Printf("写入文件出错：%v", err)        return    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="替换文件某一行内容"><a href="#替换文件某一行内容" class="headerlink" title="替换文件某一行内容"></a>替换文件某一行内容</h4><pre class="line-numbers language-none"><code class="language-none">package mainimport (        "io/ioutil"        "log"        "strings")func main() {        input, err := ioutil.ReadFile("C:/Users/76585/Desktop/key.hypara")        if err != nil {                log.Fatalln(err)        }        lines := strings.Split(string(input), "\n")        for i, line := range lines {                if strings.Contains(line, "nsimutask") {                    lines[i] = "int    nsimutask          =   0;"                }if strings.Contains(line, "string parafilename") {lines[i] = "string parafilename       =   \"../bin/grid_para.hypara\";"break}        }        output := strings.Join(lines, "\n")        err = ioutil.WriteFile("C:/Users/76585/Desktop/key.hypara", []byte(output), 0644)        if err != nil {                log.Fatalln(err)        }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="判断文件是否存在"><a href="#判断文件是否存在" class="headerlink" title="判断文件是否存在"></a>判断文件是否存在</h4><p>golang判断文件或文件夹是否存在的方法为使用 os.Stat() 函数返回的错误值进行判断：</p><p>如果返回的错误为 nil，说明文件或文件夹存在；<br>如果返回的错误类型使用 os.IsNotExist() 判断为 true，说明文件或文件夹不存在；<br>如果返回的错误为其他类型，则不确定是否存在。</p><pre class="line-numbers language-none"><code class="language-none">package mainimport (    "fmt"    "os")// 判断文件或文件夹是否存在func PathExist(path string) (bool, error) {    _, err := os.Stat(path)    if err == nil {        return true, nil    }    if os.IsNotExist(err) {        return false, nil    }    return false, err}func main() {    filePath := "e:/a.txt"    flag, err := PathExist(filePath)    if err != nil {        fmt.Println(err)    }    fmt.Println(flag) // true}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="拷贝文件"><a href="#拷贝文件" class="headerlink" title="拷贝文件"></a>拷贝文件</h4><p>将src的数据拷贝到dst，直到在src上到达EOF或发生错误。返回拷贝的字节数和遇到的第一个错误。</p><p>对成功的调用，返回值err为nil而非EOF，因为Copy定义为从src读取直到EOF，它不会将读取到EOF视为应报告的错误。如果src实现了WriterTo接口，本函数会调用src.WriteTo(dst)进行拷贝；否则如果dst实现了ReaderFrom接口，本函数会调用dst.ReadFrom(src)进行拷贝。<br></p><pre class="line-numbers language-none"><code class="language-none">package mainimport (    "bufio"    "fmt"    "io"    "os")// 将 srcFilePath 拷贝到 dstFilePathfunc CopyFile(dstFilePath string, srcFilePath string) (written int64, err error) {    // 打开srcFilePath    srcFile, err := os.Open(srcFilePath)    if err != nil {        fmt.Printf("打开文件出错：%s\n", err)        return    }    defer srcFile.Close()    // 通过 bufio/NewReader，传入 srcFile，获取到 reader    reader := bufio.NewReader(srcFile)    // 打开dstFilePath    dstFile, err := os.OpenFile(dstFilePath, os.O_WRONLY | os.O_CREATE, 0666)    if err != nil {        fmt.Printf("打开文件出错：%s\n", err)        return    }    defer dstFile.Close()    // 通过 bufio/NewWriter，传入 dstFile，获取到 writer    writer := bufio.NewWriter(dstFile)    return io.Copy(writer, reader)}func main() {    srcFilePath := "e:/a.mp4"    dstFilePath := "f:/b.mp4"    _, err := CopyFile(dstFilePath, srcFilePath)    if err != nil {        fmt.Printf("拷贝文件出错：%s", err)    }    fmt.Println("拷贝文件完成")}自己写一个函数完成拷贝文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="读取文件最后一行"><a href="#读取文件最后一行" class="headerlink" title="读取文件最后一行"></a>读取文件最后一行</h4><pre class="line-numbers language-none"><code class="language-none">func ReadFile(file_name string) (info string) {    file, err := os.Open(file_name)    if err != nil {        log.Fatal(err)    }    defer file.Close()    var lineText string    scanner := bufio.NewScanner(file)    for scanner.Scan() {        lineText = scanner.Text()        //fmt.Print(lineText)    }    return string(lineText)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="遍历目录"><a href="#遍历目录" class="headerlink" title="遍历目录"></a>遍历目录</h3><pre class="line-numbers language-none"><code class="language-none">package mainimport (    "fmt"    "os")func main() {    fmt.Println("请输入一个目录的路径：")    var path string    _, _ = fmt.Scan(&amp;path)    // 打开目录    f, err := os.OpenFile(path, os.O_RDONLY, os.ModeDir)    if err != nil {        fmt.Printf("Open file failed:%s.\n", err)        return    }    defer f.Close()    // 读取目录    info, err := f.Readdir(-1) // -1 表示读取目录中所有目录项    // 遍历返回的切片    for _, fileInfo := range info {        if fileInfo.IsDir() {            fmt.Printf("%s是一个目录\n", fileInfo.Name())        } else {            fmt.Printf("%s是一个文件\n", fileInfo.Name())        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>统计一个文件中含有的英文、数字、空格以及其他字符数量。</p><pre class="line-numbers language-none"><code class="language-none">package mainimport (    "bufio"    "fmt"    "io"    "os")// 定义一个结构体，用于保存统计结果type CharCount struct {    AlphaCount     int // 记录英文个数    NumCount     int // 记录数字的个数    SpaceCount     int // 记录空格的个数    OtherCount     int // 记录其它字符的个数}func main() {    // 思路: 打开一个文件, 创一个 reader    // 每读取一行，就去统计该行有多少个 英文、数字、空格和其他字符    // 然后将结果保存到一个结构体    filePath := "e:/a.txt"    file, err := os.Open(filePath)    if err != nil {        fmt.Printf("打开文件出错：%s\n", err)        return    }    defer file.Close()    // 定义一个 CharCount 实例    var count CharCount    //创建一个Reader    reader := bufio.NewReader(file)    // 开始循环的读取文件的内容    for {        line, err := reader.ReadString('\n')        if err == io.EOF { // 读到文件末尾就退出            break        }        // 遍历每一行（line），进行统计        for _, v := range line {            switch {                case v &gt;= 'a' &amp;&amp; v &lt;= 'z':                    fallthrough // 穿透                case v &gt;= 'A' &amp;&amp; v &lt;= 'Z':                    count.AlphaCount++                case v &gt;= '0' &amp;&amp; v &lt;= '9':                    count.NumCount++                case v == ' ' || v == '\t':                    count.SpaceCount++                default :                    count.OtherCount++            }        }    }    // 输出统计的结果看看是否正确    fmt.Printf("字符的个数为：%v\n数字的个数为：%v\n空格的个数为：%v\n其它字符个数：%v\n",        count.AlphaCount, count.NumCount, count.SpaceCount, count.OtherCount)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="问题或其他知识"><a href="#问题或其他知识" class="headerlink" title="问题或其他知识"></a>问题或其他知识</h2><h3 id="使用grpcurl"><a href="#使用grpcurl" class="headerlink" title="使用grpcurl"></a>使用grpcurl</h3><p><a href="https://zhuanlan.zhihu.com/p/415775403">原链接</a></p><p>如果准备使用docker来运行，那么pull完成后，使用下面的命令:<br></p><pre class="line-numbers language-none"><code class="language-none">docker run fullstorydev/grpcurl ip:"端口" list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>“ip”和“端口” 记得替换<p></p><h3 id="map类型interface-转换"><a href="#map类型interface-转换" class="headerlink" title="map类型interface{}转换"></a>map类型interface{}转换</h3><p>有时候我们在map里面嵌套map<br>想取内存map的值就会出现以下问题</p><pre class="line-numbers language-none"><code class="language-none">cannot range over v (type interface {})<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>interface{} 与其他数据类型不能直接赋值</p><p><strong>解决方法</strong></p><ol><li><p>转为map</p><pre class="line-numbers language-none"><code class="language-none">v.(map[string] interface {})<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>转为int<br><code>value.(int)</code><br>在目标变量后面用. 括号int</p></li><li>转为map</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令</title>
      <link href="/posts/48230/"/>
      <url>/posts/48230/</url>
      
        <content type="html"><![CDATA[<h2 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h2><h3 id="修改文件用户组"><a href="#修改文件用户组" class="headerlink" title="修改文件用户组"></a>修改文件用户组</h3><p>chgrp： change group的简写，修改文件所属的用户组。<br></p><pre class="line-numbers language-none"><code class="language-none">chgrp users test.log<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p><p>如果要修改该目录下所有文件和目录，使用-R参数。<br></p><pre class="line-numbers language-none"><code class="language-none">chgrp -R users test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p><h3 id="修改文件所有者"><a href="#修改文件所有者" class="headerlink" title="修改文件所有者"></a>修改文件所有者</h3><p>chown ：change owner的简写， 修改文件的所有者。<br></p><pre class="line-numbers language-none"><code class="language-none">chown [-R] 账号名称  文件或目录<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p><p>将所有者和组名称都修改为root。<br></p><pre class="line-numbers language-none"><code class="language-none">chown root:root test.log<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p><h3 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h3><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/f08c5be5513c4aea88cb3c13b3a2b3d7.png" alt=""></p><h2 id="运行sh文件命令"><a href="#运行sh文件命令" class="headerlink" title="运行sh文件命令"></a>运行sh文件命令</h2><p><strong>第一种（这种办法需要用chmod使得文件具备执行条件(x): chmod u+x datelog.sh）：</strong></p><pre class="line-numbers language-none"><code class="language-none">/xx/xxx/xxx.sh   //任意路径 ./XXX.sh  //当前路径<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>第二种（这种办法不需要文件具备可执行的权限也可运行）：</strong></p><pre class="line-numbers language-none"><code class="language-none">sh xxx.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="解压缩命令"><a href="#解压缩命令" class="headerlink" title="解压缩命令"></a>解压缩命令</h2><h3 id="ZIP"><a href="#ZIP" class="headerlink" title="ZIP"></a>ZIP</h3><pre class="line-numbers language-none"><code class="language-none">zip [选项] 压缩包名 源文件或源目录-r：压缩目录示例：zip ana.zip anaconda-ks.cfg压缩多个文件：zip test.zip abc abcd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">zip对应的解压缩命令为unzip：命令所在目录为/usr/bin/unzip，所有用户可执行unzip [选项] 压缩包名-d：指定解压缩位置-o:不必先询问用户，unzip执行后覆盖原有文件。//其它参数可自行查看unzip -d /tmp/ test.zipunzip -d /tmp -o test.zip //这条命令和上一条相比，可以不用询问直接覆盖<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="gz"><a href="#gz" class="headerlink" title="gz"></a>gz</h3><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20190604225601664.png" alt=""><br>注意：使用gzip压缩文件后会将原文件删除，如果想保留原文件则可以使用-c选项将压缩过程产生的标准输出写入一个新的文件中，示例如下：&gt;的作用是覆盖内容，&gt;&gt;的作用是追加内容<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20190604230304985.png" alt=""><br>压缩目录下的每个文件：下述命令会将123这个目录下的每个文件分别进行压缩，而不是将整个123目录进行压缩，也就是说<strong>gzip命令不会打包压缩</strong></p><p>解压缩也可以使用gunzip：<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20190604225930966.png" alt=""></p><h3 id="bz2"><a href="#bz2" class="headerlink" title="bz2"></a>bz2</h3><p>.bz2格式是Linux中的另一种常用压缩格式，该格式的压缩算法更先进，压缩比更高，但是压缩的时间要比.gz长，.bz2格式的压缩命令是bzip2，<strong>注意bzip2不能压缩目录，会报错</strong></p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20190604231244456.png" alt=""><br>解压时如果原文件已存在则会报错，因此最好先将原文件删除</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20190604231835998.png" alt=""></p><h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><p><strong>只是打包并不会压缩文件，.gz，.xz。这些才是压缩</strong><br>.tar格式的打包和解打包都是使用tar命令，区别只是选项不同<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20190604232717559.png" alt=""><br>打包示例：<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20190604232744240.png" alt=""><br>打包多个文件：<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20190604232921456.png" alt=""><br>解打包：<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20190604232957741.png" alt=""></p><h3 id="tar-gz和-tar-bz2"><a href="#tar-gz和-tar-bz2" class="headerlink" title=".tar.gz和.tar.bz2"></a>.tar.gz和.tar.bz2</h3><p><strong>tar 压缩、解压缩都可以使用多线程</strong></p><p>.tar.gz格式和.tar.bz2格式：使用tar命令后跟选项的方式实现tar命令和gzip或者bzip2命令的组合，实现同时进行打包和压缩，这也是最经常使用的压缩和解压缩方式<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20190604233644257.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20190604233704887.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20190604234051220.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20190604234541328.png" alt=""></p><h3 id="tar-xz"><a href="#tar-xz" class="headerlink" title=".tar.xz"></a>.tar.xz</h3><p>默认压缩后的文件后缀为 xz，速度慢一些，但是压缩的会更小。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">//常用参数-z强制执行压缩, 默认不保留源文件。压缩后的文件名为源文件.xz-d强制执行解压缩-l列出压缩文件的信息-k保留源文件不要删除-f强制覆盖输出文件和压缩链接-c写入到标准输出，输入文件不要删除-0<span class="token punctuation">..</span>-9压缩比例，默认为6-e  使用更多的 CPU <span class="token function">time</span> 来进行压缩，提高压缩率。不会影响解压时所需要的内存。-T  指定线程数，默认是 <span class="token number">1</span> ，当设置为 <span class="token number">0</span> 时使用和机器核心一样多的线程。--format<span class="token operator">=</span>  指定压缩输出格式，可以是 raw、xz、lzma-v显示更详细的信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意点： 压缩后的文件时在和源文件同一个目录。当我们压缩的文件为 /home/nginx/logs/error.log-20191126 ，当我们在任意目录执行完 xz /home/nginx/logs/error.log-20191126 后，压缩后的文件路径是 /home/nginx/logs/error.log-20191126.xz.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">//不保留源文件xz   /home/nginx/logs/error.log-20191126//保留源文件xz -k /home/nginx/logs/error.log-20191126//解压缩文件xz -d  /home/nginx/logs/error.log-20191126.xz//指定多线程数来进行压缩xz -T <span class="token number">4</span>  /home/nginx/logs/error.log-20191126<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="查询或查看命令汇总"><a href="#查询或查看命令汇总" class="headerlink" title="查询或查看命令汇总"></a>查询或查看命令汇总</h2><h3 id="查看某个软件对应的软连接"><a href="#查看某个软件对应的软连接" class="headerlink" title="查看某个软件对应的软连接"></a>查看某个软件对应的软连接</h3><pre class="line-numbers language-none"><code class="language-none">ls -l "xxxx"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用<code>ls -al</code>也可也，那就是查看整个目录下面的。</p><h3 id="which-与-whereis"><a href="#which-与-whereis" class="headerlink" title="which 与 whereis"></a>which 与 whereis</h3><p>which和whereis命令都是Linux操作系统下查找可执行文件路径的命令</p><h4 id="which"><a href="#which" class="headerlink" title="which"></a>which</h4><p>这条命令主要是用来查找系统<strong><em>PATH目录下</em></strong>的可执行文件。说白了就是查找那些我们已经安装好的可以直接执行的命令，比如<br></p><pre class="line-numbers language-none"><code class="language-none">swq123459@swq123459PC:~$ which ls/bin/ls<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br>注意上述斜体字， which 查找的可执行文件，必须是要在 PATH 下的可执行文件，而不能是没有加入 PATH 的可执行文件，即使他就是可执行文件，但是没有加入到系统搜索路径，他仍然无法被 which 发现（好吧，有点啰嗦了）。<p></p><h4 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h4><p>这个命令可以用来查找二进制（命令）、源文件、man文件。与which不同的是这条命令可以是通过文件索引数据库而非PATH来查找的，所以查找的面比which要广。例如：<br></p><pre class="line-numbers language-none"><code class="language-none">swq123459@swq123459PC:~$ whereis lsls: /bin/ls /usr/share/man/man1/ls.1.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br>可以看到，whereis不仅找到了 ls 可执行文件的位置，还找到了其 man 帮助文件，可见其搜索范围比较广，不局限于PATH。<p></p><h3 id="查看某个进程或者服务是否存在"><a href="#查看某个进程或者服务是否存在" class="headerlink" title="查看某个进程或者服务是否存在"></a>查看某个进程或者服务是否存在</h3><pre class="line-numbers language-none"><code class="language-none">ps -aux ｜ grep xxx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="查找文件及文件夹"><a href="#查找文件及文件夹" class="headerlink" title="查找文件及文件夹"></a>查找文件及文件夹</h3><pre class="line-numbers language-none"><code class="language-none">find的主要用来查找文件，查找文件的用法我们比较熟悉，也可用它来查找文件夹，用法跟查找文件类似，只要在最后面指明查找的文件类型 -type d,如果不指定type类型，会将包含查找内容的文件和文件夹一起输出。find基本语法如下：find [PATH] [Option] [action]-newer file:file为一个存在的文件，列出比file还要新的文件名find / -mtime 0———0代表当前的时间，即从现在开始到24小时前，有改动过内容的文件都会被列出来find /etc -newer /etc/passwd———寻找/etc下面的文件，如果文件日期比/etc/passwd新就列出find / -name file——/代表全文搜索find /home -user Anmy——查找/home下属于Anmy的文件find / -nouser—— 查找系统中不属于任何人的文件，可以轻易找出那些不太正常的文件find / -name passed—— 查找文件名为passed的文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>若不指定查找类型，使用命令：find / -name AnmyTest 则会将目录和文件一同输出<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20180918104346399.png" alt=""><br>若指定查找类型，使用命令：find / -name AnmyTest -type d 则只会将目录输出<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20180918104448278.png" alt=""></p><h3 id="查看文件最后几行"><a href="#查看文件最后几行" class="headerlink" title="查看文件最后几行"></a>查看文件最后几行</h3><pre class="line-numbers language-none"><code class="language-none">//显示filename最后20行。tail -n 20 filename<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="查看端口"><a href="#查看端口" class="headerlink" title="查看端口"></a>查看端口</h3><h4 id="查看某个服务的状态"><a href="#查看某个服务的状态" class="headerlink" title="查看某个服务的状态"></a>查看某个服务的状态</h4><pre class="line-numbers language-none"><code class="language-none">service ‘servicename’ status//centos7以上用 systemctl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>例子</p><pre class="line-numbers language-none"><code class="language-none">service sshd status //查看sshd服务的状态，可以看到它的进程号，如果不需要可以kill 杀死<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="lsof-i-端口号"><a href="#lsof-i-端口号" class="headerlink" title="lsof -i:端口号"></a>lsof -i:端口号</h4><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/76c06a2619c04918af8a7331869739fd.png" alt=""><br>可以看到 8000 端口已经被轻 nodejs 服务占用。</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/a9bdaa252c8c4083baf16c1e664416ac.png" alt=""></p><h4 id="netstat-tunlp-grep-端口号"><a href="#netstat-tunlp-grep-端口号" class="headerlink" title="netstat -tunlp | grep 端口号  "></a>netstat -tunlp | grep 端口号  <br></h4><p><strong>用于显示 tcp，udp 的端口和进程等相关情况</strong></p><blockquote><p>-t (tcp) 仅显示tcp相关选项<br>-u (udp)仅显示udp相关选项<br>-n 拒绝显示别名，能显示数字的全部转化为数字<br>-l 仅列出在Listen(监听)的服务状态<br>-p 显示建立相关链接的程序名</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/b16427d1c6cc430080b1dae37360358c.png" alt=""></p><h4 id="kill-杀死进程"><a href="#kill-杀死进程" class="headerlink" title="kill(杀死进程)"></a>kill(杀死进程)</h4><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/e228676961554ebaa0725d3cad3b14c6.png" alt=""></p><h4 id="telnet-检测端口是否可用"><a href="#telnet-检测端口是否可用" class="headerlink" title="telnet(检测端口是否可用)"></a>telnet(检测端口是否可用)</h4><p>有时我们想知道端口是否开启。</p><pre class="line-numbers language-none"><code class="language-none">tenlet ip 端口<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/46ee47447ace457e95d472fef5ea9ea8.png" alt=""><br>上图表示：80端口开放，8899端口未开放。</p><h3 id="查看系统情况"><a href="#查看系统情况" class="headerlink" title="查看系统情况"></a>查看系统情况</h3><h4 id="cpu"><a href="#cpu" class="headerlink" title="cpu"></a>cpu</h4><pre class="line-numbers language-none"><code class="language-none">lscpu //cpu架构、每个核的线程数都能看到<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h4><pre class="line-numbers language-none"><code class="language-none">lsblk //命令用来查看接入到系统中的块设备，默认输出分区、大小、挂载点等信息df -h //查看硬盘的使用情况<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><pre class="line-numbers language-none"><code class="language-none">free -h<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="系统版本"><a href="#系统版本" class="headerlink" title="系统版本"></a>系统版本</h4><p>centos:</p><pre class="line-numbers language-none"><code class="language-none">cat /etc/redhat-release<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="删除除了某个文件外的其他文件"><a href="#删除除了某个文件外的其他文件" class="headerlink" title="删除除了某个文件外的其他文件"></a>删除除了某个文件外的其他文件</h3><pre class="line-numbers language-none"><code class="language-none">shopt -s extglob      （打开extglob模式）rm -fr !(file1)# 如果是多个要排除的，可以这样：rm -rf !(file1|file2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="复制-移动文件、文件改名"><a href="#复制-移动文件、文件改名" class="headerlink" title="复制/移动文件、文件改名"></a>复制/移动文件、文件改名</h2><p>Linux 将一个文件夹的所有内容拷贝到另外一个文件夹</p><p>cp 命令使用 -r 参数可以将 packageA 下的所有文件拷贝到 packageB 中：</p><pre class="line-numbers language-none"><code class="language-none">cp -r /home/packageA/* /home/cp/packageB/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将一个文件夹复制到另一个文件夹下，以下实例 packageA 文件会拷贝到 packageB 中：</p><pre class="line-numbers language-none"><code class="language-none">cp -r /home/packageA /home/packageB<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行命令之后 packageB 文件夹下就有 packageA 文件夹了。</p><ol><li><code>cp /xx/xx(a)  /xx/xx(a)</code>   :复制   ~~~~  //将a复制到b</li><li><code>mv /xx /xx /xx/xx</code> :剪切</li><li><code>mv 旧文件夹名 新文件夹名</code>   //更改名字</li></ol><h2 id="touch命令-创建文件"><a href="#touch命令-创建文件" class="headerlink" title="touch命令(创建文件)"></a>touch命令(创建文件)</h2><p><code>touch</code>命令用于修改文件或者目录的时间属性，包括存取时间和更改时间，若文件不存在，系统会建立一个新的文件。</p><p>创建一个空白文件，如果文件已经存在，它将更改文件的访问时间。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">touch</span> /tmp/file.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建多个文件。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">touch</span> /tmp/file1.txt /tmp/file2.txt /tmp/file3.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改文件的修改时间并查看文件属性。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">touch</span> -m /tmp/file.txt <span class="token operator">&amp;&amp;</span> <span class="token function">stat</span> /tmp/file.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同时修改访问时间和修改时间并设置一个特定的访问与修改时间。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">touch</span> -am -t <span class="token number">202007010000.00</span> /tmp/file.txt <span class="token operator">&amp;&amp;</span> <span class="token function">stat</span> /tmp/file.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="cat命令-显示文件内容"><a href="#cat命令-显示文件内容" class="headerlink" title="cat命令(显示文件内容)"></a>cat命令(显示文件内容)</h2><p><code>cat</code>命令属于文件管理，用于连接文件并打印到标准输出设备上，<code>cat</code>经常用来显示文件的内容，注意，当文件较大时，文本在屏幕上迅速闪过，会出现滚屏现象，此时往往看不清所显示的内容，为了控制滚屏，可以按<code>Ctrl+S</code>键停止滚屏，按<code>Ctrl+Q</code>键可以恢复滚屏，此外可以用<code>more</code>等命令进行读文件并分页显示。</p><p>使用<code>cat</code>命令创建一个文件，输入文件信息后按<code>Ctrl+D</code>输出<code>EOF</code>标识后结束输入。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">&gt;</span> file.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出<code>file.txt</code>文件中的内容。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> file.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同时输出<code>file.txt</code>与<code>file2.txt</code>文件中的内容。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> file.txt file2.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>把<code>file.txt</code>文件的内容加上行号后追加到<code>file2.txt</code>文件中。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> -n file.txt <span class="token operator">&gt;&gt;</span> file2.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>清空<code>file2.txt</code>文件，<code>/dev/null</code>称为空设备，是一个特殊的设备文件，其会丢弃一切写入其中的数据，但报告写入操作成功，读取它则会立即得到一个<code>EOF</code>。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> /dev/null <span class="token operator">&gt;</span> file2.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将<code>file.txt</code>与<code>file2.txt</code>文件内容合并输出到<code>file3.txt</code>。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> file.txt file2.txt <span class="token operator">&gt;</span> file3.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="Centos7特性"><a href="#Centos7特性" class="headerlink" title="Centos7特性"></a>Centos7特性</h2><p>服务相关命令使用systemctl，之前的版本是service</p><blockquote><p>systemctl (stop/restart/start)  (服务)<br>systemctl restart nginx</p></blockquote><h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><h3 id="开启端口（以80为例）"><a href="#开启端口（以80为例）" class="headerlink" title="开启端口（以80为例）"></a>开启端口（以80为例）</h3><blockquote><p>firewall-cmd —zone=public —add-port=80/tcp —permanent<br>//zone add permanent前面是两个横杠</p></blockquote><h3 id="重启防火墙"><a href="#重启防火墙" class="headerlink" title="重启防火墙"></a>重启防火墙</h3><blockquote><p>systemctl restart firewalld.service</p></blockquote><h3 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h3><pre class="line-numbers language-none"><code class="language-none">systemctl stop firewalld.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="开机禁用防火墙"><a href="#开机禁用防火墙" class="headerlink" title="开机禁用防火墙"></a>开机禁用防火墙</h3><pre class="line-numbers language-none"><code class="language-none">systemctl disable firewalld.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>不同的系统命令可能不同</strong></p><h2 id="修改主机名"><a href="#修改主机名" class="headerlink" title="修改主机名"></a>修改主机名</h2><h3 id="debian-ubuntu系列"><a href="#debian-ubuntu系列" class="headerlink" title="debian/ubuntu系列"></a>debian/ubuntu系列</h3><pre class="line-numbers language-none"><code class="language-none">第一步：vi /etc/hostname写入HOSTNAME=yourhostname保存后执行以下：hostname yourhostname 查看设置后的hostnamehostname<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">第二步：vi /etc/hosts修改成新的主机名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="redhat-centos系列"><a href="#redhat-centos系列" class="headerlink" title="redhat/centos系列"></a>redhat/centos系列</h3><pre class="line-numbers language-none"><code class="language-none">vi /etc/sysconfig/network输入以下：HOSTNAME=yourhostname保存后执行以下：hostname yourhostname 查看设置后的hostnamehostname<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="vim相关操作"><a href="#vim相关操作" class="headerlink" title="vim相关操作"></a>vim相关操作</h2><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>1）单行复制</p><p>在命令模式下，将光标移动到将要复制的行处，按“yy”进行复制；</p><p>2）多行复制 在命令模式下，将光标移动到将要复制的首行处，按“nyy”复制n行；其中n为1、2、3……</p><p>【yy】 复制光标所在的那一行<br>【nyy】 复制光标所在的向下n行</p><h3 id="粘贴"><a href="#粘贴" class="headerlink" title="粘贴"></a>粘贴</h3><p>在命令模式下，将光标移动到将要粘贴的行处，按“p”进行粘贴</p><p>【p,P】 p为将已经复制的数据在光标下一行粘贴；P为将已经复制的数据在光标上一行粘贴</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除一行：dd</p><p>删除一个单词/光标之后的单词剩余部分：dw</p><p>删除当前字符：x</p><p>光标之后的该行部分：d$</p><p>文本删除</p><p>dd 删除一行</p><p>d$ 删除以当前字符开始的一行字符</p><p>ndd 删除以当前行开始的n行</p><p>dw 删除以当前字符开始的一个字</p><p>ndw 删除以当前字符开始的n个字</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>【/word】 在文件中查找内容为word的字符串（向下查找）<br>【?word】 在文件中查找内容为word的字符串（向上查找）<br>【[n]】 表示重复查找动作，即查找下一个<br>【[N]】 反向查找下一个</p><h3 id="取消高亮"><a href="#取消高亮" class="headerlink" title="取消高亮"></a>取消高亮</h3><p>搜索后，我们打开别的文件，发现也被高亮了，怎么关闭高亮？</p><p>命令模式下，输入:nohlsearch  也可以:set nohlsearch； 当然，可以简写，noh或者set noh。<br>PS：nohlsearch是（no highlight search缩写）</p><h3 id="设置行号"><a href="#设置行号" class="headerlink" title="设置行号"></a>设置行号</h3><p>如果编辑后，又想显示行号，同样操作按一下esc键，并输入:（冒号），输入set number    ，并按回车键，完成后即显示行号</p><h3 id="跳到指定行"><a href="#跳到指定行" class="headerlink" title="跳到指定行"></a>跳到指定行</h3><p>在知道所查找的内容在文件中的具体位置时可以使用以下命令直接定位：<br>跳到文件指定行：比如跳到66行</p><p>66+G（也就是66+shift+g）<br>当然你可以选择另一种跳转方式：</p><p>命令行输入“ : n ” 然后回车<br>跳到文件第一行：gg （两个小写的G）</p><p>跳到文件最后一行：shift+g （也就是G）</p><h3 id="文件上下翻转"><a href="#文件上下翻转" class="headerlink" title="文件上下翻转"></a>文件上下翻转</h3><p>页翻转可以直接使用PgUp和PgDn</p><p>向前滚动一屏：Ctrl+F</p><p>向后滚动一屏：Ctrl+B</p><p>向前滚动半屏：Ctrl+D（向下）</p><p>向后滚动半屏：Ctrl+U（向上）</p><p>向下滚动一行，保持当前光标不动：Ctrl+E</p><p>向上滚动一行，保持当前光标不动：Ctrl+Y</p><p>当前行滚动：<br>当前行移动到屏幕顶部并滚动：Z+Enter<br>滚动指定行到屏幕顶部： 10Z+Enter（指定第十行）<br>当前行移动到屏幕中央并滚动：Z + .<br>当前行移动到屏幕底部并滚动：Z + -<br>当前屏幕操作：<br>H：大写h，移动到当前屏幕首行；nH移动到首行下的第n行<br>M：大写m，移动到当前屏幕中间行<br>L：大写l，移动到当前屏幕末行；nL移动到末行上面的第n行</p><h3 id="撤销上一步操作"><a href="#撤销上一步操作" class="headerlink" title="撤销上一步操作"></a>撤销上一步操作</h3><p>【u】 撤消上一个操作<br>【[Ctrl] + r】 多次撤消<br>【.】 这是小数点键，重复上一个操作</p><p>  缩进：</p><p>  插入模式下，ctrl+shift+d 减少缩进，ctrl+shift+t 增加缩进</p><h3 id="vim编辑"><a href="#vim编辑" class="headerlink" title="vim编辑"></a>vim编辑</h3><p>1、进入插入模式（６个命令）<br>【i】 从目前光标所在处插入<br>【I】 从目前光标<br>【a】 从当前光标所在的下一个字符处开始插入<br>【A】 从光标所在行的最后一个字符处开始插入<br>【o】 英文小写字母o，在目前光标所在行的下一行处插入新的一行并开始插入<br>【O】 英文大写字母O，在目前光标所在行的上一行处插入新的一行并开始插入</p><p> 2、进入替换模式（2个命令）<br>【r】 只会替换光标所在的那一个字符一次<br>【R】 会一直替换光标所在字符，直到按下[ESC]键为止<br>【[ESC]】 退出编辑模式回到一般模式</p><p>  3、一般模式切换到命令行模式<br>【:w】 保存文件<br>【:w!】 若文件为只读，强制保存文件<br>【:q】 离开vi<br>【:q!】 不保存强制离开vi<br>【:wq】 保存后离开<br>【:wq!】 强制保存后离开<br>【:! command】 暂时离开vi到命令行下执行一个命令后的显示结果<br>【:set nu】 显示行号<br>【:set nonu】 取消显示行号<br>【:w newfile】 另存为<br>【:set fileencoding】 查看当前文件编码格式<br>【:set fileencoding=utf-8】 设置当前文件编码格式为utf-8，也可以设置成其他编码格式<br>【:set fileformat】 查看当前文件的断行格式（dos\windows,unix或macintosh）<br>【:set fileformat=unix】 将当前文件的断行格式设置为unix格式</p><h3 id="多窗口功能"><a href="#多窗口功能" class="headerlink" title="多窗口功能"></a>多窗口功能</h3><p>【:sp [filename]】 打开一个新窗口，显示新文件，若只输入:sp，则两窗口显示同一个文件<br>【[Ctrl] + w + j】 光标移动到下方窗口<br>【[Ctrl] + w + k】 光标移动到上方窗口<br>【[Ctrl] + w + q】 离开当前窗口</p><h3 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h3><p>批量缩进</p><p>在程序代码界面，按esc，退出编辑模式，到命令模式，并在英语输入法下输入“：”</p><p>将所要批量缩进的行号写上，按照格式：“行号1，行号2&gt;”输入命令，如要将2至9行批量缩进一个tab值，则命令为“2,9&gt;”</p><p>输入完毕后，按回车可以执行，就可以看到2至9行全部缩进了一个tab值了，同样的，如果要缩回来一个tab值，则用命令“行号1，行号2&lt;”即可</p><p>可视模式缩进</p><p>方法二是在可视模式下选择要移动的列，操作为，esc从编辑模式退到命令模式，将光标移到需要缩进的行的行首，然后按shift+v，可以看到该行已被选中，且左下角提示为“可视”</p><p>此时，按键盘上的上下左右方向键，如这里按向下的箭头，选中所有需要批量缩进的行</p><p>选择好了之后，按shift+&gt;,是向前缩进一个tab值，按shift+&lt;，则是缩回一个tab值，</p><h2 id="vscode-Remote-SSH"><a href="#vscode-Remote-SSH" class="headerlink" title="vscode Remote SSH"></a>vscode Remote SSH</h2><p>ssh登录命令：</p><pre class="line-numbers language-none"><code class="language-none">ssh username@ip -p port  //密码登录 ，-p port可以不用输入，不输默认是22，因为linux默认也确实是22ssh username@ip -p port –i id_rsa //密钥登录//密钥生成的时候建议命名，不要使用默认的，否则多了容易分不清。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用Remote SSH 插件访问linux，用密钥登录。需要把公钥放在服务器，私钥放在<code>.ssh</code>目录下</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/300494cec18445139acafaa165d99186.png" alt=""><br>再配置VScode<br>点击Remote SSH的图标后再点击箭头所指的齿轮<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/a1b38b4440e85b519ea1004ad23ae66f.png" alt=""><br>会弹出菜单让你选择需要编辑的配置文件，一般选第一个<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/112e1d35b8003716395a4ecbcf2946ac.png" alt=""><br>参数的含义分别为：</p><p>Host 连接的主机的名称，可自定</p><p>Hostname 远程主机的IP地址</p><p>User 用于登录远程主机的用户名</p><p>Port 用于登录远程主机的端口</p><p>IdentityFile 本地的id_rsa的路径</p><p>右键点击Connect!<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/78b37be94d60822412e1640e5f980c6a.png" alt=""></p><h2 id="设置-SSH-通过密钥登录"><a href="#设置-SSH-通过密钥登录" class="headerlink" title="设置 SSH 通过密钥登录"></a>设置 SSH 通过密钥登录</h2><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>密钥的制作和用户有关。比如我在服务器上使用xxx制作的密钥，那么登录的话，是让ssh xxx@ip 可以免密登录，其它用户不行的。</li><li>如果我想免密登录服务器，那么是在服务器上面把密钥制作出来，将<strong>私钥</strong>传给别人，别人用私钥来访问。（感觉这样做不是很安全，看到的介绍都是把公钥给别人。但如果是公钥给别人，那就只有在本地制作密钥，再把公钥给服务器，但是用户就没法对上，后面有时间再想想吧）</li></ol><h3 id="制作密钥对"><a href="#制作密钥对" class="headerlink" title="制作密钥对"></a>制作密钥对</h3><blockquote><p>我们一般使用 PuTTY 等 SSH 客户端来远程管理 Linux<br>服务器。但是，一般的密码方式登录，容易有密码被暴力破解的问题。所以，一般我们会将 SSH 的端口设置为默认的 22 以外的端口，或者禁用<br>root 账户登录。其实，有一个更好的办法来保证安全，而且让你可以放心地用 root 账户从远程登录——那就是通过密钥方式登录。</p><p>密钥形式登录的原理是：利用密钥生成器制作一对密钥——一只公钥和一只私钥。将公钥添加到服务器的某个账户上，然后在客户端利用私钥即可完成认证并登录。这样一来，没有私钥，任何人都无法通过<br>SSH 暴力破解你的密码来远程登录到系统。此外，如果将公钥复制到其他账户甚至主机，利用私钥也可以登录。</p><p>下面来讲解如何在 Linux 服务器上制作密钥对，将公钥添加给账户，设置 SSH，最后通过客户端登录。</p></blockquote><pre class="line-numbers language-none"><code class="language-none">首先在服务器上制作密钥对。首先用密码登录到你打算使用密钥登录的账户，然后执行以下命令：[root@host ~]$ ssh-keygen  &lt;== 建立密钥对Generating public/private rsa key pair.Enter file in which to save the key (/root/.ssh/id_rsa): &lt;== 按 Enter。如果输入其它字符，比如test，那么生产的私钥是test，公钥是test.pub。说白了就是让你输入密钥文件名，不输入就采用默认的。Created directory '/root/.ssh'.Enter passphrase (empty for no passphrase): &lt;== 输入密钥锁码，后续使用私钥登录的时候会要求输密码，建议输入；或直接按 Enter 留空Enter same passphrase again: &lt;== 再输入一遍密钥锁码Your identification has been saved in /root/.ssh/id_rsa. &lt;== 私钥Your public key has been saved in /root/.ssh/id_rsa.pub. &lt;== 公钥The key fingerprint is:0f:d3:e7:1a:1c:bd:5c:03:f1:19:f1:22:df:9b:cc:08 root@host密钥锁码在使用私钥时必须输入，这样就可以保护私钥不被盗用。当然，也可以留空，实现无密码登录。现在，在 root 用户的家目录中生成了一个 .ssh 的隐藏目录，内含两个密钥文件。id_rsa 为私钥，id_rsa.pub 为公钥。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="在服务器上安装公钥"><a href="#在服务器上安装公钥" class="headerlink" title="在服务器上安装公钥"></a>在服务器上安装公钥</h3><pre class="line-numbers language-none"><code class="language-none">键入以下命令，在服务器上安装公钥：[root@host ~]$ cd .ssh[root@host .ssh]$ cat id_rsa.pub &gt;&gt; authorized_keys如此便完成了公钥的安装。为了确保连接成功，请保证以下文件权限正确：[root@host .ssh]$ chmod 600 authorized_keys[root@host .ssh]$ chmod 700 ~/.ssh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="设置-SSH，打开密钥登录功能"><a href="#设置-SSH，打开密钥登录功能" class="headerlink" title="设置 SSH，打开密钥登录功能"></a>设置 SSH，打开密钥登录功能</h3><pre class="line-numbers language-none"><code class="language-none">编辑 /etc/ssh/sshd_config 文件，进行如下设置：RSAAuthentication yesPubkeyAuthentication yes另外，请留意 root 用户能否通过 SSH 登录：PermitRootLogin yes当你完成全部设置，并以密钥方式登录成功后，再禁用密码登录：PasswordAuthentication no最后，重启 SSH 服务：[root@host .ssh]$ service sshd restart<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="普通用户制作密钥"><a href="#普通用户制作密钥" class="headerlink" title="普通用户制作密钥"></a>普通用户制作密钥</h3><p><strong>如果是用普通用户来制作密钥，需要在普通用户的状态下执行上述命令，生成的密钥会在/home/yskj/.ssh目录下面（这里以yskj用户为例）</strong></p><p>如果遇到无法登录，出现<br></p><pre class="line-numbers language-none"><code class="language-none">Server refused our key<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>这样的错误，从两个方面出发。一个是authorized_keys与.ssh的权限，一定要按照前面提到的，一个是600，一个是700。<br>如果这样不行，那就看看/home目录下面或yskj目录下面的权限，有没有拥有者或组是root的，然后改正过来。<p></p><h3 id="将私钥下载到客户端，然后转换为-PuTTY-能使用的格式"><a href="#将私钥下载到客户端，然后转换为-PuTTY-能使用的格式" class="headerlink" title="将私钥下载到客户端，然后转换为 PuTTY 能使用的格式"></a>将私钥下载到客户端，然后转换为 PuTTY 能使用的格式</h3><p>使用 WinSCP、SFTP 等工具将私钥文件 id_rsa 下载到客户端机器上。然后打开 PuTTYGen，单击 Actions 中的 Load 按钮，载入你刚才下载到的私钥文件。如果你刚才设置了密钥锁码，这时则需要输入。</p><p>载入成功后，PuTTYGen 会显示密钥相关的信息。在 Key comment 中键入对密钥的说明信息，然后单击 Save private key 按钮即可将私钥文件存放为 PuTTY 能使用的格式。</p><p>今后，当你使用 PuTTY 登录时，可以在左侧的 Connection -&gt; SSH -&gt; Auth 中的 Private key file for authentication: 处选择你的私钥文件，然后即可登录了，过程中只需输入密钥锁码即可。</p><h3 id="ssh客户端—xshell登录linux服务器"><a href="#ssh客户端—xshell登录linux服务器" class="headerlink" title="ssh客户端—xshell登录linux服务器"></a>ssh客户端—xshell登录linux服务器</h3><p>将服务器上生成的私钥，id_rsa下载到本地。<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/8aa2ee35095b499c9cddaf21b877ca01.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/a96ed4029057488f9ee7a6b9acae0fd3.png" alt=""></p><h3 id="ssh-keygen命令详解"><a href="#ssh-keygen命令详解" class="headerlink" title="ssh-keygen命令详解"></a>ssh-keygen命令详解</h3><p>这条命令目的是为了本地机器ssh登录远程服务器无需输入密码</p><p><strong>1.ssh-keygen</strong></p><blockquote><p>SSH 为 Secure Shell 的缩写，SSH 为建立在应用层基础上的安全协议。SSH<br>是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。<br><br><br>从客户端来看，SSH提供两种级别的安全验证：<br><br><br>第一种级别（基于口令的安全验证）：只要你知道自己帐号和口令，就可以登录到远程主机。所有传输的数据都会被加密，但是不能保证你正在连接的服务器就是你想连接的服务器。可能会有别的服务器在冒充真正的服务器，也就是受到“中间人”这种方式的攻击。<br>    <br><br>第二种级别（基于密匙的安全验证）ssh-keygen：需要依靠密匙，你必须为自己创建一对密匙，并把公用密匙放在需要访问的服务器上。如果你要连接到SSH服务器上，客户端软件就会向服务器发出请求，请求用你的密匙进行安全验证。服务器收到请求之后，先在该服务器上你的主目录下寻找你的公用密匙，然后把它和你发送过来的公用密匙进行比较。如果两个密匙一致，服务器就用公用密匙加密“质询”（challenge）并把它发送给客户端软件。客户端软件收到“质询”之后就可以用你的私人密匙解密再把它发送给服务器。用这种方式，你必须知道自己密匙的口令。但是，与第一种级别相比，第二种级别不需要在网络上传送口令。第二种级别不仅加密所有传送的数据，而且“中间人”这种攻击方式也是不可能的（因为他没有你的私人密匙）。但是整个登录的过程可能需要10秒。<br><br>    ssh-keygen有很多的参数，比如这里的-t -b -C都是他的一些参数</p></blockquote><p><strong>2.-t rsa</strong></p><blockquote><p>-t即指定密钥的类型，密钥的类型有两种，一种是RSA，一种是DSA：<br><br>RSA：RSA加密算法是一种非对称加密算法，是由三个麻省理工的牛人弄出来的，RSA是他们三个人姓的开头首字母组合。<br><br>DSA：Digital Signature Algorithm (DSA)是Schnorr和ElGamal签名算法的变种。<br><br>为了让两个linux机器之间使用ssh不需要用户名和密码。所以采用了数字签名RSA或者DSA来完成这个操作。ssh-keygen默认使用rsa密钥，所以不加-t rsa也行，如果你想生成dsa密钥，就需要加参数-t dsa。</p></blockquote><p><strong>3.-b 4096</strong></p><blockquote><p>-b 指定密钥长度。对于RSA密钥，最小要求768位，默认是2048位。命令中的4096指的是RSA密钥长度为4096位。<br><br>DSA密钥必须恰好是1024位(FIPS 186-2 标准的要求)。</p></blockquote><p><strong>这里额外补充一个知识</strong></p><blockquote><p>命令后面还可以增加-C “注释内容”<br><br>-C表示要提供一个新注释，用于识别这个密钥，可以是任何内容,一个用来识别的key</p></blockquote><p><strong>小结：当你创建ssh的时候：-t 表示密钥的类型 ，-b表示密钥的长度，-C 用于识别这个密钥的注释 ，这个注释你可以输入任何内容</strong></p><h2 id="Centos-启动-停止-重启-开机自启动服务"><a href="#Centos-启动-停止-重启-开机自启动服务" class="headerlink" title="Centos 启动/停止/重启/开机自启动服务"></a>Centos 启动/停止/重启/开机自启动服务</h2><pre class="line-numbers language-none"><code class="language-none">systemctl start sshd //启动ssh服务systemctl stop sshd //停止ssh服务 systemctl restart sshd //重启ssh服务systemctl enable sshd //开机自启动ssh服务docker 和其他服务也适用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="文件内容覆盖-追加内容（cat命令）"><a href="#文件内容覆盖-追加内容（cat命令）" class="headerlink" title="文件内容覆盖/追加内容（cat命令）"></a>文件内容覆盖/追加内容（cat命令）</h2><pre class="line-numbers language-none"><code class="language-none">cat  textfile1 &gt; textfile2 //使用“&gt;” 重定向后 文件 中原本的内容会被覆盖cat  textfile1 &gt;&gt; textfile2 //"&gt;&gt;" 代表 将输出的内容已追加的方式重定向到文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>cat 原单词concatenate(用途是连接文件或标准输入并打印。)<br>cat 命令用于将所有文件内容打印到屏幕上。<br>语法:</p><pre class="line-numbers language-none"><code class="language-none">cat 文件<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="linux中的-amp-amp-和-amp-，-和"><a href="#linux中的-amp-amp-和-amp-，-和" class="headerlink" title="linux中的&amp;&amp; 和 &amp;，| 和 ||"></a>linux中的&amp;&amp; 和 &amp;，| 和 ||</h2><blockquote><p>在linux中，&amp;和&amp;&amp;,|和||介绍如下：<br><br><br>&amp;  表示任务在后台执行，如要在后台运行redis-server,则有  redis-server &amp;<br><br><br>&amp;&amp; 表示前一条命令执行成功时，才执行后一条命令 ，如 echo ‘1‘ &amp;&amp; echo ‘2’<br><br><br>| 表示管道，上一条命令的输出，作为下一条命令参数，如 echo ‘yes’ | wc -l<br><br><br>|| 表示上一条命令执行失败后，才执行下一条命令，如 cat nofile || echo “fail”</p></blockquote><p>具体案例：<br>1.rpm -qa | grep mysql</p><blockquote><p>rpm -qa会输出符合筛选条件的软件套件，然后使用grep 筛选与mysql相关的软件套件</p></blockquote><h2 id="rpm命令"><a href="#rpm命令" class="headerlink" title="rpm命令"></a>rpm命令</h2><blockquote><p>Linux rpm 命令用于管理套件。<br><br><br>rpm（英文全拼：redhat package manager） 原本是 Red Hat Linux 发行版专门用来管理 Linux<br>各项套件的程序，由于它遵循 GPL 规则且功能强大方便，因而广受欢迎。逐渐受到其他发行版的采用。RPM 套件管理方式的出现，让 Linux<br>易于安装，升级，间接提升了 Linux 的适用度。<br><br>因为是redhat的，所以这个命令对ubuntu不适用，一般就是centos用，看看是否安装了或有某个软件的套件</p></blockquote><p>实例：</p><p>1.安装软件</p><pre class="line-numbers language-none"><code class="language-none"># rpm -hvi dejagnu-1.4.2-10.noarch.rpm 警告：dejagnu-1.4.2-10.noarch.rpm: V3 DSA 签名：NOKEY, key ID db42a60e准备...           ################################################################ [100%]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>2.显示软件安装信息</p><pre class="line-numbers language-none"><code class="language-none"># rpm -qi dejagnu-1.4.2-10.noarch.rpm【第1次更新 教程、类似命令关联】<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>3.检查是否已经安装过mysql</p><pre class="line-numbers language-none"><code class="language-none">rpm -qa | grep mysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4.删除mysql</p><pre class="line-numbers language-none"><code class="language-none">rpm -e --nodeps mysql-libs-5.1.73-5.el6_6.x86_64  //-e&lt;套件档&gt;或--erase&lt;套件档&gt; 　删除指定的套件。//--nodeps 　不验证套件档的相互关联性。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="更换yum源"><a href="#更换yum源" class="headerlink" title="更换yum源"></a>更换yum源</h2><p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/centos/">更换为清华源</a></p><ol><li>建议先备份 /etc/yum.repos.d/ 内的文件（CentOS 7 及之前为 CentOS-Base.repo，CentOS 8 为CentOS-Linux-*.repo）</li><li>然后编辑 /etc/yum.repos.d/ 中的相应文件，在 mirrorlist= 开头行前面加 # 注释掉；并将 baseurl= 开头行取消注释（如果被注释的话），把该行内的域名（例如mirror.centos.org）替换为 mirrors.tuna.tsinghua.edu.cn。</li><li>以上步骤可以被下方的命令一步完成</li></ol><pre class="line-numbers language-none"><code class="language-none">sudo sed -e 's|^mirrorlist=|#mirrorlist=|g' \        -e 's|^#baseurl=http://mirror.centos.org|baseurl=https://mirrors.tuna.tsinghua.edu.cn|g' \        -i.bak \        /etc/yum.repos.d/CentOS-*.repo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意其中的*通配符，如果只需要替换一些文件中的源，请自行增删。<br><br><br>注意，如果需要启用其中一些 repo，需要将其中的 enabled=0 改为 enabled=1。<br><br></p></blockquote><p>4.最后，更新软件包缓存</p><pre class="line-numbers language-none"><code class="language-none">sudo yum makecache<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> Linux </tag>
            
            <tag> ssh </tag>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机基础知识</title>
      <link href="/posts/7909/"/>
      <url>/posts/7909/</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p><a href="https://juejin.cn/post/7007218290711855134">详解哈希表</a></p><p><a href="https://blog.csdn.net/zhishengqianjun/article/details/79087525">哈希表的大小为何是素数</a></p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>环境变量是系统变量当中的一种，就是PATH。Windows和DOS操作系统中的path环境变量，当要求系统运行一个程序而没有告诉它程序所在的完整路径时，系统除了在当前目录下面寻找此程序外，还应到path中指定的路径去找。用户通过设置环境变量，来更好的运行进程。</p><p><strong>说白了，把可执行程序的路径放到环境变量里面，那么以后在任意的路径下就可以直接使用这个可执行程序，而不用输入绝对路径，方便。</strong></p><p>1.在Windows中，是由可视化的窗口模式展现出来的<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/20190906150416564.png" alt=""><br>2.linux中，在 <code>/etc/profile</code>文件中设置<br>可以直接用vim进入文件进行设置，也可以用下面的语句</p><pre class="line-numbers language-none"><code class="language-none">echo "export PATH=${PATH}:/usr/local/go/bon" &gt;&gt; /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最好还是用vim进行修改，用echo输入到为你文件中，会出现冗余，直接添加比较好。用冒号分隔。</p><p>修改好以后，需要更新环境变量</p><pre class="line-numbers language-none"><code class="language-none">source /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="计组-操作系统"><a href="#计组-操作系统" class="headerlink" title="计组+操作系统"></a>计组+操作系统</h2><h3 id="cpu工作流程"><a href="#cpu工作流程" class="headerlink" title="cpu工作流程"></a>cpu工作流程</h3><p>CPU的根本任务就是执行指令，对计算机来说最终都是一串由“0”和“1”组成的序列。CPU从逻辑上可以划分成3个模块，分别是控制单元、运算单元和存储单元，这三部分由CPU内部总线连接起来。如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/9893254095656f4a4b405400721af669.png" alt=""></p><ol><li><p>控制单元：控制单元是整个CPU的指挥控制中心，由程序计数器PC（Program Counter）, 指令寄存器IR(Instruction Register)、指令译码器ID(Instruction Decoder)和操作控制器OC(Operation Controller)等，对协调整个电脑有序工作极为重要。它根据用户预先编好的程序，依次从存储器中取出各条指令，放在指令寄存器IR中，通过指令译码(分析)确定应该进行什么操作，然后通过操作控制器OC，按确定的时序，向相应的部件发出微操作控制信号。操作控制器OC中主要包括节拍脉冲发生器、控制矩阵、时钟脉冲发生器、复位电路和启停电路等控制逻辑。</p></li><li><p>运算单元：是运算器的核心。可以执行算术运算(包括加减乘数等基本运算及其附加运算)和逻辑运算(包括移位、逻辑测试或两个值比较)。相对控制单元而言，运算器接受控制单元的命令而进行动作，即运算单元所进行的全部操作都是由控制单元发出的控制信号来指挥的，所以它是执行部件。</p></li><li><p>存储单元：包括CPU片内缓存和寄存器组，是CPU中暂时存放数据的地方，里面保存着那些等待处理的数据，或已经处理过的数据，CPU访问寄存器所用的时间要比访问内存的时间短。采用寄存器，可以减少CPU访问内存的次数，从而提高了CPU的工作速度。但因为受到芯片面积和集成度所限，寄存器组的容量不可能很大。寄存器组可分为专用寄存器和通用寄存器。专用寄存器的作用是固定的，分别寄存相应的数据。而通用寄存器用途广泛并可由程序员规定其用途，通用寄存器的数目因微处理器而异。这个是我们以后要介绍这个重点，这里先提一下。</p></li></ol><p>CPU的运行原理(简洁版):</p><ol><li><p>取指令：CPU的控制器从内存读取一条指令并放入指令寄存器。指令的格式一般是这个样子滴：<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/f1a9b80fb3f7cd81550d3484a0bd3193.png" alt=""></p></li><li><p>指令译码：指令寄存器中的指令经过译码，决定该指令应进行何种操作(就是指令里的操作码)、操作数在哪里(操作数的地址)。</p></li><li><p>执行指令，分两个阶段“取操作数”和“进行运算”。</p></li><li><p>修改指令计数器，决定下一条指令的地址。</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/61f3e30367246b169b660a5ea05c0493.png" alt=""></p><h3 id="微机设计"><a href="#微机设计" class="headerlink" title="微机设计"></a>微机设计</h3><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/f86b4de44bb94a4bdb72decee9b18497.png" alt=""></p><p>其中：</p><ul><li>时钟 (clock) 对 CPU 内部操作与系统其他组件进行同步。</li><li>控制单元 (control unit, CU) 协调参与机器指令执行的步骤序列。</li><li>算术逻辑单元 (arithmetic logic unit, ALU) 执行算术运算，如加法和减法，以及逻辑运算，如 AND（与）、OR（或）和 NOT（非）。</li></ul><p>CPU 通过主板上 CPU 插座的引脚与计算机其他部分相连。大部分引脚连接的是数据总线、控制总线和地址总线。</p><p>内存存储单元 (memory storage unit) 用于在程序运行时保存指令与数据。它接受来自 CPU 的数据请求，将数据从随机存储器 (RAM) 传输到 CPU，并从 CPU 传输到内存。</p><p>由于所有的数据处理都在 CPU 内进行，因此保存在内存中的程序在执行前需要被复制到 CPU 中。程序指令在复制到 CPU 时，可以一次复制一条，也可以一次复制多条。</p><p>总线 (bus) 是一组并行线，用于将数据从计算机一个部分传送到另一个部分。一个计算机系统通常包含四类总线：数据类、I/O 类、控制类和地址类。</p><p>数据总线 (data bus) 在 CPU 和内存之间传输指令和数据。I/O 总线在 CPU 和系统输入 / 输出设备之间传输数据。控制总线 (control bus) 用二进制信号对所有连接在系统总线上设备的行为进行同步。当前执行指令在 CPU 和内存之间传输数据时，地址总线 (address bus) 用于保持指令和数据的地址。</p><p>时钟与 CPU 和系统总线相关的每一个操作都是由一个恒定速率的内部时钟脉冲来进行同步。机器指令的基本时间单位是机器周期 (machine cycle) 或时钟周期 (clock cycle)。</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/ec98768c43ecf14f25c7694dea02a95e.png" alt=""></p><p>时钟周期持续时间用时钟速度的倒数来计算，而时钟速度则用每秒振荡数来衡量。例如，一个每秒振荡 10 亿次 (1GHz) 的时钟，其时钟周期为 10 亿分之 1 秒 (1 纳秒 )。（CPU主频）</p><p>执行一条机器指令最少需要 1 个时钟周期，有几个需要的时钟则超过了 50 个（比如 8088 处理器中的乘法指令）。由于在 CPU、系统总线和内存电路之间存在速度差异，因此，需要访问内存的指令常常需要空时钟周期，也被称为等待状态 (wait states)。</p><h3 id="指令执行周期"><a href="#指令执行周期" class="headerlink" title="指令执行周期"></a>指令执行周期</h3><p><a href="https://blog.csdn.net/weixin_30598353/article/details/113052914">原文链接</a><br>一条机器指令不会神奇地一下就执行完成。CPU 在执行一条机器指令时，需要经过一系列预先定义好的步骤，这些步骤被称为指令执行周期 (instruction execution cycle)。</p><p>假设现在指令指针寄存器中已经有了想要执行指令的地址，下面就是执行步骤：</p><p>1) CPU 从被称为指令队列 (instruction queue) 的内存区域取得指令，之后立即增加指令指针的值。</p><p>2) CPU 对指令的二进制位模式进行译码。这种位模式可能会表示该指令有操作数（输入值）。</p><p>3) 如果有操作数，CPU 就从寄存器和内存中取得操作数。有时，这步还包括了地址计算。</p><p>4) 使用步骤 3 得到的操作数，CPU 执行该指令。同时更新部分状态标志位，如零标志 (Zero)、进位标志 (Carry) 和溢出标志 (Overflow)。</p><p>5) 如果输出操作数也是该指令的一部分，则 CPU 还需要存放其执行结果。</p><p>通常将上述听起来很复杂的过程简化为三个步骤：取指 (Fetch)、译码 (Decode) 和执行 (Execute)。操作数 (operand) 是指操作过程中输入或输出的值。例如，表达式 Z=X+Y 有两个输入操作数 (X 和 Y)，—个输岀操作数 (Z)。</p><p>下图是一个典型 CPU 中的数据流框图。该图表现了在指令执行周期中相互交互部件之间的关系。在从内存读取程序指令之前，将其地址放到地址总线上。然后，内存控制器将所需代码送到数据总线上，存入代码高速缓存 (code cache)。指令指针的值决定下一条将要执行的指令。指令由指令译码器分析，并产生相应的数值信号送往控制单元，其协调 ALU 和浮点单元。虽然图中没有画出控制总线，但是其上传输的信号用系统时钟协调不同 CPU 部件之间的数据传输。</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/fe981489b47fa0e05d59e4d2d552cb7d.png" alt=""></p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p><a href="https://zhuanlan.zhihu.com/p/102293437">原文链接</a><br>作为一个常见现象，计算机从内存读取数据比从内部寄存器读取速度要慢很多。这是因为从内存读取一个值，需要经过下述步骤：</p><p>将想要读取的值的地址放到地址总线上。<br>设置处理器 RD（读取）引脚（改变 RD 的值）。<br>等待一个时钟周期给存储器芯片进行响应。<br>将数据从数据总线复制到目标操作数。<br>上述每一步常常只需要一个时钟周期，时钟周期是基于处理器内固定速率时钟节拍的一种时间测量方法。计算机的 CPU 通常是用其时钟速率来描述。例如，速率为 1.2GHz 意味着时钟节拍或振荡为每秒 12 亿次。</p><p>因此，考虑到每个时钟周期仅为 1/1 200 000 000 秒，4 个时钟周期也是非常快的。但是，与 CPU 寄存器相比，这个速度还是慢了，因为访问寄存器一般只需要 1 个时钟周期。</p><p>CPU和主存之间直接数据传输的方式转变成CPU和cache之间直接数据传输。cache负责和主存之间数据传输。</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/c932d9d2255061d1fa435d6b1abccaeb.jpeg" alt=""></p><h3 id="加载并执行程序"><a href="#加载并执行程序" class="headerlink" title="加载并执行程序"></a>加载并执行程序</h3><p>在程序执行之前，需要用一种工具程序将其加载到内存，这种工具程序称为程序加载器 (program loader)。加载后，操作系统必须将 CPU 指向程序的入口，即程序开始执行的地址。以下步骤是对这一过程的详细分解。</p><p>1) 操作系统（OS）在当前磁盘目录下搜索程序的文件名。如果找不到，则在预定目录列表（称为路径（path））下搜索文件名。当 OS 无法检索到文件名时，它会发出一个出错信息。</p><p>2) 如果程序文件被找到，OS 就访问磁盘目录中的程序文件基本信息，包括文件大小，及其在磁盘驱动器上的物理位置。</p><p>3) OS 确定内存中下一个可使用的位置，将程序文件加载到内存。为该程序分配内存块，并将程序大小和位置信息加入表中（有时称为描述符表（descriptor table））。另外，OS 可能调整程序内指针的值，使得它们包括程序数据地址。</p><p>4) OS 开始执行程序的第一条机器指令（程序入口）。当程序开始执行后，就成为一个进程（process）。OS 为这个进程分配一个标识号（进程 ID），用于在执行期间对其进行追踪。</p><p>5) 进程自动运行。OS 的工作是追踪进程的执行，并响应系统资源的请求。这些资源包括内存、磁盘文件和输入输出设备等。</p><p>6) 进程结束后，就会从内存中移除。</p><p>不论使用哪个版本的 Microsoft Windows，按下 Ctrl-Alt-Delete 组合键，可以选择任务管理器（task manager）选项。在任务管理器窗口可以查看应用程序和进程列表。</p><p>应用程序列表中列出了当前正在运行的完整程序名称，比如，Windows 浏览器，或者 Microsoft Visual C++。如果选择进程列表，则会看见一长串进程名。其中的每个进程都是一个独立于其他进程的，并处于运行中的小程序。</p><p>可以连续追踪每个进程使用的 CPU 时间和内存容量。在某些情况下，选定一个进程名称后，按下 Delete 键就可以关闭该进程。</p><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p><a href="https://zhuanlan.zhihu.com/p/368777813">原链接，详细内容见原文</a></p><ul><li>一条指令就是机器语言的一个语句，它是一组有意义的二进制代码。</li><li>一台计算机的所有指令的集合构成该机的指令系统，也称为指令集。</li></ul><h4 id="指令的格式"><a href="#指令的格式" class="headerlink" title="指令的格式"></a>指令的格式</h4><p>从最基本的结构上来说：一条指令通常要包括操作码字段和地址码字段两部分:</p><p>操作码字段告诉用户做什么操作？<br>地址码告诉用户对谁操作？</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/18383ae3dd0d90d3775436aba4eb124a.jpeg" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/1797cee715559dec28fb0d615fc8801a.jpeg" alt=""></p><h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><p><a href="https://zhuanlan.zhihu.com/p/370204019">原链接，详细内容见原文</a></p><p>指令寻址的方式包括两部分：</p><p>一种是指令的寻址<br>（是不是很晕？指令寻址怎么又包括指令寻址。hh因为这里的指令寻址指的是具体的操作码上发出的指令。是狭义上的指令寻址。）<br>另一种是数据的寻址（可以理解为地址码上操作数的地址寻址）</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/dd4748b236f46d082fe96b0c45ce444d.png" alt=""></p><h3 id="指令寻址方式"><a href="#指令寻址方式" class="headerlink" title="指令寻址方式"></a>指令寻址方式</h3><p>程序执行跳转指令，将程序计数器中的数据改为7。</p><ol><li>顺序寻址<br>从0开始执行，我们就需要在pc中写入地址0。执行完零号指令后，由于这是普通的取数指令，因此程序计数器自动+1，于是cpu开始执行指令1。<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/0a3664e358a332a4f106ea27526c1cba.png" alt=""></li></ol><ol><li>跳转寻址<br>知道碰到跳转指令，也就是指令3,程序执行跳转指令，将程序计数器中的数据改为7。<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/5fe522f26cedb98cf8b125e2abaf338c.jpeg" alt=""></li></ol><h3 id="数据寻址方式"><a href="#数据寻址方式" class="headerlink" title="数据寻址方式"></a>数据寻址方式</h3><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/d4c9ef871e158164c958bdfac1ce1811.jpeg" alt=""></p><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="cookie和session"><a href="#cookie和session" class="headerlink" title="cookie和session"></a>cookie和session</h3><h4 id="cookie和seesion主要区别"><a href="#cookie和seesion主要区别" class="headerlink" title="cookie和seesion主要区别"></a>cookie和seesion主要区别</h4><p>星巴克开始优惠活动，每消费10杯咖啡，会免费赠送1杯。考虑到一个人一次性消费10杯咖啡几乎不可能，所以需要采取某种方式来记录顾客的消费数量。</p><p>1)分给顾客一张卡片，每消费一次记录一次；</p><p>2)发给顾客一张卡片，上面有卡号，顾客每消费一次，由店员在操作机上记录一次。</p><p>而方案一和二正是对应的客户端记录和服务端记录。与之相对应的正是cookie和session。 好了，我们进入正题。</p><h4 id="什么是cookie"><a href="#什么是cookie" class="headerlink" title="什么是cookie"></a>什么是cookie</h4><p>HTTP是一种无状态协议,服务器没有办法单单从网络连接上面知道访问者的身份,为了解决这个问题,就诞生了Cookie</p><p>Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie</p><p>客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie。</p><h4 id="cookie的弊端"><a href="#cookie的弊端" class="headerlink" title="cookie的弊端"></a>cookie的弊端</h4><p>cookie 可以让服务端程序跟踪每个客户端的访问，但是每次客户端的访问都必须传回这些Cookie，如果 Cookie 很多，这无形地增加了客户端与服务端的数据传输量，</p><p><img src="https://img-blog.csdn.net/20180411123828426?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2puc2h1X2l0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><h4 id="session"><a href="#session" class="headerlink" title="session"></a>session</h4><p>Session 的出现正是为了解决这个问题。同一个客户端每次和服务端交互时，不需要每次都传回所有的 Cookie 值，而是只要传回一个 ID，这个 ID 是客户端第一次访问服务器的时候生成的， 而且每个客户端是唯一的。这样每个客户端就有了一个唯一的 ID，客户端只要传回这个 ID 就行了，这个 ID 通常是 NANE 为JSESIONID 的一个 Cookie。</p><p>Session机制是一种服务端的机制，服务器使用一种类似散列表的结构来保存信息。</p><p>当程序需要为某个客户端的请求创建一个session的时候，服务器首先检查这个客户端里的请求里是否已包含了一个session标识—sessionID，</p><p>如果已经包含一个sessionID，则说明以前已经为此客户端创建过session，服务器就按照sessionID把这个session检索出来使用</p><p>如果客户端请求不包含sessionID，则为此客户端创建一个session并且声称一个与此session相关联的sessionID，</p><p>sessionID的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串(服务器会自动创建),这个sessionID将被在本次响应中返回给客户端保存。</p><h3 id="centOS7-桥接模式设置静态Ip的方法步骤"><a href="#centOS7-桥接模式设置静态Ip的方法步骤" class="headerlink" title="centOS7 桥接模式设置静态Ip的方法步骤"></a>centOS7 桥接模式设置静态Ip的方法步骤</h3><p><a href="https://cloud.tencent.com/developer/article/1722144">原文链接</a></p><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>如果你虚拟机IP是自动获取的，难免会碰到IP经常变动，给xshell相关连接工具使用造成不便，那么怎么固定IP且正常访问外网地址呢？由于主机网络采用的是自动获取IP方式,所以每次重启机器可能导致IP地址的变更,不利于项目的部署和运行</p><p>静态ip就是虚拟机的ip 外界想要连你的虚拟机的ip </p><h4 id="虚拟机选择桥接模式"><a href="#虚拟机选择桥接模式" class="headerlink" title="虚拟机选择桥接模式"></a>虚拟机选择桥接模式</h4><p>注意虚拟机网卡要选择主机上网的网卡</p><h4 id="虚拟机设置静态ip-关键步骤"><a href="#虚拟机设置静态ip-关键步骤" class="headerlink" title="虚拟机设置静态ip(关键步骤)"></a>虚拟机设置静态ip(关键步骤)</h4><p><img src="https://ask.qcloudimg.com/http-save/yehe-1844341/npty8pp5hp.jpeg?imageView2/2/w/1620" alt=""></p><p>虚拟机的网卡名称是ens33</p><p>然后用vim编辑以下文件</p><p><strong>/etc/sysconfig/network-scripts/ifcfg-xxx</strong></p><p>上面的xxx就是虚拟机的网卡名称，不同的linux发行版名称可能不同。原因见原链接</p><p>需要修改的属性：<br></p><pre class="line-numbers language-none"><code class="language-none">ONBOOT=YES #no换成yesBOOTPROTO=static #dhcp换成static添加：IPADDR=192.168.230.129 #静态ip地址 与主机中IP的前三位一致，最后一位需要修改，不要跟主机ip一样导致发生冲突GATEWAY=192.168.230.1 #默认网关 和物理主机一样就可以了NETMASK=255.255.255.0 #子网掩码 和物理主机一样就可以了DNS1=8.8.8.8　　　　　　#DNS，写谷歌的地址就可以了。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>具体解释：<br></p><pre class="line-numbers language-none"><code class="language-none">TYPE=Ethernet    # 网卡类型：为以太网PROXY_METHOD=none   # 代理方式：关闭状态BROWSER_ONLY=no    # 只是浏览器：否BOOTPROTO=dhcp    # 网卡的引导协议：DHCP[中文名称: 动态主机配置协议]DEFROUTE=yes    # 默认路由：是, 不明白的可以百度关键词 `默认路由`IPV4_FAILURE_FATAL=no  # 是不开启IPV4致命错误检测：否IPV6INIT=yes    # IPV6是否自动初始化: 是[不会有任何影响, 现在还没用到IPV6]IPV6_AUTOCONF=yes   # IPV6是否自动配置：是[不会有任何影响, 现在还没用到IPV6]IPV6_DEFROUTE=yes   # IPV6是否可以为默认路由：是[不会有任何影响, 现在还没用到IPV6]IPV6_FAILURE_FATAL=no  # 是不开启IPV6致命错误检测：否IPV6_ADDR_GEN_MODE=stable-privacy   # IPV6地址生成模型：stable-privacy [这只一种生成IPV6的策略]NAME=ens33     # 网卡物理设备名称UUID=f47bde51-fa78-4f79-b68f-d5dd90cfc698 # 通用唯一识别码, 每一个网卡都会有, 不能重复, 否两台linux只有一台网卡可用DEVICE=ens33     # 网卡设备名称, 必须和 `NAME` 值一样ONBOOT=no      # 是否开机启动， 要想网卡开机就启动或通过 `systemctl restart network`控制网卡,必须设置为 `yes`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="重启网络服务"><a href="#重启网络服务" class="headerlink" title="重启网络服务"></a>重启网络服务</h4><pre class="line-numbers language-none"><code class="language-none">#centos7systemctl restart network <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>输入命令ping www.baidu.com（测试外网） </p><p>输入命令ping 192.168.2.153（宿主机ip） </p><p><strong>注意：</strong><br>如果无法ping通宿主机，很有可能是因为防火墙。<br>宿主机无法ping通虚拟机，也有可能是因为防火墙。</p><h3 id="VMware三种网卡解析"><a href="#VMware三种网卡解析" class="headerlink" title="VMware三种网卡解析"></a>VMware三种网卡解析</h3><p><a href="https://blog.csdn.net/qq_41672971/article/details/125825563">原文链接</a></p><div class="table-container"><table><thead><tr><th>虚拟网卡名</th><th>网络属性</th><th>定义</th></tr></thead><tbody><tr><td>VMnet0</td><td>物理网卡</td><td>Bridge桥接</td></tr><tr><td>Vmnet1</td><td>虚拟网卡</td><td>host-only仅主机</td></tr><tr><td>VMnet8</td><td>虚拟网卡</td><td>NAT</td></tr></tbody></table></div><p><strong>但是我们查看主机的网络链接，有时却看不见VMnet0</strong><br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/b5aa37b6f88245799d58da6be23b497a.png" alt=""></p><p>通过网络配置这里，能够看见使用那张网卡（这里是virtualbox，VMware也是差不多）<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/eee41028523f4d33a06c7c0fec4c34a8.png" alt=""><br><strong>所以根据上面两张图的对比，本地网络连接中的以太网3就是桥接模式使用的网卡。</strong></p><h3 id="VM虚拟机-三种网络连接方式（桥接、NAT、仅主机模式）"><a href="#VM虚拟机-三种网络连接方式（桥接、NAT、仅主机模式）" class="headerlink" title="VM虚拟机-三种网络连接方式（桥接、NAT、仅主机模式）"></a>VM虚拟机-三种网络连接方式（桥接、NAT、仅主机模式）</h3><p><a href="https://blog.csdn.net/tjcwt2011/article/details/124664594">原文链接</a></p><h4 id="桥接"><a href="#桥接" class="headerlink" title="桥接"></a>桥接</h4><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/2021082016475582.png" alt=""></p><p><strong>桥接，即架设了一条桥，让虚拟机成为一台真正的计算机，直接连入到实际网络中了。</strong></p><p>因此，它使得虚拟机能被分配到一个网络中独立的IP，所有网络功能完全和在网络中的真实机器一样，它和主机连接在同一个交换机上（此交换机通过vmnet0模拟），处于同一个 LAN，它可以访问网内任何一台机器。</p><p><strong>此模式下虚拟机：</strong></p><ol><li><p>可以与主机相互访问</p></li><li><p>可以与网络中其他主机相互访问</p></li><li><p>可以与其他虚拟机相互访问</p></li></ol><p>所以，桥接模式下的虚拟机，你把它直接认为是真实计算机就行了。</p><p>默认情况下DHCP会自动为虚拟机配置网络，但如果你需要在桥接模式下，手动为虚拟系统配置IP地址时，配置的虚拟机的ip不能是已经被占用的地址，还要和宿主机器处于同一网段，不然会造成地址冲突，只有这样虚拟系统才能和宿主机器以及外网进行通信。</p><hr><p><strong>复制物理网络连接状态</strong></p><p>一般在虚拟机设置为桥接时就能看见这个选项（无特殊要求默认不用勾选）</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/20210820141133567.png" alt=""></p><p>这个选项是只在移动设备上有用，比如在笔记本上使用VMware软件，最开始主机用有线连接的局域网，开启虚拟机（使用桥接），虚拟机系统获取的局域网地址为192.168.1.4。然后你把主机的有线拔掉，连接上同一局域网的wifi时，如果你选择了复制物理网络连接状态这个选项，那你的虚拟机系统的IP不会变化（还是192.168.1.4），如果你没有选择复制物理网络连接状态这个选项，那你的虚拟机系统的IP可能就会发生变化，比如变为192.168.1.5。</p><h4 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h4><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/20210820164721916.png" alt=""></p><p>NAT，虚拟机访问网络的所有数据都是由主机提供的，虚拟机并不真实存在于网络中，主机与网络中的任何机器都不能查看和访问到虚拟机的存在。 </p><p>虚拟机和主机之间通过VMnet8这个网卡来模拟路由器的作用，进行nat地址转换功能，负责将虚拟机发到 VMnet8 的包进行地址转换之后发到实际的网络上，再将实际网络上返回的包进行地址转换后通过 VMnet8 发送给虚拟机。</p><p>此模式下虚拟机：</p><pre><code>   可以单向访问主机   可以单向访问其他网络中主机   不可以访问其他虚拟机</code></pre><p>虚拟机可以访问主机能访问到的所有网络，但是对于主机以及主机网络上的其他机器，虚拟机又是不可见的，甚至主机也访问不到虚拟机。包括所有nat模式下的虚拟机之间相互都不能访问，虚拟机与虚拟机各自完全独立，相互间无法通过网络访问彼此。</p><h4 id="仅主机"><a href="#仅主机" class="headerlink" title="仅主机"></a>仅主机</h4><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/20210820172148978.png" alt=""></p><p>仅主机，虚拟机的与主机通过VMnet1连接，VMnet1不提供提供任何路由服务，因此虚拟机只能和宿主机进行通信，而不能连接到实际网络上。</p><p>其实就是NAT模式去除了nat地址转换功能</p><p>此模式下虚拟机：</p><pre><code>   可以与主机互相访问   不可以访问其他网络中主机   不可以访问其他虚拟机</code></pre><p>仅主机模式看着很简单，但是其实这是一种比较复杂的模式，其他模式可以实现的功能，在仅主机模式下，通过虚拟机及网卡的设置都可以被实现。所以该模式需要有比较扎实的网络基础知识</p><p>这种模式下，我们可以理解为虚拟机在主机中模拟出一张专供虚拟机使用的网卡VMnet1，所有虚拟机都是连接到该网卡上的，我们可以通过设置这张网卡来实现上网及其他很多功能，比如（网卡共享、网卡桥接等）。</p><h3 id="正向代理和反向代理区别"><a href="#正向代理和反向代理区别" class="headerlink" title="正向代理和反向代理区别"></a>正向代理和反向代理区别</h3><p><a href="https://www.cnblogs.com/taostaryu/p/10547132.html">原文链接</a></p><p><strong>一 什么是代理</strong></p><p>代理其实就是一个中介，A和B本来可以直连，中间插入一个C，C就是中介。<br>刚开始的时候，代理多数是帮助内网client访问外网server用的<br>后来出现了反向代理，”反向”这个词在这儿的意思其实是指方向相反，即代理将来自外网客户端的请求转发到内网服务器，从外到内</p><p><strong>二 正向代理</strong></p><p>正向代理类似一个跳板机，代理访问外部资源</p><p>比如我们国内访问谷歌，直接访问访问不到，我们可以通过一个正向代理服务器，请求发到代理服，代理服务器能够访问谷歌，这样由代理去谷歌取到返回数据，再返回给我们，这样我们就能访问谷歌了<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/cd381c5de09a40f2bfedae52042eb66d.png" alt=""></p><p><strong>正向代理的用途：</strong></p><p>　　（1）访问原来无法访问的资源，如google</p><p>（2） 可以做缓存，加速访问资源</p><p>　　（3）对客户端访问授权，上网进行认证</p><p>　　（4）代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息　　</p><p><strong>三 反向代理</strong><br>反向代理（Reverse Proxy）实际运行方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/85649ed3b62c40d38de64b5170114f5b.png" alt=""></p><p><strong>反向代理的作用：</strong><br>（1）保证内网的安全，阻止web攻击，大型网站，通常将反向代理作为公网访问地址，Web服务器是内网</p><p>（2）负载均衡，通过反向代理服务器来优化网站的负载</p><p><strong>四 总结<br>正向代理即是客户端代理, 代理客户端, 服务端不知道实际发起请求的客户端.<br>反向代理即是服务端代理, 代理服务端, 客户端不知道实际提供服务的服务端</strong></p><p>看图理解一：<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/0c3860e58d2cffd66b808fe07631e358.png" alt=""></p><p>看图理解二：<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/7cc6fc2baf342df6a450a54ca2ad6b8a.png" alt=""></p><p>正向代理中，proxy和client同属一个LAN，对server透明；<br>反向代理中，proxy和server同属一个LAN，对client透明。<br>实际上proxy在两种代理中做的事都是代为收发请求和响应，不过从结构上来看正好左右互换了下，所以把后出现的那种代理方式叫成了反向代理</p><p><strong>总结：</strong><br>正向代理: 买票的黄牛</p><p>反向代理: 租房的代理</p><h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><p><a href="https://juejin.cn/post/6844904129987526663">原文链接</a><br>“Nginx 是一款轻量级的 HTTP 服务器，采用事件驱动的异步非阻塞处理方式框架，这让其具有极好的 IO 性能，时常用于服务端的<strong>反向代理</strong>和<strong>负载均衡</strong>。”<br>Nginx 是一款 http 服务器 （或叫web服务器）。它是由俄罗斯人 伊戈尔·赛索耶夫为俄罗斯访问量第二的 Rambler.ru 站点开发的，并于2004年首次公开发布的。</p><pre class="line-numbers language-none"><code class="language-none">web服务器：负责处理和响应用户请求，一般也称为http服务器，如 Apache、IIS、Nginx应用服务器：存放和运行系统程序的服务器，负责处理程序中的业务逻辑，如 Tomcat、Weblogic、Jboss（现在大多数应用服务器也包含了web服务器的功能）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Nginx 是什么，总结一下就是这些：</p><ul><li>一种轻量级的web服务器</li><li>设计思想是事件驱动的异步非阻塞处理（类node.js）</li><li>占用内存少、启动速度快、并发能力强</li><li>使用C语言开发</li><li>扩展性好，第三方插件非常多</li><li>在互联网项目中广泛应用</li></ul><h4 id="Nginx配置"><a href="#Nginx配置" class="headerlink" title="Nginx配置"></a>Nginx配置</h4><p><strong>安装/卸载</strong></p><p><strong><em>安装、卸载、启动自查找资料</em></strong></p><p>修改配置<br>经常要用到的几个文件路径：</p><pre class="line-numbers language-none"><code class="language-none">/usr/local/etc/nginx/nginx.conf （nginx配置文件路径）/usr/local/var/www （nginx服务器默认的根目录）/usr/local/Cellar/nginx/1.17.9 （nginx的安装路径）/usr/local/var/log/nginx/error.log (nginx默认的日志路径)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>nginx 默认配置文件简介：</p><pre class="line-numbers language-none"><code class="language-none">## 首尾配置暂时忽略server {          # 当nginx接到请求后，会匹配其配置中的service模块        # 匹配方法就是将请求携带的host和port去跟配置中的server_name和listen相匹配        listen       8080;                server_name  localhost; # 定义当前虚拟主机（站点）匹配请求的主机名        location / {            root   html; # Nginx默认值            # 设定Nginx服务器返回的文档名            index  index.html index.htm; # 先找根目录下的index.html，如果没有再找index.htm        }}## 首尾配置暂时忽略<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>server{ } 其实是包含在 http{ } 内部的。每一个 server{ } 是一个虚拟主机（站点）。<br>上面代码块的意思是：当一个请求叫做localhost:8080请求nginx服务器时，该请求就会被匹配进该代码块的 server{ } 中执行。<br>当然 nginx 的配置非常多，用的时候可以根据文档进行配置。</p><p>英文文档：nginx.org/en/docs/<br>中文文档：www.nginx.cn/doc/</p><p>Nginx有哪些应用？<br>主要有4大应用（动静分离、正向代理、反向代理、负载均衡）</p><h4 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h4><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/e9d551a4479341cca95a54fbe13f3ebe.webp" alt=""></p><p>如上图所示，动静分离其实就是 Nginx 服务器将接收到的请求分为动态请求和静态请求。<br>静态请求直接从 nginx 服务器所设定的根目录路径去取对应的资源，动态请求转发给真实的后台（前面所说的应用服务器，如图中的Tomcat）去处理。<br>这样做不仅能给应用服务器减轻压力，将后台api接口服务化，还能将前后端代码分开并行开发和部署。（传送门：<a href="https://www.php.cn/nginx/424631.html">nginx动静分离的好处</a>）</p><pre class="line-numbers language-none"><code class="language-none">server {          listen       8080;                server_name  localhost;        location / {            root   html; # Nginx默认值            index  index.html index.htm;        }                # 静态化配置，所有静态请求都转发给 nginx 处理，存放目录为 my-project        location ~ .*\.(html|htm|gif|jpg|jpeg|bmp|png|ico|js|css)$ {            root /usr/local/var/www/my-project; # 静态请求所代理到的根目录        }                # 动态请求匹配到path为'node'的就转发到8002端口处理        location /node/ {              proxy_pass http://localhost:8002; # 充当服务代理        }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>访问静态资源 nginx 服务器会返回 my-project 里面的文件，如获取 index.html：<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/34472ca6f5724173402dbaf6d4e6f8b3.webp" alt=""></p><p>访问动态请求 nginx 服务器会将它从8002端口请求到的内容，原封不动的返回回去：</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/1f897ee545286a0b59fc4243f6af84b2.webp" alt=""><br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/ec6173b234f9c06fe646c9b709abb44e.webp" alt=""></p><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>负载均衡是什么？<br>随着业务的不断增长和用户的不断增多，一台服务已经满足不了系统要求了。这个时候就出现了服务器 集群。<br>在服务器集群中，Nginx 可以将接收到的客户端请求“均匀地”（严格讲并不一定均匀，可以通过设置权重）分配到这个集群中所有的服务器上。这个就叫做负载均衡。<br>负载均衡的示意图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/06ee1083810d768945b4234ba3e18204.webp" alt=""><br>负载均衡的作用</p><p>分摊服务器集群压力<br>保证客户端访问的稳定性</p><p>前面也提到了，负载均衡可以解决分摊服务器集群压力的问题。除此之外，Nginx还带有健康检查（服务器心跳检查）功能，会定期轮询向集群里的所有服务器发送健康检查请求，来检查集群中是否有服务器处于异常状态。<br>一旦发现某台服务器异常，那么在这以后代理进来的客户端请求都不会被发送到该服务器上（直健康检查发现该服务器已恢复正常），从而保证客户端访问的稳定性。</p><p><strong>配置负载均衡</strong></p><p>配置一个简单的负载均衡并不复杂，代码如下：</p><pre class="line-numbers language-none"><code class="language-none">## 负载均衡：设置domainupstream domain {    server localhost:8000;    server localhost:8001;}server {          listen       8080;                server_name  localhost;        location / {            # root   html; # Nginx默认值            # index  index.html index.htm;                        proxy_pass http://domain; # 负载均衡配置，请求会被平均分配到8000和8001端口            proxy_set_header Host $host:$server_port;        }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>8000和8001是我本地用 Node.js 起的两个服务，负载均衡成功后可以看到访问 localhost:8080 有时会访问到8000端口的页面，有时会访问到8001端口的页面。<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/2299761055052914c2f089ab072b37fd.webp" alt=""><br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/3440c0ca236da8de821da682fcf157b1.webp" alt=""><br>能看到这个效果，就说明你配置的负载均衡策略生效了。<br>实际项目中的负载均衡远比这个案例要更加复杂，但是万变不离其宗，都是根据这个理想模型衍生出来的。<br>受集群单台服务器内存等资源的限制，负载均衡集群的服务器也不能无限增多。但因其良好的容错机制，负载均衡成为了实现高可用架构中必不可少的一环。</p><h3 id="ping和ssh"><a href="#ping和ssh" class="headerlink" title="ping和ssh"></a>ping和ssh</h3><p><strong>ping 和 ssh 的连通性是相互独立的。如果你不能 ping 通一个 IP，不意味着你不能 ssh 到它；同样，如果你可以 ping 通一个 IP，也不意味着你可以 ssh 到它。</strong></p><p>ping 和 ssh 使用的是不同的网络协议和端口。ping 使用的是 ICMP (Internet Control Message Protocol)，而 ssh 使用的是 TCP 协议，默认端口为22。这意味着以下几种情况可能发生：</p><ol><li><p>ICMP 被阻止：在许多网络环境中，出于安全原因，ICMP 可能被防火墙或路由器屏蔽。这意味着你可能无法 ping 通一个 IP，但是还是可以通过 ssh 连接它。</p></li><li><p>SSH 服务未运行：即使你可以 ping 通一个 IP，如果那台计算机上没有运行 SSH 服务，或者 SSH 服务配置不当，你仍然无法通过 ssh 连接它。</p></li><li><p>SSH 端口被阻止：某些网络可能允许 ICMP，但阻止了 SSH 的默认端口（22）。这可能是因为网络管理员想要防止未经授权的远程访问。</p></li><li><p>使用非默认端口的 SSH：有时，为了安全或其他原因，SSH 可能配置为在非默认端口上运行。在这种情况下，即使默认的 SSH 端口被阻止，你仍然可能能够连接，只要你知道正确的端口号。</p></li></ol><h3 id="代理软件全局模型ip是否被修改"><a href="#代理软件全局模型ip是否被修改" class="headerlink" title="代理软件全局模型ip是否被修改"></a>代理软件全局模型ip是否被修改</h3><p>使用全局代理模式时，你的公共 IP 地址（从外部服务器或网站看到的 IP 地址）会被修改为代理服务器的 IP 地址。这是因为所有的网络请求都通过代理服务器进行，在到达最终的服务器或网站之前，首先到达代理服务器，然后由代理服务器转发。因此，对于外部服务器或网站，它们看到的请求似乎是来自代理服务器，而不是你的原始设备。</p><p><strong>不过本地cmd查看ip是没有变化的</strong></p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>不同的语言，不同的开发环境，编译出的东西不一定一样。</p><blockquote><p>比如C/C++，windows下编出的是后缀为exe的可执行程序，双击就能直接运行。但如果在linux下编出的后缀是没有exe的，是一个可运行的二进制文件。原因是因为编译器不同，linux环境的编译器一般是gcc，windows下一般是MinGW等（用VSCODE跑C一般就是这个编译器）</p><p>不过java比较特殊，因为编出来的class文件是运行在JVM上，在os上一层，与操作系统没有直接联系。所以windows编出来的class，或者打包的tar/war可以直接扔到服务器（linux）上使用（B站黑马程序员的jenkins教程—（SpringCloud微服务部署）就是这样的）</p></blockquote><h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><h3 id="Session-与-Cookie"><a href="#Session-与-Cookie" class="headerlink" title="Session 与 Cookie"></a>Session 与 Cookie</h3><p><a href="https://www.cnblogs.com/l199616j/p/11195667.html">原文链接</a></p><p><strong>会话（Session）跟踪是Web程序中常用的技术，用来跟踪用户的整个会话。常用的会话跟踪技术是Cookie与Session。Cookie通过在客户端记录信息确定用户身份，Session通过在服务器端记录信息确定用户身份。</strong></p><h4 id="Cookie机制"><a href="#Cookie机制" class="headerlink" title="Cookie机制"></a>Cookie机制</h4><p>在程序中，会话跟踪是很重要的事情。理论上，一个用户的所有请求操作都应该属于同一个会话，而另一个用户的所有请求操作则应该属于另一个会话，二者不能混淆。例如，用户A在超市购买的任何商品都应该放在A的购物车内，不论是用户A什么时间购买的，这都是属于同一个会话的，不能放入用户B或用户C的购物车内，这不属于同一个会话。</p><p>　　而Web应用程序是使用HTTP协议传输数据的。HTTP协议是无状态的协议。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话。即用户A购买了一件商品放入购物车内，当再次购买商品时服务器已经无法判断该购买行为是属于用户A的会话还是用户B的会话了。要跟踪该会话，必须引入一种机制。</p><p>　　Cookie就是这样的一种机制。它可以弥补HTTP协议无状态的不足。在Session出现之前，基本上所有的网站都采用Cookie来跟踪会话。</p><h4 id="什么是Cookie"><a href="#什么是Cookie" class="headerlink" title="什么是Cookie"></a>什么是Cookie</h4><p>Cookie意为“甜饼”，是由W3C组织提出，最早由Netscape社区发展的一种机制。目前Cookie已经成为标准，所有的主流浏览器如IE、Netscape、Firefox、Opera等都支持Cookie。</p><p>　　由于HTTP是一种无状态的协议，服务器单从网络连接上无从知道客户身份。怎么办呢？就给客户端们颁发一个通行证吧，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。这就是Cookie的工作原理。</p><p>　　Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/f8e326e26add2797b05d3ed8c17a8f8b.png" alt=""></p><h4 id="Session机制"><a href="#Session机制" class="headerlink" title="Session机制"></a>Session机制</h4><p>Session是服务器端使用的一种记录客户端状态的机制，使用上比Cookie简单一些，相应的也增加了服务器的存储压力。</p><h4 id="什么是Session"><a href="#什么是Session" class="headerlink" title="什么是Session"></a>什么是Session</h4><p>Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。</p><p>　　如果说<strong>Cookie机制是通过检查客户身上的“通行证”来确定客户身份的话，那么Session机制就是通过检查服务器上的“客户明细表”来确认客户身份。Session相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。</strong>　　</p><h4 id="cookie和session的区别"><a href="#cookie和session的区别" class="headerlink" title="cookie和session的区别"></a>cookie和session的区别</h4><p><strong>1、cookie数据存放在客户的浏览器上，session数据放在服务器上.</strong></p><p>简单的说，当你登录一个网站的时候，如果web服务器端使用的是session,那么所有的数据都保存在服务器上面，</p><p>客户端每次请求服务器的时候会发送 当前会话的session_id，服务器根据当前session_id判断相应的用户数据标志，以确定用户是否登录，或具有某种权限。</p><p>由于数据是存储在服务器 上面，所以你不能伪造，但是如果你能够获取某个登录用户的session_id，用特殊的浏览器伪造该用户的请求也是能够成功的。</p><p>session_id是服务器和客户端链接时候随机分配的，一般来说是不会有重复，但如果有大量的并发请求，也不是没有重复的可能性。</p><p>Session是由应用服务器维持的一个服务器端的存储空间，用户在连接服务器时，会由服务器生成一个唯一的SessionID,用该SessionID 为标识符来存取服务器端的Session存储空间。而SessionID这一数据则是保存到客户端，用Cookie保存的，用户提交页面时，会将这一 SessionID提交到服务器端，来存取Session数据。这一过程，是不用开发人员干预的。所以一旦客户端禁用Cookie，那么Session也会失效。</p><p><strong>2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。</strong></p><p><strong>3、设置cookie时间可以使cookie过期。但是使用session-destory（），我们将会销毁会话。</strong></p><p><strong>4、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用cookie。</strong></p><p><strong>5、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。(Session对象没有对存储的数据量的限制，其中可以保存更为复杂的数据类型)</strong></p><h2 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h2><h3 id="MD5加密"><a href="#MD5加密" class="headerlink" title="MD5加密"></a>MD5加密</h3><p><strong>为什么要对密码MD5</strong><br>密码明文传递或者直接写到数据库中，都有被偷看的风险</p><p><strong>为什么要对密码做两次MD5</strong><br>现在存在的一些反查md5的软件，做两次为了更好的保密</p><p><strong>整体流程如何实现</strong></p><p><strong>1.整体加密流程</strong></p><pre class="line-numbers language-none"><code class="language-none">MD5(MD5(pass明文+固定salt)+随机salt)第一次固定salt写死在前端第二次加密采用随机的salt 并将每次生成的salt保存在数据库中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>2.登录流程：</strong></p><pre class="line-numbers language-none"><code class="language-none">前端对用户输入的密码进行md5加密（固定的salt）将加密后的密码传递到后端后端使用用户id取出用户信息后端对加密后的密码在进行md5加密（取出盐），然后与数据库中存储的密码进行对比，ok登录成功，否则登录失败<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3.注册流程</strong></p><pre class="line-numbers language-none"><code class="language-none">前端对用户输入的密码进行md5加密（固定的salt）将加密后的密码传递到后端后端随机生成一个salt，使用生成salt对前端传过来的密码进行加密，然后将加密后密码和salt一起保存到db中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="硬件知识"><a href="#硬件知识" class="headerlink" title="硬件知识"></a>硬件知识</h2><h3 id="cpu核心数与线程数"><a href="#cpu核心数与线程数" class="headerlink" title="cpu核心数与线程数"></a>cpu核心数与线程数</h3><p><a href="https://zhuanlan.zhihu.com/p/86855590">原文链接</a></p><p><strong>物理 cpu 数（physical cpu）</strong></p><p>指主板上实际插入的 cpu 硬件个数（socket）。（但是这一概念经常被泛泛的说成是 cpu 数，这很容易导致与 core 数，processor 数等概念混淆，所以此处强调是物理 cpu 数）。</p><p>由于在主板上引入多个 cpu 插槽需要更复杂的硬件支持（连接不同插槽的 cpu 到内存和其他资源），通常只会在服务器上才这样做。在家用电脑中，一般主板上只会有一个 cpu 插槽。</p><p><strong>核心（core）</strong><br>一开始，每个物理 cpu 上只有一个核心（a single core），对操作系统而言，也就是同一时刻只能运行一个进程/线程。 为了提高性能，cpu 厂商开始在单个物理 cpu 上增加核心（实实在在的硬件存在），也就出现了双核心 cpu（dual-core cpu）以及多核心 cpu（multiple cores），这样一个双核心 cpu 就是同一时刻能够运行两个进程/线程的。</p><p><strong>同时多线程技术（simultaneous multithreading）和 超线程技术（hyper–threading/HT）</strong></p><p>本质一样，是为了提高单个 core 同一时刻能够执行的多线程数的技术（充分利用单个 core 的计算能力，尽量让其“一刻也不得闲”）。</p><p>simultaneous multithreading 缩写是 SMT，AMD 和其他 cpu 厂商的称呼。 hyper–threading 是 Intel 的称呼，可以认为 hyper–threading 是 SMT 的一种具体技术实现。</p><p>在类似技术下，产生了如下等价术语：</p><ul><li>虚拟 core： virtual core </li><li>逻辑 processer： logical processor </li><li>线程：thread</li></ul><p>所以可以这样说：某款采用 SMT 技术的 4 核心 AMD cpu 提供了 8 线程同时执行的能力；某款采用 HT 技术的 2 核心 Intel cpu 提供了 4 线程同时执行的能力。</p><p><strong>查看 cpu 信息</strong><br>1.linux系统：</p><pre class="line-numbers language-none"><code class="language-none">//法一lscpu<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">CPU(s):                24On-line CPU(s) list:   0-23Thread(s) per core:    2Core(s) per socket:    6Socket(s):             2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">//法二cat /proc/cpuinfo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">processor   : 0vendor_id   : GenuineIntelcpu family  : 6model       : 60model name  : Intel(R) Core(TM) i7-4700MQ CPU @ 2.40GHzstepping    : 3microcode   : 0x22cpu MHz     : 2393.631cache size  : 6144 KBphysical id : 0siblings    : 8core id     : 0cpu cores   : 4...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中有几个physical id,机器上就安装了几个物理CPU<br>cpu core记录了每个物理CPU,内部有几个物理核<br>siblings 代表每个物理CPU有多少个逻辑核</p><p>2.windows<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/c82b797044d88e27b217706604a29bc7.png" alt=""><br><strong>多线程程序线程数</strong><br>为了让我们的多线程程序更好的利用 cpu 资源，我们通常会先了解机器拥有的 processor 数，有若干手段可以获取这一信息：</p><ul><li>cpuinfo 中查看：比如上文中的 cat /proc/cpuinfo | grep “processor” | wc -l</li><li>top 命令查看：cpu0,cpu1,…</li><li>编程：比如在 Java 中用 Runtime.getRuntime().availableProcessors()</li></ul><p>具体在多线程程序中设置线程数多大，对计算密集型的程序有的建议是 processor count + 1，有的建议是 processor count 的 1.5 倍，都是经验值，实测为准。</p><p><strong>小结</strong></p><ul><li>一台完整的计算机可能包含一到多个物理 cpu </li><li>从单个物理 cpu （physical cpu）的角度看，其可能是单核心、双核心甚至多核心的</li><li>从单个核心（core）的角度看，还有 SMT / HT 等技术让每个 core 对计算机操作系统而言用起来像多个物理 core 差不多</li></ul><p>总的逻辑 cpu 数 = 物理 cpu 数 <em> 每颗物理 cpu 的核心数 </em> 每个核心的超线程数</p><h3 id="cpu-线程与进程关系"><a href="#cpu-线程与进程关系" class="headerlink" title="cpu 线程与进程关系"></a>cpu 线程与进程关系</h3><p><a href="https://juejin.cn/post/6844904120684396552">原文链接</a></p><h4 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h4><p>两种常见解释</p><p>1.进程和线程都是一个时间段的描述，是CPU工作时间段的描述。<br>2.进程是资源分配的最小单位，线程是CPU调度的最小单位</p><p>解释：</p><ol><li>CPU太快了,只有缓存存储器SRAM才能勉强追上它的速度,因此,一台机器上同时开30个程序,CPU可以把这30个程序变成顺序执行，每个只执行一小段，立马切换到下一个程序，再执行一小段，再切回来，人是无感知的。</li><li><strong><em>一个程序准备开始执行的时候，相关资源必须要准备好，比如RAM地址，显卡，磁盘资源，这些准备好的东西打包一起就叫做上下文环境</em></strong>，然后CPU开始执行程序A，当然只执行了一小段时间，CPU就要切换到别的程序执行B，以保证几个程序的并发，切换之前要把A的上下问状态保存起来，下次切回来的时候接着用。</li><li>因此，进程就是包换上下文切换的程序执行时间总和 = CPU加载上下文+CPU执行+CPU保存上下文</li><li>进程的颗粒度太大，每次都要有上下的调入，保存，调出。线程就是进程的小分支，比如进程A有a，b，c三个线程，那么线程a，b，c就共享了进程A的上下文环境，成为了更细小的执行时间。</li></ol><h4 id="程序中的线程与CPU线程"><a href="#程序中的线程与CPU线程" class="headerlink" title="程序中的线程与CPU线程"></a>程序中的线程与CPU线程</h4><p>看到这里会懵逼，假设一台8CPU32核的服务器，是不是跑的程序最多只能开32个线程呢？</p><p>答案当然是否定的，我们常说的进程中的线程，与CPU的线程，虽然都叫线程，但完全不是一回事。</p><p>程序的线程是软件概念，一个程序可以有多个线程，可以在一个CPU核上轮流<strong>并发</strong>执行。<br>CPU的线程是硬件的概念,就是核。八线程就是能让八个线程<strong>并行</strong>执行。</p><h4 id="linux中的线程"><a href="#linux中的线程" class="headerlink" title="linux中的线程"></a>linux中的线程</h4><p>暂时来不及总结，原文链接有。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="脚手架、框架、架构"><a href="#脚手架、框架、架构" class="headerlink" title="脚手架、框架、架构"></a>脚手架、框架、架构</h3><ul><li>脚手架是指一个项目模板，通过这个模板可以生成固定模板的项目。 </li><li>框架一般是说应用框架，就是别人已经搭建好的成熟组件，我们只需要填代码就行，比如Spring<br>Boot就是一个框架，我们要开发spring应用，就可以在这个框架里面按照它的规范去写代码。</li><li>架构是指解决特定业务场景的技术解决方案。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础知识 </category>
          
          <category> web </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VM </tag>
            
            <tag> nginx </tag>
            
            <tag> 编译 </tag>
            
            <tag> 环境变量 </tag>
            
            <tag> Cookie </tag>
            
            <tag> Session </tag>
            
            <tag> 密码学 </tag>
            
            <tag> 硬件知识 </tag>
            
            <tag> 线程、进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代理设置</title>
      <link href="/posts/58712/"/>
      <url>/posts/58712/</url>
      
        <content type="html"><![CDATA[<h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><p>windows不要开全局模式，使用命令行下载会出一些问题。用直连或者PAC模式，用浏览器代理，使用插件switchyomega</p><h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><p>npm在windows下载过慢一般两个办法，换源或设置代理，linux也是这个思路。</p><h3 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h3><p>先打开小飞机。使用命令行</p><pre class="line-numbers language-none"><code class="language-none">npm config set proxy http://server:port<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>server一般就是127.0.0.1<br>port一般是1080</p></blockquote><p>因为是在本地使用的，所以server为localhost</p><p>查看状态：</p><pre class="line-numbers language-none"><code class="language-none">npm config list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除代理：</p><pre class="line-numbers language-none"><code class="language-none">npm config delete proxy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h3><pre class="line-numbers language-none"><code class="language-none">npm config set registry https://registry.npm.taobao.org<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果淘宝源不好，可以尝试清华源</p><h3 id="设置代理和换源的区别"><a href="#设置代理和换源的区别" class="headerlink" title="设置代理和换源的区别"></a>设置代理和换源的区别</h3><blockquote><p>代理的话，是设置代理服务器，代理服务器帮你转发下载请求；镜像源的话，是镜像站点已经提前镜像(下载)了所有的npm包，你是直接从它的服务器上获取到的包</p></blockquote><h2 id="git-linux相同"><a href="#git-linux相同" class="headerlink" title="git(linux相同)"></a>git(linux相同)</h2><h3 id="git设置代理"><a href="#git设置代理" class="headerlink" title="git设置代理"></a>git设置代理</h3><h4 id="http-https协议"><a href="#http-https协议" class="headerlink" title="http||https协议"></a>http||https协议</h4><pre class="line-numbers language-none"><code class="language-none">//设置全局代理//httpgit config --global https.proxy http://127.0.0.1:1080//httpsgit config --global https.proxy https://127.0.0.1:1080//使用socks5代理的 例如ss，ssr 1080是windows下ss的默认代理端口,mac下不同，或者有自定义的，根据自己的改git config --global http.proxy socks5://127.0.0.1:1080git config --global https.proxy socks5://127.0.0.1:1080//只对github.com使用代理，其他仓库不走代理git config --global http.https://github.com.proxy socks5://127.0.0.1:1080git config --global https.https://github.com.proxy socks5://127.0.0.1:1080//取消github代理git config --global --unset http.https://github.com.proxygit config --global --unset https.https://github.com.proxy//取消全局代理git config --global --unset http.proxygit config --global --unset https.proxy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="ssh协议"><a href="#ssh协议" class="headerlink" title="ssh协议"></a>ssh协议</h4><pre class="line-numbers language-none"><code class="language-none">//对于使用git@协议的，可以配置socks5代理//在~/.ssh/config 文件后面添加几行，没有可以新建一个//socks5Host github.comUser gitProxyCommand connect -S 127.0.0.1:1080 %h %p//http || httpsHost github.comUser gitProxyCommand connect -H 127.0.0.1:1080 %h %p<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="git-clone-过慢"><a href="#git-clone-过慢" class="headerlink" title="git clone 过慢"></a>git clone 过慢</h3><p><a href="https://blog.csdn.net/Kingknot/article/details/104271885">原链接</a></p><p>git clone特别慢是因为github.global.ssl.fastly.net域名被限制了。<br>只要找到这个域名对应的ip地址，然后在hosts文件中加上ip–&gt;域名的映射，刷新DNS缓存便可。</p><p>解决办法：</p><ol><li>在网站 <a href="https://www.ipaddress.com/">https://www.ipaddress.com/</a> 分别搜索：<pre class="line-numbers language-none"><code class="language-none">github.global.ssl.fastly.netgithub.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><img src="https://s2.loli.net/2022/11/25/obMQc1JLpK3kXut.png" alt=""></li></ol><p>得到准确的ip</p><p>(我当时没搜到github.global.ssl.fastly.net的准确ip，只有github.com的)  </p><ol><li><p>打开hosts文件，进行配置</p><ul><li>Windows上的hosts文件路径在C:\Windows\System32\drivers\etc\hosts</li><li>Linux的hosts文件路径在：sudo vim /etc/hosts</li></ul></li><li><p>在hosts文件末尾添加两行(对应上面查到的ip)</p></li></ol><pre class="line-numbers language-none"><code class="language-none">199.232.5.194 github.global-ssl.fastly.net192.30.253.113 github.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li>保存更新DNS</li></ol><p>Winodws系统的做法：打开CMD，输入<br></p><pre class="line-numbers language-none"><code class="language-none">ipconfig /flushdns<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>Linux的做法：在终端输入(失败了)<br><pre class="line-numbers language-none"><code class="language-none">sudo /etc/init.d/networking restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p><p>现在很多Linux发行版都没有内置DNS本地缓存，Linux不像Windows那样可以使用ipconfig /flushdns来刷新，在Linux下无需刷新，因为本身没有缓存；</p><p>当然，如果非要缓存刷新，可以安装nscd，然后刷新这个守护进程。</p><p>Ubuntu：</p><p>apt-get install -y nscd</p><p>CentOS:</p><p>yum install -y nscd</p><p>使用：</p><p>service nscd restart</p><h2 id="Linux下设置代理"><a href="#Linux下设置代理" class="headerlink" title="Linux下设置代理"></a>Linux下设置代理</h2><p>换源的方法和windows一样，设置代理有些不同。</p><h3 id="npm设置代理"><a href="#npm设置代理" class="headerlink" title="npm设置代理"></a>npm设置代理</h3><p>需要下载代理客户端—clash<br>可以去Github直接搜索。<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/8986f5c2d1ec4c1eb9143f50a80b613e.png" alt=""></p><p>这里面有个关键的东西：</p><pre class="line-numbers language-none"><code class="language-none">wget -O config.yml https://dingyue.suying666.info/link/1mrTmf9SI8DxkW5c?clash=1&amp;log-level=info<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>http那一块是由厂家提供的，每个厂家的不一样。</p><p>按照这个教程会生成两个配置文件，.yml和.yaml。把yml里面的内容复制到.yaml，再删除yml。.yaml是新版的。</p><p>如果这个时候输出的信息不大对，或者无法使用clahs dashboard 访问，可能是配置文件有问题。</p><p>使用：</p><pre class="line-numbers language-none"><code class="language-none">./clash -f 配置文件<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到是否有错误。</p><p>关于clash的命令可以使用help来尝试。</p><h3 id="npm-查看一个包的版本信息"><a href="#npm-查看一个包的版本信息" class="headerlink" title="npm 查看一个包的版本信息"></a>npm 查看一个包的版本信息</h3><p><strong>假设现在我们已经成功下载了jquery，过了一段时间，我忘记了下载的jquery的版本信息，这个时候，我们就需要查看本地下载的jquery版本信息，怎么做呢？</strong></p><p>第一种方式：<code>npm ls jquery</code> 即可（查看本地安装的jQuery），下面我的本地没有安装jquery，所以返回empty的结果；</p><p>第二种方式：<code>npm ls jquery -g</code> (查看全局安装的jquery)</p><p>有了npm 我们能够简单的一段代码就下载我们需要的包，但是包是不断更新的，</p><p>所以我们要关注包的版本信息；</p><p><strong>现在，假设我们需要 jquery ，但是jquery现在有很多版本，我们如何通过npm查看呢？<br>要知道，现在的jquery包在npm服务器的上，我们使用下面的命令查看：</strong></p><p>一种方式：使用<code>npm view jquery versions</code>这种方式可以查看npm服务器上所有的jquery版本信息；</p><p>第二种方式：使用<code>npm view jquery version</code>这种方式只能查看jquery的最新的版本是哪一个；</p><p>第三种方式：使用<code>npm info jquery</code>这种方式和第一种类似，也可以查看jquery所有的版本，但是能查出更多的关于jquery的信息；</p><h3 id="npm-安装指定版本的包"><a href="#npm-安装指定版本的包" class="headerlink" title="npm 安装指定版本的包"></a>npm 安装指定版本的包</h3><p><strong>安装指定版本的jquery-1.11.2</strong></p><pre class="line-numbers language-none"><code class="language-none">npm install jquery@1.11.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>安装1.0中的最新版本</strong></p><pre class="line-numbers language-none"><code class="language-none">npm install jquery@1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>安装2.0版本中的最新版本</strong></p><pre class="line-numbers language-none"><code class="language-none">npm install jquery@2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="clash"><a href="#clash" class="headerlink" title="clash"></a>clash</h2><h3 id="配置clash"><a href="#配置clash" class="headerlink" title="配置clash"></a>配置clash</h3><p>目前（23-07-28）要使用gpt，基本只有美国节点可行，且要开全局模型，但是这样没法访问国内网站。要想访问国内的，只能切换节点，很麻烦。</p><p>解决办法：<br>打开clash-&gt;Profiles-&gt;找到已有的代理（我的是AnthonCloud）-&gt;右键点击 “Edit”-&gt;里面的文件替换为onedirve工具中的文件。</p><p>思路来源：<a href="https://blog.wolfbolin.com/archives/813">原文链接</a></p><h2 id="yarn"><a href="#yarn" class="headerlink" title="yarn"></a>yarn</h2><h3 id="yarn安装"><a href="#yarn安装" class="headerlink" title="yarn安装"></a>yarn安装</h3><pre class="line-numbers language-none"><code class="language-none">npm install -g yarn //成功npm install yarn //失败<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="pip-下载过慢"><a href="#pip-下载过慢" class="headerlink" title="pip 下载过慢"></a>pip 下载过慢</h2><p>由于pip/pypi默认为国外源，下载和安装Python第三方库会非常慢，建议配置国内源：<br>清华源：<br><code>pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</code></p><p>然后 pip install <em>*</em></p><h2 id="swithcyomegy-v2ray"><a href="#swithcyomegy-v2ray" class="headerlink" title="swithcyomegy  v2ray"></a>swithcyomegy  v2ray</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>目的：让浏览器既可以访问outside，访问国内网址也不慢</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/cabf32f8757d45c58bc49ac69d58aa74.png" alt=""><br>默认注意几个模式的选择，默认情景模式是直接连接</p><p>规则列表如果网上找的更新失败，可以去github上面找。<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/57d74b4807c14dba9e65f3dd18f989f5.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/94f842edafb9435e844181e2245b3d74.png" alt=""><br>随便选一个<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/5f590171d65c488db4c6deebc57acd0b.png" alt=""></p><p>复制输入框里面的网址就好了。<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/62667fc0fd2d4a25b932d201dcb1f7db.png" alt=""></p><p>第一次更新情景模式要调成直连模式，后面换为PAC模式。然后switchyomegy换为auto switch</p><h3 id="更新订阅遇到问题"><a href="#更新订阅遇到问题" class="headerlink" title="更新订阅遇到问题"></a>更新订阅遇到问题</h3><p>当需要更新订阅时（购买了套餐，或续费）。一定要先关闭http链接，再选择更新订阅。<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/6cf1b31547d54325bea8cf40ee0129a2.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> npm </tag>
            
            <tag> yarn </tag>
            
            <tag> 梯子 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工具使用技巧集合</title>
      <link href="/posts/300/"/>
      <url>/posts/300/</url>
      
        <content type="html"><![CDATA[<h2 id="科研工具使用"><a href="#科研工具使用" class="headerlink" title="科研工具使用"></a>科研工具使用</h2><h3 id="latex"><a href="#latex" class="headerlink" title="latex"></a>latex</h3><h4 id="latex安装"><a href="#latex安装" class="headerlink" title="latex安装"></a>latex安装</h4><p><a href="https://zhuanlan.zhihu.com/p/166523064">原文链接</a></p><h4 id="latex、mathtype公式结合"><a href="#latex、mathtype公式结合" class="headerlink" title="latex、mathtype公式结合"></a>latex、mathtype公式结合</h4><p>有的期刊的公式无法用word自带的编辑，只能用mathtype。<br>安装好mathtype后，就可以在word里面使用公式，一般来说有两种方式</p><p>一种是mathtype里面的显示，直接写就好<br>第二种是在页面中，用latex形式。$a_i$，然后点击mathtype切换到latex就可转换为公式。</p><h3 id="zotero"><a href="#zotero" class="headerlink" title="zotero"></a>zotero</h3><h4 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h4><p>插件一般从github上面下载，直接搜就好。实在不知道就百度，下载的格式一般是xpi。</p><p>然后进入到zotero。工具-》附加组件-》“右上角齿轮”-》Install Add-on From File</p><p><strong>注意：安装的版本不要pre-release，否则部分功能是没有的。要在latest或者之前的</strong></p><h4 id="zotero记笔记"><a href="#zotero记笔记" class="headerlink" title="zotero记笔记"></a>zotero记笔记</h4><p><strong>需要提前安装好zotero better notes插件</strong></p><p>安装好以后左侧会出现工作区<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/Snipaste_2023-04-16_12-32-28.png" alt=""></p><p>Better Notes引入工作区的概念,工作区是一个单独的Zotero标签页或单独窗口，分为三栏，从左到右依次为：大纲区，主笔记区，预览笔记区<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/cbb52913-237e-4c1b-b59b-3a013bd1c3b9.png" alt=""></p><ol><li>大纲区相当于主笔记区的一个导航</li><li>主笔记可以创建多个，但是每一次只能有一个被使用，要想使用别的主笔记，需要将当前笔记设为主笔记</li><li>主笔记一般来说是针对某一类文章的笔记，而条目笔记是针对每一篇文章的笔记，每篇文章可以创建多个条目笔记，主笔记里面没有特别多的内容，但是可以将其与条目笔记关联起来，最终在预览笔记区就能看到。</li><li>一般来说主笔记是专门有一个分类，叫My Notes。（不清楚我的为什么没有）</li></ol><p>添加条目笔记：<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/Snipaste_2023-04-16_12-45-34.png" alt=""></p><p>链接到指定主笔记位置，主笔记里面还可以设置二三级标题，将条目笔记连接到此<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/Snipaste_2023-04-16_12-49-07.png" alt=""></p><h4 id="zotero抓取pdf元数据失败"><a href="#zotero抓取pdf元数据失败" class="headerlink" title="zotero抓取pdf元数据失败"></a>zotero抓取pdf元数据失败</h4><p>背景：将下载好的pdf导入zotero中，知网抓取元数据失败</p><p>方法：</p><ol><li><p>手动创建条目<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/v2-606c04d45d62dba1235687131ca178fc_r.jpg" alt=""><br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/v2-26e50c913eb9ce6bffcef709128a5858_r.jpg" alt=""><br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/v2-0a378dedf6f34f9e8d850270a79d028c_r.jpg" alt=""><br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/v2-dac636138a29ee80124777e7a59459c1_r.jpg" alt=""></p></li><li><p>把PDF拖到该条目下</p></li></ol><h3 id="zotero同步"><a href="#zotero同步" class="headerlink" title="zotero同步"></a>zotero同步</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p><a href="https://blog.csdn.net/qq_43012930/article/details/114137259">原文链接</a></p><p>zotero同步分为两种：<br>数据同步和文件同步<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/Snipaste_2023-06-03_11-39-19.png" alt=""></p><p>数据同步：数据同步内容可以包含<strong>文献库的条目、笔记、链接、标签</strong>等等。在Zotero中，可以使用Zotero提供的同步服务同步除了附件之外的所有内容，以便在不同的支持Zotero的设备上使用Zotero。英文版内容为：[library items, notes, links, tags, etc.—everything except attachment files]。此外，还可以登录 Zotero.org 在线查看文献库。<strong>数据同步是免费和无限的，无需文件同步即可使用。</strong></p><p>文件同步：数据同步将同步库项目，但不同步附件（PDF，音频和视频文件，图像等）。<strong>官方提供的网盘只有300M，PDF多了后肯定不够用</strong></p><h4 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h4><p><a href="https://www.bilibili.com/video/BV1oD4y1h7rJ/?share_source=copy_web&amp;vd_source=0aac08942099868c6eaf781c9de8ebb1">原链接</a></p><p>核心思路：把题录数据和附件分开存储</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/Snipaste_2023-06-03_11-36-49.png" alt=""></p><h4 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h4><p>在不同的电脑做好以下操作：</p><ol><li>安装zotero软件、zotfile插件、茉莉花插件</li><li><p>zotero账号注册，同步设置。看下图，有一个框不要勾选<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/Snipaste_2023-06-03_11-21-58.png" alt=""></p></li><li><p>网盘同步（可以使用坚果云、百度网盘、onedrive等）。我是用的是onedrive，只需要在onedrive中新建一个文件夹来存放pdf文件</p></li><li><p>找到zotFile首选项，把上一步设置的文件夹位置填进去，下面的子文件夹命名方式表示作者的姓氏（详细的可以去查一下）</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/Snipaste_2023-06-03_11-24-43.png" alt=""></p><ol><li><p>找到[首选项]-&gt;[高级]-&gt;[文件和文件夹]，把根目录的路径设置为上面的路径，这一步是为了让你的zotero知道附件存储在哪<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/Snipaste_2023-06-03_11-28-44.png" alt=""></p></li><li><p>将文件移动到网盘，zotero里面只用剩一个链接。可以看到移动后，pdf文件图标左下角有一个链接的图案</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/Snipaste_2023-06-03_11-44-12.png" alt=""></p><ol><li>其他设备使用，进入zotero后，点击右边的绿色同步按钮，等待即可<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/Snipaste_2023-06-03_11-46-13.png" alt=""></li></ol><h2 id="常用软件或IDE"><a href="#常用软件或IDE" class="headerlink" title="常用软件或IDE"></a>常用软件或IDE</h2><h3 id="MobaXterm"><a href="#MobaXterm" class="headerlink" title="MobaXterm"></a>MobaXterm</h3><h4 id="密钥登录保持长时间连接"><a href="#密钥登录保持长时间连接" class="headerlink" title="密钥登录保持长时间连接"></a>密钥登录保持长时间连接</h4><p>Settings-&gt;Configuration</p><p><img src="https://s2.loli.net/2022/10/28/kc6YuxZpJ1tL3HB.png" alt=""></p><h3 id="postman"><a href="#postman" class="headerlink" title="postman"></a>postman</h3><h4 id="模拟后端数据"><a href="#模拟后端数据" class="headerlink" title="模拟后端数据"></a>模拟后端数据</h4><ol><li><p>选择 Mock Servers。 创建一个mock。记下这个url<br><img src="https://s2.loli.net/2022/05/22/tLCDn7hRwHeFuMo.png" alt="1.png"></p></li><li><p>在集合里面新建request，<br><img src="https://s2.loli.net/2022/05/22/ZoxS7czAkjv6XFq.png" alt="2.png"></p></li><li>再add example<br><img src="https://s2.loli.net/2022/05/22/FgH7stpNEn5zfWI.png" alt="3.png"></li><li>将之前赋值的url，放上去，可以加一个/test 这个符号。下面可以放数据。浏览器访问这个网址就返回这个数据<br><img src="https://s2.loli.net/2022/05/22/GpIWSXxhPBoydw7.png" alt="4.png"></li></ol><h3 id="jupyter"><a href="#jupyter" class="headerlink" title="jupyter"></a>jupyter</h3><h4 id="Cell中-Code-和-Markdown的切换"><a href="#Cell中-Code-和-Markdown的切换" class="headerlink" title="Cell中 Code 和 Markdown的切换"></a>Cell中 Code 和 Markdown的切换</h4><blockquote><p>在一个cell中（在command模式下） 按下 y, 进入Code 按下m, 进入Markdown</p></blockquote><h3 id="VSCode"><a href="#VSCode" class="headerlink" title="VSCode"></a>VSCode</h3><h4 id="快速重启"><a href="#快速重启" class="headerlink" title="快速重启"></a>快速重启</h4><p>打开命令面板：<br></p><pre class="line-numbers language-none"><code class="language-none">Ctrl+shift+p<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>输入：<p></p><pre class="line-numbers language-none"><code class="language-none">Reload Window<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><ol><li>寻找文件夹中的文本内容 <br></li></ol><blockquote><p> 工具栏，编辑-&gt;查找</p></blockquote><ol><li>查找文件夹中的文件：</li></ol><blockquote><p>ctrl+p</p></blockquote><h4 id="列选择快捷键"><a href="#列选择快捷键" class="headerlink" title="列选择快捷键"></a>列选择快捷键</h4><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/99fdf312492c4b4db617bfc61546bffc.png" alt=""></p><h4 id="保证打开新文件不覆盖旧文件"><a href="#保证打开新文件不覆盖旧文件" class="headerlink" title="保证打开新文件不覆盖旧文件"></a>保证打开新文件不覆盖旧文件</h4><p>首先进行搜索，快捷键ctrl+shift+p，在搜索框里输入settings进行搜索，看到User Setting选项，点击打开<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/cc15f737ae23cae6be0cf2e8d521beea.png" alt=""></p><p>打开以后看到如下界面，输入enablePreview(选项在Workbench工作台中)搜索，然后将箭头指示的地方的对勾取消即可，再次打开文件就不会覆盖原窗口文件了<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/bad54313e45d6dcd629fe32ca1d217be.png" alt=""></p><h4 id="remote-ssh无法连接"><a href="#remote-ssh无法连接" class="headerlink" title="remote ssh无法连接"></a>remote ssh无法连接</h4><p>有时候使用插件remote ssh连接失败，会出现”lockfile” 这个词，解决办法就是在vscode的设置里面搜索”remote ssh:lockfile”，然后勾选。</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/Snipaste_2023-09-04_13-57-34.png" alt=""></p><h3 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h3><h4 id="springboot中的pom-xml没有变蓝色"><a href="#springboot中的pom-xml没有变蓝色" class="headerlink" title="springboot中的pom.xml没有变蓝色"></a>springboot中的pom.xml没有变蓝色</h4><p>新建一个springboot项目，pom.xml没有变蓝色，前面没有蓝色的m。也不能run和debug。<br>解决办法：<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/20201102125508404.png" alt=""></p><h4 id="intellij-idea折叠文件夹展开"><a href="#intellij-idea折叠文件夹展开" class="headerlink" title="intellij idea折叠文件夹展开"></a>intellij idea折叠文件夹展开</h4><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/2020091812214994.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/20200918122331608.png" alt=""></p><h4 id="intellij-idea快速生成main方法、for循环、out输出"><a href="#intellij-idea快速生成main方法、for循环、out输出" class="headerlink" title="intellij idea快速生成main方法、for循环、out输出"></a>intellij idea快速生成main方法、for循环、out输出</h4><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/ff17e40bd4ea43169a3ef746cbb36550.png" alt=""></p><pre class="line-numbers language-none"><code class="language-none">Ctrl+d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="替换指定内容"><a href="#替换指定内容" class="headerlink" title="替换指定内容"></a>替换指定内容</h4><pre class="line-numbers language-none"><code class="language-none">idea替换快捷键有两种：1、“ctrl+r”快捷键，用于当前文件内容替换，指的是在当前打开的文件中替换匹配的字符，只操作一个文件；2、“ctrl+shift+r”快捷键，用于在路径中替换。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="快速添加-getter、setter-方法"><a href="#快速添加-getter、setter-方法" class="headerlink" title="快速添加 getter、setter 方法"></a>快速添加 getter、setter 方法</h4><pre class="line-numbers language-none"><code class="language-none">Alt+Insert<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="代码对比工具"><a href="#代码对比工具" class="headerlink" title="代码对比工具"></a>代码对比工具</h3><h4 id="sublime"><a href="#sublime" class="headerlink" title="sublime"></a>sublime</h4><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/3d989651b0d14c65a56aea98f857013d.png" alt=""></p><h3 id="SSH客户端"><a href="#SSH客户端" class="headerlink" title="SSH客户端"></a>SSH客户端</h3><h4 id="MobaXterm-1"><a href="#MobaXterm-1" class="headerlink" title="MobaXterm"></a>MobaXterm</h4><p>选择它的原因是因为可以直接将windonws下的文件拖拽过来，不用通过专门的传输软件（xftp），且不用命令可以看到目录结构<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/e86c8f5d1e0f4262a73dc4dc958a4cd8.png" alt=""></p><h5 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h5><p>不用设置，MobaXTerm 里面选取内容就已经复制了，如图，白色的内容就已经成功复制了哈哈哈哈，真方便。<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/ff09c618917940a79a19b1da827f9b59.png" alt=""><br>如果不行，看看是否是这里没有勾上（在 setting 里的 Configuration里面）：<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/2cbe8be79b734c069e1f1920e9080f12.png" alt=""></p><h5 id="粘贴"><a href="#粘贴" class="headerlink" title="粘贴"></a>粘贴</h5><p>MobaXterm默认的复制键不是 ctrl+v，当初复制服务器密码的时候老出错，一度怀疑密码错了。<br>这个快捷键可以设置</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/cc6fb7c9545f447b902bc8af4ea94ba3.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/fa9344127b15405cbc97e18c8cb92998.png" alt=""></p><p>好了，现在 复制-粘贴 就是：选中，Ctrl + V</p><h5 id="下载文件到本地"><a href="#下载文件到本地" class="headerlink" title="下载文件到本地"></a>下载文件到本地</h5><p>选中目标文件，右击 ，Download。<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/95fc0ebdbabd46918713cb124e31ace9.png" alt=""></p><h5 id="修改字体"><a href="#修改字体" class="headerlink" title="修改字体"></a>修改字体</h5><p>修改完成后要重新新建会话才会生效。<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/217b607feab24741a1d55f3abd15c627.png" alt=""></p><h3 id="Everything"><a href="#Everything" class="headerlink" title="Everything"></a>Everything</h3><h4 id="很多文件搜索不到"><a href="#很多文件搜索不到" class="headerlink" title="很多文件搜索不到"></a>很多文件搜索不到</h4><p>工具-&gt;选项-&gt;左侧找”索引”-&gt;点击里面的”强制重建”</p><p>可解决这个问题，以避免卸载重装</p><h2 id="Microsoft"><a href="#Microsoft" class="headerlink" title="Microsoft"></a>Microsoft</h2><h3 id="visio"><a href="#visio" class="headerlink" title="visio"></a>visio</h3><h4 id="快捷键集合"><a href="#快捷键集合" class="headerlink" title="快捷键集合"></a>快捷键集合</h4><p>箭头反转</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">点箭头，然后Ctrl<span class="token operator">+</span>h即可<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Word"><a href="#Word" class="headerlink" title="Word"></a>Word</h3><h4 id="项目封面问题"><a href="#项目封面问题" class="headerlink" title="项目封面问题"></a>项目封面问题</h4><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/66dad9a8d7944bb98f925bcff19989fe.png" alt=""><br>封面经常会对不齐，可以新建一个<strong>3列表格</strong>。在表格里面调整对齐。</p><h4 id="显示word文档所有格式"><a href="#显示word文档所有格式" class="headerlink" title="显示word文档所有格式"></a>显示word文档所有格式</h4><p>在模板处直接改动，会出现格式突然不一样，即使<strong>只粘贴文字</strong>也不行；如果自己制作格式，有可能不知不觉会影响其它部分的格式。</p><h4 id="公式添加编号并右对齐"><a href="#公式添加编号并右对齐" class="headerlink" title="公式添加编号并右对齐"></a>公式添加编号并右对齐</h4><p><img src="https://pic1.zhimg.com/80/v2-2e7e2220c80699bc8f1f5c3d21a46c24_720w.webp" alt=""></p><p>在公式内部的末尾添加：#(1)</p><p><strong>还是按照模板的要求制作格式，最后两个相互对比</strong></p><p>先看下效果图<br><img src="https://s2.loli.net/2022/06/10/E2rJMdF9tZhDUQO.png" alt="Snipaste_2022-06-10_09-32-53.png"></p><p>光标指到那一部分就显示那一部分的格式。</p><p>如何制作：</p><ol><li>打开word软件，菜单栏中选择“文件”，在弹出的界面中，选中“选项”。</li><li>在弹出的word选项属性中，点击选择“自定义功能区”。</li><li>在选择命令区中，下拉列表框，选择“不在功能区命令”，按字母排序的顺序，在列中快速找到“显示格式”，</li><li>在右侧的中，选择主选项卡，展开视图——显示，并选中。</li><li>再点击新建组，输入名字“显示格式”，然后点击添加，将显示格式添加进去，然后确定。</li><li>接着我们就可以在视图中找“显示格式”，点击起用显示格，在右边就可以看到显示格式的属性。</li></ol><h4 id="Word中插入公式后行距变大的解决办法"><a href="#Word中插入公式后行距变大的解决办法" class="headerlink" title="Word中插入公式后行距变大的解决办法"></a>Word中插入公式后行距变大的解决办法</h4><p>撰写论文时，在word中插入公式后，行间距变大，与纯文字的行间距不一致，解决办法如下：</p><p>光标定位到出现异常的段落，右键选择“段落”→“缩进和间距”，找到间距下面的“如果定义了文档网格，则对齐到网格”，取消勾选即可。</p><h3 id="PPT"><a href="#PPT" class="headerlink" title="PPT"></a>PPT</h3><h3 id="Excel"><a href="#Excel" class="headerlink" title="Excel"></a>Excel</h3><h3 id="visio-1"><a href="#visio-1" class="headerlink" title="visio"></a>visio</h3><h4 id="添加连接点，并且与另一个连接点对齐"><a href="#添加连接点，并且与另一个连接点对齐" class="headerlink" title="添加连接点，并且与另一个连接点对齐"></a>添加连接点，并且与另一个连接点对齐</h4><p><a href="https://jingyan.baidu.com/article/5d368d1e9c893d3f60c05722.html">原链接</a></p><ol><li>点击工具上的这个 X 形工具。可以看到，最左边的矩形只有一个连接点，为了画出需要的框图，需要手动添加四个连接点。</li></ol><p><img src="https://exp-picture.cdn.bcebos.com/32fbcd41037de137c78f7e09f6c5cf672a5f2a52.jpg?x-bce-process=image%2Fformat%2Cf_auto%2Fquality%2Cq_80" alt=""></p><ol><li>选中不需要添加连接点的那个图形（这里以中间部分最上方第一个矩形为例，选中它）。然后点击工具里的连接线</li></ol><p><img src="https://exp-picture.cdn.bcebos.com/04d7a614f4d0b503d02b1a4bcc4ec28332bf2052.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1%2Fformat%2Cf_auto%2Fquality%2Cq_80" alt=""></p><ol><li>从选中的那个矩形最左边的连接点引出一条水平的连接线（把鼠标移动到那个连接点出，看到连接点变绿之后，按住鼠标向左拖动一段，然后松开鼠标），效果如下</li></ol><p><img src="https://exp-picture.cdn.bcebos.com/51f9aa3ea8db574ad9cbcf29a7f7dfb2dd191752.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1%2Fformat%2Cf_auto%2Fquality%2Cq_80" alt=""></p><ol><li>把鼠标光标移动到绘图区域上方的刻度上，然后向下拉出一条参考线，使参考线和刚才引出的水平连接线重合。（刻度就是红箭头所指的那个）</li></ol><p><img src="https://exp-picture.cdn.bcebos.com/5a5a00def4dca0393ee6925958d96975f3c40d52.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1%2Fformat%2Cf_auto%2Fquality%2Cq_80" alt=""></p><p><img src="https://exp-picture.cdn.bcebos.com/edd84743040148fe28bb01de8fd149299b880252.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1%2Fformat%2Cf_auto%2Fquality%2Cq_80" alt=""></p><ol><li>先按住ctrl键，滑动鼠标滚轮，将图像放大，方便操作。然后继续按住ctrl键，移动鼠标到参考线和左边竖长的那个矩形的交点，看到它变白之后点击一下，对齐的连接点就添加成功了。</li></ol><p><strong>这一步很关键，如果连接点添加到了参考线，那么是无法连接的，要确保连接点添加在形状上，可以通过放大，找打参考线和形状的交接点，然后多点几次鼠标找一找</strong></p><p><img src="https://exp-picture.cdn.bcebos.com/9bc92713e8e5ecee9345e29acc704618deda7a52.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1%2Fformat%2Cf_auto%2Fquality%2Cq_80" alt=""></p><h4 id="输出矢量图"><a href="#输出矢量图" class="headerlink" title="输出矢量图"></a>输出矢量图</h4><p>首先“ctrl+A”，然后选择“另存为”，保存类型选择“Tag图像文件格式”，接着在输出里面设置，压缩格式选为“LZW”，接着是“256色”，然后选择“打印机”，下面是“源”，然后点击确定就可以了。这样绝对是满足投稿要求的，分辨率为300dpi。</p><h4 id="插入公式"><a href="#插入公式" class="headerlink" title="插入公式"></a>插入公式</h4><ol><li>使用wps自带的公式编辑器</li></ol><p>首先打开Visio，任意新建一个Visio绘图。点击插入——对象——WPS公式3.0，最后点击确定，会弹出WPS的公式编辑器。<br>在公式编辑器中，输入自己想要的公式后，点击关闭窗口，即可成功插入公式。</p><ol><li>使用mathtype（推荐） </li></ol><p>打开Visio，任意新建一个Visio绘图。点击插入——对象——MathType 6.0 Equation，点击确定，会弹出MathType公式编辑器。</p><h2 id="不小心关闭了某个页面"><a href="#不小心关闭了某个页面" class="headerlink" title="不小心关闭了某个页面"></a>不小心关闭了某个页面</h2><p>恢复： </p><blockquote><p>ctrl+shift+t</p></blockquote><h2 id="快速开启powershell"><a href="#快速开启powershell" class="headerlink" title="快速开启powershell"></a>快速开启powershell</h2><p>在需要启动powershell的文件里面</p><pre class="line-numbers language-none"><code class="language-none">shift+右键<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/a3d91843cc7245db81df0ba36eeadc29.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> office </tag>
            
            <tag> IDE </tag>
            
            <tag> 编辑器 </tag>
            
            <tag> 快捷键 </tag>
            
            <tag> vscode </tag>
            
            <tag> visio </tag>
            
            <tag> postman </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java知识</title>
      <link href="/posts/53165/"/>
      <url>/posts/53165/</url>
      
        <content type="html"><![CDATA[<h2 id="Java基础知识"><a href="#Java基础知识" class="headerlink" title="Java基础知识"></a>Java基础知识</h2><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p><a href="https://blog.csdn.net/weixin_43271086/article/details/106023108?spm=1001.2101.3001.6650.1&amp;depth_1-utm_relevant_index=2">原文链接</a></p><p><strong>JAVA反射机制是在运行状态中，对于任意一个实体类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</strong></p><p><strong>反射的好处：<br>      1.可以在程序运行过程中，操作这些对象。<br>      2.可以进行解耦，提高程序的扩展性。</strong></p><p>Java代码在计算机中的三个阶段</p><ul><li>1.Sources源代码阶段：<em>.java被编译成</em>.class字节码文件。</li><li>2.Class类对象阶段：*.class字节码文件被类加载器加载进内存，并将其封装成Class对象（用于描述在内存中描述字节码文件），Class对象将原字节码文件中的成员变量，构造函数，方法等的做了封装。</li><li>3.Runtime运行阶段：创建对象的过程new</li></ul><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/20200509170218257.png" alt=""></p><h4 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h4><p>获取Class对象的三种方式对应着java代码在计算机中的三个阶段：</p><p>1.源代码阶段<br>Class.forName(“全类名”)：将字节码文件加载进内存，返回Class对象。</p><p>2.Class类对象阶段<br>类名.class:通过类名的属性class获取</p><p>3.Runtime运行时阶段<br>对象.getClass():getClass()方法是定义在Object类中的方法。</p><p><strong>结论：同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，无论通过哪一种方式获取的Class对象都是同一个。</strong></p><p>测试代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>company<span class="token punctuation">.</span>reflect</span><span class="token punctuation">;</span> <span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>company<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>domain<span class="token punctuation">.</span></span><span class="token class-name">Person</span><span class="token punctuation">;</span> <span class="token comment">/** * ⊙﹏⊙&amp;&amp;&amp;&amp;&amp;&amp;⊙▽⊙ * * @Auther: pangchenbo * @Date: 2020/5/9 10:37 * @Description: */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReflectDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{</span>        <span class="token comment">//方式一：Class.forName("全类名")</span>        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> aClass <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.company.reflect.domain.Person"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>aClass<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//方式二：类名.class</span>        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">&gt;</span></span> personClass <span class="token operator">=</span> <span class="token class-name">Person</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>personClass<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//方式三：对象.getClass()</span>        <span class="token class-name">Person</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span><span class="token punctuation">&gt;</span></span> aClass1 <span class="token operator">=</span> person<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>aClass1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//比较 == 三个对象</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>aClass <span class="token operator">==</span> aClass1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>personClass<span class="token operator">==</span>aClass1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/20200509171516530.png" alt=""><br>两个true表示Class对象是同一个。</p><h4 id="获取Class对象功能"><a href="#获取Class对象功能" class="headerlink" title="获取Class对象功能"></a>获取Class对象功能</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">（<span class="token number">1</span>）获取成员变量们<span class="token class-name">Field</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getFields</span><span class="token punctuation">(</span><span class="token punctuation">)</span> ：获取所有<span class="token keyword">public</span>修饰的成员变量<span class="token class-name">Field</span> <span class="token function">getField</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span>   获取指定名称的 <span class="token keyword">public</span>修饰的成员变量 <span class="token class-name">Field</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getDeclaredFields</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  获取所有的成员变量，不考虑修饰符<span class="token class-name">Field</span> <span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span>（<span class="token number">2</span>）获取构造方法们<span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getConstructors</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">getConstructor</span><span class="token punctuation">(</span>类<span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> parameterTypes<span class="token punctuation">)</span>   <span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getDeclaredConstructors</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span>类<span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> parameterTypes<span class="token punctuation">)</span>  （<span class="token number">3</span>）获取成员方法们<span class="token class-name">Method</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token class-name">Method</span> <span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> 类<span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> parameterTypes<span class="token punctuation">)</span>   <span class="token class-name">Method</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getDeclaredMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token class-name">Method</span> <span class="token function">getDeclaredMethod</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> 类<span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> parameterTypes<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <strong>Field：成员变量</strong><br>先写一个测试类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> a<span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token class-name">String</span> b<span class="token punctuation">;</span>    <span class="token class-name">String</span> c<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> d<span class="token punctuation">;</span>     <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">Integer</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Person{"</span> <span class="token operator">+</span>                <span class="token string">"name='"</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token char">'\''</span> <span class="token operator">+</span>                <span class="token string">", age="</span> <span class="token operator">+</span> age <span class="token operator">+</span>                <span class="token string">", a='"</span> <span class="token operator">+</span> a <span class="token operator">+</span> <span class="token char">'\''</span> <span class="token operator">+</span>                <span class="token string">", b='"</span> <span class="token operator">+</span> b <span class="token operator">+</span> <span class="token char">'\''</span> <span class="token operator">+</span>                <span class="token string">", c='"</span> <span class="token operator">+</span> c <span class="token operator">+</span> <span class="token char">'\''</span> <span class="token operator">+</span>                <span class="token string">", d='"</span> <span class="token operator">+</span> d <span class="token operator">+</span> <span class="token char">'\''</span> <span class="token operator">+</span>                <span class="token char">'}'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//无参方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"eat..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token comment">//重载有参方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token class-name">String</span> food<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"eat..."</span><span class="token operator">+</span>food<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>获取所有的public修饰的成员变量</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//0.获取Person对象</span>        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">&gt;</span></span> personClass <span class="token operator">=</span> <span class="token class-name">Person</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>        <span class="token comment">//1.获取所有public修饰的成员变量</span>        <span class="token class-name">Field</span><span class="token punctuation">[</span><span class="token punctuation">]</span> fields <span class="token operator">=</span> personClass<span class="token punctuation">.</span><span class="token function">getFields</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Field</span> field <span class="token operator">:</span> fields<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>field<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/2020050917325871.png" alt=""><br><strong>获取特定的成员变量（public）</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//2.Field getField(String name)</span>        <span class="token class-name">Field</span> a <span class="token operator">=</span> personClass<span class="token punctuation">.</span><span class="token function">getField</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//获取成员变量a 的值 [也只能获取公有的，获取私有的或者不存在的字符会抛出异常]</span>        <span class="token class-name">Person</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Object</span> o <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"o  value: "</span><span class="token operator">+</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//设置属性a的值</span>        a<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span><span class="token string">"haha"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/20200509173350461.png" alt=""></p><p><strong>获取全部的成员变量</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//Field[] getDeclaredFields()：获取所有的成员变量，不考虑修饰符</span>        <span class="token class-name">Field</span><span class="token punctuation">[</span><span class="token punctuation">]</span> declaredFields <span class="token operator">=</span> personClass<span class="token punctuation">.</span><span class="token function">getDeclaredFields</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Field</span> declaredField <span class="token operator">:</span> declaredFields<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>declaredField<span class="token operator">+</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"=============================="</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/20200509173421562.png" alt=""><br><strong>获取特定的成员变量，在这里如果需要对private进行修改，就必须进行暴力反射，将d.setAccessible(true);设置为true</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"=============================="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Field</span> d <span class="token operator">=</span> personClass<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"d"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        d<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//暴力反射</span>        d<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>        d<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span><span class="token string">"222"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/20200509173436455.png" alt=""><br> <strong>普通方法获取</strong><br>获取指定名称的方法（不带参数的获取）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">&gt;</span></span> personClass <span class="token operator">=</span> <span class="token class-name">Person</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>        <span class="token comment">//获取指定名称的方法</span>        <span class="token class-name">Method</span> eat <span class="token operator">=</span> personClass<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"eat"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Person</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        eat<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//执行方法</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/202005091739379.png" alt=""><br>获取指定名称的方法（带参数获取）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//获取具有参数的构造方法</span>        <span class="token class-name">Method</span> eat1 <span class="token operator">=</span> personClass<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"eat"</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        eat1<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span><span class="token string">"fans"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"==============================="</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/20200509173946494.png" alt=""><br>获取方法列表</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Method</span><span class="token punctuation">[</span><span class="token punctuation">]</span> methods <span class="token operator">=</span> personClass<span class="token punctuation">.</span><span class="token function">getMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Method</span> method <span class="token operator">:</span> methods<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//继承的方法也会被访问（前提是方法是public）</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/20200509174104725.png" alt=""><br>如果设置的方法中含有私有的方法，也可以设置d.setAccessible(true);设置为true，然后就可以访问私有方法。</p><p><strong>构造方法</strong><br>获取无参数的构造器</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">&gt;</span></span> personClass <span class="token operator">=</span> <span class="token class-name">Person</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>        <span class="token comment">//Constructor&lt;?&gt;[] getConstructors()</span>        <span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> constructors <span class="token operator">=</span> personClass<span class="token punctuation">.</span><span class="token function">getConstructors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> constructor <span class="token operator">:</span> constructors<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>constructor<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes)</span>        <span class="token comment">//获取无参</span>        <span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">&gt;</span></span> constructor1 <span class="token operator">=</span> personClass<span class="token punctuation">.</span><span class="token function">getConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>constructor1<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//利用获取的构造器创建对象</span>        <span class="token class-name">Person</span> person <span class="token operator">=</span> constructor1<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/20200509174551558.png" alt=""><br>获取有参数的构造器<br></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//获取有参</span>        <span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">&gt;</span></span> constructor <span class="token operator">=</span> personClass<span class="token punctuation">.</span><span class="token function">getConstructor</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>constructor<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Person</span> person1 <span class="token operator">=</span> constructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token string">"PCB"</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>person1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//理应Class类对象进行对象的构建获取</span>        <span class="token class-name">Person</span> person2 <span class="token operator">=</span> personClass<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>person2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//对于getDeclaredConstructor方法和getDeclaredConstructors方法,此外在构造器的对象内也有setAccessible(true);方法，并设置成true就可以操作了。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/20200509174655701.png" alt=""><p></p><h4 id="简单框架设计、理解反射好处"><a href="#简单框架设计、理解反射好处" class="headerlink" title="简单框架设计、理解反射好处"></a>简单框架设计、理解反射好处</h4><p>准备测试类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>company<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>domain</span><span class="token punctuation">;</span> <span class="token comment">/** * ⊙﹏⊙&amp;&amp;&amp;&amp;&amp;&amp;⊙▽⊙ * * @Auther: pangchenbo * @Date: 2020/5/9 13:27 * @Description: */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"sleep..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 准备文件properties文件</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">className <span class="token operator">=</span> <span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>company<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>domain<span class="token punctuation">.</span></span>Student</span>methodName <span class="token operator">=</span> sleep<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> <strong>需求</strong><br>写一个”框架”，不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且执行其中任意方法。</p><p><strong>实现</strong><br>（1）配置文件 （2）反射</p><p><strong>步骤</strong></p><p>（1）将需要创建的对象的全类名和需要执行的方法定义在配置文件中 （2）在程序中加载读取配置文件 （3）使用反射技术来加载类文件进内存 （4）创建对象 （5）执行方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>company<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span>反射案例<span class="token punctuation">;</span> <span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">InputStream</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token class-name">Method</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Properties</span><span class="token punctuation">;</span> <span class="token comment">/** * ⊙﹏⊙&amp;&amp;&amp;&amp;&amp;&amp;⊙▽⊙ * * @Auther: pangchenbo * @Date: 2020/5/9 13:30 * @Description: */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReflectTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token comment">/**         * 前提：不能改变该类的任何代码。可以创建任意类的对象，可以执行任意方法         */</span>        <span class="token comment">//1.加载配置文件</span>        <span class="token comment">//1.1创建Properties对象</span>        <span class="token class-name">Properties</span> properties <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//1.2加载配置文件，转换为一个集合</span>        <span class="token comment">//1.2.1获取class目录下的配置文件  使用类加载器</span>        <span class="token class-name">ClassLoader</span> classLoader <span class="token operator">=</span> <span class="token class-name">ReflectTest</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">InputStream</span> resourceAsStream <span class="token operator">=</span> classLoader<span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span><span class="token string">"pro.properties"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        properties<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>resourceAsStream<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2.获取配置文件中定义的数据</span>        <span class="token class-name">String</span> className <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"className"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> methodName <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"methodName"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">//加载类到内存中</span>        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> aClass <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>className<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//创建对象</span>        <span class="token class-name">Object</span> o <span class="token operator">=</span> aClass<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//获取对象方法</span>        <span class="token class-name">Method</span> method <span class="token operator">=</span> aClass<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span>methodName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//执行方法</span>        method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/2020050917521036.png" alt=""><br>改变配置文件</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">className <span class="token operator">=</span> <span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>company<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>domain<span class="token punctuation">.</span></span>Person</span>methodName <span class="token operator">=</span> eat<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/20200509175301411.png" alt=""></p><p>好处<br>我们这样做有什么好处呢，对于框架来说，是人家封装好的，我们拿来直接用就可以了，而不能去修改框架内的代码。但如果我们使用传统的new形式来实例化，那么当类名更改时我们就要修改Java代码，这是很繁琐的。修改Java代码以后我们还要进行测试，重新编译、发布等等一系列的操作。而如果我们仅仅只是修改配置文件，就来的简单的多，配置文件就是一个实实在在的物理文件。</p><h3 id="String类与StringBuilder类的区别"><a href="#String类与StringBuilder类的区别" class="headerlink" title="String类与StringBuilder类的区别"></a>String类与StringBuilder类的区别</h3><p><a href="https://www.cnblogs.com/huameitang/p/10528646.html">原文链接</a></p><h4 id="StringBuilder类介绍"><a href="#StringBuilder类介绍" class="headerlink" title="StringBuilder类介绍"></a>StringBuilder类介绍</h4><p><strong>StringBuilder类是一个可变的字符序列。</strong></p><p>StringBuilder()<br>          构造一个不带任何字符的字符串生成器，其初始容量为 16 个字符。<br>StringBuilder(CharSequence seq)<br>          构造一个字符串生成器，它包含与指定的 CharSequence 相同的字符。<br>StringBuilder(int capacity)<br>          构造一个不带任何字符的字符串生成器，其初始容量由 capacity 参数指定。<br>StringBuilder(String str)<br>          构造一个字符串生成器，并初始化为指定的字符串内容。</p><h4 id="StringBuilder类的几个常用方法"><a href="#StringBuilder类的几个常用方法" class="headerlink" title="StringBuilder类的几个常用方法"></a>StringBuilder类的几个常用方法</h4><pre class="line-numbers language-none"><code class="language-none">append(任意类型)  追加到字符串后面reverse 反转字符串insert(int offset, 任意类型)  在某个index后插入字符串toString()  返回String类的对象<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先看一段String类的字符串拼接的代码。<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/388de719a9f6ee002b965e622dc87c46.png" alt=""></p><p>String s = “hello” 会在常量池开辟一个内存空间来存储”hello”。</p><p>s += “world”会先在常量池开辟一个内存空间来存储“world”。然后再开辟一个内存空间来存储”helloworld“。</p><p>这么以来，001与002就成为了垃圾内存空间了。这么简单的一个操作就产生了两个垃圾内存空间，如果有大量的字符串拼接，将会造成极大的浪费。</p><h4 id="StringBuilder的作用"><a href="#StringBuilder的作用" class="headerlink" title="StringBuilder的作用"></a>StringBuilder的作用</h4><p>上面的例子可以知道String类的字符串拼接会产生大量的垃圾内存空间。但是StringBuilder的字符串拼接是直接在原来的内存空间操作的，即直接在hello这个内存空间把hello拼接为helloworld。</p><p>来证明下：</p><pre class="line-numbers language-none"><code class="language-none">public class StringBuilderTest {    public static void main(String[] args){        StringBuilder sb = new StringBuilder();        StringBuilder sb2 = sb.append("hello");        System.out.println(sb);        System.out.println(sb2);        // 引用类型，判断的是他们的内存地址是否一样        System.out.println(sb == sb2);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果是：</p><p>hello<br>hello<br>true</p><h4 id="String类与StringBuilder类的相互转换"><a href="#String类与StringBuilder类的相互转换" class="headerlink" title="String类与StringBuilder类的相互转换"></a>String类与StringBuilder类的相互转换</h4><p><strong>1.String类转换为StringBuilder类</strong></p><pre class="line-numbers language-none"><code class="language-none">public class String12 {    public static void main(String[] args){        String s = "hello";        StringBuilder sb = new StringBuilder(s);        System.out.println(sb);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2.StringBuilder类转换为String类</strong></p><pre class="line-numbers language-none"><code class="language-none">public class String12 {    public static void main(String[] args){        StringBuilder sb = new StringBuilder();        sb.append("abc").append("efg");        String s = sb.toString();        System.out.println(s);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h4 id="接口的作用"><a href="#接口的作用" class="headerlink" title="接口的作用"></a>接口的作用</h4><p>接口的最主要的作用是达到统一访问，就是在创建对象的时候用接口创建，<code>【接口名】 【对象名】=new 【实现接口的类】</code>，这样你像用哪个类的对象就可以new哪个对象了，不需要改原来的代码，就和你的USB接口一样，插什么读什么，就是这个原理。如果我用接口，<code>one.method1();</code> 那样我<code>new a()；</code>就是用<code>a</code>的方法，<code>new b()</code>就是用<code>b</code>的方法</p><p>这个就叫统一访问，因为你实现这个接口的类的方法名相同，但是实现内容不同。</p><h4 id="为什么使用接口"><a href="#为什么使用接口" class="headerlink" title="为什么使用接口"></a>为什么使用接口</h4><p><strong>解耦，可扩展这是设计接口的主要原因之一</strong></p><p>如果你开发业务逻辑代码，当你好不容易的实现了它全部的功能，突然用户需求要改，你在修改你代码的同时，调用你代码的其它人也会改，如果代码关联性强的话，会有很多人都要改动代码，这样一来二去，程序会变得相当的不稳定，而且可能还会出现更多的新Bug,所有人都可能会陷入混乱。</p><p>但如果使用接口的话，在你使用它之前，就要想好它要实现的全部功能（接口实际上就是将功能的封装）。确定下这个接口后，如果用户需求变了，你只要重新写它的实现类，而其它人只会调用你的接口，他不管你是怎么实现的，它只需要接口提供的功能。这样，很可能只需要把你的代码修改就可以了，其他人什么都不用做。</p><p>同时：<br>这样做的话，使得开发人员能够分工明确，只要确定下来接口了，就可以同时进行开发，提高开发效率。另外，使用接口还有使用方便，可读性强，结构清晰等优点。</p><h2 id="Java内存分配"><a href="#Java内存分配" class="headerlink" title="Java内存分配"></a>Java内存分配</h2><p><a href="https://blog.csdn.net/shimiso/article/details/8595564">原文链接</a></p><h3 id="内存表示图"><a href="#内存表示图" class="headerlink" title="内存表示图"></a>内存表示图</h3><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/02e0fdf7e9d05a24f1b00895c1726f04.png" alt=""></p><ul><li>l 寄存器：JVM内部虚拟寄存器，存取速度非常快，程序不可控制。</li><li>l 栈：保存局部变量的值，包括：1.用来<strong>保存基本数据类型的值</strong>；2.保存<strong>类的实例</strong>，即堆区对象的引用(指针)。也可以用来保存加载方法时的帧。</li><li>| 堆：用来存放动态产生的数据，比如new出来的对象。注意创建出来的对象只包含属于各自的成员变量，并不包括成员方法。因为同一个类的对象拥有各自的成员变量，存储在各自的堆中，但是他们共享该类的方法，并不是每创建一个对象就把成员方法复制一次。</li><li>l 常量池：JVM为每个已加载的类型维护一个常量池，常量池就是这个类型用到的常量的一个有序集合。包括直接常量(基本类型，String)和对其他类型、方法、字段的符号引用(1)。池中的数据和数组一样通过索引访问。由于常量池包含了一个类型所有的对其他类型、方法、字段的符号引用，所以常量池在Java的动态链接中起了核心作用。常量池存在于堆中。</li><li>l 代码段：用来存放从硬盘上读取的源程序代码。</li><li>l 数据段：用来存放static定义的静态成员。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/20180607221353561.png" alt=""></p><ul><li><p>Byte Short Double等包装类也是类，属于引用数据类型。</p></li><li><p>除了8个基本数据类型，其余都是引用。包括String(只是编译器对其做了特殊处理（使其和基本数据类型一样）)</p></li></ul><h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><p>1.一个Java文件，只要有main入口方法，我们就认为这是一个Java程序，可以单独编译运行。</p><p>2.无论是普通类型的变量还是引用类型的变量(俗称实例)，都可以作为局部变量，他们都可以出现在栈中。只不过普通类型的变量在栈中直接保存它所对应的值，而引用类型的变量保存的是一个指向堆区的指针，通过这个指针，就可以找到这个实例在堆区对应的对象。因此，普通类型变量只在栈区占用一块内存，而引用类型变量要在栈区和堆区各占一块内存。</p><h3 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h3><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/e66638ef11aa279b0b6fd9cd9d559044.png" alt=""><br>1.JVM自动寻找main方法，执行第一句代码，创建一个Test类的实例，在栈中分配一块内存，存放一个指向堆区对象的指针110925。</p><p>2.创建一个int型的变量date，由于是基本类型，直接在栈中存放date对应的值9。</p><p>3.创建两个BirthDate类的实例d1、d2，在栈中分别存放了对应的指针指向各自的对象。他们在实例化时调用了有参数的构造方法，因此对象中有自定义初始值。</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/705d238bc74dcccff8b69184132da30c.png" alt=""><br>调用test对象的change1方法，并且以date为参数。JVM读到这段代码时，检测到i是局部变量，因此会把i放在栈中，并且把date的值赋给i。</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/352eb6cc1d1356088c01eff85f968f29.png" alt=""></p><p>把1234赋给i。很简单的一步。<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/17a915e436d6d65fac2429a7a11b8866.png" alt=""><br>change1方法执行完毕，立即释放局部变量i所占用的栈空间。</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/c26f92c212ed59baec902643ce847cdb.png" alt=""><br>调用test对象的change2方法，以实例d1为参数。JVM检测到change2方法中的b参数为局部变量，立即加入到栈中，由于是引用类型的变量，所以b中保存的是d1中的指针，此时b和d1指向同一个堆中的对象。在b和d1之间传递是指针。</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/de5ed94481f833da822dae4b0ba7829c.png" alt=""></p><p>change2方法中又实例化了一个BirthDate对象，并且赋给b。在内部执行过程是：在堆区new了一个对象，并且把该对象的指针保存在栈中的b对应空间，此时实例b不再指向实例d1所指向的对象，但是实例d1所指向的对象并无变化，这样无法对d1造成任何影响。</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/a5962e6481115a3701e9af607d7dbef5.png" alt=""><br>change2方法执行完毕，立即释放局部引用变量b所占的栈空间，注意只是释放了栈空间，堆空间要等待自动回收。<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/320c1cc9ffa2cb1765dce52ab4e78512.png" alt=""></p><p>调用test实例的change3方法，以实例d2为参数。同理，JVM会在栈中为局部引用变量b分配空间，并且把d2中的指针存放在b中，此时d2和b指向同一个对象。再调用实例b的setDay方法，其实就是调用d2指向的对象的setDay方法。</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/7085e0609e9a98b2cd813f7321083938.png" alt=""><br>调用实例b的setDay方法会影响d2，因为二者指向的是同一个对象。<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/20781e5bcd02ed64fce2f1f20a8f4c8d.png" alt=""><br>change3方法执行完毕，立即释放局部引用变量b。</p><p>以上就是Java程序运行时内存分配的大致情况。其实也没什么，掌握了思想就很简单了。无非就是两种类型的变量：基本类型和引用类型。二者作为局部变量，都放在栈中，基本类型直接在栈中保存值，引用类型只保存一个指向堆区的指针，真正的对象在堆里。作为参数时基本类型就直接传值，引用类型传指针。</p><p>小结：</p><p>1.分清什么是实例什么是对象。Class a= new Class();此时a叫实例，而不能说a是对象。实例在栈中，对象在堆中，操作实例实际上是通过实例的指针间接操作对象。多个实例可以指向同一个对象。</p><p>2.栈中的数据和堆中的数据销毁并不是同步的。方法一旦结束，栈中的局部变量立即销毁，但是堆中对象不一定销毁。因为可能有其他变量也指向了这个对象，直到栈中没有变量指向堆中的对象时，它才销毁，而且还不是马上销毁，要等垃圾回收扫描时才可以被销毁。</p><p>3.以上的栈、堆、代码段、数据段等等都是相对于应用程序而言的。每一个应用程序都对应唯一的一个JVM实例，每一个JVM实例都有自己的内存区域，互不影响。并且这些内存区域是所有线程共享的。这里提到的栈和堆都是整体上的概念，这些堆栈还可以细分。</p><p>4.类的成员变量在不同对象中各不相同，都有自己的存储空间(成员变量在堆中的对象中)。而类的方法却是该类的所有对象共享的，只有一套，对象使用方法的时候方法才被压入栈，方法不使用则不占用内存。</p><p>以上分析只涉及了栈和堆，还有一个非常重要的内存区域：常量池，这个地方往往出现一些莫名其妙的问题。常量池是干嘛的上边已经说明了，也没必要理解多么深刻，只要记住它维护了一个已加载类的常量就可以了。接下来结合一些例子说明常量池的特性。</p><h3 id="预备知识2"><a href="#预备知识2" class="headerlink" title="预备知识2"></a>预备知识2</h3><p>基本类型和基本类型的包装类。基本类型有：byte、short、char、int、long、boolean。基本类型的包装类分别是：Byte、Short、Character、Integer、Long、Boolean。注意区分大小写。二者的区别是：基本类型体现在程序中是普通变量，基本类型的包装类是类，体现在程序中是引用变量。因此二者在内存中的存储位置不同：基本类型存储在栈中，而基本类型包装类存储在堆中。上边提到的这些包装类都实现了常量池技术，另外两种浮点数类型的包装类则没有实现。另外，String类型也实现了常量池技术。</p><h3 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">public class <span class="token builtin class-name">test</span> <span class="token punctuation">{</span>    public static void main<span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>            objPoolTest<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     public static void <span class="token function-name function">objPoolTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        int i <span class="token operator">=</span> <span class="token number">40</span><span class="token punctuation">;</span>        int i0 <span class="token operator">=</span> <span class="token number">40</span><span class="token punctuation">;</span>        Integer i1 <span class="token operator">=</span> <span class="token number">40</span><span class="token punctuation">;</span>        Integer i2 <span class="token operator">=</span> <span class="token number">40</span><span class="token punctuation">;</span>        Integer i3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        Integer i4 <span class="token operator">=</span> new Integer<span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Integer i5 <span class="token operator">=</span> new Integer<span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Integer i6 <span class="token operator">=</span> new Integer<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Double <span class="token assign-left variable">d1</span><span class="token operator">=</span><span class="token number">1.0</span><span class="token punctuation">;</span>        Double <span class="token assign-left variable">d2</span><span class="token operator">=</span><span class="token number">1.0</span><span class="token punctuation">;</span>                System.out.println<span class="token punctuation">(</span><span class="token string">"i=i0<span class="token entity" title="\t">\t</span>"</span> + <span class="token punctuation">(</span>i <span class="token operator">==</span> i0<span class="token punctuation">))</span><span class="token punctuation">;</span>        System.out.println<span class="token punctuation">(</span><span class="token string">"i1=i2<span class="token entity" title="\t">\t</span>"</span> + <span class="token punctuation">(</span>i1 <span class="token operator">==</span> i2<span class="token punctuation">))</span><span class="token punctuation">;</span>        System.out.println<span class="token punctuation">(</span><span class="token string">"i1=i2+i3<span class="token entity" title="\t">\t</span>"</span> + <span class="token punctuation">(</span>i1 <span class="token operator">==</span> i2 + i3<span class="token punctuation">))</span><span class="token punctuation">;</span>        System.out.println<span class="token punctuation">(</span><span class="token string">"i4=i5<span class="token entity" title="\t">\t</span>"</span> + <span class="token punctuation">(</span>i4 <span class="token operator">==</span> i5<span class="token punctuation">))</span><span class="token punctuation">;</span>        System.out.println<span class="token punctuation">(</span><span class="token string">"i4=i5+i6<span class="token entity" title="\t">\t</span>"</span> + <span class="token punctuation">(</span>i4 <span class="token operator">==</span> i5 + i6<span class="token punctuation">))</span><span class="token punctuation">;</span>            System.out.println<span class="token punctuation">(</span><span class="token string">"d1=d2<span class="token entity" title="\t">\t</span>"</span> + <span class="token punctuation">(</span>d1<span class="token operator">==</span>d2<span class="token punctuation">))</span><span class="token punctuation">;</span>                 System.out.println<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">i</span><span class="token operator">=</span>i0    <span class="token boolean">true</span><span class="token assign-left variable">i1</span><span class="token operator">=</span>i2   <span class="token boolean">true</span><span class="token assign-left variable">i1</span><span class="token operator">=</span>i2+i3        <span class="token boolean">true</span><span class="token assign-left variable">i4</span><span class="token operator">=</span>i5   <span class="token boolean">false</span><span class="token assign-left variable">i4</span><span class="token operator">=</span>i5+i6        <span class="token boolean">true</span><span class="token assign-left variable">d1</span><span class="token operator">=</span>d2   <span class="token boolean">false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>结果分析：</strong></p><p>1.i和i0均是普通类型(int)的变量，所以数据直接存储在栈中，而栈有一个很重要的特性：栈中的数据可以共享。当我们定义了int i = 40;，再定义int i0 = 40;这时候会自动检查栈中是否有40这个数据，如果有，i0会直接指向i的40，不会再添加一个新的40。</p><p>2.i1和i2均是引用类型，在栈中存储指针，因为Integer是包装类。由于Integer包装类实现了常量池技术，因此i1、i2的40均是从常量池中获取的，均指向同一个地址，因此i1=12。</p><p>3.很明显这是一个加法运算，Java的数学运算都是在栈中进行的，Java会自动对i1、i2进行拆箱操作转化成整型，因此i1在数值上等于i2+i3。</p><p>4.i4和i5均是引用类型，在栈中存储指针，因为Integer是包装类。但是由于他们各自都是new出来的，因此不再从常量池寻找数据，而是从堆中各自new一个对象，然后各自保存指向对象的指针，所以i4和i5不相等，因为他们所存指针不同，所指向对象不同。</p><p>5.这也是一个加法运算，和3同理。</p><p>6.d1和d2均是引用类型，在栈中存储指针，因为Double是包装类。但Double包装类没有实现常量池技术，因此Doubled1=1.0;相当于Double d1=new Double(1.0);，是从堆new一个对象，d2同理。因此d1和d2存放的指针不同，指向的对象不同，所以不相等。</p><p><strong>小结：</strong></p><p>1.以上提到的几种基本类型包装类均实现了常量池技术，但他们维护的常量仅仅是【-128至127】这个范围内的常量，如果常量值超过这个范围，就会从堆中创建对象，不再从常量池中取。比如，把上边例子改成Integer i1 = 400; Integer i2 = 400;，很明显超过了127，无法从常量池获取常量，就要从堆中new新的Integer对象，这时i1和i2就不相等了。</p><p>2.String类型也实现了常量池技术，但是稍微有点不同。String型是先检测常量池中有没有对应字符串，如果有，则取出来；如果没有，则把当前的添加进去。</p><h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><h4 id="三种使用方式"><a href="#三种使用方式" class="headerlink" title="三种使用方式"></a>三种使用方式</h4><p>Java 中每一个对象都可以作为锁，这是 synchronized 实现同步的基础。synchronized 的三种使用方式如下：</p><ul><li>普通同步方法（实例方法）：锁是当前实例对象 ，进入同步代码前要获得当前实例的锁；</li><li>静态同步方法：锁是当前类的 class 对象 ，进入同步代码前要获得当前类对象的锁；</li><li>同步方法块：锁是括号里面的对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</li></ul><ol><li>类锁所有对象一把锁</li><li>对象锁一个对象一把锁，多个对象多把锁</li><li>同步是对同一把锁而言的，同步这个概念是在多个线程争夺同一把锁的时候才能实现的，如果多个线程争夺不同的锁，那多个线程是不能同步的</li><li>两个线程一个取对象锁，一个取类锁，则不能同步</li><li>两个线程一个取a对象锁，一个取b对象锁，则不能同步</li></ol><h4 id="修饰普通方法："><a href="#修饰普通方法：" class="headerlink" title="修饰普通方法："></a>修饰普通方法：</h4><ol><li>修饰普通方法锁的是当前对象实例，但是如果两个线程调用的是同一个对象的普通synchronized方法，持有的是不同的锁，是不会block的。<pre class="line-numbers language-none"><code class="language-none">public static void main(String[] args) throws InterruptedException {        DemoTest test = new DemoTest();        DemoTest testNew = new DemoTest();        Thread t1 = new Thread(test);        Thread t2 = new Thread(testNew);        t1.setName("threadOne");        t2.setName("threadTwo");        t1. start();        t2. start();    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>结果：<br></p><pre class="line-numbers language-none"><code class="language-none">threadTwo 获取到锁，其他线程在我执行完毕之前，不可进入。threadOne 获取到锁，其他线程在我执行完毕之前，不可进入。threadTwo: 1threadOne: 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>如果把 <code>DemoTest testNew = new DemoTest();</code>删掉，调用同一个对象，那么就能阻塞</p><h4 id="修饰静态方法"><a href="#修饰静态方法" class="headerlink" title="修饰静态方法"></a>修饰静态方法</h4><p><strong>静态方法不属于任何一个实例对 象，是属于类成员。所以当线程A访问调用一个实例对象的synchronized方法，线程B调用这个实例对象的静态synchronized方法是允许的，即synchronized修饰静态方法，会对该类的所有实例加同步锁</strong><br></p><pre class="line-numbers language-none"><code class="language-none">public static synchronized void increase() throws InterruptedException {        System.out.println(Thread.currentThread().getName() + "获取到锁，其他线程在我执行完毕之前，不可进入。" );        sleep(1000);        count++;        System.out.println(Thread.currentThread().getName() + ": " + count);    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="修饰代码块"><a href="#修饰代码块" class="headerlink" title="修饰代码块"></a>修饰代码块</h4><p><strong>对于 synchronized 作用于同步代码，锁为任何我们创建的对象，只要是个对象即可，如 new Object () 可以作为锁，new String () 也可作为锁，当然如果传入 this，那么此时代表当前对象。</strong></p><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><ol><li>只能修饰变量，被修饰的变量，线程读写都会直接和主内存打交道，绕过缓存。</li><li>该关键字可以确保当一个线程更新共享变量时，更新操作对其他线程马上可见</li></ol><h4 id="volatile-amp-synchronized"><a href="#volatile-amp-synchronized" class="headerlink" title="volatile &amp; synchronized"></a>volatile &amp; synchronized</h4><ul><li>volatile 本质是在告诉 jvm 当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；</li><li>synchronized 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住；</li><li>volatile 仅能使用在变量级别；synchronized 则可以使用在变量、方法、和类级别的；</li><li>volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性；</li><li>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞；</li></ul><h2 id="辅助知识"><a href="#辅助知识" class="headerlink" title="辅助知识"></a>辅助知识</h2><h3 id="JAVA环境变量JAVA-HOME、CLASSPATH、PATH配置说明"><a href="#JAVA环境变量JAVA-HOME、CLASSPATH、PATH配置说明" class="headerlink" title="JAVA环境变量JAVA_HOME、CLASSPATH、PATH配置说明"></a>JAVA环境变量JAVA_HOME、CLASSPATH、PATH配置说明</h3><p>首先明白一个基础概念：</p><h4 id="current-directory-当前目录-：当前在用的目录就是当前目录"><a href="#current-directory-当前目录-：当前在用的目录就是当前目录" class="headerlink" title="current directory(当前目录)：当前在用的目录就是当前目录"></a>current directory(当前目录)：当前在用的目录就是当前目录</h4><p>比如说当你打开NOTEPAD，并处于运行状态时候，当前目录就是c:/windows；<br>如果你用cmd命令打开命令行窗口，    当前目录就是c:/windows/system32;</p><p>如果你在用java这条指令，当前目录就是JAVA下的BIN目录所在的路径，因为java.exe在bin里面。在java开发配置环境变量时，系统默认(我们对classpath不做任何设定时)的路径也是当前目录。</p><h4 id="JAVA-HOME：它是指jdk的安装目录"><a href="#JAVA-HOME：它是指jdk的安装目录" class="headerlink" title="JAVA_HOME：它是指jdk的安装目录"></a>JAVA_HOME：它是指jdk的安装目录</h4><p>像D:/j2sdk1.4.2_16，在这路径下你应该能够找到bin、lib等目录。<br> 为什么要设置它呢，不设定可不可以呢？不设定也是可以滴，但是最好还是设置一下。<br> 我们现在就当它是一个变量代换 JAVA_HOME = D:/j2sdk1.4.2_16，就是为了避免多写字，它还有一个好处就是当我们需要改变某个jdk时，只需要改JAVA_HOME的值就可以了。等在后面看了Tomcat的启动分析时你就明白了。当在环境变量中引用它的时候要用%JAVA_HOME%来表示      D:/j2sdk1.4.2_16。</p><h4 id="Path：系统变量Path告诉操作系统可执行文件-exe、-bat等-所在的路径"><a href="#Path：系统变量Path告诉操作系统可执行文件-exe、-bat等-所在的路径" class="headerlink" title="Path：系统变量Path告诉操作系统可执行文件(.exe、.bat等)所在的路径"></a>Path：系统变量Path告诉操作系统可执行文件(<em>.exe、</em>.bat等)所在的路径</h4><p> 当OS(操作系统)发现某个*.exe时，windows默认从当前目录开始查找这      个命令，若查不到，OS就会到Path所设定的路径中去寻找该命令，然后执行。</p><p>   系统默认的系统变量为：Path = %SystemRoot%;%SystemRoot%/system32;%SystemRoot%/System32/Wbem<br>   就是说处于上面3个目录(多个变量用分号隔开)中的*.exe文件，可以在任意地方被执行(在 运行 窗口能直接执行的命令，像cmd、notepad等，基本都    在上面的3个目录里面)，所以他们可以直接运行。<br>   上面的%SystemRoot%是什么意思呢？%SystemRoot%就是安装操作系统的时候，系统默认的安装路径<br>    若你的windows xp装在C:/WINDOWS<br>    则你的%systemRoot%路径就是c:/windows<br>     %systemRoot%只是一个符号,代表你的系统安装目录<br>     下面是常见系统默认安装路径:<br>    98——c:/windows<br>    2000—c:/winnt<br>    2003—c:/windows<br>    xp——c:/windows<br>     当我们要进行java开发时，OS经常需要用到java.exe、javac.exe等，（若jdk安装在D:/j2sdk1.4.2_16）因此应该将      D:/j2sdk1.4.2_16/bin（%JAVA_HOME%/bin）加入到系统的path中去。<br>    注意：如果你加入的位置不是在最后，那还需要在bin后面加上英文状态下的分号：%JAVA_HOME%/bin；多个变量之间要用分号隔开，如果它前面    没有，你就加一个。<br>   明确一下：%JAVA_HOME%/jre/bin 这个路径是不需要加入Path的。参考：<a href="http://java.sun.com/javase/6/docs/technotes/tools/windows/jdkfiles.html">http://java.sun.com/javase/6/docs/technotes/tools/windows/jdkfiles.html</a></p><h4 id="CLASSPATH：告诉java虚拟机-jvm-要使用或执行的-class文件放在什么地方"><a href="#CLASSPATH：告诉java虚拟机-jvm-要使用或执行的-class文件放在什么地方" class="headerlink" title="CLASSPATH：告诉java虚拟机(jvm)要使用或执行的*.class文件放在什么地方"></a>CLASSPATH：告诉java虚拟机(jvm)要使用或执行的*.class文件放在什么地方</h4><p>CLASSPATH是专门针对java的，它相当于windows的path；path是针对整个windows的。<br>所谓的JVM就好像是在微软OS上面再激活另外一个OS，对JVM来说CLASSPATH就好像是对微软OS来说的PATH，所以要用jvm开运行程序就需要设定classpath，然而jvm像windows一样它也有个默认的查找class文件的路径，对刚开始学习java的我们来说，默认的已经够我们用了，那就是当前路径，因此不设置classpath也可以。</p><p>在windows中 classpath 大小写没有关系，其他的环境变量名称也一样。<br> 当我们不设定classpath时，系统默认的classpath是当前目录，如果你个人想设置classpath的话，那么务必在classpath中加入”.”，这个英文状态下的点就表示当前目录。至于classpath中要不要加入其他的路径(包括文件目录、包的根目录等)，这要看开发的需要，一般我们初学者是用不到的。</p><p>JAVA_HOME = D:/j2sdk1.4.2_16<br>Path 环境变量中在最前面加入(若系统原来没有就新建) %JAVA_HOME%/bin; （加在最前面可以提高查找速度）<br>CLASSPATH = . 这一步可以不用设。</p><h3 id="JDK-和-JRE-的区别"><a href="#JDK-和-JRE-的区别" class="headerlink" title="JDK 和 JRE 的区别"></a>JDK 和 JRE 的区别</h3><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/7b9ff76b66e949fc9a04515e960b9de4.png" alt=""><br>从图中可以看出JDK包含JRE包含JVM…</p><p>JDK：java development kit （java开发工具）</p><p>JRE：java runtime environment （java运行时环境）</p><p>引申出JVM</p><p>JVM：java virtual machine （java虚拟机）</p><p>一、JDK——开发环境（核心）</p><p>java development kit 的缩写，意思是JAVA开发工具，我们写文档做PPT需要office 办公软件，开发当然需要开发工具了，说到开发工具大家肯定会想到Eclipse，但是如果直接安装Eclipse你会发现它是运行不起来 是会报错的，只有安装了JDK，配置好了环境变量和path才可以运行成功。这点相信很多人都深有体会。</p><p>JDK主要包含三部分，</p><p>第一部分就是Java运行时环境，JVM。</p><p>第二部分就是Java的基础类库，这个类库的数量还是非常可观的。</p><p>第三部分就是Java的开发工具，它们都是辅助你更好的使用Java的利器。</p><p>详寻《玩好JDK，面试不用愁》</p><p>二、JRE——运行环境</p><p>java runtime environment （java运行时环境）的缩写</p><p>1,1_JDK中的JRE</p><p>如下图：jdk中包含的jre，在jre的bin目录里有个jvm.dll，既然JRE是运行时环境，那么运行在哪？肯定是JVM虚拟机上了。另，jre的lib目录中放的是一些JAVA类库的class文件，已经打包成jar文件。</p><p>1.2_第二个JRE（独立出来的运行时环境）</p><p>如下图，不管是JDK中的JRE还是JRE既然是运行时环境必须有JVM。所以JVM也是有两个的。</p><p>三、JVM——转换环境</p><p>java virtual machine （java虚拟机）的缩写。</p><p>大家一提到JAVA的优点就会想到：一次编译，随处运行，说白了就是跨平台性好，这点JVM功不可没。</p><p>JAVA的程序也就是我们编译的代码都会编译为Class文件，Class文件就是在JVM上运行的文件，</p><p>只有JVM还不能成class的执行，因为在解释class的时候JVM需要调用解释所需要的类库lib，而jre包含lib类库。</p><p>JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。</p><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="Math方法"><a href="#Math方法" class="headerlink" title="Math方法"></a>Math方法</h3><p>1： java取整</p><pre><code> a：floor向下取整   用法：Math.floor(num)   Math.floor(1.9)//1                      Math.floor(-1.9)//-2b:  round四舍五入  用法：Math.round(num)实际上是等价于Math.floor(num+0.5)  Math.round(1.5)//2                     Math.round(1.4)//1  Math.round(-1.4)//-1                  Math.round(-1.5)//-1               Math.round(-1.6)//-2c:  ceil取不小于num的最小整数   用法: Math.ceil(num)   Math.ceil(1.4)//2      Math.ceil(1.5)//2             Math.ceil(1.6)//2   Math.ceil(-1.4)//-1   Math.ceil(-1.5)//-1           Math.ceil(-1.6)//-1d:  神级方法直接加(int)强制转换，直接去掉小数点位，没有任何向上向下，需要时最好用的方法</code></pre><p>2： java求绝对值</p><pre><code> Math.abs(num) Math.abs(-30.5)//30.5</code></pre><p>3:   java随机数</p><pre><code> Math.random()随机去0~1的数 (int)(100*Math.random())这样就可以取0~100随机整数</code></pre><p>4： java幂函数</p><pre><code> Math.pow(a,b)a的b次方 Math.pow(x,2)就是平方 Math.pow(x,3)就是立方</code></pre><p>5： java开根号</p><pre><code> Math.sqrt(num)num的平方根</code></pre><h3 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h3><p>使用步骤：</p><p>1.导入包</p><p>import java.util.Random;</p><p>2.创建对象</p><p>Random r = new Random();</p><p>3.产生随机数</p><p>int num = r.nextInt(10);<br>代码解析：10代表的是一个范围，如果括号写10，产生的随机数就是0-9，括号写20，参数的随机数则是0-19</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Random</span><span class="token punctuation">;</span> <span class="token comment">//1. 导入包</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo1Random</span> <span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">// 2. 创建对象</span><span class="token class-name">Random</span> r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">// 3. 获取随机数</span><span class="token keyword">int</span> num <span class="token operator">=</span> r<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">// 1-10</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><h4 id="substring-返回字符串字串"><a href="#substring-返回字符串字串" class="headerlink" title="substring() 返回字符串字串"></a>substring() 返回字符串字串</h4><pre class="line-numbers language-none"><code class="language-none">public String substring(int beginIndex)或public String substring(int beginIndex, int endIndex)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参数<br>beginIndex — 起始索引（包括）, 索引从 0 开始。</p><p>endIndex — 结束索引（不包括）。</p><pre class="line-numbers language-none"><code class="language-none">public class RunoobTest {    public static void main(String args[]) {        String Str = new String("This is text");         System.out.print("返回值 :" );        System.out.println(Str.substring(4) );         System.out.print("返回值 :" );        System.out.println(Str.substring(4, 10) );    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：<br>返回值 : is text<br>返回值 : is te</p><h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><h4 id="字符串某个位置插入一个字符"><a href="#字符串某个位置插入一个字符" class="headerlink" title="字符串某个位置插入一个字符"></a>字符串某个位置插入一个字符</h4><pre class="line-numbers language-none"><code class="language-none">StringBuffer sb = new StringBuffer("原字符串"); sb.insert(index,"需要插入的字符串");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h4><pre class="line-numbers language-none"><code class="language-none">s.length()//数组长度是 num.length<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="字符串修改"><a href="#字符串修改" class="headerlink" title="字符串修改"></a>字符串修改</h4><p>当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。</p><p>和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/cdb4cc2d3e374b40bdb8a0a5897606c1.png" alt=""></p><p>在使用 StringBuffer 类时，每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，所以如果需要对字符串进行修改推荐使用 StringBuffer。</p><p>StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。</p><p><strong>由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。</strong></p><pre class="line-numbers language-none"><code class="language-none">public class RunoobTest{    public static void main(String args[]){        StringBuilder sb = new StringBuilder(10);        //也可以直接 new StringBuilder()        sb.append("Runoob..");        System.out.println(sb);          sb.append("!");        System.out.println(sb);         sb.insert(8, "Java");        System.out.println(sb);         sb.delete(5,8);        System.out.println(sb);      }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="返回指定索引处的字符"><a href="#返回指定索引处的字符" class="headerlink" title="返回指定索引处的字符"></a>返回指定索引处的字符</h4><p>实例：</p><pre class="line-numbers language-none"><code class="language-none">public class Test {    public static void main(String args[]) {        String s = "www.runoob.com";        char result = s.charAt(6);        System.out.println(result);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="删除字符串首尾空白符"><a href="#删除字符串首尾空白符" class="headerlink" title="删除字符串首尾空白符"></a>删除字符串首尾空白符</h4><pre class="line-numbers language-none"><code class="language-none">str=str.trim();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="返回字符串的子字符串"><a href="#返回字符串的子字符串" class="headerlink" title="返回字符串的子字符串"></a>返回字符串的子字符串</h4><pre class="line-numbers language-none"><code class="language-none">public String substring(int beginIndex, int endIndex)beginIndex -- 起始索引（包括）, 索引从 0 开始。endIndex -- 结束索引（不包括）。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">public class RunoobTest {    public static void main(String args[]) {        String Str = new String("This is text");         System.out.print("返回值 :" );        System.out.println(Str.substring(4) );         System.out.print("返回值 :" );        System.out.println(Str.substring(4, 10) );    }}//结果返回值 : is text返回值 : is te<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="字符串反转"><a href="#字符串反转" class="headerlink" title="字符串反转"></a>字符串反转</h4><p>使用<code>StringBuilder</code></p><pre class="line-numbers language-none"><code class="language-none">Scanner in = new Scanner(System.in);        String str = in.nextLine();        StringBuffer strb = new StringBuffer(str);        strb.reverse();        System.out.println(strb.toString());  //要求返回String类可用这句        System.out.println(strb);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="数组长度"><a href="#数组长度" class="headerlink" title="数组长度"></a>数组长度</h4><pre class="line-numbers language-none"><code class="language-none">num.length//字符串长度是 s.length()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><pre class="line-numbers language-none"><code class="language-none">//声明int类型的二维数组int[][] intArray;//创建一个三行四列的int类型数组intArray = new int[3][4];//声明数组的同时进行创建char[][] ch = new char[3][5];/二维数组的初始化int[][] num = {{1,2,3},{4,5,6},{9,8,7}};//获取行和列num.length //行数num[0].length //列数//循环输出二维数组的内容for(int i=0;i&lt;num1.length;i++){    for(int j=0;j&lt;num1[i].length;j++){         System.out.print(num1[i][j]+" ");       }    System.out.println(); }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h4><pre class="line-numbers language-none"><code class="language-none">Arrays.sort(arr);Arrays.sort()重载了四类方法sort(T[] a)：对指定T型数组按数字升序排序。sort(T[] a,int formIndex, int toIndex)：对指定T型数组的指定范围按数字升序排序。sort(T[] a, Comparator&lt;? supre T&gt; c): 根据指定比较器产生的顺序对指定对象数组进行排序。sort(T[] a, int formIndex, int toIndex, Comparator&lt;? supre T&gt; c): 根据指定比较器产生的顺序对指定对象数组的指定对象数组进行排序。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="数组拷贝"><a href="#数组拷贝" class="headerlink" title="数组拷贝"></a>数组拷贝</h4><p><strong>Arrays.copyOf方法</strong></p><pre class="line-numbers language-none"><code class="language-none">Arrays.copyOf(array, to_index);// to_index是1，就是拷贝从头往后数的1个数，5就是从头往后数的5个数Arrays.fill(array, from_index, to_index);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>第一个方法其实就是返回一个数组，而这个数组就等于数组array的前to_index个数，也就是array[0] ~ array[to_index - 1]。</p><p>而第二种方法也只是加了一个初始的位置，即返回一个数组等于array[from_index] ~ array[to_index - 1]。</p><p>这里要注意一下，不管是上面哪种使用方法，都务必记住时不包含array[to_index]这个数。</p><p><strong>还有一点差点忘了说了，这里得提前导入Arrays类，即在开头写如下代码<br>import java.utl.Arrays;</strong></p><h3 id="构造函数（方法）"><a href="#构造函数（方法）" class="headerlink" title="构造函数（方法）"></a>构造函数（方法）</h3><p><strong>作用：一般用来初始化成员属性和成员方法的，即new对象产生后，就调用了对象了属性和方法。</strong></p><p>一个对象建立，构造函数只运行一次。</p><p> 而一般函数可以被该对象调用多次。</p><p>特点：<br>1、函数名与类名相同</p><p>2、不用定义返回值类型。（不同于void类型返回值，void是没有具体返回值类型；构造函数是连类型都没有）</p><p>3、不可以写return语句。（返回值类型都没有，也就不需要return语句了）</p><p> 注：一般函数不能调用构造函数，只有构造函数才能调用构造函数。</p><p>示例：<br>1、无参构造函数中只定义了一个方法。new对象时，就调用与之对应的构造函数，执行这个方法。不必写“.方法名”。 </p><pre class="line-numbers language-none"><code class="language-none">package javastudy;public class ConfunDemo {    public static void main(String[] args) {        Confun c1=new Confun();            //输出Hello World。new对象一建立，就会调用对应的构造函数Confun()，并执行其中的println语句。    }}class Confun{            Confun(){        //定义构造函数，输出Hello World        System.out.println("Hellow World");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2、有参构造函数，在new对象时，将实参值传给private变量，相当于完成setter功能。</p><pre class="line-numbers language-none"><code class="language-none">package javastudy;public class ConfunDemo3 {    public static void main(String[] args){        Person z=new Person("zhangsan",3);        //实例化对象时，new Person()里直接调用Person构造函数并转转实参，相当于setter功能        z.show();    }}class Person{    private String name;    private int age;    public Person(String n,int m){                //有参数构造函数，实现给private成员变量传参数值的功能        name=n;        age=m;            }    //getter                                      //实例化对象时，完成了sett功能后，需要getter，获取实参值。    public String getName(){        return name;    }    public int getAget(){        return age;    }    public void show(){                           //获取private值后，并打印输出        System.out.println(name+"\n"+age);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码，我们也可以将show()方法中的输出语句直接放在构造函数中，new对象时，即可直接输出值，如下</p><pre class="line-numbers language-none"><code class="language-none">package javastudy;public class ConfunDemo3 {    public static void main(String[] args){        Person z=new Person("zhangsan",3);        //实例化对象时，new Person()里直接调用Person构造函数并转转实参，同时执行输出语句    }}class Person{    private String name;    private int age;    public Person(String n,int m){                //有参数构造函数，实现给private成员变量传参数值的功能，同时直接输出值        name=n;        age=m;        System.out.println(name+"\n"+age);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个对象建立后，构造函数只运行一次。</p><p>如果想给对象的值再赋新的值，就要使用set和get方法，此时是当做一般函数使用</p><p>如下：</p><pre class="line-numbers language-none"><code class="language-none">package javastudy;public class ConfunDemo4 {    public static void main(String[] args) {            PersonDemo s=new PersonDemo("李三",33);        //new对象时，即调用对应的构造函数，并传值。同时，不能new同一个对象多次，否则会报错。            s.setName("李五");                            //对象建立后，想变更值时，就要用set/get方法，重新设置新的值            s.setName("阿尔法狗");                        //并可调用对象多次。            s.print();    }}class PersonDemo{    private String name;    private int age;    PersonDemo(String n,int m){                //建立有参构造函数，用于给两个private变量name、age赋值，同时输出值        name=n;        age=m;        System.out.println("姓名："+name+"年龄："+age);    }    public void setName(String x){            //set方法，用于再次给name赋值        name=x;            }    public String getName(){                //get方法，用于获取name的赋值        return name;    }    public void print(){        System.out.println(name);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="字母大小写判断与转换"><a href="#字母大小写判断与转换" class="headerlink" title="字母大小写判断与转换"></a>字母大小写判断与转换</h3><pre class="line-numbers language-none"><code class="language-none">Character.isDigit(char c)　//判断字符c是否是数字字符，如‘1’，‘2’，是则返回true，否则返回falseCharacter.isLetter(char c)  //判断字符c是否是字母Character.isLowerCase(char c)　//判断c是否是小写字母字符Character.isUpperCase(char c)　//判断c是否是大写字母字符Character.isLetterOrDigit(char c)　判断c是否是字母或数字字符Character.toLowerCase(char c)　//字母转换为小写字母字符Character.toUpperCase(char c)　//字母转换为大写字母字符<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>Java 中集合主要分为java.util.Collection和java.util.Map两大接口。</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/87ff2a104a409b2942cbb33fd43efeee.png" alt=""></p><p>图表最下方的ArrayList、LinkedList、HashSet以及HashMap都是常用实现类。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><pre class="line-numbers language-none"><code class="language-none">// 无参构造实例化，初始容量为10List arrayList1 = new ArrayList();// 实例化一个初始容量为20的空列表List arrayList2 = new ArrayList(20);// 实例化一个集合元素为 arrayList2 的列表（由于 arrayList2 为空列表，因此其实例化的对象也为空列表）List arrayList3 = new ArrayList(arrayList2);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的方法可能会报错，所以引入泛型。</p><pre class="line-numbers language-none"><code class="language-none">List&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(); // () “括号”里面如果什么都不写，会采取默认容量，也可以复制，也可以将同类型的元素直接放进去<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Collections之间相互转换"><a href="#Collections之间相互转换" class="headerlink" title="Collections之间相互转换"></a>Collections之间相互转换</h4><p>背景：ArrayList元素去重</p><pre class="line-numbers language-none"><code class="language-none">import java.util.ArrayList;import java.util.Arrays;import java.util.LinkedHashSet; public class ArrayListExample {    public static void main(String[] args) {        ArrayList&lt;Integer&gt; numbersList = new ArrayList&lt;&gt;(Arrays.asList(1, 1, 2, 3, 3, 3, 4, 5, 6, 6, 6, 7, 8));        System.out.println(numbersList);        LinkedHashSet&lt;Integer&gt; hashSet = new LinkedHashSet&lt;&gt;(numbersList);        ArrayList&lt;Integer&gt; listWithoutDuplicates = new ArrayList&lt;&gt;(hashSet);        System.out.println(listWithoutDuplicates);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：</p><pre class="line-numbers language-none"><code class="language-none">[1, 1, 2, 3, 3, 3, 4, 5, 6, 6, 6, 7, 8][1, 2, 3, 4, 5, 6, 7, 8]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="ArrayList数据去重"><a href="#ArrayList数据去重" class="headerlink" title="ArrayList数据去重"></a>ArrayList数据去重</h3><p><a href="https://blog.csdn.net/The_clown/article/details/113339283">原文链接</a></p><p><strong>法一：</strong><br>LinkedHashSet是在一个ArrayList删除重复数据的最佳方法。</p><p>LinkedHashSet在内部完成两件事：</p><p> 1 删除重复数据<br> 2 保持添加到其中的数据的顺序<br></p><pre class="line-numbers language-none"><code class="language-none">import java.util.ArrayList;import java.util.Arrays;import java.util.LinkedHashSet; public class ArrayListExample {    public static void main(String[] args) {        ArrayList&lt;Integer&gt; numbersList = new ArrayList&lt;&gt;(Arrays.asList(1, 1, 2, 3, 3, 3, 4, 5, 6, 6, 6, 7, 8));        System.out.println(numbersList);        LinkedHashSet&lt;Integer&gt; hashSet = new LinkedHashSet&lt;&gt;(numbersList);        ArrayList&lt;Integer&gt; listWithoutDuplicates = new ArrayList&lt;&gt;(hashSet);        System.out.println(listWithoutDuplicates);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p><strong>法二：</strong><br>要从arraylist中删除重复项，我们也可以使用java 8 stream api。使用steam的distinct()方法返回一个由不同数据组成的流，通过对象的equals（）方法进行比较。<br>收集所有区域数据List使用Collectors.toList()。<br>Java程序，用于在不使用Set的情况下从java中的arraylist中删除重复项。</p><pre class="line-numbers language-none"><code class="language-none">import java.util.ArrayList;import java.util.Arrays;import java.util.List;import java.util.stream.Collectors; public class ArrayListExample {    public static void main(String[] args) {        ArrayList&lt;Integer&gt; numbersList = new ArrayList&lt;&gt;(Arrays.asList(1, 1, 2, 3, 3, 3, 4, 5, 6, 6, 6, 7, 8));        System.out.println(numbersList);        List&lt;Integer&gt; listWithoutDuplicates = numbersList.stream().distinct().collect(Collectors.toList());        System.out.println(listWithoutDuplicates);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>法三：</strong><br>利用HashSet不能添加重复数据的特性 由于HashSet不能保证添加顺序，所以只能作为判断条件保证顺序：</p><pre class="line-numbers language-none"><code class="language-none">private static void removeDuplicate(List&lt;String&gt; list) {    HashSet&lt;String&gt; set = new HashSet&lt;String&gt;(list.size());    List&lt;String&gt; result = new ArrayList&lt;String&gt;(list.size());    for (String str : list) {        if (set.add(str)) {            result.add(str);        }    }    list.clear();    list.addAll(result);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>法四：</strong><br>利用List的contains方法循环遍历,重新排序,只添加一次数据,避免重复：<br></p><pre class="line-numbers language-none"><code class="language-none">private static void removeDuplicate(List&lt;String&gt; list) {    List&lt;String&gt; result = new ArrayList&lt;String&gt;(list.size());    for (String str : list) {        if (!result.contains(str)) {            result.add(str);        }    }    list.clear();    list.addAll(result);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p><strong>法五：双重for循环去重</strong></p><pre class="line-numbers language-none"><code class="language-none">for (int i = 0; i &lt; list.size(); i++) { for (int j = 0; j &lt; list.size(); j++) { if(i!=j&amp;&amp;list.get(i)==list.get(j)) { list.remove(list.get(j));  } } }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Collections-sort"><a href="#Collections-sort" class="headerlink" title="Collections.sort()"></a>Collections.sort()</h3><p><a href="https://www.jianshu.com/p/32f9578b9acc">原文链接</a></p><blockquote><p>Collections类中的sort方法可以对实现了List接口的集合进行排序。这个方法假定列表元素实现了Comparable接口。</p></blockquote><h4 id="sort常用形式"><a href="#sort常用形式" class="headerlink" title="sort常用形式"></a>sort常用形式</h4><p><strong>sort有两种重载形式，第一种（默认升序）：</strong></p><pre class="line-numbers language-none"><code class="language-none">static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>根据官方文档的描述，这个方法将列表元素进行升序排序，但是列表要满足以下条件：<br>  1.列表元素实现了Comparable接口，且任意两个列表元素都是可比的。<br>  2.列表必须支持set方法。</p><p>实现代码如下：</p><pre class="line-numbers language-none"><code class="language-none">import java.util.*;public class Sort {    public static void main(String[] args) {                Scanner scan = new Scanner(System.in);        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();                          //用户输入10个整数        System.out.println("请输入10个整数：");        for(int i = 0; i &lt; 10; i++)                              {            list.add(scan.nextInt());        }        scan.close();                //排序        Collections.sort(list);                //输出排序结果       System.out.println(list);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/ccfb2d08efa818a82b206d9ed8054630.png" alt=""></p><p><strong>sort第二种重载（降序）：</strong></p><pre class="line-numbers language-none"><code class="language-none">public static &lt;T&gt; void sort(List&lt;T&gt; list,Comparator&lt;? super T&gt; c)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果想采用其他方式进行排序，那么可将一个Comparator对象作为sort方法的第二个参数。当要进行逆序排序时，最简便的方法是将Collections.reverseOrder()作为第二个参数。</p><pre class="line-numbers language-none"><code class="language-none">import java.util.*;public class Sort {    public static void main(String[] args) {                Scanner scan = new Scanner(System.in);        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();                          //用户输入10个整数        System.out.println("请输入10个整数：");        for(int i = 0; i &lt; 10; i++)                              {            list.add(scan.nextInt());        }        scan.close();                //逆序排序        Collections.sort(list,Collections.reverseOrder());                //输出排序结果        System.out.println(list);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/5bce696faab5422217b9fd87c15c610b.png" alt=""><br>看到这里，对 <code>Comparator</code>这个词多关注下</p><h4 id="排序对象不是基本数据类型"><a href="#排序对象不是基本数据类型" class="headerlink" title="排序对象不是基本数据类型"></a>排序对象不是基本数据类型</h4><blockquote><p>定义一个点类，其中有整型属性x和y，代表其坐标；除了这两个属性以外没有其他属性。随机产生10个点，并按照这些点与原点(0,0)之间的距离大小对点进行降序排序。</p></blockquote><p>如果仍想通过sort方法进行排序的话，首先点类就必须满足上面曾经提过的约束条件：点对象是可比的，因此点类必须实现Comparable接口。查看官方文档可知，Comparable接口中只有一个方法：</p><pre class="line-numbers language-none"><code class="language-none">int compareTo(T o)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>调用这个方法的对象将会与参数o进行比较，小于o、等于o和大于o分别对应的返回值为负数、0和正数。对象之间相对大小的判断方法是自定义的，在这个问题中，就是通过比较各点与原点之间的距离来判断大小，所以点类的实现如下：</p><pre class="line-numbers language-none"><code class="language-none">class Point implements Comparable&lt;Point&gt;{        private int x;    private int y;        public Point(int x,int y)    {        this.x = x;        this.y = y;    }        @Override    //如果该点到原点的距离大于o点到原点的距离，则该点大于o点    public int compareTo(Point o) {        int distance1 = (this.x) * (this.x) + (this.y) * (this.y);        int distance2 = (o.x) * (o.x) + (o.y) * (o.y);                return (distance1 &gt; distance2) ? 1 : ((distance1 == distance2) ? 0 : -1);     }        @Override    public String toString() {        return "(" + x + ","+  y + ")";    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为要进行降序排序，所以可以通过将Collections.reverseOrder()作为sort方法的第二个参数来实现：</p><pre class="line-numbers language-none"><code class="language-none">public class SortDemo {    private static List&lt;Point&gt; list = new ArrayList&lt;&gt;();        public static void main(String[] args) {                //随机生成10个点        for(int i = 0; i &lt; 10; i++)        {            //点的坐标取值在[1,20]之间            int x = (int)(Math.random() * 20) + 1;            int y = (int)(Math.random() * 20) + 1;                        list.add(new Point(x,y));        }        System.out.print("排序前：");        System.out.println(list);                //降序排序        Collections.sort(list,Collections.reverseOrder());                System.out.print("排序后：");        System.out.println(list);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/2a13ef90ac25d9d1c73a21f774ce4611.png" alt=""></p><p><strong>sort方法小结：</strong><br>实现了Comparable接口的类都可以用sort方法进行排序，默认的排序方法是升序；如果想进行降序排序，只需把Collections.reverseOrder作为第二个参数传给sort方法。</p><h4 id="Comparator接口"><a href="#Comparator接口" class="headerlink" title="Comparator接口"></a>Comparator接口</h4><p>上面反复提到的Collections.reverseOrder方法返回的是一个Comparator对象。其实Comparator接口并不陌生，常用的equals方法就来自这个接口。Comparator接口用来定义两个对象之间的比较方法，它有一个叫做compare的方法，函数签名如下：</p><pre class="line-numbers language-none"><code class="language-none">int compare(T o1,T o2)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>o1 &gt; o2，返回正数；o1 = o2，返回0；o1 &lt; o2，返回负数。<br>  从前面的例子可以看出，可以使用Comparator对象来控制sort的排序方法，这是如何实现的？查看sort方法的相关源码，我发现其中有这样一段代码：</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/da415407eb899af9aab66f06ba75028a.png" alt=""><br>注意看图中用红线框起来的部分。经分析可知，这段代码实现了这样的逻辑：如果compare的返回值为正数，就交换进行比较的两个元素的位置。于是可以得出这样一个结论，如果让 x &gt; y 时compare(x,y)返回正数，那么交换 x 和 y 的位置后大的元素在后，这就实现了升序排序；反之，如果让 x &lt; y 时compare(x,y)返回正数，那么交换位置后小的元素在后，这就实现了降序排序。这就是Comparator对象控制排序方式的原理。</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/69bf5bc0fb7fa88c13d7a45defa84b1c.png" alt=""></p><p>通过Comparator对象来实现点对象的降序排序，一种可行的实现方式如下：</p><pre class="line-numbers language-none"><code class="language-none">import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;import java.util.List;//点类class Point {        private int x;    private int y;        public Point(int x,int y)    {        this.x = x;        this.y = y;    }        public int getX() {        return x;    }    public int getY() {        return y;    }        @Override    public String toString() {        return "(" + x + ","+  y + ")";    }}public class SortDemo {    private static List&lt;Point&gt; list = new ArrayList&lt;&gt;();        public static void main(String[] args) {                //随机生成10个点        for(int i = 0; i &lt; 10; i++)        {            //点的坐标取值在[1,20]之间            int x = (int)(Math.random() * 20) + 1;            int y = (int)(Math.random() * 20) + 1;                        list.add(new Point(x,y));        }        System.out.print("排序前：");        System.out.println(list);                //降序排序        Collections.sort(list,new Comparator&lt;Point&gt;() {            @Override            //当 o1 &lt; o2 时返回正数            public int compare(Point o1, Point o2) {                int distance1 = (o1.getX()) * (o1.getX()) + (o1.getY()) * (o1.getY());                int distance2 = (o2.getX()) * (o2.getX()) + (o2.getY()) * (o2.getY());                                return (distance1 &lt; distance2) ? 1 : ((distance1 == distance2) ? 0 : -1);             }                    });                System.out.print("排序后：");        System.out.println(list);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/997282c1a828c3c32ff7ed4600419ccd.png" alt=""></p><h3 id="Arrays-sort"><a href="#Arrays-sort" class="headerlink" title="Arrays.sort()"></a>Arrays.sort()</h3><p><a href="https://www.cnblogs.com/SupremeBoy/p/12717532.html">原文</a><br>Arrays.sort()是经过调优排序算法，性能能达到n*log(n)</p><p><strong>Arrays.sort()重载了四类方法</strong></p><ul><li>sort(T[] a)：对指定T型数组按数字升序排序。 </li><li>sort(T[] a,int formIndex, int toIndex)：对指定T型数组的指定范围按数字升序排序。</li><li>sort(T[] a, Comparator&lt;? supre T&gt; c): 根据指定比较器产生的顺序对指定对象数组进行排序。</li><li>sort(T[] a, int formIndex, int toIndex, Comparator&lt;? supre T&gt; c): 根据指定比较器产生的顺序对指定对象数组的指定对象数组进行排序。</li></ul><h4 id="sort-T-a"><a href="#sort-T-a" class="headerlink" title="sort(T[] a)"></a>sort(T[] a)</h4><p>对指定T型数组按数字升序排序。</p><pre class="line-numbers language-none"><code class="language-none">import java.util.Arrays;import java.util.Comparator;public class ArraysSort {    public static void main(String[] args) {        int[] a={2,5,4,3,1,8};        Arrays.sort(a);        System.out.println(Arrays.toString(a));    }}// 结果// [1, 2, 3, 4, 5, 8]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="sort-T-a-int-formIndex-int-toIndex"><a href="#sort-T-a-int-formIndex-int-toIndex" class="headerlink" title="sort(T[] a,int formIndex, int toIndex)"></a>sort(T[] a,int formIndex, int toIndex)</h4><p>对指定T型数组的指定范围按数字升序排序。</p><pre class="line-numbers language-none"><code class="language-none">import java.util.Arrays;import java.util.Comparator;public class ArraysSort {    public static void main(String[] args) {        int[] a={2,5,4,3,1,8};        Arrays.sort(a,2,5);        System.out.println(Arrays.toString(a));    }}// 结果// [2, 5, 1, 3, 4, 8]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="sort-T-a-Comparator-lt-supre-T-gt-c"><a href="#sort-T-a-Comparator-lt-supre-T-gt-c" class="headerlink" title="sort(T[] a, Comparator<? supre T> c)"></a>sort(T[] a, Comparator&lt;? supre T&gt; c)</h4><p>（1）按第一维元素比较二维数组<br>代码：</p><pre class="line-numbers language-none"><code class="language-none">import java.util.Arrays;import java.util.Comparator;public class ArraysSort {    public static void main(String[] args) {        int[][] nums=new int[][]{{1,3},{1,2},{4,5},{3,7}};        //方法一        Arrays.sort(nums,new Comparator&lt;int[]&gt;(){            @Override            public int compare(int[] a,int[] b){                if(a[0]==b[0]){                    return a[1]-b[1];                }else{                    return a[0]-b[0];                }            }        });        // 方法二，使用匿名表达式        // (a,b)-&gt;a[1]-b[1]会自动转变成上面的形式        /*Arrays.sort(nums,(a,b)-&gt;a[1]-b[1]);*/        for (int[] num : nums) {            System.out.println(Arrays.toString(num));        }        int[] a={2,5,4,3,1,8};        Arrays.sort(a,2,5);        System.out.println(Arrays.toString(a));    }}// 结果/*[1, 2][1, 3][3, 7][4, 5]*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）按第二维元素比较二维数组</p><pre class="line-numbers language-none"><code class="language-none">import java.util.Arrays;import java.util.Comparator;public class ArraysSort {    public static void main(String[] args) {        int[][] nums=new int[][]{{1,3},{1,2},{4,5},{3,7}};        //方法一        Arrays.sort(nums,new Comparator&lt;int[]&gt;(){            @Override            public int compare(int[] a,int[] b){                if(a[1]==b[1]){                    return a[0]-b[0];                }else{                    return a[1]-b[1];                }            }        });        //方法二        /*Arrays.sort(nums,(a,b)-&gt;a[1]-b[1]);*/        for (int[] num : nums) {            System.out.println(Arrays.toString(num));        }    }}// 结果/*[1, 2][1, 3][4, 5][3, 7]*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实这个方法最重要的还是类对象的比较</p><p>由于我们可以自定义比较器，所以我们可以使用策略模式，使得在运行时选择不同的算法</p><pre class="line-numbers language-none"><code class="language-none">import java.util.Arrays;import java.util.Comparator;class Dog{    int size;    int weight;    public Dog(int s, int w){        size = s;        weight = w;    }}class DogSizeComparator implements Comparator&lt;Dog&gt;{    @Override    public int compare(Dog o1, Dog o2) {        return o1.size - o2.size;    }}class DogWeightComparator implements Comparator&lt;Dog&gt;{    @Override    public int compare(Dog o1, Dog o2) {        return o1.weight - o2.weight;    }}public class ArraysSort {    public static void main(String[] args) {        Dog d1 = new Dog(2, 50);        Dog d2 = new Dog(1, 30);        Dog d3 = new Dog(3, 40);        Dog[] dogArray = {d1, d2, d3};        printDogs(dogArray);        Arrays.sort(dogArray, new DogSizeComparator());        printDogs(dogArray);        Arrays.sort(dogArray, new DogWeightComparator());        printDogs(dogArray);    }    public static void printDogs(Dog[] dogs){        for(Dog d: dogs)            System.out.print("size="+d.size + " weight=" + d.weight + " ");        System.out.println();    }}// 结果/*size=2 weight=50 size=1 weight=30 size=3 weight=40 size=1 weight=30 size=2 weight=50 size=3 weight=40 size=1 weight=30 size=3 weight=40 size=2 weight=50 */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么在参数中会出现super呢？这意味着这类型可以是T或者它的父类型。这就是的该方法可以允许所有子类使用相同的比较器。详细见代码：</p><pre class="line-numbers language-none"><code class="language-none">import java.util.Arrays;import java.util.Comparator;class Animal{    int size;}class Dog extends Animal{    public Dog(int s){        size = s;    }}class Cat extends Animal{    public Cat(int s){        size  = s;    }}class AnimalSizeComparator implements Comparator&lt;Animal&gt;{    @Override    public int compare(Animal o1, Animal o2) {        return o1.size - o2.size;    }}public class ArraysSort {    public static void main(String[] args) {        Dog d1 = new Dog(2);        Dog d2 = new Dog(1);        Dog d3 = new Dog(3);        Dog[] dogArray = {d1, d2, d3};        printDogs(dogArray);        Arrays.sort(dogArray, new AnimalSizeComparator());        printDogs(dogArray);        System.out.println();                Cat c1 = new Cat(2);        Cat c2 = new Cat(1);        Cat c3 = new Cat(3);        Cat[] catArray = {c1, c2, c3};        printDogs(catArray);        Arrays.sort(catArray, new AnimalSizeComparator());        printDogs(catArray);    }    public static void printDogs(Animal[] animals){        for(Animal a: animals)            System.out.print("size="+a.size + " ");        System.out.println();    }}// 结果/*size=2 size=1 size=3 size=1 size=2 size=3 size=2 size=1 size=3 size=1 size=2 size=3 */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="sort-T-a-int-formIndex-int-toIndex-Comparator-lt-supre-T-gt-c"><a href="#sort-T-a-int-formIndex-int-toIndex-Comparator-lt-supre-T-gt-c" class="headerlink" title="sort(T[] a, int formIndex, int toIndex, Comparator<? supre T> c)"></a>sort(T[] a, int formIndex, int toIndex, Comparator&lt;? supre T&gt; c)</h4><p>根据指定比较器产生的顺序对指定对象数组的指定对象数组进行排序。</p><pre class="line-numbers language-none"><code class="language-none">import java.util.Arrays;import java.util.Comparator;public class ArraysSort {    public static void main(String[] args) {        int[][] nums=new int[][]{{1,3},{1,2},{4,5},{3,7}};                Arrays.sort(nums,2,4,new Comparator&lt;int[]&gt;(){            @Override            public int compare(int[] a,int[] b){                if(a[0]==b[0]){                    return a[1]-b[1];                }else{                    return a[0]-b[0];                }            }        });    }}// 结果/*[1, 3][1, 2][3, 7][4, 5]可以看到只对第三行和第四行排序了*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="判断变量类型"><a href="#判断变量类型" class="headerlink" title="判断变量类型"></a>判断变量类型</h3><p>1.使用反射的方法： <code>变量名.getClass().getSimpleName()</code>来判断。<br>2.使用 instanceof 来判断：<code>变量名 instanceof 类型</code>来判断。</p><p>1.使用反射的方法来判断<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/2c5f884df06f5761442c47f2e648a233.png" alt=""><br>2.使用 instanceof 来判断<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/911efc74c4904e65843c8411be1308d1.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法总结</title>
      <link href="/posts/57899/"/>
      <url>/posts/57899/</url>
      
        <content type="html"><![CDATA[<h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><p>力扣876：<br>快慢指针：比较经典的做法是：</p><p><strong>使用两个指针变量，刚开始都位于链表的第 1 个结点，一个永远一次只走 1 步，一个永远一次只走 2 步，一个在前，一个在后，同时走。这样当快指针走完的时候，慢指针就来到了链表的中间位置。</strong></p><p><strong>不一定同时从起点一起走，也有可能快指针先走基本，在按照相同补发或不同步伐一起走。</strong></p><p>根据这种确定性去解决链表中的一些问题。使用这种思想还可以解决链表的以下问题：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">「力扣」第 <span class="token number">19</span> 题： 倒数第 k 个结点，快指针先走几步，不是靠猜的，要在纸上画图模拟一下，就清楚了；「力扣」第 <span class="token number">141</span> 题：环形链表，在环中的时候可以想象，<span class="token class-name">A</span> 同学开始有存款 <span class="token number">100</span> 元，每天赚 <span class="token number">1</span> 元，<span class="token class-name">B</span> 同学开始有存款 <span class="token number">50</span> 元，每天赚 <span class="token number">2</span> 元，<span class="token class-name">B</span> 同学一定会在某一天和 <span class="token class-name">A</span> 同学的存款一样；「力扣」第 <span class="token number">142</span> 题：环形链表 II；「力扣」第 <span class="token number">161</span> 题：相交链表，起点不同，构造相同长度让它们相遇，同样是利用了同步走这个等量关系。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="动态规划解题框架"><a href="#动态规划解题框架" class="headerlink" title="动态规划解题框架"></a>动态规划解题框架</h2><p>框架：<br></p><pre class="line-numbers language-none"><code class="language-none">for 状态1 in 状态1的所有取值：    for 状态2 in 状态2的所有取值：        for ...            dp[状态1][状态2][...] = 择优(选择1，选择2...)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p></p><h3 id="股票问题"><a href="#股票问题" class="headerlink" title="股票问题"></a>股票问题</h3><p><a href="https://labuladong.gitee.io/algo/1/12/">原链接</a></p><p>重点看一下最大交易次数k<br></p><pre class="line-numbers language-none"><code class="language-none">dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])              max( 今天选择 rest,        今天选择 sell       )dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])            max( 今天选择 rest,         今天选择 buy         )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p><strong>只有从状态0到1，k才会变化。就是从未持有到持有</strong></p><h2 id="回溯（两种形式）与动态规划"><a href="#回溯（两种形式）与动态规划" class="headerlink" title="回溯（两种形式）与动态规划"></a>回溯（两种形式）与动态规划</h2><p>动态规划一般有两种形式：<strong>自顶向下和自底向上</strong></p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/3.jpg" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/4.jpg" alt=""></p><p>不用管细节，回溯/递归是树，动态规划是数组。</p><p><strong>结论：</strong></p><ol><li>自顶向下就是回溯<strong>函数</strong>，自底向上就是dp数组。</li><li>回溯需要单独的一个<strong>回溯函数</strong>，可以是void类型，也可以是非void类型；如果要使用备忘录优化，需要使用非void类型</li><li>有的题没法用备忘录，<strong>二叉树最大深度</strong>就不行。备忘录是记录后面会用到的结果，这个题记了也没有。</li><li>自底向上就不需要额外的函数，就是<strong>dp数组</strong></li><li>dp函数变化的是函数的形参数值，dp数组变化的是索引</li></ol><h3 id="两种形式的dp函数-买卖股票题目"><a href="#两种形式的dp函数-买卖股票题目" class="headerlink" title="两种形式的dp函数(买卖股票题目)"></a>两种形式的dp函数(买卖股票题目)</h3><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/submissions/">void与非void写法</a></p><p>带备忘录写法：<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/4.jpg" alt=""><br></p><pre class="line-numbers language-none"><code class="language-none">class Solution {    public int maxProfit(int[] prices) {        if(prices==null || prices.length==0) {            return 0;        }        Map&lt;Pair,Integer&gt; map = new HashMap&lt;Pair,Integer&gt;();        return dfs(map,prices,0,false);    }    private int dfs(Map&lt;Pair,Integer&gt; map,int[] prices,int index,boolean status) {        //Pair对象封装了index和status，作为map的key        Pair p = new Pair(index,status);        if(map.containsKey(p)) {            return map.get(p);        }        if(index==prices.length) {            map.put(p,0);            return 0;        }        int a=0,b=0,c=0;        a = dfs(map,prices,index+1,status);        if(status) {            b = dfs(map,prices,index+1,false)+prices[index];        } else {            c = dfs(map,prices,index+1,true)-prices[index];        }        map.put(p,Math.max(Math.max(a,b),c));        return map.get(p);    }    //自定义一个Pair类，封装 index和status    private class Pair {        private final int index;        private final boolean status;        Pair(int index,boolean status) {            this.index = index;            this.status = status;        }        //这里需要实现自定义的equals和hashCode函数        public boolean equals(Object obj) {            Pair other = (Pair)obj;            if(other.index!=this.index) {                return false;            }            if(other.status!=this.status) {                return false;            }            return true;        }        public int hashCode() {            if(this.status) {                return this.index+1;            } else {                return this.index+0;            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h3 id="备忘录回溯与dp数组"><a href="#备忘录回溯与dp数组" class="headerlink" title="备忘录回溯与dp数组"></a>备忘录回溯与dp数组</h3><p><a href="https://labuladong.gitee.io/algo/3/23/66/">凑零钱</a></p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/solution/kan-bu-dong-di-gui-de-kan-guo-lai-xi-wan-1akq/">原链接</a><br><strong>Rules Number One</strong>，基本上，所有的递归问题都可以用递推公式来表示。有了这个递推公式，我们就可以很轻松地将它改为递归代码。。所以，遇到递归不要怕，先想递推公式。</p><p>例1: (比较明显的能递推公式的问题)</p><ul><li>问题：斐波那契数列的第n项 </li><li>递推公式：</li></ul><pre class="line-numbers language-none"><code class="language-none">f(n)=f(n-1)+f(n-2) 其中，f(0)=0,f(1)=1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>终止条件：</li></ul><pre class="line-numbers language-none"><code class="language-none">if (n &lt;= 2) return 1;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>递归代码：</li></ul><pre class="line-numbers language-none"><code class="language-none">int f(int n) {  if (n &lt;= 2) return 1;  return f(n-1) + f(n-2);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>例2:(不那么明显的有递推公式的问题)</p><ul><li>问题：逆序打印一个数组 </li><li>递推公式：</li></ul><pre class="line-numbers language-none"><code class="language-none">假设令F(n)=逆序遍历长度为n的数组那么F(n)= 打印数组中下标为n的元素 + F(n-1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>终止条件：</li></ul><pre class="line-numbers language-none"><code class="language-none">if (n &lt;0) return ;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>递归代码：</li></ul><pre class="line-numbers language-none"><code class="language-none">public void Print(int[] nums,int n){    if(n&lt;0) return;    System.out.println(nums[n]);    Print(nums,n-1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>到这里，不知道大家对写递归有没有一些理解了。其实写递归不能总想着去把递归平铺展开，这样脑子里就会循环，一层一层往下调，然后再一层一层返回，试图想搞清楚计算机每一步都是怎么执行的，这样就很容易被绕进去。对于递归代码，这种试图想清楚整个递和归过程的做法，实际上是进入了一个思维误区。只要找到<strong>递推公式</strong>，我们就能很轻松地写出递归代码。</p><p>到这里，我想进一步跟大家说明我这个思路是比较能够容易出代码的，那么就树的遍历问题来和大家讲。递归总是和树分不开，其中，最典型的便是树的遍历问题。刚开始学的时候，不知道大家是怎么理解先／中／后序遍历的递归写法的，这里我提供我的思路供参考，以前序遍历为例：</p><ul><li>问题：二叉树的先序遍历 </li><li>递推公式：</li></ul><pre class="line-numbers language-none"><code class="language-none">令F(Root)为问题:遍历以Root为根节点的二叉树，令F(Root.left)为问题:遍历以F(Root.left)为根节点的二叉树令F(Root.right)为问题:遍历以F(Root.right)为根节点的二叉树那么其递推公式为：F(Root)=遍历Root节点+F(Root.left)+F(Root.right)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>递归代码：</li></ul><pre class="line-numbers language-none"><code class="language-none">public void preOrder(TreeNode node){    if(node==null) return;    System.out.println(node.val);    preOrder(node.left);    preOrder(node.righr);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Rules Number Two</strong>, 递归是一种关于某个重复动作(完成重复性的功能)的形式化描述。具体点讲，如果一个问题 A 可以分解为若干子问题 B、C、D，你可以假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A。而且，你只需要思考问题 A 与子问题 B、C、D 两层之间的关系即可，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系(也就是说，递归只能考虑当前层和下一层的关系，不能继续往下深入)。我们需要屏蔽掉递归细节，理解为完成了某种功能的形式化描述即可。</p><ul><li>问题：单向链表的反转 </li><li>递推公式</li></ul><pre class="line-numbers language-none"><code class="language-none">令F(node)为问题:反转以node为头节点的单向链表；一般，我们需要考虑F(n)和F(n-1)的关系，那么这里，如果n代表以node为头节点的单向链表，那么n-1就代表以node.next为头节点的单向链表.所以，我们令F(node.next)为问题：反转以node.next为头节点的单向链表；那么，F(node)和F(node.next)之间的关系是？这里我们来简单画个图，假设我们反转3个节点的链表：1 -&gt; 2 -&gt; 3那么，F(node=1)=F(node=2)+?这里假设子问题F(node=2)已经解决，那么我们如何解决F(node=1)：很明显，我们需要反转node=2和node=1， 即 node.next.next=node; 同时 node.next=null;所以，这个问题就可以是：F(node=1)=F(node=2)+ 反转node=2和node=1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>递归代码：</li></ul><pre class="line-numbers language-none"><code class="language-none">public ListNode reverseList(ListNode head) {        if(head == null || head.next == null) {  //终止条件并不难想            return head;        }        ListNode node = reverseList(head.next);        head.next.next = head;        head.next = null;        return node;  //按上面的例子，F(node=1)和F(node=2)它俩反转后的头节点是同一个    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3.写递归的小tips</strong></p><ul><li>将问题抽象化，可以将问题抽象为f(n)（或者其他的数学符号）,<br>然后用f(n)代表欲求的问题，然后去发现和子问题（比如f(n-1)）的递推关系！（这一点在写动态规划的时候特别有用，其实动态规划就是记忆化的递归！）</li><li>递归函数是带语义的，但是记住一个递归函数只有一个语义，如果在写递归函数实现的时候，发现出现了多个语义，需要对新出现的语义重新定义一个函数！</li><li>在写递归函数的时候，可以先写子问题f(n-1)，再写所求问题f(n)，这样的话就很好知道f(n)和f(n-1)的关系，更容易保证一个递归函数只包含一个语义。</li></ul><h2 id="求数组所有子数组的方法"><a href="#求数组所有子数组的方法" class="headerlink" title="求数组所有子数组的方法"></a>求数组所有子数组的方法</h2><p>一个包含n个元素的集合,求它的所有子集。比如集合A= {1,2,3}, 它的所有子集是:<br>{ {1}, {2}, {3}, {1,2}, {1,3}, {2,3}, {1,2,3}, @}(@表示空集)。</p><p>这种问题一般有两种思路，先说说第一种，递归。递归肯定要基于一个归纳法的思想，这个思想用到了二叉树的遍历，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/145f041b48acaf3f3657f6a985a4696b.png" alt=""></p><p>可以这样理解这张图，从集合A的每个元素自身分析，它只有两种状态，或是某个子集的元素，或是不属于任何子集，所以求子集的过程就可以看成对每个元素进行“取舍”的过程。上图中，根结点是初始状态，叶子结点是终结状态，该状态下的8个叶子结点就表示集合A的8个子集。第i层(i=1,2,3…n)表示已对前面i-1层做了取舍，所以这里可以用递归了。整个过程其实就是对二叉树的先序遍历。<br>代码见方法getSonSet1。</p><p>还有一种思想比较巧妙，可以叫按位对应法。如集合A={a,b,c},对于任意一个元素，在每个子集中，要么存在，要么不存在。<br>映射为子集：<br>(a,b,c)<br>(1,1,1)-&gt;(a,b,c)<br>(1,1,0)-&gt;(a,b)<br>(1,0,1)-&gt;(a,c)<br>(1,0,0)-&gt;(a)<br>(0,1,1)-&gt;(b,c)<br>(0,1,0)-&gt;(b)<br>(0,0,1)-&gt;©<br>(0,0,0)-&gt;@(@表示空集)<br>观察以上规律，与计算机中数据存储方式相似，故可以通过一个整型数与集合映射00…00 ~ 11…11（1表示有，0表示无，反之亦可），通过该整型数逐次增可遍历获取所有的数，即获取集合的相应子集。<br>实现代码见方法getSonSet2</p><pre class="line-numbers language-none"><code class="language-none">import java.util.ArrayList;import java.util.List;public class SonSet {public static void main(String[] args){int[] arr={1,2,3};List&lt;Integer&gt; aList=new ArrayList&lt;Integer&gt;();List&lt;Integer&gt; bList=new ArrayList&lt;Integer&gt;();for(int i=0;i&lt;arr.length;i++){aList.add(arr[i]);}getSonSet1(0,aList,bList); //方法1，递归法System.out.println("----数组arr公用，分割线-----");getSonSet2(arr,arr.length); //方法2，按位对应法}/* * 递归法*/public static void getSonSet1(int i,List&lt;Integer&gt; aList,List&lt;Integer&gt; bList){if(i&gt;aList.size()-1){if(bList.size()&lt;=0){System.out.print("@");}else {/*for(int v:bList){System.out.print(v+",");//可以直接用这种方法输出bList数组里所有值，但是每个子数组最后就会带逗号}*/System.out.print(bList.get(0));for(int m=1;m&lt;bList.size();m++){System.out.print(","+bList.get(m));}}System.out.println();}else {bList.add(aList.get(i));getSonSet1(i+1, aList, bList);int bLen=bList.size();bList.remove(bLen-1);getSonSet1(i+1, aList, bList);}}/* *按位对应法。*/private static void getSonSet2(int[] arr, int length) {int mark=0;int nEnd=1&lt;&lt;length;boolean bNullSet=false;for(mark=0;mark&lt;nEnd;mark++){bNullSet=true;for(int i=0;i&lt;length;i++){if(((1&lt;&lt;i)&amp;mark)!=0){//该位有元素输出bNullSet=false;System.out.print(arr[i]+",");}}if(bNullSet){//空集合System.out.print("@");}System.out.println();}}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-none"><code class="language-none">1,2,31,21,312,323@----数组arr公用，分割线-----@1,2,1,2,3,1,3,2,3,1,2,3,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h3><p>原始</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//按照刚才那个动图进行对应</span><span class="token comment">//冒泡排序两两比较的元素是没有被排序过的元素---&gt;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>array<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//控制比较轮次，一共 n-1 趟</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>array<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//控制两个挨着的元素进行比较</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> array<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">int</span> temp <span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                array<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>优化</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> arr<span class="token punctuation">;</span>     <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">boolean</span> isSorted  <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment">//有序标记，每一轮的初始是true</span>         <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                 isSorted  <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment">//有元素交换，所以不是有序，标记变为false</span>                 <span class="token keyword">int</span> t <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                 arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                 arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>             <span class="token punctuation">}</span>         <span class="token punctuation">}</span>         <span class="token comment">//一趟下来是否发生位置交换，如果没有交换直接跳出大循环</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>isSorted <span class="token punctuation">)</span>              <span class="token keyword">break</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">return</span> arr<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="岛屿类问题的通用解法、DFS-遍历框架"><a href="#岛屿类问题的通用解法、DFS-遍历框架" class="headerlink" title="岛屿类问题的通用解法、DFS 遍历框架"></a>岛屿类问题的通用解法、DFS 遍历框架</h2><p><a href="https://leetcode-cn.com/problems/number-of-islands/solution/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/">原文链接</a><br>我们所熟悉的 DFS（深度优先搜索）问题通常是在树或者图结构上进行的。而我们今天要讨论的 DFS 问题，是在一种「网格」结构中进行的。岛屿问题是这类网格 DFS 问题的典型代表。网格结构遍历起来要比二叉树复杂一些，如果没有掌握一定的方法，DFS 代码容易写得冗长繁杂。</p><p>本文将以岛屿问题为例，展示网格类问题 DFS 通用思路，以及如何让代码变得简洁。</p><h3 id="网格问题的基本概念"><a href="#网格问题的基本概念" class="headerlink" title="网格问题的基本概念"></a>网格问题的基本概念</h3><p>我们首先明确一下岛屿问题中的网格结构是如何定义的，以方便我们后面的讨论。</p><p>网格问题是由 m \times nm×n 个小方格组成一个网格，每个小方格与其上下左右四个方格认为是相邻的，要在这样的网格上进行某种搜索。</p><p>岛屿问题是一类典型的网格问题。每个格子中的数字可能是 0 或者 1。我们把数字为 0 的格子看成海洋格子，数字为 1 的格子看成陆地格子，这样相邻的陆地格子就连接成一个岛屿。</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/eae61771e4f546c7e2572db3832696b8.png" alt=""><br>在这样一个设定下，就出现了各种岛屿问题的变种，包括岛屿的数量、面积、周长等。不过这些问题，基本都可以用 DFS 遍历来解决。</p><h3 id="DFS-的基本结构"><a href="#DFS-的基本结构" class="headerlink" title="DFS 的基本结构"></a>DFS 的基本结构</h3><p>网格结构要比二叉树结构稍微复杂一些，它其实是一种简化版的图结构。要写好网格上的 DFS 遍历，我们首先要理解二叉树上的 DFS 遍历方法，再类比写出网格结构上的 DFS 遍历。我们写的二叉树 DFS 遍历一般是这样的：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">traverse</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 判断 base case</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 访问两个相邻结点：左子结点、右子结点</span>    <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，二叉树的 DFS 有两个要素：<strong>「访问相邻结点」和「判断 base case」</strong>。</p><p>第一个要素是<strong>访问相邻结点</strong>。二叉树的相邻结点非常简单，只有左子结点和右子结点两个。二叉树本身就是一个递归定义的结构：一棵二叉树，它的左子树和右子树也是一棵二叉树。那么我们的 DFS 遍历只需要递归调用左子树和右子树即可。</p><p>第二个要素是 <strong>判断 base case</strong>。一般来说，二叉树遍历的 base case 是 root == null。这样一个条件判断其实有两个含义：一方面，这表示 root 指向的子树为空，不需要再往下遍历了。另一方面，在 root == null 的时候及时返回，可以让后面的 root.left 和 root.right 操作不会出现空指针异常。</p><p>对于网格上的 DFS，我们完全可以参考二叉树的 DFS，写出网格 DFS 的两个要素：</p><p>首先，网格结构中的格子有多少相邻结点？答案是上下左右四个。对于格子 (r, c) 来说（r 和 c 分别代表行坐标和列坐标），四个相邻的格子分别是 (r-1, c)、(r+1, c)、(r, c-1)、(r, c+1)。换句话说，网格结构是「四叉」的。<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/76496d04f877bc1d1157d0ed514e833b.png" alt=""><br>其次，网格 DFS 中的 base case 是什么？从二叉树的 base case 对应过来，应该是网格中不需要继续遍历、grid[r][c] 会出现数组下标越界异常的格子，也就是那些超出网格范围的格子。<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/cc2be06dade85d546c2b6655e3b5c9e6.png" alt=""><br>这一点稍微有些反直觉，坐标竟然可以临时超出网格的范围？这种方法我称为「先污染后治理」—— 甭管当前是在哪个格子，先往四个方向走一步再说，如果发现走出了网格范围再赶紧返回。这跟二叉树的遍历方法是一样的，先递归调用，发现 root == null 再返回。</p><p>这样，我们得到了网格 DFS 遍历的框架代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 判断 base case</span>    <span class="token comment">// 如果坐标 (r, c) 超出了网格范围，直接返回</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">inArea</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> r<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 访问上、下、左、右四个相邻结点</span>    <span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> r <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> r<span class="token punctuation">,</span> c <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> r<span class="token punctuation">,</span> c <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 判断坐标 (r, c) 是否在网格中</span><span class="token keyword">boolean</span> <span class="token function">inArea</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> r <span class="token operator">&amp;&amp;</span> r <span class="token operator">&lt;</span> grid<span class="token punctuation">.</span>length         <span class="token operator">&amp;&amp;</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> c <span class="token operator">&amp;&amp;</span> c <span class="token operator">&lt;</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="如何避免重复遍历"><a href="#如何避免重复遍历" class="headerlink" title="如何避免重复遍历"></a>如何避免重复遍历</h3><p>网格结构的 DFS 与二叉树的 DFS 最大的不同之处在于，遍历中可能遇到遍历过的结点。这是因为，网格结构本质上是一个「图」，我们可以把每个格子看成图中的结点，每个结点有向上下左右的四条边。在图中遍历时，自然可能遇到重复遍历结点。</p><p>如何避免这样的重复遍历呢？答案是标记已经遍历过的格子。以岛屿问题为例，我们需要在所有值为 1 的陆地格子上做 DFS 遍历。每走过一个陆地格子，就把格子的值改为 2，这样当我们遇到 2 的时候，就知道这是遍历过的格子了。也就是说，每个格子可能取三个值：</p><p>0 —— 海洋格子<br>1 —— 陆地格子（未遍历过）<br>2 —— 陆地格子（已遍历过）<br>我们在框架代码中加入避免重复遍历的语句：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 判断 base case</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">inArea</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> r<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 如果这个格子不是岛屿，直接返回</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>grid<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    grid<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 将格子标记为「已遍历过」</span>        <span class="token comment">// 访问上、下、左、右四个相邻结点</span>    <span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> r <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> r<span class="token punctuation">,</span> c <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> r<span class="token punctuation">,</span> c <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 判断坐标 (r, c) 是否在网格中</span><span class="token keyword">boolean</span> <span class="token function">inArea</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> r <span class="token operator">&amp;&amp;</span> r <span class="token operator">&lt;</span> grid<span class="token punctuation">.</span>length         <span class="token operator">&amp;&amp;</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> c <span class="token operator">&amp;&amp;</span> c <span class="token operator">&lt;</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><h3 id="二叉树BFS"><a href="#二叉树BFS" class="headerlink" title="二叉树BFS"></a>二叉树BFS</h3><p><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/solution/bfshe-di-gui-zui-hou-liang-chong-ji-bai-liao-100-2/">原文</a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> tree<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tree <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>tree<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//相当于把数据加入到队列尾部</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//poll方法相当于移除队列头部的元素</span>        <span class="token class-name">TreeNode</span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>leetcode 116</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Node</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token class-name">Node</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//每一层的数量</span>        <span class="token keyword">int</span> levelCount <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//前一个节点</span>        <span class="token class-name">Node</span> pre <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> levelCount<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//出队</span>            <span class="token class-name">Node</span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//如果pre为空就表示node节点是这一行的第一个，</span>            <span class="token comment">//没有前一个节点指向他，否则就让前一个节点指向他</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>pre <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                pre<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">//然后再让当前节点成为前一个节点</span>            pre <span class="token operator">=</span> node<span class="token punctuation">;</span>            <span class="token comment">//左右子节点如果不为空就入队</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> root<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>优化版本：<br>上面运行效率并不是很高，这是因为我们把节点不同的入队然后再不停的出队，其实可以不需要队列，每一行都可以看成一个链表比如第一行就是只有一个节点的链表，第二行是只有两个节点的链表（假如根节点的左右两个子节点都不为空）……<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/f5c37a62f65367e19edbdaa65c8f24bb.png" alt=""></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Node</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token class-name">Node</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token comment">//cur我们可以把它看做是每一层的链表</span>    <span class="token class-name">Node</span> cur <span class="token operator">=</span> root<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//遍历当前层的时候，为了方便操作在下一</span>        <span class="token comment">//层前面添加一个哑结点（注意这里是访问</span>        <span class="token comment">//当前层的节点，然后把下一层的节点串起来）</span>        <span class="token class-name">Node</span> dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//pre表示下一层节点的前一个节点</span>        <span class="token class-name">Node</span> pre <span class="token operator">=</span> dummy<span class="token punctuation">;</span>                <span class="token comment">//然后开始遍历当前层的链表</span>        <span class="token comment">//因为是完美二叉树，如果有左子节点就一定有右子节点</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> cur<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//让pre节点的next指向当前节点的左子节点，也就是把它串起来</span>            pre<span class="token punctuation">.</span>next <span class="token operator">=</span> cur<span class="token punctuation">.</span>left<span class="token punctuation">;</span>            <span class="token comment">//然后再更新pre</span>            pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token comment">//pre节点的next指向当前节点的右子节点，</span>            pre<span class="token punctuation">.</span>next <span class="token operator">=</span> cur<span class="token punctuation">.</span>right<span class="token punctuation">;</span>            pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token comment">//继续访问这一行的下一个节点</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//把下一层串联成一个链表之后，让他赋值给cur，</span>        <span class="token comment">//后续继续循环，直到cur为空为止</span>        cur <span class="token operator">=</span> dummy<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> root<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 递归 </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins知识点</title>
      <link href="/posts/10218/"/>
      <url>/posts/10218/</url>
      
        <content type="html"><![CDATA[<h2 id="流水线语法找不到模板"><a href="#流水线语法找不到模板" class="headerlink" title="流水线语法找不到模板"></a>流水线语法找不到模板</h2><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/e93ad73b8c094398bdfc1b49f5388317.png" alt=""><br>有时候在“流水线语言”板块找不到模板，即使安装了相对于的插件。如上图，安装了<strong>publish over ssh插件</strong>就会出现这个选项，但是当时没有。</p><p><strong>解决办法：</strong><br>重启jenkins。初始域名后面加/restart</p><pre class="line-numbers language-none"><code class="language-none">ip:port/restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="Publish-over-ssh连接失败"><a href="#Publish-over-ssh连接失败" class="headerlink" title="Publish over ssh连接失败"></a>Publish over ssh连接失败</h2><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/72c9e5709ded45fcadfc75afc94e0baf.png" alt=""><br><strong>解决办法：</strong><br>这里要填密钥的密码</p><h2 id="无法执行远程脚本"><a href="#无法执行远程脚本" class="headerlink" title="无法执行远程脚本"></a>无法执行远程脚本</h2><blockquote><p>背景：<br>创建一个jenkins作业，通过ssh在另一台服务器上运行脚本，实现从harbor仓库拉取docker镜像，并运行。<br><br><br>问题： 运行jenkins作业/流水线，在对应的服务器没有镜像和运行的容器，且构建过程没有错误输出。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/833850a8163b42f79d14e14b9551c356.png" alt=""></p><blockquote><p>分析：<br>由于是照着黑马程序员的视频和资料来的，由于输出的信息不太一样，以为是哪里操作有问题，或者脚本不对，但是重复所有过程和按照网上教程修改脚本均没有成功。然后单独运行脚本，发现出错，类似于下图。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/635aed74d26a41bc84833f34bef37f50.png" alt=""></p><blockquote><p><strong>反应过来是因为Docker没有把Harbor加入信任列表中</strong>，</p><p><br> 加入就好</p><p><code>vim /etc/docker/daemon.json</code></p><p><br> 再次构建出现了错误信息，搜索得知是因为这个命令默认有个时间限制，超过这个时间限制就会出错，断开，类似于联网超时。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/cf2801f8c63a42bb8e91adf61a3f8590.png" alt=""></p><blockquote><p><strong>把时间改为0就好</strong></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/30e99ed138474b01800e583e61389dfd.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jenkins </tag>
            
            <tag> 运维 </tag>
            
            <tag> 持续集成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git操作</title>
      <link href="/posts/3828/"/>
      <url>/posts/3828/</url>
      
        <content type="html"><![CDATA[<h2 id="config相关命令"><a href="#config相关命令" class="headerlink" title="config相关命令"></a>config相关命令</h2><h3 id="查看配置信息"><a href="#查看配置信息" class="headerlink" title="查看配置信息"></a>查看配置信息</h3><ol><li>查看系统config</li></ol><pre class="line-numbers language-none"><code class="language-none">git config --system --list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>查看当前用户（global）配置</li></ol><pre class="line-numbers language-none"><code class="language-none">git config --global  --list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>查看当前仓库配置信息</li></ol><pre class="line-numbers language-none"><code class="language-none">git config -- local    --list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="设置-修改配置信息"><a href="#设置-修改配置信息" class="headerlink" title="设置/修改配置信息"></a>设置/修改配置信息</h3><p>设置用户名：</p><pre class="line-numbers language-none"><code class="language-none">git config --global user.name "github用户名"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>设置邮箱</p><pre class="line-numbers language-none"><code class="language-none">git config --global user.email "github注册邮箱"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="查看提交记录-commit相关操作"><a href="#查看提交记录-commit相关操作" class="headerlink" title="查看提交记录+commit相关操作"></a>查看提交记录+commit相关操作</h2><h3 id="查看指定文件的历史提交记录"><a href="#查看指定文件的历史提交记录" class="headerlink" title="查看指定文件的历史提交记录"></a>查看指定文件的历史提交记录</h3><pre class="line-numbers language-none"><code class="language-none">git log -- &lt;file&gt;  //主要，这个文件要在当前目录才能直接输文件名，否则要给出路径<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/b1dc02f3dc8d4c888f7d98443524a64f.png" alt=""></p><h3 id="查看每次提交的内容差异"><a href="#查看每次提交的内容差异" class="headerlink" title="查看每次提交的内容差异"></a>查看每次提交的内容差异</h3><pre class="line-numbers language-none"><code class="language-none">git log -p -2 -- &lt;file&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>参数：-p 表示每次提交的内容差异，-2 则表示显示最近的两次更新。</p><p>说明：该选项除了显示基本信息之外，还在附带了每次 commit 的变化。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/381402cab6344a00b05b3a42fe128a60.png" alt=""></p><h3 id="根据哈希值查看修改代码细节"><a href="#根据哈希值查看修改代码细节" class="headerlink" title="根据哈希值查看修改代码细节"></a>根据哈希值查看修改代码细节</h3><pre class="line-numbers language-none"><code class="language-none">git show 哈希值<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">git show 哈希值 文件名 //具体某个文件的变化<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="根据分支或用户查看提交信息"><a href="#根据分支或用户查看提交信息" class="headerlink" title="根据分支或用户查看提交信息"></a>根据分支或用户查看提交信息</h3><pre class="line-numbers language-none"><code class="language-none">git log 分支名git log --authot='用户名'//这两个命令可以通过 | xargs  与 git show搭配用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="单词层面上的对比"><a href="#单词层面上的对比" class="headerlink" title="单词层面上的对比"></a>单词层面上的对比</h3><pre class="line-numbers language-none"><code class="language-none">git log --word-diff -- &lt;file&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>参数：—word-diff 表示获取单词层面上的对比。</p><p>说明：进行单词层面的对比常常是没什么用的。不过当你需要在书籍、论文这种很大的文本文件上进行对比的时候，这个功能就显出用武之地了。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/dbf8557886aa4e16905b75a0fc368c29.png" alt=""><br><strong>提示：新增加的单词被 {+ +} 括起来，被删除的单词被 [- -] 括起来。</strong></p><h3 id="图形化查看提交历史"><a href="#图形化查看提交历史" class="headerlink" title="图形化查看提交历史"></a>图形化查看提交历史</h3><pre class="line-numbers language-none"><code class="language-none">gitk -- &lt;file&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>说明：随 Git 一同发布的 gitk 就是这样一种工具。它是用 Tcl/Tk 写成的，基本上相当于 git log 命令的可视化版本，凡是<br>git log 可以用的选项也都能用在 gitk 上。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/b981ba602f044894b93bf19d74116145.png" alt=""><br>**</p><blockquote><p>gitk中文乱码问题</p></blockquote><p>**<br>解决办法：<br>打开git的配置文件(根据自己安装的git目录，此处为安装在D盘)：D:\Program Files\Git\etc\gitconfig</p><p>在文件内追加以下内容：</p><pre class="line-numbers language-none"><code class="language-none">[gui]  encoding = utf-8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="提取git中某个文件的所有版本并按顺序命名"><a href="#提取git中某个文件的所有版本并按顺序命名" class="headerlink" title="提取git中某个文件的所有版本并按顺序命名"></a>提取git中某个文件的所有版本并按顺序命名</h3><pre class="line-numbers language-none"><code class="language-none">git log --follow --pretty=format:%H 文件名 | xargs -I{} sh -c 'git show {}:文件名 &gt; 文件名.{}'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>文件名需要进行替换，不可直接输入 文件名 三个字</strong></p><p><br></p><p><strong>如果出现</strong> </p><blockquote><p>Did you menan ‘哈希值：路径’ aka ‘哈希值：路径’</p></blockquote><p>字眼的错误</p><p>给第二个文件名添加 <code>./</code></p><h3 id="git将远程分支按分支名在本地建立文件夹"><a href="#git将远程分支按分支名在本地建立文件夹" class="headerlink" title="git将远程分支按分支名在本地建立文件夹"></a>git将远程分支按分支名在本地建立文件夹</h3><pre class="line-numbers language-none"><code class="language-none">git branch -r | xargs -d/ -n1 | grep -v 'origin' | xargs -I{} sh -c 'mkdir "C:\Users\76585\Desktop\try\{}" '<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令分线见 <strong>博客—Linux Shell命令总结</strong></p><h3 id="撤回git-commit-操作"><a href="#撤回git-commit-操作" class="headerlink" title="撤回git commit 操作"></a>撤回git commit 操作</h3><p>写完代码后，我们一般这样</p><p>git add .</p><p>git commit -m “msg”</p><p>执行完commit后，想撤回commit，怎么办？</p><ol><li>撤回操作</li></ol><p><strong>git reset —soft HEAD^</strong><br>（ps：如果控制台出现More?，则将命令改成 git reset —soft HEAD^^即可）</p><p>这样就成功的撤销了你的commit</p><p>注意，仅仅是撤回commit操作，您写的代码仍然保留。</p><p><strong>说一下个人理解：</strong><br>HEAD^的意思是上一个版本，也可以写成HEAD~1</p><p>如果你进行了2次commit，想都撤回，可以使用HEAD~2</p><ol><li>参数：<br><strong>—mixed</strong><br>意思是：不删除工作空间改动代码，撤销commit，并且撤销git add . 操作<br>这个为默认参数,git reset —mixed HEAD^ 和 git reset HEAD^ 效果是一样的。</li></ol><p><strong>—soft</strong><br>不删除工作空间改动代码，撤销commit，不撤销git add .</p><p><strong>—hard</strong><br>删除工作空间改动代码，撤销commit，撤销git add .</p><p>注意完成这个操作后，就恢复到了上一次的commit状态。</p><ol><li>修改注释</li></ol><p>顺便说一下，如果commit注释写错了，只是想改一下注释，只需要：<br>git commit —amend</p><p>此时会进入默认vim编辑器，修改注释完毕后保存就好了。</p><h3 id="比较两个分支的commit"><a href="#比较两个分支的commit" class="headerlink" title="比较两个分支的commit"></a>比较两个分支的commit</h3><p>比如我们有 2 个分支：master, dev，现在想查看这两个 branch 的区别，有以下几种方式：</p><ol><li>查看 dev 有，而 master 中没有的<pre class="line-numbers language-none"><code class="language-none">git log dev ^master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p>查看 master 中有，而 dev 中没有的内容:<br></p><pre class="line-numbers language-none"><code class="language-none">git log master ^dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p><ol><li><p>查看 dev 中比 master 中多提交了哪些内容</p><pre class="line-numbers language-none"><code class="language-none">git log master..dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>不管谁提交的多谁提交的少，单纯想知道有什么不一样</p></li></ol><pre class="line-numbers language-none"><code class="language-none">git log dev...master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>在上述情况下，再显示出每个提交是在哪个分支上：</li></ol><pre class="line-numbers language-none"><code class="language-none">git log --left-right dev...master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h2><h3 id="分支的使用"><a href="#分支的使用" class="headerlink" title="分支的使用"></a>分支的使用</h3><p><strong>mster代表主分支，最终的代码都整合到这里面去，我们可以看下</strong><br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/fcc0d993653e42e7a48a10d25328f11e.png" alt=""></p><p><strong>这里只有一个主分支master。<br>有一种情况就是，一个项目多人开发，我的任务需要开发一个功能，我没办法短时间内就开发测试等等一系列完成。所以我可以新建一个分支，然后把每次完成的代码都上传到这个分支里面去，最后等到所有操作都完成后，我再把这个分支整合到master中去。下面看步骤</strong></p><p>1.首先查看当前分支</p><pre class="line-numbers language-none"><code class="language-none">git branch -a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>-a代表查看本地和远程的分支，此时我们看到都只有一个master分支<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/8e219832c5df4eef8c7da9dce7cd1829.png" alt=""></p><p>2.新建分支dev</p><pre class="line-numbers language-none"><code class="language-none">git checkout -b dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>执行该命令，会在本地创建一个新分支。该分支是从当前分支上生成的，所有内容和当前分支一样。</strong></p><p>-b代表同时切换到dev分支下面去，这时你可以再去查看分支</p><p>3.然后我们重新写一个b.js文件，再执行add，commit，最后push</p><pre class="line-numbers language-none"><code class="language-none">git add b.jsgit commit -m "dev"git push origin dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意push时要到dev分支</strong></p><p>成功后我们去coding看已经有了dev，并且dev下有b.js，而master没有b.js<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/ca05925c026f48d4af3cc08ced1632da.png" alt=""></p><p>master：<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/abc1cba6a233436a8a4731ec90324646.png" alt=""></p><p>我们可以再去看看分支情况，</p><p>git branch -a<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/5323471b84664e88b25f3f6228da4e74.png" alt=""></p><p>此时已经有了两个分支，且当前位于dev分之下<br>切换分支可以用 <strong>git checkout [branch-name]</strong></p><h3 id="将远程git仓库里的指定分支拉取到本地（本地不存在的分支）"><a href="#将远程git仓库里的指定分支拉取到本地（本地不存在的分支）" class="headerlink" title="将远程git仓库里的指定分支拉取到本地（本地不存在的分支）"></a>将远程git仓库里的指定分支拉取到本地（本地不存在的分支）</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> checkout -b<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上述命令虽然能生成新分支，但是会复制当前分支。但有时从远程仓库拉取分支，我只想要远程那个分支，不想先复制别的，这样拉下来会有冲突。<br>方法如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> checkout -b 本地分支名 origin/远程分支名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个将会自动创建一个新的本地分支，并与指定的远程分支关联起来。</p><p>如果出现提示：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">fatal: Cannot update paths and switch to branch <span class="token string">'dev2'</span> at the same time.Did you intend to checkout <span class="token string">'origin/dev2'</span> <span class="token function">which</span> can not be resolved as commit?<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>或者：<br></p><pre class="line-numbers language-none"><code class="language-none">fatal: 'origin/xlh' is not a commit and a branch 'xlh' cannot be created from it<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br><strong>git remote发现远程仓库的新分支没有显示出来，git fetch就好</strong><p></p><p>表示拉取不成功或远程仓库信息没有更新。我们需要先执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> fetch<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后再执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> checkout -b 本地分支名 origin/远程分支名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><p><strong>查看分支</strong></p><pre class="line-numbers language-none"><code class="language-none">git branch -a //远程的是红色<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>删除本地分支</strong></p><pre class="line-numbers language-none"><code class="language-none">git branch -d &lt;BranchName&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>删除远程分支</strong></p><pre class="line-numbers language-none"><code class="language-none">git push origin --delete &lt;BranchName&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="整合分支"><a href="#整合分支" class="headerlink" title="整合分支"></a>整合分支</h3><p><strong>当我们在dev下折腾完成后，最终要整合到master中去，看步骤</strong></p><p>1.切换本地分支到master</p><pre class="line-numbers language-none"><code class="language-none">git checkout master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2.将远程仓库的最新代码pull下来！！因为期间其他人可能已经提交代码到远程master了，所以你首先得更新下自己本地的master代码</p><pre class="line-numbers language-none"><code class="language-none">git pull origin master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>假如有改动过，那么执行后会显示改动的信息</p><p>3.然后再把本地的dev代码整合到master，输入</p><pre class="line-numbers language-none"><code class="language-none">git merge dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>merge整合操作，把dev整合到当前分之下（当前分支为master）。会提示增加了东西<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/249f2d65516c483a9517f8ce5affb72f.png" alt=""></p><p>4.由于当前的东西已经在本地仓库里面了，所以最后我们再执行push，到远程仓库的master</p><pre class="line-numbers language-none"><code class="language-none">git push origin master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>成功后你可看到，master下已经有b.js文件了<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/1f2c3d8b692b42619534a683d2c3f21a.png" alt=""></p><h3 id="本地从远程仓库拉取代码，只在某分支开发"><a href="#本地从远程仓库拉取代码，只在某分支开发" class="headerlink" title="本地从远程仓库拉取代码，只在某分支开发"></a>本地从远程仓库拉取代码，只在某分支开发</h3><p>远程仓库有master，dev1两个分支。本地用git clone拉取代码，<code>git branch -a</code>查看，本地只有一个分支。此时用<code>git checkout dev1</code> 切换到dev1分支。代码和远程仓库一致。可以用<code>git log</code>来确认是否是该分支（因为git log 只能看到当前分支的提交记录）</p><h3 id="合并分支—git-merge应用的三种情况"><a href="#合并分支—git-merge应用的三种情况" class="headerlink" title="合并分支—git merge应用的三种情况"></a>合并分支—git merge应用的三种情况</h3><p><a href="https://blog.csdn.net/qq_42780289/article/details/97945300?spm=1001.2101.3001.6650.2&amp;depth_1-utm_relevant_index=5">原链接</a></p><ol><li>“快进”(无冲突)<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93czEuc2luYWltZy5jbi9sYXJnZS8wMDZWckpBSmd5MWc1ajRqMXFodjNqMzBrdzBiYmRmdy5qcGc" alt=""></li></ol><p><strong>合并dev和master</strong><br>由于当前 master 分支所指向的提交是你当前提交（dev的提交）的直接上游，所以 Git 只是简单的将 master 指针向前移动。 换句话说，当你试图合并两个分支时，如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候，只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”。合并结果如下：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93czEuc2luYWltZy5jbi9sYXJnZS8wMDZWckpBSmd5MWc1ajRyZms0NjFqMzBrcTBhYjN5ay5qcGc" alt=""></p><ol><li>非“快进”，修改不同文件。(无冲突)</li></ol><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93czEuc2luYWltZy5jbi9sYXJnZS8wMDZWckpBSmd5MWc1ajVsbXViOXhqMzBndjBhb2FhNS5qcGc" alt=""></p><p>在 master 分支和 dev 分支的公共祖先 B2 后，master 和 dev 的提交是对不同文件或者同一文件的不同部分进行了修改，Git 可以合并它们。（比如说原来有 test-1 和 test-2 两个文件，B4修改的是 test-1 文件，而B3修改的是 test-2 文件，然后合并两个分支。）</p><p>合并是成功的。</p><ol><li>非“快进”，修改相同文件。(有冲突)</li></ol><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93czEuc2luYWltZy5jbi9sYXJnZS8wMDZWckpBSmd5MWc1ajVsbXViOXhqMzBndjBhb2FhNS5qcGc" alt=""></p><p>在 master 分支和 dev 分支的公共祖先 B2 后，master 和 dev 的提交是对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。（比如说原来有 test-1 和 test-2 两个文件，B4修改的是 test-1 文件，而B3修改的也是 test-1 文件的同一部分，然后合并两个分支。）</p><p><strong>合并是失败的。</strong></p><p>此时 Git 做了合并，但是没有自动地创建一个新的合并提交。 Git 会暂停下来，等待你去解决合并产生的冲突。</p><h3 id="分支改名"><a href="#分支改名" class="headerlink" title="分支改名"></a>分支改名</h3><ol><li>修改本地分支名<pre class="line-numbers language-none"><code class="language-none">git branch -m oldBranchName newBranchName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h2 id="git-常用操作"><a href="#git-常用操作" class="headerlink" title="git 常用操作"></a>git 常用操作</h2><h3 id="git-pull-与-git-push-详解"><a href="#git-pull-与-git-push-详解" class="headerlink" title="git pull 与 git push 详解"></a>git pull 与 git push 详解</h3><p>1.git remote<br></p><pre class="line-numbers language-none"><code class="language-none">git remote add origin url  //这里面的origin 是给远程仓库起名字，不是给本地仓库！<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p><p>2.git pull<br></p><pre class="line-numbers language-none"><code class="language-none">git pull 其实就是 git fetch 和 git merge FETCH_HEAD 的简写。 命令格式如下：git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p></p><pre class="line-numbers language-none"><code class="language-none">将远程主机 origin 的 master 分支拉取过来，与本地的 brantest 分支合并。git pull origin master:brantest如果远程分支是与当前分支合并，则冒号后面的部分可以省略。git pull origin master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.git push<br></p><pre class="line-numbers language-none"><code class="language-none">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;如果本地分支名与远程分支名相同，则可以省略冒号：git push &lt;远程主机名&gt; &lt;本地分支名&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>实例：<br>以下命令将本地的 master 分支推送到 origin 主机的 master 分支。</p><pre class="line-numbers language-none"><code class="language-none">git push origin master相等于：git push origin master:master如果本地版本与远程版本有差异，但又要强制推送可以使用 --force 参数：git push --force origin master删除主机的分支可以使用 --delete 参数，以下命令表示删除 origin 主机的 master 分支：git push origin --delete master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="将本地代码上传到远程仓库"><a href="#将本地代码上传到远程仓库" class="headerlink" title="将本地代码上传到远程仓库"></a>将本地代码上传到远程仓库</h3><p>1.（电脑里得先下载git）登录coding，新建一个仓库，点击代码浏览可以看到<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/dfad51be62a440cd86b764c2e4f16487.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/7063830ad8194b8792977f5750a8d1d4.png" alt=""><br>2.在本地新建一个文件夹，作为项目根目录，再此启动 Git Bash ，进入目录，并输入</p><pre class="line-numbers language-none"><code class="language-none">git init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3.将本地仓库和我们在coding上创建的远程仓库对接起来，输入</p><pre class="line-numbers language-none"><code class="language-none">git remote add *yourname* *git_url*  //不用输这条，输下面那条<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>add 后面输入你的仓库名字，自定义。git_url代表你的git地址，这里我命名为origin</p><pre class="line-numbers language-none"><code class="language-none">git remote add origin *url* //这条指令是上面的详细版，输入这个就好。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>（这里可能会出现叫你设置邮箱，和姓名，跟着提示设置就行了，或者可以选择以SSH公钥进行连接，不过得先去配置公钥）</p></blockquote><p>回车成功后可以输入</p><pre class="line-numbers language-none"><code class="language-none">git remote -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4.为了我们的代码是最新的状态 和 提交时不会产生冲突，我们先执行下pull操作，将远程仓库最新代码拉到我们本地来，输入</p><pre class="line-numbers language-none"><code class="language-none">git pull origin master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>（origin就是我们上面设置的仓库名，master代表主分支，你可以把分支理解为一块区域，我们最终编写完成的代码都要整合到master分支里面去。然后，我们还可创建一些其他分支，去保存我们正在编写中，或者尚未测试的代码。）</p></blockquote><p>执行完后，你可以查看目录下的文件，这时我们本地的文件就和远程仓库里面master分支里的文件一样了。</p><p>5.接下来我们来模拟写代码并上传到远程仓库去。<br>我们新建一个 a.js文件，并编辑一些内容进去。首先将a文件添加到暂存区</p><pre class="line-numbers language-none"><code class="language-none">git add a.js //（add后面可以带多个文件名字，用空格隔开；或者输入 . 代表全部）//然后再提交到本地仓库中去git commit -m "first commit"//然后我们需要把它push到远程仓库中去。输入git push origin master  //push到origin的master主分支里面，成功后会显示提示消息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查看远程仓库的情况"><a href="#查看远程仓库的情况" class="headerlink" title="查看远程仓库的情况"></a>查看远程仓库的情况</h3><p>查看当前配置有哪些远程仓库</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> remote<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>本地与远程仓库的取消<br><strong>git remote remove “仓库名”</strong></p><p><strong>可以同时关联多个仓库，名字起的不一样就好，不一定非要用origin。但是要注意的是，git pull 和 git push指定的仓库名字也要改变。不然容易出问题。</strong></p><h3 id="回退到某版本"><a href="#回退到某版本" class="headerlink" title="回退到某版本"></a>回退到某版本</h3><pre class="line-numbers language-none"><code class="language-none">git reset --hard 139dcfaa558e3276b30b6b2e5cbbb9c00bbdca96 //后面的是git提交的历史版本号，上git上面找到复制下来就行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="回退到某版本，且放弃之前的记录"><a href="#回退到某版本，且放弃之前的记录" class="headerlink" title="回退到某版本，且放弃之前的记录"></a>回退到某版本，且放弃之前的记录</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> reset --hard回退之后，如果直接push会出错，因为我们本地库HEAD指向的版本比远程库的要旧，所以我们要用“git push -f”强制推上去<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="将现有代码保存带其它仓库"><a href="#将现有代码保存带其它仓库" class="headerlink" title="将现有代码保存带其它仓库"></a>将现有代码保存带其它仓库</h3><ol><li>git remote add neworigin <strong>“url”</strong></li><li>git push -u neworigin <strong>“分支名”</strong></li><li>如果第二条命令不行就：git push -u neworigin <strong>“分支名”</strong> : <strong>“分支名”</strong></li></ol><h3 id="生成新的ssh密钥"><a href="#生成新的ssh密钥" class="headerlink" title="生成新的ssh密钥"></a>生成新的ssh密钥</h3><p>我们在重装系统后，如果要使用ssh来拉去代码，就需要生成密钥。<br><a href="https://docs.github.com/zh/enterprise-server@3.7/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent">原文链接</a></p><p>1.打开git Bash。输入 <code>ssh-keygen -t ed25519 -C "your_email@example.com"</code>；email替换为github的email（其他eamil没有尝试过）<br>2.后面一直回车就好，详细的去看原链接。<strong>需要注意的是不要更改密钥文件名字，否则会出问题</strong>。因为更改后，执行完后面的操作一直出问题。使用<code>ssh -vT git@github.com</code>命令发现它一直在寻找带有id<em>rsa</em>字段的文件，擅自改了名字当然找不到，这个问题如何解决目前还没有找到方法。<br>3.<code>eval "$(ssh-agent -s)"</code>//确保 ssh-agent 正在运行<br>4.<code>ssh-add ~/.ssh/id_ed25519</code>//将 SSH 私钥添加到 ssh-agent。<br>5.将后缀为.pub的文件（公钥）添加到 GitHub 上的帐户</p><h3 id="git-push之前忘记了git-pull，但是已经commit"><a href="#git-push之前忘记了git-pull，但是已经commit" class="headerlink" title="git push之前忘记了git pull，但是已经commit"></a>git push之前忘记了git pull，但是已经commit</h3><p>背景：公司和家里面各有一台电脑。公司的电脑忘记了pull，对文件进行修改后，push无法成功。pull也被拒绝。如果直接回退，之前的记录就没了。而我想保留修改，因为也是有用的东西。</p><p>解决办法：<br></p><pre class="line-numbers language-none"><code class="language-none">git stash //保存本地快照git reset --hard "hash_value"//通过git log查看离的最近的没有发生冲突的提交记录，把哈希值找到，再回退git pull origin hexo:hexo //hexo是博客的分支git stash pop//把之前本地的修改重新补上<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p></p><h2 id="git-bash扩展命令"><a href="#git-bash扩展命令" class="headerlink" title="git bash扩展命令"></a>git bash扩展命令</h2><p><a href="https://blog.51cto.com/u_15127579/2670631">原链接</a><br>总共有三个思路：</p><h3 id="1-借助winpty调用cmd可以使用的命令"><a href="#1-借助winpty调用cmd可以使用的命令" class="headerlink" title="1.借助winpty调用cmd可以使用的命令"></a>1.借助winpty调用cmd可以使用的命令</h3><p><strong>winpty 是一种提供与 cmd 通信的软件包,详情请参考 <a href="https://github.com/rprichard/winpty">https://github.com/rprichard/winpty</a></strong></p><p>git bash 命令行内没有 tree 命令而 cmd 命令行却有 tree 命令.</p><p>只不过 cmd 命令中的 tree 命令实际上是 tree.com 并不是 tree.exe 文件.<br>(tree 命令是以树状结构显示文件目录的一种命令,查看目录结构层次非常直观.)</p><pre class="line-numbers language-none"><code class="language-none">`winpty tree.com` 效果等价于 `cmd` 内直接执行 `tree.com` 命令,瞬间解决了中文乱码问题<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-gunWin填补（用的最多）"><a href="#2-gunWin填补（用的最多）" class="headerlink" title="2.gunWin填补（用的最多）"></a>2.gunWin填补（用的最多）</h3><p>绝大多数命令可以从这里找到，有的是可执行程序，有的是源码，需要先编译。<br><a href="https://sourceforge.net/">访问该网址</a></p><h3 id="3-工具—Babun"><a href="#3-工具—Babun" class="headerlink" title="3.工具—Babun"></a>3.工具—Babun</h3><h3 id="4-工具—gitforwindows"><a href="#4-工具—gitforwindows" class="headerlink" title="4.工具—gitforwindows"></a>4.工具—gitforwindows</h3><h3 id="扩展实例"><a href="#扩展实例" class="headerlink" title="扩展实例"></a>扩展实例</h3><h3 id="安装make命令"><a href="#安装make命令" class="headerlink" title="安装make命令"></a>安装make命令</h3><ol><li><a href="https://sourceforge.net/projects/ezwinports/files/">前往该网址</a>，下载 make-4.1-2-without-guile-w32-bin.zip，并解压zip文件</li><li>将解压内容(bin,lib等文件夹)放到git-bash安装路径的 mingw64文件夹 Git\mingw64\ （重复文件不要覆盖）</li></ol><h3 id="安装wget"><a href="#安装wget" class="headerlink" title="安装wget"></a>安装wget</h3><ol><li><a href="https://eternallybored.org/misc/wget/">前往该网址</a>，下载最新的wget可执行文件（下载zip文件，包含document；或者直接下载exe文件）</li><li>得到wget.exe（如果可执行文件名称是wget64.exe，将其重命名为wget.exe）</li><li>将 wget.exe 移动到你的git-bash安装路径的bin文件夹中 Git\mingw64\bin\</li></ol><h3 id="安装sshpass"><a href="#安装sshpass" class="headerlink" title="安装sshpass"></a>安装sshpass</h3><ol><li>从<a href="http://sourceforge.net/projects/sshpass/">网址</a>下载1.05版本</li><li>windows编译需要安装Cygwin编译器，如果安装的是MinGW，那么后面make会出错。<a href="https://blog.csdn.net/weixin_42109012/article/details/106060913">win10 安装Cygwin</a>。关键就是把编译c语言的相关东西装好。</li><li>进入sshpass源码，打开git bash。 <strong>./configure</strong></li><li>make &amp;&amp; make install</li><li>把编译好的exe程序放到：C:\Software\git\usr\bin;如果报缺少cygwin.dll这种信息，用everything搜索这个，然后放到这个目录</li><li>把上面的路径放到环境变量</li></ol><h3 id="git-bash安装zip"><a href="#git-bash安装zip" class="headerlink" title="git bash安装zip"></a>git bash安装zip</h3><p>git bash有些话可能没法执行zip命令</p><p>1.打开<a href="https://sourceforge.net/projects/gnuwin32/files/">https://sourceforge.net/projects/gnuwin32/files/</a><br>2.2.找到zip和bzip2，由于zip依赖bzip2.dll，<strong>下载zip-3.0-bin.zip和bzip2-1.0.5-bin.zip</strong>，解压后，复制zip-3.0-bin的bin目录下的<strong>zip.exe</strong> 和bzip2-1.0.5-bin的bin目录下的<strong>bzip2.dll</strong>到 <strong>git/usr/bin/</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">放置的目录不能放错，一开始放到了git/bin/目录下，结果不行。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="git-所遇问题"><a href="#git-所遇问题" class="headerlink" title="git 所遇问题"></a>git 所遇问题</h2><h3 id="git代理"><a href="#git代理" class="headerlink" title="git代理"></a>git代理</h3><p>git代理一般分为两种：http和ssh</p><ol><li>http<br>仅为github.com设置socks5代理(推荐这种方式, 公司内网就不用设代理了, 多此一举):<br>git config —global http.<a href="https://github.com.proxy">https://github.com.proxy</a> socks5://127.0.0.1:1086<br>其中1086是socks5的监听端口, 这个可以配置的, 每个人不同, 在macOS上一般为1086.<br>设置完成后, ~/.gitconfig文件中会增加以下条目:<pre class="line-numbers language-none"><code class="language-none">[http "https://github.com"]    proxy = socks5://127.0.0.1:1086<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>ssh<br>需要修改~/.ssh/config文件, 没有的话新建一个. 同样仅为github.com设置代理:<pre class="line-numbers language-none"><code class="language-none">Host github.com    User git    ProxyCommand nc -v -x 127.0.0.1:1086 %h %p<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><p>如果是在Windows下, 则需要个性%home%.ssh\config, 其中内容类似于:<br></p><pre class="line-numbers language-none"><code class="language-none">Host github.com    User git    ProxyCommand connect -S 127.0.0.1:1086 %h %p<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p></p><p>这里-S表示使用socks5代理, 如果是http代理则为-H. connect工具git自带, 在\mingw64\bin\下面.</p><p>当时我换了个梯子，导致无法使用ssh拉取代码。一开始以为是网络问题，后面发现是新梯子端口不对。把windows在用户目录下的.ssh目录里面的端口改好就可以了，本人电脑的配置如下：</p><pre class="line-numbers language-none"><code class="language-none">Host github.com  HostName ssh.github.com  Port 443  ProxyCommand connect -S 127.0.0.1:7890 %h %pHost github.com  User git  ProxyCommand connect -H 127.0.0.1:7890 %h %p<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ssh-Connection-refused"><a href="#ssh-Connection-refused" class="headerlink" title="ssh  Connection refused"></a>ssh  Connection refused</h3><p>ssh: connect to host github.com port  22: Connection refused</p><p><a href="https://segmentfault.com/a/1190000041909858">原链接</a></p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> Linux </tag>
            
            <tag> git </tag>
            
            <tag> 代码管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python</title>
      <link href="/posts/51872/"/>
      <url>/posts/51872/</url>
      
        <content type="html"><![CDATA[<h2 id="所遇问题"><a href="#所遇问题" class="headerlink" title="所遇问题"></a>所遇问题</h2><h3 id="输出格式有问题"><a href="#输出格式有问题" class="headerlink" title="输出格式有问题"></a>输出格式有问题</h3><p>背景：python2.7，IDE：VSCode<br>源码：<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/aad38ed43cf14169a81178f15d5cab6b.png" alt=""></p><p>two.txt:<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/30f55f74a6f04008af34c386d4ac4631.png" alt=""></p><p>输出：<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/006fd38c10064562b5261b067cd0d0e8.png" alt=""><br>预期应该为商品，单价，数量。</p><p>修改最后一行的print<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/be1c33ec8b6e4593806ab989758d5641.png" alt=""></p><h3 id="打包pip-install-包"><a href="#打包pip-install-包" class="headerlink" title="打包pip install 包"></a>打包pip install 包</h3><p><a href="https://blog.csdn.net/weixin_43843003/article/details/98619962">相似的回答</a></p><blockquote><p>背景：内网需要安装python和一些包，无法连互联网，只能外网下载再u盘拷过去。</p></blockquote><ol><li><p>在外网机器Python的安装目录中新建一个文件夹，如packages：<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/f86df46c2cc4468fa89c15c1708df6fe.png" alt=""></p></li><li><p>进入到packages文件夹下，shift按住，鼠标右键“在此处打开命令行”，输入pip<br>list查看系统中安装了哪些python包，如下：<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/730bff4d9f30437790528bf4db3797cb.png" alt=""></p></li><li>把所有包名及版本号，重定向到requirements.txt中<pre class="line-numbers language-none"><code class="language-none">pip freeze &gt;requirements.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>然后下载系统中已经安装的所有包到一个目录下，比如在packages的packages中，使用如下命令,此时packages下有两个文件：</li></ol><pre class="line-numbers language-none"><code class="language-none">pip download -r requirements.txt -d packages<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/1db7754fe1984892849f3d5adca5bc5b.png" alt=""></p><ol><li>内网安装。先复制刚才外网机器上的文件夹pacjages到内网机器对应的目录<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/8a4c18aa77c040dd925733f93ade928e.png" alt=""></li><li>进入到D:\Python37\packages下，打开命令行，执行安装</li></ol><pre class="line-numbers language-none"><code class="language-none">pip install --no-index --find-links=packages -r requirements.txt <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果失败，可以一个一个安装</p><pre class="line-numbers language-none"><code class="language-none">pip install XXXX包名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="python2-7-卸载失败问题"><a href="#python2-7-卸载失败问题" class="headerlink" title="python2.7 卸载失败问题"></a>python2.7 卸载失败问题</h3><blockquote><p>背景：使用.msi文件进行卸载，出现以下情况：</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/bcd0965e3e1c4c929422fa9b879729cb.png" alt=""><br>解决方法：<br>找到出问题的版本，个人当时出问题的版本是2.7.10。官网下载msi文件。<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/93c843b909ec45ec85865dbf3c2ae945.png" alt=""><br>依次运行。</p><h3 id="open函数传参数出错"><a href="#open函数传参数出错" class="headerlink" title="open函数传参数出错"></a>open函数传参数出错</h3><blockquote><p>背景：python2.7，open函数传递参数。<br>自定义函数，函数里面调用open函数</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/4c36a39430c747eb86e933b2ae67b809.png" alt=""><br>如果不在路径前面加r，就会报错。按理说应该是<br>open(file_path,mode)</p><p>后面写出函数，拼接的时候老出错。<br><strong>解决办法：</strong></p><blockquote><p>路径使用/<br>‘C:/Users/76585/Desktop/compare/one.txt’</p></blockquote><p>open函数可以正常使用open(path,mode)</p><h3 id="Python编码错误的解决办法SyntaxError-Non-ASCII-character-‘-xe5’-in-file"><a href="#Python编码错误的解决办法SyntaxError-Non-ASCII-character-‘-xe5’-in-file" class="headerlink" title="Python编码错误的解决办法SyntaxError: Non-ASCII character ‘\xe5’ in file"></a>Python编码错误的解决办法SyntaxError: Non-ASCII character ‘\xe5’ in file</h3><blockquote><p>原因：python的默认编码文件是用的ASCII码，而你的python文件中使用了中文等非英语字符</p></blockquote><p>解决办法：</p><p>在Python源文件的最开始一行，加入一句：</p><pre class="line-numbers language-none"><code class="language-none">##coding=UTF-8（等号换为”:“也可以）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-none"><code class="language-none">##-*- coding:UTF-8 -*-<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="RuntimeError-dictionary-changed-size-during-iteration"><a href="#RuntimeError-dictionary-changed-size-during-iteration" class="headerlink" title="RuntimeError: dictionary changed size during iteration"></a>RuntimeError: dictionary changed size during iteration</h3><p>在字典遍历过程中修改字典元素，报错 RuntimeError: dictionary changed size during iteration</p><p>得知遍历时不能修改字典元素</p><pre class="line-numbers language-none"><code class="language-none">for k in func_dict.keys():    if func_dict[k] is np.nan:        del func_dict[k]        continue<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>解决办法：将遍历条件改为列表</strong></p><pre class="line-numbers language-none"><code class="language-none">for k in list(func_dict.keys()):    if func_dict[k] is np.nan:        del func_dict[k]        continue<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="VScode-code-runner无法运行出正确的结果"><a href="#VScode-code-runner无法运行出正确的结果" class="headerlink" title="VScode code runner无法运行出正确的结果"></a>VScode code runner无法运行出正确的结果</h3><p>背景：<br>内网电脑上，通过python程序对文件进行读写操作，但是没有出现相应的结果。单步调试可以出正确的结果。</p><p>分析：<br>通过print 输出可以发现问题。命令行运行py文件可以得到正确的结果，说明原因出在code runner上面。</p><p>解决办法：<br>1.首选项找到设置<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/84c82a81f052455385019bbc37bc93b2.png" alt=""><br>2.输入code-runner，找到 Executor Map<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/b22a0f9e154642e0843ce47974245361.png" alt=""><br>3.选择这个，（将设置复制为id）<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/a78e8887588e4e0591da5a2f391335aa.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/59d97e84f5384682828af42b5d5f03a1.png" alt=""></p><p>将复制的内容粘贴到里面</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/0bdfe664d55944f3b118f82861f2a31a.png" alt=""><br>修改其中python字段的python值替换为vscode左下角的python解释器：<br>结果如下;</p><pre class="line-numbers language-none"><code class="language-none">"python": "C:\\Python27\\python.exe -u" //注意转义符//下面这个也可以"python": "\"C:/Python27/python.exe\" -u"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/6eef8ba7ef9e47a9bbef68a0918f3b94.png" alt=""></p><h3 id="vscode进行调试，系统把conda-activate-base写入了用户输入区域该怎么办？"><a href="#vscode进行调试，系统把conda-activate-base写入了用户输入区域该怎么办？" class="headerlink" title="vscode进行调试，系统把conda activate base写入了用户输入区域该怎么办？"></a>vscode进行调试，系统把conda activate base写入了用户输入区域该怎么办？</h3><p><strong>问题：在运行调试的时候编译器在运行语句前没有进入虚拟base环境，于是在遇到激活用户输入语句时，自动输入了conda activate base ，导致程序出错</strong></p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/20190531113214107.png" alt=""><br>解决办法：避免在使用这些终端命令时激活虚拟环境和conda环境，<strong>请将python.terminal.activateEnvironment设置更改为false</strong></p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/2019053111303868.png" alt=""></p><p>这个setting.json在在<code>C:\Users\Administrator\AppData\Roaming\Code\User\setting.json</code> 是个纯文本文件，直接打开就好。如果没有python.terminal.activateEnvironment这一行可以自己加上。</p><h3 id="windows安装了conda，但无法在vscode使用"><a href="#windows安装了conda，但无法在vscode使用" class="headerlink" title="windows安装了conda，但无法在vscode使用"></a>windows安装了conda，但无法在vscode使用</h3><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/Snipaste_2023-08-28_11-33-58.png" alt=""></p><p>cmd可以正常使用，环境变量也添加了，但是一直不行。</p><p>解决办法：<br>找到conda安装目录下的Scripts下的activate,在vscode终端输入命令激活：<br></p><pre class="line-numbers language-none"><code class="language-none">C:\Users\76585\Miniconda3\Scripts\activate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p><h2 id="技术知识点"><a href="#技术知识点" class="headerlink" title="技术知识点"></a>技术知识点</h2><h3 id="遍历文件夹下的文件名"><a href="#遍历文件夹下的文件名" class="headerlink" title="遍历文件夹下的文件名"></a>遍历文件夹下的文件名</h3><blockquote><h1 id="方法1：使用os-listdir"><a href="#方法1：使用os-listdir" class="headerlink" title="方法1：使用os.listdir"></a>方法1：使用os.listdir</h1></blockquote><pre class="line-numbers language-none"><code class="language-none">import osfor filename in os.listdir(r'c:\windows'):    print("文件夹名字",filename)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><h1 id="方法2：使用glob模块，可以设置文件过滤"><a href="#方法2：使用glob模块，可以设置文件过滤" class="headerlink" title="方法2：使用glob模块，可以设置文件过滤"></a>方法2：使用glob模块，可以设置文件过滤</h1></blockquote><pre class="line-numbers language-none"><code class="language-none">import globfor filename in glob.glob(r'c:\windows\*.exe'):    print("是.exe的文件名",filename)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><h1 id="方法3：非递归"><a href="#方法3：非递归" class="headerlink" title="方法3：非递归"></a>方法3：非递归</h1></blockquote><pre class="line-numbers language-none"><code class="language-none">import osfor dirpath, dirnames, filenames in os.walk('D:'):    print('文件路径', dirpath)    print('文件夹名字',dirnames)    for filename in filenames:        print('文件名', filename)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="sorted排序"><a href="#sorted排序" class="headerlink" title="sorted排序"></a>sorted排序</h3><h4 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h4><p>文件夹里面的文件按照文件名里面的数字进行排序<br>文件如下：0.txt, 1.txt, 2.txt, 3.txt, 34.txt, 54.txt  …………….</p><pre class="line-numbers language-none"><code class="language-none">file_list=os.listdir(file_path)file_list.sort(key=lambda x:int((re.findall(r'\d+', str(x)))[0]))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>1.re.findall(r’\d+’, str(x))[0] 正则表达式提取数字，但结果是列表，所以把元素取出来，再用一个int转成整数类型</p><p>按照key来排序，后面是一个lambda表达式。</p><h4 id="对列表排序-返回的对象不会改变原列表"><a href="#对列表排序-返回的对象不会改变原列表" class="headerlink" title="对列表排序,返回的对象不会改变原列表"></a>对列表排序,返回的对象不会改变原列表</h4><pre class="line-numbers language-none"><code class="language-none">list = [1,5,7,2,4]sorted(list)Out[87]: [1, 2, 4, 5, 7]##可以设定时候排序方式，默认从小到大，设定reverse = False 可以从大到小sorted(list,reverse=False)Out[88]: [1, 2, 4, 5, 7]sorted(list,reverse=True)Out[89]: [7, 5, 4, 2, 1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="根据自定义规则来排序，使用参数：key"><a href="#根据自定义规则来排序，使用参数：key" class="headerlink" title="根据自定义规则来排序，使用参数：key"></a>根据自定义规则来排序，使用参数：key</h4><pre class="line-numbers language-none"><code class="language-none">## 使用key,默认搭配lambda函数使用sorted(chars,key=lambda x:len(x))Out[92]: ['a', 'is', 'boy', 'bruce', 'handsome']sorted(chars,key=lambda x:len(x),reverse= True)Out[93]: ['handsome', 'bruce', 'boy', 'is', 'a']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="根据自定义规则来排序，对元组构成的列表进行排序"><a href="#根据自定义规则来排序，对元组构成的列表进行排序" class="headerlink" title="根据自定义规则来排序，对元组构成的列表进行排序"></a>根据自定义规则来排序，对元组构成的列表进行排序</h4><pre class="line-numbers language-none"><code class="language-none">tuple_list = [('A', 1,5), ('B', 3,2), ('C', 2,6)]##key=lambda x: x[1]中可以任意选定x中可选的位置进行排序sorted(tuple_list, key=lambda x: x[1]) Out[94]: [('A', 1, 5), ('C', 2, 6), ('B', 3, 2)]sorted(tuple_list, key=lambda x: x[0])Out[95]: [('A', 1, 5), ('B', 3, 2), ('C', 2, 6)]sorted(tuple_list, key=lambda x: x[2])Out[96]: [('B', 3, 2), ('A', 1, 5), ('C', 2, 6)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="排序的元素是自定义类"><a href="#排序的元素是自定义类" class="headerlink" title="排序的元素是自定义类"></a>排序的元素是自定义类</h4><pre class="line-numbers language-none"><code class="language-none">class tuple_list: def __init__(self, one, two, three):  self.one = one  self.two = two  self.three = three def __repr__(self):  return repr((self.one, self.two, self.three))tuple_list_ = [tuple_list('A', 1,5), tuple_list('B', 3,2), tuple_list('C', 2,6)]sorted(tuple_list_, key=lambda x: x.one)Out[104]: [('A', 1, 5), ('B', 3, 2), ('C', 2, 6)]sorted(tuple_list_, key=lambda x: x.two)Out[105]: [('A', 1, 5), ('C', 2, 6), ('B', 3, 2)]sorted(tuple_list_, key=lambda x: x.three)Out[106]: [('B', 3, 2), ('A', 1, 5), ('C', 2, 6)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="根据多个字段来排序"><a href="#根据多个字段来排序" class="headerlink" title="根据多个字段来排序"></a>根据多个字段来排序</h4><pre class="line-numbers language-none"><code class="language-none">class tuple_list: def __init__(self, one, two, three):  self.one = one  self.two = two  self.three = three def __repr__(self):  return repr((self.one, self.two, self.three))tuple_list_ = [tuple_list('C', 1,5), tuple_list('A', 3,2), tuple_list('C', 2,6)]## 首先根据one的位置来排序，然后根据two的位置来排序sorted(tuple_list_, key=lambda x:(x.one, x.two))Out[112]: [('A', 3, 2), ('C', 1, 5), ('C', 2, 6)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="二维排序"><a href="#二维排序" class="headerlink" title="二维排序"></a>二维排序</h4><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt;l=[('a', 1), ('b', 2), ('c', 6), ('d', 4), ('e', 3)]&gt;&gt;&gt;sorted(l, key=lambda x:x[0])Out[39]: [('a', 1), ('b', 2), ('c', 6), ('d', 4), ('e', 3)]&gt;&gt;&gt;sorted(l, key=lambda x:x[0], reverse=True)Out[40]: [('e', 3), ('d', 4), ('c', 6), ('b', 2), ('a', 1)]&gt;&gt;&gt;sorted(l, key=lambda x:x[1])Out[41]: [('a', 1), ('b', 2), ('e', 3), ('d', 4), ('c', 6)]&gt;&gt;&gt;sorted(l, key=lambda x:x[1], reverse=True)Out[42]: [('c', 6), ('d', 4), ('e', 3), ('b', 2), ('a', 1)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><h4 id="字符串切割"><a href="#字符串切割" class="headerlink" title="字符串切割"></a>字符串切割</h4><p>注：使用前需要引入包（import re）<br>功能：split能够按照所能匹配的字串将字符串进行切分，返回切分后的字符串列表<br>形式：<br></p><pre class="line-numbers language-none"><code class="language-none">re.split(pattern, string[, maxsplit=0, flags=0])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>pattern:匹配的字符串<br>string:需要切分的字符串<br>maxsplit:分隔次数，默认为0(即不限次数)<br>flags:标志位，用于控制正则表达式的匹配方式，比如：是否区分大小写，，，如下图所示<p></p><p>具体分析：</p><pre class="line-numbers language-none"><code class="language-none">//传入某个文件的绝对路径（file_path），根据 '\'进行分割，将结果存入列表，再取出最后一个，就是文件名。new_line= re.split(r'[/]',str(file_path))file_name=new_line[-1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="替换字符串中的匹配项"><a href="#替换字符串中的匹配项" class="headerlink" title="替换字符串中的匹配项"></a>替换字符串中的匹配项</h4><p><strong>re.sub()</strong><br></p><pre class="line-numbers language-none"><code class="language-none">def sub(pattern, repl, string, count=0, flags=0):    """Return the string obtained by replacing the leftmost    non-overlapping occurrences of the pattern in string by the    replacement repl.  repl can be either a string or a callable;    if a string, backslash escapes in it are processed.  If it is    a callable, it's passed the match object and must return    a replacement string to be used."""    return _compile(pattern, flags).sub(repl, string, count)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>从上面的代码中可以看到re.sub()方法中含有5个参数，下面进行一一说明（加粗的为必须参数）：<br>（1）<strong>pattern</strong>：该参数表示正则中的模式字符串；<br>（2）<strong>repl</strong>：该参数表示要替换的字符串（即匹配到pattern后替换为repl），也可以是个函数；<br>（3）<strong>string</strong>：该参数表示要被处理（查找替换）的原始字符串；<br>（4）count：可选参数，表示是要替换的最大次数，而且必须是非负整数，该参数默认为0，即所有的匹配都会被替换；<br>（5）flags：可选参数，表示编译时用的匹配模式（如忽略大小写、多行模式等），数字形式，默认为0。<p></p><p>使用案例：<br><strong>1.匹配单一数字</strong><br>（1）只匹配单一数字</p><pre><code>&gt;&gt;&gt; import re&gt;&gt;&gt; s"大家好，我是一个程序员小白。I 'm so glad to introduce myself, and I’m 18 years old.   Today is 2020/01/01. It is a wonderful DAY! @HHHHello,,,#111ComeHere222...66？AA？zz？——http://welcome.cn"&gt;&gt;&gt; re.sub(r'[0-9]', '*', s)"大家好，我是一个程序员小白。I 'm so glad to introduce myself, and I’m ** years old.   Today is ****/**/**. It is a wonderful DAY! @HHHHello,,,#***ComeHere***...**？AA？zz？——http://welcome.cn"</code></pre><p>上面 re.sub(r’[0-9]’, ‘*’, s) 这句话则表示只匹配单一数字，并将每一个数字替换为一个星号 。</p><p>（2）只匹配单一字母<br></p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; s"大家好，我是一个程序员小白。I 'm so glad to introduce myself, and I’m 18 years old.   Today is 2020/01/01. It is a wonderful DAY! @HHHHello,,,#111ComeHere222...66？AA？zz？——http://welcome.cn"&gt;&gt;&gt; re.sub(r'[a-z]', '*', s)"大家好，我是一个程序员小白。I '* ** **** ** ********* ******, *** I’* 18 ***** ***.   T**** ** 2020/01/01. I* ** * ********* DAY! @HHHH****,,,#111C***H***222...66？AA？**？——****://*******.**"&gt;&gt;&gt; re.sub(r'[A-Z]', '*', s)"大家好，我是一个程序员小白。* 'm so glad to introduce myself, and *’m 18 years old.   *oday is 2020/01/01. *t is a wonderful ***! @****ello,,,#111*ome*ere222...66？**？zz？——http://welcome.cn"&gt;&gt;&gt; re.sub(r'[A-Za-z]', '*', s)"大家好，我是一个程序员小白。* '* ** **** ** ********* ******, *** *’* 18 ***** ***.   ***** ** 2020/01/01. ** ** * ********* ***! @********,,,#111********222...66？**？**？——****://*******.**"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>上面 re.sub(r’[a-z]’, ‘<em>‘, s) 这句话则表示只匹配单一小写字母，并将每一个小写字母替换为一个星号 。<br>上面 re.sub(r’[A-Z]’, ‘</em>‘, s) 这句话则表示只匹配单一大写字母，并将每一个大写字母替换为一个星号 。<br>上面 re.sub(r’[A-Za-z]’, ‘*’, s) 这句话则表示只匹配单一字母，并将每一个字母替换为一个星号 。<p></p><p>（3）匹配单一数字和字母</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; s"大家好，我是一个程序员小白。I 'm so glad to introduce myself, and I’m 18 years old.   Today is 2020/01/01. It is a wonderful DAY! @HHHHello,,,#111ComeHere222...66？AA？zz？——http://welcome.cn"&gt;&gt;&gt; re.sub(r'[0-9A-Z]', '*', s)"大家好，我是一个程序员小白。* 'm so glad to introduce myself, and *’m ** years old.   *oday is ****/**/**. *t is a wonderful ***! @****ello,,,#****ome*ere***...**？**？zz？——http://welcome.cn"&gt;&gt;&gt; re.sub(r'[0-9a-z]', '*', s)"大家好，我是一个程序员小白。I '* ** **** ** ********* ******, *** I’* ** ***** ***.   T**** ** ****/**/**. I* ** * ********* DAY! @HHHH****,,,#***C***H******...**？AA？**？——****://*******.**"&gt;&gt;&gt; re.sub(r'[0-9A-Za-z]', '*', s)"大家好，我是一个程序员小白。* '* ** **** ** ********* ******, *** *’* ** ***** ***.   ***** ** ****/**/**. ** ** * ********* ***! @********,,,#**************...**？**？**？——****://*******.**"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面 re.sub(r’[0-9A-Z]’, ‘<em>‘, s) 这句话则表示只匹配单一数字和大写字母，并将每一个数字和大写字母替换为一个星号 。<br>上面 re.sub(r’[0-9a-z]’, ‘</em>‘, s) 这句话则表示只匹配单一数字和小写字母，并将每一个数字和小写字母替换为一个星号 。<br>上面 re.sub(r’[0-9A-Za-z]’, ‘*’, s) 这句话则表示只匹配单一数字和字母，并将每一个数字和字母替换为一个星号 。</p><p><strong>2.匹配多个数字或字母</strong><br>注意：这里的所说的多个指的是大于等于一个。</p><p>（1）匹配多个数字<br></p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; s"大家好，我是一个程序员小白。I 'm so glad to introduce myself, and I’m 18 years old.   Today is 2020/01/01. It is a wonderful DAY! @HHHHello,,,#111ComeHere222...66？AA？zz？——http://welcome.cn"&gt;&gt;&gt; re.sub(r'[0-9]+', '*', s)"大家好，我是一个程序员小白。I 'm so glad to introduce myself, and I’m * years old.   Today is */*/*. It is a wonderful DAY! @HHHHello,,,#*ComeHere*...*？AA？zz？——http://welcome.cn"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>上面 re.sub(r’[0-9]+’, ‘*’, s) 这句话则表示匹配多个连续的数字，并将多个连续的数字替换为一个星号 。<p></p><p>（2）匹配多个字母</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; s"大家好，我是一个程序员小白。I 'm so glad to introduce myself, and I’m 18 years old.   Today is 2020/01/01. It is a wonderful DAY! @HHHHello,,,#111ComeHere222...66？AA？zz？——http://welcome.cn"&gt;&gt;&gt; re.sub(r'[a-z]+', '*', s)"大家好，我是一个程序员小白。I '* * * * * *, * I’* 18 * *.   T* * 2020/01/01. I* * * * DAY! @HHHH*,,,#111C*H*222...66？AA？*？——*://*.*"&gt;&gt;&gt; re.sub(r'[A-Z]+', '*', s)"大家好，我是一个程序员小白。* 'm so glad to introduce myself, and *’m 18 years old.   *oday is 2020/01/01. *t is a wonderful *! @*ello,,,#111*ome*ere222...66？*？zz？——http://welcome.cn"&gt;&gt;&gt; re.sub(r'[a-zA-Z]+', '*', s)"大家好，我是一个程序员小白。* '* * * * * *, * *’* 18 * *.   * * 2020/01/01. * * * * *! @*,,,#111*222...66？*？*？——*://*.*"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面 re.sub(r’[a-z]+’, ‘<em>‘, s) 这句话则表示匹配多个连续的小写字母，并将多个连续的小写字母替换为一个星号 。<br>上面 re.sub(r’[A-Z]+’, ‘</em>‘, s) 这句话则表示匹配多个连续的大写字母，并将多个连续的大写字母替换为一个星号 。<br>上面 re.sub(r’[A-Za-z]+’, ‘*’, s) 这句话则表示匹配多个连续的字母，并将多个连续的字母替换为一个星号 。</p><p>（3）匹配多个数字和字母<br></p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; s"大家好，我是一个程序员小白。I 'm so glad to introduce myself, and I’m 18 years old.   Today is 2020/01/01. It is a wonderful DAY! @HHHHello,,,#111ComeHere222...66？AA？zz？——http://welcome.cn"&gt;&gt;&gt; re.sub(r'[0-9a-zA-Z]+', '*', s)"大家好，我是一个程序员小白。* '* * * * * *, * *’* * * *.   * * */*/*. * * * * *! @*,,,#*...*？*？*？——*://*.*"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>上面 re.sub(r’[0-9A-Za-z]+’, ‘*’, s) 这句话则表示匹配多个连续的数字和字母，并将多个连续的数字、连续的字母、连续的数字和字母替换为一个星号 。<p></p><p><strong>3.匹配其他</strong></p><p>（1）匹配非数字<br></p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; s"大家好，我是一个程序员小白。I 'm so glad to introduce myself, and I’m 18 years old.   Today is 2020/01/01. It is a wonderful DAY! @HHHHello,,,#111ComeHere222...66？AA？zz？——http://welcome.cn"&gt;&gt;&gt; re.sub(r'[^0-9]', '*', s)'********************************************************18***********************2020*01*01**************************************111********222***66**************************'&gt;&gt;&gt; re.sub(r'[^0-9]+', '*', s)'*18*2020*01*01*111*222*66*'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>上面 re.sub(r’<sup><a href="#fn_0-9" id="reffn_0-9">0-9</a></sup>‘, ‘<em>‘, s) 这句话则表示匹配单个非数字，并将单个非数字替换为一个星号 。<br>上面 re.sub(r’<sup><a href="#fn_0-9" id="reffn_0-9">0-9</a></sup>+’, ‘</em>‘, s) 这句话则表示匹配多个连续的非数字，并将多个连续的非数字替换为一个星号 。<p></p><p>（2）匹配非字母</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; s"大家好，我是一个程序员小白。I 'm so glad to introduce myself, and I’m 18 years old.   Today is 2020/01/01. It is a wonderful DAY! @HHHHello,,,#111ComeHere222...66？AA？zz？——http://welcome.cn"&gt;&gt;&gt; re.sub(r'[^a-z]', '*', s)'*****************m*so*glad*to*introduce*myself**and***m****years*old*****oday*is**************t*is*a*wonderful***********ello********ome*ere************zz***http***welcome*cn'&gt;&gt;&gt; re.sub(r'[^A-Z]', '*', s)'**************I*************************************I*******************T********************I*****************DAY***HHHH***********C***H************AA***********************'&gt;&gt;&gt; re.sub(r'[^A-Za-z]', '*', s)'**************I**m*so*glad*to*introduce*myself**and*I*m****years*old****Today*is*************It*is*a*wonderful*DAY***HHHHello*******ComeHere*********AA*zz***http***welcome*cn'&gt;&gt;&gt; re.sub(r'[^a-z]+', '*', s)'*m*so*glad*to*introduce*myself*and*m*years*old*oday*is*t*is*a*wonderful*ello*ome*ere*zz*http*welcome*cn'&gt;&gt;&gt; re.sub(r'[^A-Z]+', '*', s)'*I*I*T*I*DAY*HHHH*C*H*AA*'&gt;&gt;&gt; re.sub(r'[^A-Za-z]+', '*', s)'*I*m*so*glad*to*introduce*myself*and*I*m*years*old*Today*is*It*is*a*wonderful*DAY*HHHHello*ComeHere*AA*zz*http*welcome*cn'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面 re.sub(r’<sup><a href="#fn_a-z" id="reffn_a-z">a-z</a></sup>‘, ‘<em>‘, s) 这句话则表示匹配单个非小写字母，并将单个非小写字母替换为一个星号 。<br>上面 re.sub(r’<sup><a href="#fn_A-Z" id="reffn_A-Z">A-Z</a></sup>‘, ‘</em>‘, s) 这句话则表示匹配单个非大写字母，并将单个非大写字母替换为一个星号 。<br>上面 re.sub(r’<sup><a href="#fn_A-Za-z" id="reffn_A-Za-z">A-Za-z</a></sup>‘, ‘<em>‘, s) 这句话则表示匹配单个非字母，并将单个非字母替换为一个星号 。<br>上面 re.sub(r’<sup><a href="#fn_a-z" id="reffn_a-z">a-z</a></sup>+’, ‘</em>‘, s) 这句话则表示匹配多个连续的非小写字母，并将多个连续的非小写字母替换为一个星号 。<br>上面 re.sub(r’<sup><a href="#fn_A-Z" id="reffn_A-Z">A-Z</a></sup>+’, ‘<em>‘, s) 这句话则表示匹配多个连续的非大写字母，并将多个连续的非大写字母替换为一个星号 。<br>上面 re.sub(r’<sup><a href="#fn_A-Za-z" id="reffn_A-Za-z">A-Za-z</a></sup>+’, ‘</em>‘, s) 这句话则表示匹配多个连续的非字母，并将多个连续的非字母替换为一个星号 。</p><p>（3）匹配非数字和非字母</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; s"大家好，我是一个程序员小白。I 'm so glad to introduce myself, and I’m 18 years old.   Today is 2020/01/01. It is a wonderful DAY! @HHHHello,,,#111ComeHere222...66？AA？zz？——http://welcome.cn"&gt;&gt;&gt; re.sub(r'[^0-9A-Za-z]', '*', s)'**************I**m*so*glad*to*introduce*myself**and*I*m*18*years*old****Today*is*2020*01*01**It*is*a*wonderful*DAY***HHHHello****111ComeHere222***66*AA*zz***http***welcome*cn'&gt;&gt;&gt; re.sub(r'[^0-9A-Za-z]+', '*', s)'*I*m*so*glad*to*introduce*myself*and*I*m*18*years*old*Today*is*2020*01*01*It*is*a*wonderful*DAY*HHHHello*111ComeHere222*66*AA*zz*http*welcome*cn'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面 re.sub(r’<sup><a href="#fn_0-9A-Za-z" id="reffn_0-9A-Za-z">0-9A-Za-z</a></sup>‘, ‘<em>‘, s) 这句话则表示匹配单个非数字和非字母，并将单个非数字和非字母替换为一个星号 。<br>上面 re.sub(r’<sup><a href="#fn_0-9A-Za-z" id="reffn_0-9A-Za-z">0-9A-Za-z</a></sup>+’, ‘</em>‘, s) 这句话则表示匹配多个连续的非数字和非字母，并将多个连续的非数字和非字母替换为一个星号 。</p><p>（4）匹配固定形式<br>a.只保留字母和空格，将 repl 设置为空字符即可。</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; s"大家好，我是一个程序员小白。I 'm so glad to introduce myself, and I’m 18 years old.   Today is 2020/01/01. It is a wonderful DAY! @HHHHello,,,#111ComeHere222...66？AA？zz？——http://welcome.cn"&gt;&gt;&gt; re.sub(r'[^a-z ]', '', s)' m so glad to introduce myself and m  years old   oday is  t is a wonderful  elloomeerezzhttpwelcomecn'&gt;&gt;&gt; re.sub(r'[^a-z ]+', '', s)' m so glad to introduce myself and m  years old   oday is  t is a wonderful  elloomeerezzhttpwelcomecn'&gt;&gt;&gt; re.sub(r'[^A-Za-z ]', '', s)'I m so glad to introduce myself and Im  years old   Today is  It is a wonderful DAY HHHHelloComeHereAAzzhttpwelcomecn'&gt;&gt;&gt; re.sub(r'[^A-Za-z ]+', '', s)'I m so glad to introduce myself and Im  years old   Today is  It is a wonderful DAY HHHHelloComeHereAAzzhttpwelcomecn'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果要使句子语义和结构更完整，则要先将其余字符替换为空格（即repl设置为空格），然后去除多余的空格，如下：</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; s1 = re.sub(r'[^A-Za-z ]+', ' ', s)&gt;&gt;&gt; s1' I  m so glad to introduce myself  and I m   years old    Today is   It is a wonderful DAY   HHHHello ComeHere AA zz http welcome cn'&gt;&gt;&gt; re.sub(r'[ ]+', ' ', s1)' I m so glad to introduce myself and I m years old Today is It is a wonderful DAY HHHHello ComeHere AA zz http welcome cn'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>b.去除以 @ 开头的英文单词<br></p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; s"大家好，我是一个程序员小白。I 'm so glad to introduce myself, and I’m 18 years old.   Today is 2020/01/01. It is a wonderful DAY! @HHHHello,,,#111ComeHere222...66？AA？zz？——http://welcome.cn"&gt;&gt;&gt; re.sub(r'@[A-Za-z]+', '', s)"大家好，我是一个程序员小白。I 'm so glad to introduce myself, and I’m 18 years old.   Today is 2020/01/01. It is a wonderful DAY! ,,,#111ComeHere222...66？AA？zz？——http://welcome.cn"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br>c.去除以 ？结尾的英文单词和数字（注意这是中文问号）<br><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; s"大家好，我是一个程序员小白。I 'm so glad to introduce myself, and I’m 18 years old.   Today is 2020/01/01. It is a wonderful DAY! @HHHHello,,,#111ComeHere222...66？AA？zz？——http://welcome.cn"&gt;&gt;&gt; re.sub(r'[A-Za-z]+？', '', s)"大家好，我是一个程序员小白。I 'm so glad to introduce myself, and I’m 18 years old.   Today is 2020/01/01. It is a wonderful DAY! @HHHHello,,,#111ComeHere222...66？——http://welcome.cn"&gt;&gt;&gt; re.sub(r'[0-9A-Za-z]+？', '', s)"大家好，我是一个程序员小白。I 'm so glad to introduce myself, and I’m 18 years old.   Today is 2020/01/01. It is a wonderful DAY! @HHHHello,,,#111ComeHere222...——http://welcome.cn"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>d.去除原始字符串中的URL</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; s"大家好，我是一个程序员小白。I 'm so glad to introduce myself, and I’m 18 years old.   Today is 2020/01/01. It is a wonderful DAY! @HHHHello,,,#111ComeHere222...66？AA？zz？——http://welcome.cn"&gt;&gt;&gt; re.sub(r'http[:.]+\S+', '', s)"大家好，我是一个程序员小白。I 'm so glad to introduce myself, and I’m 18 years old.   Today is 2020/01/01. It is a wonderful DAY! @HHHHello,,,#111ComeHere222...66？AA？zz？——"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="字符串提取—提取数字"><a href="#字符串提取—提取数字" class="headerlink" title="字符串提取—提取数字"></a>字符串提取—提取数字</h4><pre class="line-numbers language-none"><code class="language-none">re.findall(r'\d+', str(string))// '\d'是正则表达式，+表示匹配多个，如果不加，就是单个的数字<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="字符串相似度比较"><a href="#字符串相似度比较" class="headerlink" title="字符串相似度比较"></a>字符串相似度比较</h4><p>python自带比较相似度的模块，difflib。比较两个字符串的模块是difflib.SequenceMatcher，使用起来很简单：</p><pre class="line-numbers language-none"><code class="language-none">import difflib def string_similar(s1, s2):    return difflib.SequenceMatcher(None, s1, s2).quick_ratio() print string_similar('爱尔眼科沪滨医院', '沪滨爱尔眼科医院')print string_similar('安定区妇幼保健站', '定西市安定区妇幼保健站')print string_similar('广州市医院', '广东省中医院')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-none"><code class="language-none">1.00.8421052631580.606060606061<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中None的位置是一个函数，用来去掉自己不想算在内的元素。比如我想把空格排除在外：</p><pre class="line-numbers language-none"><code class="language-none">seq = difflib.SequenceMatcher(lambda x:x=" ", a, b)ratio = seq.ratio()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="去掉字符串两端的引号"><a href="#去掉字符串两端的引号" class="headerlink" title="去掉字符串两端的引号"></a>去掉字符串两端的引号</h4><p>背景：有时候会出现这种情况的字符串<code>'"srting"'</code>，用type查看，是string。如果里面是整数，需要和某个整数比大小，没法直接用int强制转，需要先去掉外面那层引号</p><pre class="line-numbers language-none"><code class="language-none">方法：eval()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例子：</p><pre class="line-numbers language-none"><code class="language-none">a='"srting"'print(a)b=eval(a)print(b)//输出//"srting"//srting<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>eval()用途：<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/488f4321054b442b97e9b42813e0e565.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/a384434e602d4276b5b6da7546bc67db.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/33d9dc9d343b4111afabc96caceac82d.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/9fec5d3536be40d1ad0676f202dd95bc.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/bed4ceca7318472d959ef280c707247c.png" alt=""></p><h4 id="字符串转数字，数字转字符串"><a href="#字符串转数字，数字转字符串" class="headerlink" title="字符串转数字，数字转字符串"></a>字符串转数字，数字转字符串</h4><p>字符串str转数字:<br>float(str)<br>int(str)</p><p>数字num转字符串<br>str(num)</p><h3 id="变量转换"><a href="#变量转换" class="headerlink" title="变量转换"></a>变量转换</h3><p><strong>字符串、数字互转看字符串里面的操作</strong></p><h4 id="数字、bytes"><a href="#数字、bytes" class="headerlink" title="数字、bytes"></a>数字、bytes</h4><p>数字num转bytes:<br>需将num转为str，再利用codec的encode函数，将str转为bytes：encode(str(num))</p><p>bytes转数字:<br>int(bytes)<br>float(bytes)</p><h4 id="字符串、bytes"><a href="#字符串、bytes" class="headerlink" title="字符串、bytes"></a>字符串、bytes</h4><p>字符串转bytes:<br></p><pre class="line-numbers language-none"><code class="language-none">from codec import encode,decodeencode(str)//法二bytes(str,'UTF-8')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>bytes转字符串：<br></p><pre class="line-numbers language-none"><code class="language-none">//法一from codec import encode,decodedecode(bytes)//法二str(bytes,'UTF-8')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h3 id="循环删除元素"><a href="#循环删除元素" class="headerlink" title="循环删除元素"></a>循环删除元素</h3><p><strong>循环删除列表中元素时千万别用正序遍历，一定要用反序遍历！</strong></p><pre class="line-numbers language-none"><code class="language-none">def test(data):    for i in data:        data.remove(i)    return datadata = [1, 2, 3]print(test(data))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>面对以上代码，乍一看以为会打印出空列表，因为test函数内通过for的方法将data中的元素都删除了，其实不然，实际输出如下：<br>原列表在内存中为：<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/bdec075c9903308b5eb69f34f3b4cad1.png" alt=""><br>第一次执行到data.remove(i)时将第一个元素‘1’删除，列表变为：</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/26822bd2c18f3bb60a2028511ca0060d.png" alt=""><br>第二次执行到data.remove(i)时i为第二个元素，即‘3’，此时将‘3’删除，列表变为：</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/79bbdbbe59e7d8d84f527e62a5bb581d.png" alt=""><br>此时列表已经没有第三个元素了，即退出循环，将[2]返回。<br>如何解决这个问题呢？ 我们可以用倒序删除的方法！</p><pre class="line-numbers language-none"><code class="language-none">def test(data):    for i in data[::-1]:        data.remove(i)    return datadata = [1, 2, 3]print(test(data))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="列表相关操作"><a href="#列表相关操作" class="headerlink" title="列表相关操作"></a>列表相关操作</h3><h4 id="列表头部插入元素"><a href="#列表头部插入元素" class="headerlink" title="列表头部插入元素"></a>列表头部插入元素</h4><pre class="line-numbers language-none"><code class="language-none">names.insert(0,'Bill') //第一个参数表示索引<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="两个列表取交集"><a href="#两个列表取交集" class="headerlink" title="两个列表取交集"></a>两个列表取交集</h4><pre class="line-numbers language-none"><code class="language-none">a=[i for i in list2 if i  in list1]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-none"><code class="language-none">list(set(a).intersection(b))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="列表取并集"><a href="#列表取并集" class="headerlink" title="列表取并集"></a>列表取并集</h4><pre class="line-numbers language-none"><code class="language-none">list(set(a).union(b))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">list(set(a) | set(b))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>多个列表取并集：</strong></p><pre class="line-numbers language-none"><code class="language-none">list(set(a).intersection(b,c)) <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="列表取差集"><a href="#列表取差集" class="headerlink" title="列表取差集"></a>列表取差集</h4><pre class="line-numbers language-none"><code class="language-none">list(set(a).difference(b))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">list(set(a).difference(b,c)) # 求特定1个list(a)中有，其他list(b、c)都没有的元素"""<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="列表排序（更详细操作见文档）"><a href="#列表排序（更详细操作见文档）" class="headerlink" title="列表排序（更详细操作见文档）"></a>列表排序（更详细操作见文档）</h4><pre class="line-numbers language-none"><code class="language-none">file_list.sort(key=lambda x:int(x[9:-4]))//根据关键字来排序，lambda是一个函数的简写。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">//下面两个写法是一样的g = lambda x:x+1 def g(x):     return x+1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="列表替换元素（更详细操作见文档）"><a href="#列表替换元素（更详细操作见文档）" class="headerlink" title="列表替换元素（更详细操作见文档）"></a>列表替换元素（更详细操作见文档）</h4><p>1.直接替换</p><pre class="line-numbers language-none"><code class="language-none">//假设要把列表中的a元素替换为b//首先得到a的索引，将这个索引的值赋为blist[list.index(a)]=b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>2.条件替换<br></p><pre class="line-numbers language-none"><code class="language-none"> lst = ['1', '2', '3'] rep = ['4' if x == '2' else x for x in lst] rep['1', '4', '3']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>3.批量替换<p></p><pre class="line-numbers language-none"><code class="language-none"> lst = ['1', '2', '3', '4', '5']pattern = ['3', '4']rep = ['d' if x in pattern else x for x in lst]rep['1', '2', 'd', 'd', '5']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4.映射替换</p><pre class="line-numbers language-none"><code class="language-none"> lst = ['1', '2', '3', '4', '5'] pattern = {'3':'three', '4':'four'} rep = [pattern[x] if x in pattern else x for x in lst]rep['1', '2', 'three', 'four', '5']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="列表截取元素"><a href="#列表截取元素" class="headerlink" title="列表截取元素"></a>列表截取元素</h4><p>l=list[0:4]</p><p>注意：列表的正向索引下标是从零开始，不是1，反向索引是到-1结束，不是0</p><p>正向索引（01234…）</p><p>1.只有头下标i和冒号（代表的是从该头下标i的元素开始截取，一直到最后）</p><p>2.只有冒号尾下标i（代表的是从开始一直截取到i-1的元素）</p><p>3.头下标i，冒号和尾下标j都有（代表的是从i一直截取到j-1的元素）</p><p>例程如下：</p><pre class="line-numbers language-none"><code class="language-none">list=['123','abc',0,True]x=list[1:]y=list[:3]z=list[2:3]print(x)print(y)print['abc', 0, True]['123', 'abc', 0][0]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>反向索引（……-2-1）</p><p>1.只有头下标i和冒号（代表的是从该头下标i的元素开始截取，一直到最后）</p><p>2.只有冒号尾下标i（代表的是从开始一直截取到i-1的元素）</p><p>3.头下标i，冒号和尾下标j都有（代表的是从i一直截取到j-1的元素</p><p>例程如下：</p><pre class="line-numbers language-none"><code class="language-none">list=['123','abc',0,True]x=list[-3:]y=list[:-2]z=list[-3:-1]print(x)print(y)print(z)['abc', 0, True]['123', 'abc']['abc', 0]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>加入步长的截取：</strong></p><p>前面讲到的截取是没有带步长的。如果想隔一定元素个数去截取列表，可以选择使用带有步长的截取方式</p><p>格式：</p><p>变量[头下标:尾下标:步长]<br>例如截取第三个到第五个元素，如果隔两个步长截取的话，就会截取到元素3和元素5，元素4就被跳过了</p><h4 id="列表查找重复元素"><a href="#列表查找重复元素" class="headerlink" title="列表查找重复元素"></a>列表查找重复元素</h4><p>推荐方法二</p><pre class="line-numbers language-none"><code class="language-none">方法一：mylist = [1,2,2,2,2,3,3,3,4,4,4,4]myset = set(mylist)for item in myset:    print("the %d has found %d" %(item,mylist.count(item)))the 1 has found 1the 2 has found 4the 3 has found 3the 4 has found 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">方法二：from collections import Countera = [1, 2, 3, 4, 3, 2, "奔奔", "benben", "奔奔"]b = dict(Counter(a))## 只展示重复元素print ([key for key,value in b.items() if value &gt; 1])## 展现重复元素和重复次数print ({key:value for key,value in b.items()if value &gt; 1})//结果[2, 3, '奔奔']{2: 2, 3: 2, '奔奔': 2}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">方法三：List=[1,2,2,2,2,3,3,3,4,4,4,4] a = {}for i in List:     if List.count(i)&gt;1:         a[i] = List.count(i)   print (a)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="XML相关操作"><a href="#XML相关操作" class="headerlink" title="XML相关操作"></a>XML相关操作</h3><h4 id="创建一个XML文档"><a href="#创建一个XML文档" class="headerlink" title="创建一个XML文档"></a>创建一个XML文档</h4><pre class="line-numbers language-none"><code class="language-none">import xml.dom.minidomimport re,oslist=['a', 'b', 'str_scheme_name', 'str_limiter']doc = xml.dom.minidom.Document() root = doc.createElement('version-check')doc.appendChild(root)for i in list:    var_name = doc.createElement(i)    version=doc.createElement('version')    version.setAttribute('v','100')    version.appendChild(doc.createTextNode(i))    var_name.appendChild(version)    root.appendChild(var_name)fp = open('C:/Users/76585/Desktop/shell/cfdname2/tow.xml', 'w')doc.writexml(fp, indent='\t', addindent='\t', newl='\n', encoding="utf-8")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="对现有XML文档进行修改"><a href="#对现有XML文档进行修改" class="headerlink" title="对现有XML文档进行修改"></a>对现有XML文档进行修改</h4><pre class="line-numbers language-none"><code class="language-none">tree=ET.parse('C:/Users/76585/Desktop/shell/cfdname2/tow.xml')         root=tree.getroot()// b是一个列表         for i in b:             newnode=ET.Element(i)             version=ET.Element('version')             version.attrib={"v":end}             version.text=i             newnode.append(version)             # newnode.text=end               root.append(newnode)             tree.write('C:/Users/76585/Desktop/shell/cfdname2/tow.xml')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><h4 id="特殊的去首尾空格方法"><a href="#特殊的去首尾空格方法" class="headerlink" title="特殊的去首尾空格方法"></a>特殊的去首尾空格方法</h4><p>strip是trim掉字符串两边的空格。<br>lstrip, trim掉左边的空格<br>rstrip, trim掉右边的空格</p><pre class="line-numbers language-none"><code class="language-none">theString = ' https://mp.csdn.net/postlist ' print theString.strip()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="判断情况总结"><a href="#判断情况总结" class="headerlink" title="判断情况总结"></a>判断情况总结</h3><h4 id="判断目录下的空文件夹并删除"><a href="#判断目录下的空文件夹并删除" class="headerlink" title="判断目录下的空文件夹并删除"></a>判断目录下的空文件夹并删除</h4><pre class="line-numbers language-none"><code class="language-none">## 导入osimport os## 让用户自行输入路径path=input('请输入文件目录路径')## 获取当前目录下的所有文件夹名称  得到的是一个列表folders=os.listdir(path)## # 遍历列表for folder in folders:    # 将上级路径path与文件夹名称folder拼接出文件夹的路径    folder2=os.listdir(path+'\\'+folder)    print(folder2)    # 若文件夹为空    if folder2==[]:        # 则打印此空文件的名称        print(folder)        # 并将此空文件夹删除        os.rmdir(path+'\\'+folder)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="判断文件内容为空"><a href="#判断文件内容为空" class="headerlink" title="判断文件内容为空"></a>判断文件内容为空</h4><p><strong>方法： size = os.path.getsize(file_path)</strong></p><ol><li>结果：如果 size == 0，则文件内容为空；</li><li>上述的 file_path 为需要判断大小的文件的存放路径。</li></ol><pre class="line-numbers language-none"><code class="language-none">if os.path.getsize(file_path) == 0:print('文件内容为空')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="变量类型判断"><a href="#变量类型判断" class="headerlink" title="变量类型判断"></a>变量类型判断</h4><blockquote><p>1、isinstance(参数1,参数2)<br><br><br>描述：该函数用来判断一个变量（参数1）是否是已知的变量类型(参数2) 类似于type()</p><p>参数1：变量</p><p>参数2：可以是直接或间接类名、基本类型或者由它们组成的元组。</p><p>返回值: 如果对象的类型与参数二的类型（classinfo）相同则返回 True，否则返回 False</p></blockquote><p><strong>方法2</strong><br></p><pre class="line-numbers language-none"><code class="language-none">type(num)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p><h3 id="深拷贝—deep-copy"><a href="#深拷贝—deep-copy" class="headerlink" title="深拷贝—deep copy"></a>深拷贝—deep copy</h3><p>背景：</p><pre class="line-numbers language-none"><code class="language-none">dict_min['name']=new_line[1]dict_mid[new_line[1]]=dict_min<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上面这段代码中，newline[1]发生变化时，dict_min发生变化，从而导致dict_mid受到影响。具体的效果<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/27eafe4c3413473b8de9f92567056d70.png" alt=""><br>name的值会依次被后面的值覆盖，但我们不希望之前的收到影响。</p><p>解决办法：</p><pre class="line-numbers language-none"><code class="language-none">dict_min['name']=new_line[1]dict_tmp=copy.deepcopy(dict_min)      dict_mid[new_line[1]]=dict_tmp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>看下深拷贝的例子：</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; import copy&gt;&gt;&gt; origin = [1, 2, [3, 4]]##origin 里边有三个元素：1， 2，[3, 4]&gt;&gt;&gt; cop1 = copy.copy(origin)&gt;&gt;&gt; cop2 = copy.deepcopy(origin)&gt;&gt;&gt; cop1 == cop2True&gt;&gt;&gt; cop1 is cop2False ##cop1 和 cop2 看上去相同，但已不再是同一个object&gt;&gt;&gt; origin[2][0] = "hey!" &gt;&gt;&gt; origin[1, 2, ['hey!', 4]]&gt;&gt;&gt; cop1[1, 2, ['hey!', 4]]&gt;&gt;&gt; cop2[1, 2, [3, 4]]##把origin内的子list [3, 4] 改掉了一个元素，观察 cop1 和 cop2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到 cop1，也就是 shallow copy 跟着 origin 改变了。而 cop2 ，也就是 deep copy 并没有变。</p><p>似乎 deep copy 更加符合我们对「复制」的直觉定义: 一旦复制出来了，就应该是独立的了。如果我们想要的是一个字面意义的「copy」，那就直接用 deep_copy 即可。</p><p>那么为什么会有 shallow copy 这样的「假」 copy 存在呢？ 这就是有意思的地方了。</p><p><strong>python的数据存储方式</strong><br>Python 存储变量的方法跟其他 OOP 语言不同。它与其说是把值赋给变量，不如说是给变量建立了一个到具体值的 reference。</p><p>当在 Python 中 a = something 应该理解为给 something 贴上了一个标签 a。当再赋值给 a 的时候，就好象把 a 这个标签从原来的 something 上拿下来，贴到其他对象上，建立新的 reference。 这就解释了一些 Python 中可能遇到的诡异情况：</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt; a = [1, 2, 3]&gt;&gt;&gt; b = a&gt;&gt;&gt; a = [4, 5, 6] //赋新的值给 a&gt;&gt;&gt; a[4, 5, 6]&gt;&gt;&gt; b[1, 2, 3]## a 的值改变后，b 并没有随着 a 变&gt;&gt;&gt; a = [1, 2, 3]&gt;&gt;&gt; b = a&gt;&gt;&gt; a[0], a[1], a[2] = 4, 5, 6 //改变原来 list 中的元素&gt;&gt;&gt; a[4, 5, 6]&gt;&gt;&gt; b[4, 5, 6]## a 的值改变后，b 随着 a 变了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面两段代码中，a 的值都发生了变化。区别在于，第一段代码中是直接赋给了 a 新的值（从 [1, 2, 3] 变为 [4, 5, 6]）；而第二段则是把 list 中每个元素分别改变。</p><p>而对 b 的影响则是不同的，一个没有让 b 的值发生改变，另一个变了。怎么用上边的道理来解释这个诡异的不同呢？</p><p>首次把 [1, 2, 3] 看成一个物品。a = [1, 2, 3] 就相当于给这个物品上贴上 a 这个标签。而 b = a 就是给这个物品又贴上了一个 b 的标签。</p><p>第一种情况：</p><p>a = [4, 5, 6] 就相当于把 a 标签从 [1 ,2, 3] 上撕下来，贴到了 [4, 5, 6] 上。</p><p>在这个过程中，[1, 2, 3] 这个物品并没有消失。 b 自始至终都好好的贴在 [1, 2, 3] 上，既然这个 reference 也没有改变过。 b 的值自然不变。</p><p>第二种情况：</p><p>a[0], a[1], a[2] = 4, 5, 6 则是直接改变了 [1, 2, 3] 这个物品本身。把它内部的每一部分都重新改装了一下。内部改装完毕后，[1, 2, 3] 本身变成了 [4, 5, 6]。</p><p>而在此过程当中，a 和 b 都没有动，他们还贴在那个物品上。因此自然 a b 的值都变成了 [4, 5, 6]。</p><p>搞明白这个之后就要问了，<strong>对于一个复杂对象的浅copy，在copy的时候到底发生了什么？</strong><br>再看一段代码：</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; import copy&gt;&gt;&gt; origin = [1, 2, [3, 4]]##origin 里边有三个元素：1， 2，[3, 4]&gt;&gt;&gt; cop1 = copy.copy(origin)&gt;&gt;&gt; cop2 = copy.deepcopy(origin)&gt;&gt;&gt; cop1 == cop2True&gt;&gt;&gt; cop1 is cop2False ##cop1 和 cop2 看上去相同，但已不再是同一个object&gt;&gt;&gt; origin[2][0] = "hey!" &gt;&gt;&gt; origin[1, 2, ['hey!', 4]]&gt;&gt;&gt; cop1[1, 2, ['hey!', 4]]&gt;&gt;&gt; cop2[1, 2, [3, 4]]##把origin内的子list [3, 4] 改掉了一个元素，观察 cop1 和 cop2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>学过docker的人应该对镜像这个概念不陌生，我们可以把镜像的概念套用在copy上面。</p><p>copy对于一个复杂对象的子对象并不会完全复制，什么是复杂对象的子对象呢？就比如序列里的嵌套序列，字典里的嵌套序列等都是复杂对象的子对象。对于子对象，python会把它当作一个公共镜像存储起来，所有对他的复制都被当成一个引用，所以说当其中一个引用将镜像改变了之后另一个引用使用镜像的时候镜像已经被改变了。</p><p>所以说看这里的origin[2]，也就是 [3, 4] 这个 list。根据 shallow copy 的定义，在 cop1[2] 指向的是同一个 list [3, 4]。那么，如果这里我们改变了这个 list，就会导致 origin 和 cop1 同时改变。这就是为什么上边 origin[2][0] = “hey!” 之后，cop1 也随之变成了 [1, 2, [‘hey!’, 4]]。</p><p>deepcopy的时候会将复杂对象的每一层复制一个单独的个体出来。<br>这时候的 origin[2] 和 cop2[2] 虽然值都等于 [3, 4]，但已经不是同一个 list了。即我们寻常意义上的复制。</p><h3 id="json相关操作"><a href="#json相关操作" class="headerlink" title="json相关操作"></a>json相关操作</h3><p><strong>dumps和dump 序列化方法</strong><br>dumps只完成了序列化为str，<br>dump必须传文件描述符，将序列化的str保存到文件中<br>下面使用实际的例子依次介绍：</p><pre class="line-numbers language-none"><code class="language-none">import jsonkey={ "people": [{ "Name": "Brett", "名字":"McLaughlin", '1': 1 },{ "Name": "Jason", "名字":"Hunter", '2': 1},{ "Name": "Elliotte", "名字":"Harold", '3': 1 }]}print(json.dumps(key,sort_keys=True,indent =4,ensure_ascii=False))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出效果如下：</p><pre class="line-numbers language-none"><code class="language-none">{    "people": [        {            "1": 1,            "Name": "Brett",            "名字": "McLaughlin"        },        {            "2": 1,            "Name": "Jason",            "名字": "Hunter"        },        {            "3": 1,            "Name": "Elliotte",            "名字": "Harold"        }    ]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>非常简便的将所需要的数据流畅的保存下来了，下面我们介绍相关的参数：<br>（1）indent=4：缩进，python中默认缩进是4个，前端和css默认是2个<br>（2）sort_keys=True/False：以key为标准，按key的a-z字母排序<br>（3）separators=(‘，’，‘：’)：减少空格，增加传输速度，参数是要保留的标点符号，json只保留 逗号和冒号就行。<br>下面我们将其保存在json的文件中：</p><pre class="line-numbers language-none"><code class="language-none">with open("E:\\测试.json", "w+",encoding='utf-8_sig')as f:    json.dump(key,f,sort_keys=True,indent =4,ensure_ascii=False) //另外一种写法f= open("E:\\测试.json", "w",encoding='utf-8_sig')  //可能会报encoding的相关错，去掉就好<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>loads和load 反序列化方法</strong><br>loads 只完成了反序列化，<br>load 只接收文件描述符，完成了读取文件和反序列化<br>同样用上述例子介绍：</p><pre class="line-numbers language-none"><code class="language-none">key_1=json.dumps(key,sort_keys=True,indent =4,ensure_ascii=False)print(json.loads(key_1))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>输出为：</p><pre class="line-numbers language-none"><code class="language-none">{'people': [{'1': 1, 'Name': 'Brett', '名字': 'McLaughlin'}, {'2': 1, 'Name': 'Jason', '名字': 'Hunter'}, {'3': 1, 'Name': 'Elliotte', '名字': 'Harold'}]}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>即将其反输出<br>下面读取json文件也是一样的：</p><pre class="line-numbers language-none"><code class="language-none">with open("E:\\测试.json", "r+",encoding='utf-8_sig')as f:    data=json.load(f)print(data)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>特别注意：</strong><br><strong><em>如果打开的文件为空，那么json.load(f)会报错，里面必须有内容才能用这个打开</em></strong></p><h3 id="字典相关操作"><a href="#字典相关操作" class="headerlink" title="字典相关操作"></a>字典相关操作</h3><h4 id="如何检查字典-Python-中是否存在某个值"><a href="#如何检查字典-Python-中是否存在某个值" class="headerlink" title="如何检查字典(Python)中是否存在某个值"></a>如何检查字典(Python)中是否存在某个值</h4><p>d = {‘1’: ‘one’, ‘3’: ‘three’, ‘2’: ‘two’, ‘5’: ‘five’, ‘4’: ‘four’}</p><p>我需要一种方法来找出这个字典中是否存在诸如“one”或“two”这样的值。</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; d = {'1': 'one', '3': 'three', '2': 'two', '5': 'five', '4': 'four'}&gt;&gt;&gt; 'one' in d.values()True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="强制结束程序或暂停程序"><a href="#强制结束程序或暂停程序" class="headerlink" title="强制结束程序或暂停程序"></a>强制结束程序或暂停程序</h3><pre class="line-numbers language-none"><code class="language-none">import syssys.exit()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">##暂停程序input()用法：直接在欲等待处输入input()即可。特点：优点：不需要借助模块，执行到此处阻塞等待人工输入。缺点：程序结束时候需要强制结束或者在控制台输入值。time.sleep()用法：导入time模块；在欲等待处输入time.sleep(time)（time为数字，表示秒）即可。特点：优点：动态等待程序执行完毕，不需要强行终止，等待时间可调。缺点：需要导入模块，等待规定时间结束后便继续往下执行。os.system("pause")用法：导入os模块；在欲等待处输入os.system("pause")即可。特点：优点：不必强行终止；不必等待时间，可自由按下enter继续。缺点：导入模块，执行系统命令。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python执行shell脚本"><a href="#python执行shell脚本" class="headerlink" title="python执行shell脚本"></a>python执行shell脚本</h3><h4 id="os-system-“command”"><a href="#os-system-“command”" class="headerlink" title="os.system(“command”)"></a>os.system(“command”)</h4><p>这是python自带的执行shell命令的方法，其中最后一个0是这个命令的返回值，为0表示命令执行成功。但是使用system()无法将执行的结果保存起来。<br></p><pre class="line-numbers language-none"><code class="language-none">import osprint(os.system("touch a.txt")) //需要用引号将命令括起来<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="os-popen-“command”-方法"><a href="#os-popen-“command”-方法" class="headerlink" title="os.popen(“command”)方法"></a>os.popen(“command”)方法</h4><p>上面的os.system()方法没办法查看shell命令返回的结果，通过 os.popen() 返回的是 file read 的对象，对其进行读取 read() 的操作可以看到执行的输出。</p><p>注意：os.popen() 返回的是一个文件对象f哦！！！<br></p><pre class="line-numbers language-none"><code class="language-none">import osf=os.popen("ls -l")  # 返回的是一个文件对象print(f.read())            # 通过文件的read()读取所返回的内容'''total 4-rw-rw-r-- 1 tengjian tengjian  0 11月  5 09:32 a.txt-rw-rw-r-- 1 tengjian tengjian 81 11月  5 09:32 python_shell.py'''<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><strong>对于有返回值的shell命令，建议使用 os.popen()<br>对于没有返回值的shell命令，建议使用 os.system()</strong><p></p><h3 id="在for循环体内修改i值"><a href="#在for循环体内修改i值" class="headerlink" title="在for循环体内修改i值"></a>在for循环体内修改i值</h3><p><strong>场景：在循环体内判断条件发生时，重新执行执行当前循环体（保留当前i值）<br>常规：类似的需求一般会在循环体里写一个 if 加上continue / break<br>实际：但是在for循环内修改i值，只会对当前一次的循环体内有效</strong></p><pre class="line-numbers language-none"><code class="language-none">for i in range(1,5):    print("i in use:", i)    i = 20    print("i modified:", i)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">//结果i in use: 1i modified: 20i in use: 2i modified: 20i in use: 3i modified: 20i in use: 4i modified: 20<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>原理：想想 in 操作符的概念，应该就能明白了<br>解读：每次for循环，相当于是从range(1,5)这个类似list里做取数的动作，修改的只是取出的值，并不是取数来源的值<br>解决：使用 while 替换 for</strong></p><pre class="line-numbers language-none"><code class="language-none">i = 1while i &lt; 6:    print(i)    if(i % 2 == 0):        i += 2    i += 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">//结果125<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="修改文件"><a href="#修改文件" class="headerlink" title="修改文件"></a>修改文件</h3><pre class="line-numbers language-none"><code class="language-none">##!/usr/bin/env python## -*- coding: utf-8 -*-## @Date    : 2019-04-25 14:35:58## @Author  : 迷风小白def changetext(a,b): with open('test','r',encoding='utf-8') as f:  lines=[] # 创建了一个空列表，里面没有元素  for line in f.readlines():   if line!='\n':    lines.append(line)  f.close() with open('test','w',encoding='utf-8') as f:  for line in lines:   if a in line:    line = b     f.write('%s\n' %line) //关键代码   else:    f.write('%s' %line)   //关键代码changetext('pig','cow')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="windows切换python2和python3"><a href="#windows切换python2和python3" class="headerlink" title="windows切换python2和python3"></a>windows切换python2和python3</h3><p><a href="https://www.zhihu.com/question/21653286/answer/95532074">同时装了Python3和Python2，怎么用pip？ - 知乎</a></p><p>已经安装了python2和python3，且Python3（&gt;=3.3）；运行python2 使用<code>py -2 hello.py</code>；运行python3 使用<code>py -3 hello.py</code></p><p><strong>去掉参数 -2/-3</strong></p><p>每次运行都要加入参数-2/-3还是比较麻烦，所以py.exe这个启动器允许你在代码中加入说明，表明这个文件应该是由python2解释运行，还是由python3解释运行。说明的方法是在代码文件的最开始加入一行</p><pre class="line-numbers language-none"><code class="language-none">#! python2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-none"><code class="language-none">#! python3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>分别表示该代码文件使用Python2或者Python3解释运行。这样，运行的时候你的命令就可以简化为<br></p><pre class="line-numbers language-none"><code class="language-none">py hello.py<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p><p><strong>如何使用pip</strong></p><pre class="line-numbers language-none"><code class="language-none">py -2 -m pip install XXXX<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>-2 还是表示使用 Python2，-m pip 表示运行 pip 模块，也就是运行pip命令了。如果是为Python3安装软件，那么命令类似的变成</p><pre class="line-numbers language-none"><code class="language-none">py -3 -m pip install XXXX<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="from-import和import的区别"><a href="#from-import和import的区别" class="headerlink" title="from import和import的区别"></a>from import和import的区别</h3><pre class="line-numbers language-none"><code class="language-none">import Module # 引入模块from Module import Other # 引入模块中的类、函数或者变量from Module import * # 引入模块中的所有‘公开’成员<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><br></p><p><strong>举例</strong></p><pre class="line-numbers language-none"><code class="language-none">from datetime import datetime##引入 datetime 模块中的 datetime 类,然后就可以通过datetime这个类调用now() 方法了##即,内部可以通过datetime.now()来调用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">import datetime##引入datetime 模块,然后通过这个模块来调用模块中的类datetime和类datetime中的方法now()##即：内部可以通过datetime.datetime.now()来调用也就是说，有一个模块datetime,这个模块中有一个类datetime,在这个类中有一个方法now()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端框架</title>
      <link href="/posts/15854/"/>
      <url>/posts/15854/</url>
      
        <content type="html"><![CDATA[<h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><h3 id="创建react项目"><a href="#创建react项目" class="headerlink" title="创建react项目"></a>创建react项目</h3><pre class="line-numbers language-none"><code class="language-none">npm install create-react-appnpx create-react-app myapp --template typescripe<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果create-react-app是全局安装的，那么前面的npx/npm可以省略</p><h3 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h3><p>重点关注三个文件：</p><pre class="line-numbers language-none"><code class="language-none">src/App.js //实现 React 组件src/index.js // React 世界的入口public/index.html //挂载的页面<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>1.index.html</p><pre class="line-numbers language-none"><code class="language-none">这个是一个模板文件，里面有过id为root的div标签，会被index.js文件中的JSX替换这个DOM节点。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/c8637d56e86b4868a275d4a01a1db9c1.png" alt=""><br>2.index.js</p><pre class="line-numbers language-none"><code class="language-none">关键就是这个ReactDOM.render()简单来说，ReactDOM.render() 会使用你的 JSX 来替换你的 HTML 中的一个 DOM 节点。这样你就可以很容易地把 React 集成到每一个其他的应用中。ReactDOM.render() 可以在你的应用中被多次使用。你可以在多个地方使用它来加载简单的 JSX 语法、单个 React 组件、多个 React 组件或者整个应用。但是在一个纯 React 的应用中，你只会使用一次用来加载你的整个组件树。ReactDOM.render() 有两个传入参数。第一个是准备渲染的 JSX。第二个参数指定了 React应用在你的 HTML 中的放置的位置。这个位置是一个 id='root' 的元素。你可以在文件public/index.html 中找到这个 id 属性<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/5a6381d4f99b4a56b00f07e3ee28f9c7.png" alt=""><br>3.App.js<br>在inde.js文件里面，ReactDOM.render() 总会很好地渲染你的 App 组件。一般来说，某个组件叫xxx，那么他的代码就叫xxx.js。要想知道页面被渲染成什么样，就看看里面内容。<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/378a772ce66d41e9b70b563c6319a470.png" alt=""></p><h3 id="react-router-dom路由"><a href="#react-router-dom路由" class="headerlink" title="react-router-dom路由"></a>react-router-dom路由</h3><p><strong>1.这是react-router-dom5的用法，现在默认安装的是6，下面会写6的语法</strong></p><p><a href="https://www.jianshu.com/p/8954e9fb0c7e">原文章链接</a><br>来源：简书</p><p><strong>使用背景：使用React构建的单页面应用，要想实现页面间的跳转，首先想到的就是使用路由。在React中，常用的有两个包可以实现这个需求，那就是react-router和react-router-dom。本文主要针对react-router-dom进行说明。</strong></p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>首先进入项目目录，使用npm安装react-router-dom：</p><pre class="line-numbers language-none"><code class="language-none">npm install react-router-dom --save-dev //这里可以使用cnpm代替npm命令；//--save-dev 标记表示该 node 包只是用作开发环境的一部分，并不会被作为你产品代码的一部分发布。哪种 node 包适用这个场景呢？设想你需要一些 node 包辅助测试你的应用，然后需要通过 npm 来安装这些包，但是不希望他们混入产品代码里面。测试过程应该只会发生在开发阶段，而不是在线上部署运行的时候。因为那个时候已经用不到测试代码了，你的应用应该已经被测试完而且可以被你的用户使用了。这可能是你唯一的使用 --save-dev的场景。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><p>然后我们新建两个页面，分别命名为“home”和“detail”。在页面中编写如下代码：<br>detail.js<br></p><pre class="line-numbers language-none"><code class="language-none">import React from 'react';export default class Home extends React.Component {    render() {        return (            &lt;div&gt;                &lt;a&gt;去detail&lt;/a&gt;            &lt;/div&gt;        )    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>home.js<p></p><pre class="line-numbers language-none"><code class="language-none">import React from 'react';export default class Home extends React.Component {    render() {        return (            &lt;div&gt;                &lt;a&gt;回到home&lt;/a&gt;            &lt;/div&gt;        )    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后再新建一个路由组件，命名为“Router.js”，并编写如下代码：</p><pre class="line-numbers language-none"><code class="language-none">import React from 'react';import {HashRouter, Route, Switch} from 'react-router-dom';import Home from '../home';import Detail from '../detail';const BasicRoute = () =&gt; (    &lt;HashRouter&gt;        &lt;Switch&gt;            &lt;Route exact path="/" component={Home}/&gt;            &lt;Route exact path="/detail" component={Detail}/&gt;        &lt;/Switch&gt;    &lt;/HashRouter&gt;);export default BasicRoute;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上代码定义了一个纯路由组件，将两个页面组件Home和Detail使用Route组件包裹，外面套用Switch作路由匹配，当路由组件检测到地址栏与Route的path匹配时，就会自动加载响应的页面。<br>然后在入口文件中——我这里指定的是index.js——编写如下代码：</p><pre class="line-numbers language-none"><code class="language-none">import React from 'react';import ReactDOM from 'react-dom';import Router from './router/router';ReactDOM.render(  &lt;Router/&gt;,  document.getElementById('root'));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里相当于向页面返回了一个路由组件。我们先运行项目看一下效果，在地址栏输入“<a href="http://localhost:3000/#/”：">http://localhost:3000/#/”：</a><br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/37aee935c7534aa39a98acfcf884e278.png" alt=""></p><p>输入“<a href="http://localhost:3000/#/detail”：">http://localhost:3000/#/detail”：</a><br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/891f1a191f764e2295b057870300cd76.png" alt=""></p><p><strong>通过a标签跳转</strong><br>可以看到其实路由已经开始工作了，接下来我们再来做页面间的跳转。在home.js和detail.js中，我们修改如下代码：</p><pre class="line-numbers language-none"><code class="language-none">import React from 'react';    export default class Home extends React.Component {        render() {            return (                &lt;div&gt;                &lt;a href='#/detail'&gt;去detail&lt;/a&gt;            &lt;/div&gt;        )    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>home.js</p><pre class="line-numbers language-none"><code class="language-none">import React from 'react';export default class Home extends React.Component {    render() {        return (            &lt;div&gt;                &lt;a href='#/'&gt;回到home&lt;/a&gt;            &lt;/div&gt;        )    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重新打包运行，在浏览器地址栏输入“<a href="http://localhost:3000/”，试试看页面能否正常跳转。如果不能，请按步骤一步一步检查代码是否有误。以上是使用a标签的href进行页面间跳转，此外react-router-dom还提供了通过函数的方式跳转页面。">http://localhost:3000/”，试试看页面能否正常跳转。如果不能，请按步骤一步一步检查代码是否有误。以上是使用a标签的href进行页面间跳转，此外react-router-dom还提供了通过函数的方式跳转页面。</a></p><p><strong>通过函数跳转</strong></p><p>首先我们需要修改router.js中的两处代码：<br>然后在home.js中：<br>import React from ‘react’;<br></p><pre class="line-numbers language-none"><code class="language-none">...import {HashRouter, Route, Switch, hashHistory} from 'react-router-dom';...&lt;HashRouter history={hashHistory}&gt;...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>在a标签下面添加一个按钮并加上onClick事件，通过this.props.history.push这个函数跳转到detail页面。在路由组件中加入的代码就是将history这个对象注册到组件的props中去，然后就可以在子组件中通过props调用history的push方法跳转页面。<p></p><p>很多场景下，我们还需要在页面跳转的同时传递参数，在react-router-dom中，同样提供了两种方式进行传参。</p><p>链接：<a href="https://www.jianshu.com/p/8954e9fb0c7e">https://www.jianshu.com/p/8954e9fb0c7e</a><br>来源：简书</p><pre class="line-numbers language-none"><code class="language-none">export default class Home extends React.Component {    constructor(props) {        super(props);    }            render() {        return (            &lt;div&gt;                &lt;a href='#/detail'&gt;去detail&lt;/a&gt;                &lt;button onClick={() =&gt; this.props.history.push('detail')}&gt;通过函数跳转&lt;/button&gt;            &lt;/div&gt;        )    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>url传参</strong><br>在router.js中，修改如下代码：</p><pre class="line-numbers language-none"><code class="language-none">...&lt;Route exact path="/detail/:id" component={Detail}/&gt;...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后修改detail.js，使用this.props.match.params获取url传过来的参数：</p><pre class="line-numbers language-none"><code class="language-none">...componentDidMount() {    console.log(this.props.match.params);}...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在地址栏输入“<a href="http://localhost:3000/#/detail/3”，打开控制台：">http://localhost:3000/#/detail/3”，打开控制台：</a><br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/d803a9af4817410c8649c09bbf06cdea.png" alt=""><br>可以看到传过去的id=3已经被获取到了。react-router-dom就是通过“/:”去匹配url传递的参数。</p><p><strong>隐式传参</strong><br>此外还可以通过push函数隐式传参。</p><p>修改home.js代码如下：</p><pre class="line-numbers language-none"><code class="language-none">import React from 'react';export default class Home extends React.Component {    constructor(props) {        super(props);    }            render() {        return (            &lt;div&gt;                &lt;a href='#/detail/3'&gt;去detail&lt;/a&gt;                    &lt;button onClick={() =&gt; this.props.history.push({                        pathname: '/detail',                        state: {                            id: 3                        }                })}&gt;通过函数跳转&lt;/button&gt;            &lt;/div&gt;        )    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在detail.js中，就可以使用this.props.history.location.state获取home传过来的参数：</p><pre class="line-numbers language-none"><code class="language-none">componentDidMount() {    //console.log(this.props.match.params);    console.log(this.props.history.location.state);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>跳转后打开控制台可以看到参数被打印：<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/972fb5894c804e8c9203fc6d304cf0c5.png" alt=""><br><strong>嵌套路由</strong></p><p>嵌套路由的适用场景还是比较多的，接下来就来介绍一下实现方法。<br>首先在Vue中实现嵌套路由，只需要将配置文件写成children嵌套，然后在需要展示子路由的位置加上<router-view>&lt;/router-view&gt;即可。React中应该如何实现呢？其实原理和Vue类似，只需要在父级路由中包含子路由即可。这样说可能很多同学会一头雾水，直接上代码（不使用上面的例子）：</router-view></p><p>首先定义父级组件MainLayout</p><pre class="line-numbers language-none"><code class="language-none">import React from 'react';import './MainLayout.scss';const { Header, Sider, Content } = Layout;export default class MainLayout extends React.Component {    render() {        return (            &lt;div className='main-layout'&gt;                父组件            &lt;/div&gt;        );    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后定义子组件Home：</p><pre class="line-numbers language-none"><code class="language-none">import React, {useState} from 'react';import {Modal, Select} from "antd";import {connect} from 'react-redux';import {addCount} from '../../servers/home';function Home(props) {    const [visible, setVisible] = useState(false);    const {countNum: {count}, dispatch} = props;    return (        &lt;div&gt;            子组件        &lt;/div&gt;    )}export default Home;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后将它们添加进路由router.js，并且关联父子关系：</p><pre class="line-numbers language-none"><code class="language-none">import React from 'react';import {HashRouter, Route, Switch} from "react-router-dom";import Home from '../pages/Home/Home';import MainLayout from '../layout/MainLayout';const BasicRouter = () =&gt; (    &lt;HashRouter&gt;        &lt;Switch&gt;            &lt;Route path="/index" component={                &lt;MainLayout&gt;                  &lt;Route exact path="/" component={Home}/&gt;                  &lt;Route exact path="/index" component={Home}/&gt;                  &lt;Route path="/index/home" component={Home}/&gt;                &lt;/MainLayout&gt;             }/&gt;        &lt;/Switch&gt;    &lt;/HashRouter&gt;);export default BasicRouter;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在MainLayout中，修改如下代码：</p><pre class="line-numbers language-none"><code class="language-none">import React from 'react';import './MainLayout.scss';const { Header, Sider, Content } = Layout;export default class MainLayout extends React.Component {    render() {        return (            &lt;div className='main-layout'&gt;                {this.props.children}            &lt;/div&gt;        );    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如此，一个嵌套路由就完成了。</p><p><strong>2.react-router-dom版本6语法</strong></p><p>&lt; Switch &gt;  -&gt;    &lt; Routes &gt;<br>component={hello}  -&gt; element={&lt; hello /&gt;}</p><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>组件，从概念上类似于 JavaScript 函数。它接受任意的入参（即 “props”），并返回用于描述页面展示内容的 React 元素。</p><p>1.函数组件<br>定义组件最简单的方式就是编写 JavaScript 函数：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">Welcome</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>Hello<span class="token punctuation">,</span> <span class="token punctuation">{</span>props<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>该函数是一个有效的 React 组件，因为它接收唯一带有数据的 “props”（代表属性）对象与并返回一个 React 元素。这类组件被称为“函数组件”，因为它本质上就是 JavaScript 函数。</p><p>2.class组件</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">Welcome</span> <span class="token keyword">extends</span> <span class="token class-name">React</span><span class="token punctuation">.</span>Component <span class="token punctuation">{</span>  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>Hello<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述两个组件在 React 里是等效的。</p><h3 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h3><p><a href="https://www.jianshu.com/p/1b32ceb8295c">原文</a></p><p>组件从概念上看就是一个函数，可以接受一个参数作为输入值，这个参数就是props，所以可以把props理解为从外部传入组件内部的数据。由于React是单向数据流，所以props基本上也就是从服父级组件向子组件传递的数据。</p><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">Hello</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>hello world  <span class="token operator">+</span>  <span class="token punctuation">{</span>props<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span><span class="token punctuation">}</span>React<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>    <span class="token operator">&lt;</span>Hello name<span class="token operator">=</span><span class="token string">"zhangshan"</span><span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>    document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>‘&lt;’ Hello name=”zhangshan”/‘&gt;’,是什么意思？</p><p>为什么我们在方法里面获取的数据是<code>{props.name}</code>里面获取到我们传递的name的？</p><p><strong>其实就是我们把参数name=”zhangshan” 放在了props里，props这个东西不需要我们定义，这个是react里面就存在的一个东西，专门用来存放我们的要传递的参数的。</strong></p><p>但是在我们的<code>function Hello(props)</code>里面，必须显式地传入我们的props。</p><p>那如果要传递很多参数呢？</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">Hello</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>hello world  <span class="token operator">+</span>  <span class="token punctuation">{</span>props<span class="token punctuation">.</span>name<span class="token punctuation">}</span> <span class="token operator">+</span> <span class="token punctuation">{</span>props<span class="token punctuation">.</span>id<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span><span class="token punctuation">}</span>React<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>    <span class="token operator">&lt;</span>Hello name<span class="token operator">=</span><span class="token string">"zhangshan"</span> id<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">12</span><span class="token punctuation">}</span><span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>    document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>相当于，我们把name和id都放入了props里面。props里面到底能够容纳多少的参数，目前我们不考虑。</p><p>但是我们发现id={12}，这个参数的样式跟到我们的name=”zhangshan”不一样，为什么呢？</p><p><strong>id我们需要传入的是一个数字，所以我们不能用分号，如果我们用分号的话id=“12”，那么12就是一个字符串了。</strong></p><p>最后还有一个很重要的点：<code>props是只读的</code></p><p>什么是只读呢？</p><p>意思是任何修改props里面参数的操作，都是错误的！例如下面：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">Hello</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">{</span>    props<span class="token punctuation">.</span>name<span class="token operator">=</span><span class="token string">"lisi"</span>    <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>hello world  <span class="token operator">+</span>  <span class="token punctuation">{</span>props<span class="token punctuation">.</span>name<span class="token punctuation">}</span> <span class="token operator">+</span> <span class="token punctuation">{</span>props<span class="token punctuation">.</span>id<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="只读性"><a href="#只读性" class="headerlink" title="只读性"></a>只读性</h4><p>props经常被用作渲染组件和初始化状态，当一个组件被实例化之后，它的props是只读的，不可改变的。如果props在渲染过程中可以被改变，会导致这个组件显示的形态变得不可预测。只有通过父组件重新渲染的方式才可以把新的props传入组件中</p><h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><p>在组件中，我们最好为props中的参数设置一个defaultProps，并且制定它的类型。比如，这样：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">Item<span class="token punctuation">.</span>defaultProps <span class="token operator">=</span> <span class="token punctuation">{</span>  item<span class="token operator">:</span> <span class="token string">'Hello Props'</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Item<span class="token punctuation">.</span>propTypes <span class="token operator">=</span> <span class="token punctuation">{</span>  item<span class="token operator">:</span> PropTypes<span class="token punctuation">.</span><span class="token builtin">string</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关于propTypes，可以声明为以下几种类型：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">optionalArray<span class="token operator">:</span> PropTypes<span class="token punctuation">.</span>array<span class="token punctuation">,</span>optionalBool<span class="token operator">:</span> PropTypes<span class="token punctuation">.</span>bool<span class="token punctuation">,</span>optionalFunc<span class="token operator">:</span> PropTypes<span class="token punctuation">.</span>func<span class="token punctuation">,</span>optionalNumber<span class="token operator">:</span> PropTypes<span class="token punctuation">.</span><span class="token builtin">number</span><span class="token punctuation">,</span>optionalObject<span class="token operator">:</span> PropTypes<span class="token punctuation">.</span>object<span class="token punctuation">,</span>optionalString<span class="token operator">:</span> PropTypes<span class="token punctuation">.</span><span class="token builtin">string</span><span class="token punctuation">,</span>optionalSymbol<span class="token operator">:</span> PropTypes<span class="token punctuation">.</span><span class="token builtin">symbol</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，bool和func是简写。<br><a href="https://link.segmentfault.com/?enc=XZBU0TmiI6SKqfvrMkCdjw==.Sre3YLwtIWGHuDErH33uREve5dWfkwURRNAKvKUhsV/VWVJDhYMqXAyqrVb8z42nC0Ov/X24XCdEp4w8kBAeuFpnjcoVi7lyjo7s1ldlwUY=">复杂数据类型</a></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>props是一个从外部传进组件的参数，主要作为就是从父组件向子组件传递数据，它具有可读性和不变性，只能通过外部组件主动传入新的props来重新渲染子组件，否则子组件的props以及展现形式不会改变。</p><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p><a href="https://segmentfault.com/a/1190000011184076">原文</a></p><p>State is similar to props, but it is private and fully controlled by the component.</p><h4 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h4><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">ItemList</span> <span class="token keyword">extends</span> <span class="token class-name">React</span><span class="token punctuation">.</span>Component<span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>      itemList<span class="token operator">:</span><span class="token string">'一些数据'</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>      <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>itemList<span class="token punctuation">}</span>    <span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先，在组件初始化的时候，通过this.state给组件设定一个初始的state，在第一次render的时候就会用这个数据来渲染组件。<br>如果要传参数，constructor、super括号里面都要加入props</p><h4 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h4><p>state不同于props的一点是，state是可以被改变的。不过，不可以直接通过this.state=的方式来修改，而需要通过this.setState()方法来修改state。</p><p>比如，我们经常会通过异步操作来获取数据，我们需要在didMount阶段来执行异步操作：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'url'</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>response <span class="token operator">=&gt;</span> response<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>itemList<span class="token operator">:</span>item<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当数据获取完成后，通过this.setState来修改数据状态。</p><p>当我们调用this.setState方法时，React会更新组件的数据状态state，并且重新调用render方法，也就是会对组件进行重新渲染。</p><p><strong>注意：通过this.state=来初始化state，使用this.setState来修改state，constructor是唯一能够初始化的地方。</strong></p><p>setState接受一个对象或者函数作为第一个参数，只需要传入需要更新的部分即可，不需要传入整个对象，比如：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">ItemList</span> <span class="token keyword">extends</span> <span class="token class-name">React</span><span class="token punctuation">.</span>Component<span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>      name<span class="token operator">:</span><span class="token string">'axuebin'</span><span class="token punctuation">,</span>      age<span class="token operator">:</span><span class="token number">25</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>age<span class="token operator">:</span><span class="token number">18</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在执行完setState之后的state应该是{name:’axuebin’,age:18}。</p><p>setState还可以接受第二个参数，它是一个函数，会在setState调用完成并且组件开始重新渲染时被调用，可以用来监听渲染是否完成：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  name<span class="token operator">:</span><span class="token string">'xb'</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setState finished'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>state的主要作用是用于组件保存、控制以及修改自己的状态，它只能在constructor中初始化，它算是组件的私有属性，不可通过外部访问和修改，只能通过组件内部的this.setState来修改，修改state属性会导致组件的重新渲染。</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li>state是组件自己管理数据，控制自己的状态，可变；</li><li>props是外部传入的数据参数，不可变；</li><li>没有state的叫做无状态组件，有state的叫做有状态组件；</li><li>多用props，少用state。也就是多写无状态组件。</li></ul><h3 id="ant-design"><a href="#ant-design" class="headerlink" title="ant design"></a>ant design</h3><p>使用方法。<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/3b09dec16e4946f6a9b46e1a55e1c5d6.png" alt=""><br>打开组件对应的源码，把里面的东西复制出来。</p><pre class="line-numbers language-none"><code class="language-none">import { Layout, Menu, Breadcrumb, Icon } from 'antd';import React, { Component } from "react";import "antd/dist/antd.css";const { SubMenu } = Menu;const { Header, Content, Sider } = Layout;class SiderDemo extends Component {　　render(){     return(  &lt;Layout&gt;    &lt;Header className="header"&gt;      &lt;div className="logo" /&gt;      &lt;Menu        theme="dark"        mode="horizontal"        defaultSelectedKeys={['2']}        style={{ lineHeight: '64px' }}      &gt;        &lt;Menu.Item key="1"&gt;nav 1&lt;/Menu.Item&gt;        &lt;Menu.Item key="2"&gt;nav 2&lt;/Menu.Item&gt;        &lt;Menu.Item key="3"&gt;nav 3&lt;/Menu.Item&gt;      &lt;/Menu&gt;    &lt;/Header&gt;    &lt;Layout&gt;      &lt;Sider width={200} style={{ background: '#fff' }}&gt;        &lt;Menu          mode="inline"          defaultSelectedKeys={['1']}          defaultOpenKeys={['sub1']}          style={{ height: '100%', borderRight: 0 }}        &gt;          &lt;SubMenu key="sub1" title={&lt;span&gt;&lt;Icon type="user" /&gt;subnav 1&lt;/span&gt;}&gt;            &lt;Menu.Item key="1"&gt;option1&lt;/Menu.Item&gt;            &lt;Menu.Item key="2"&gt;option2&lt;/Menu.Item&gt;            &lt;Menu.Item key="3"&gt;option3&lt;/Menu.Item&gt;            &lt;Menu.Item key="4"&gt;option4&lt;/Menu.Item&gt;          &lt;/SubMenu&gt;          &lt;SubMenu key="sub2" title={&lt;span&gt;&lt;Icon type="laptop" /&gt;subnav 2&lt;/span&gt;}&gt;            &lt;Menu.Item key="5"&gt;option5&lt;/Menu.Item&gt;            &lt;Menu.Item key="6"&gt;option6&lt;/Menu.Item&gt;            &lt;Menu.Item key="7"&gt;option7&lt;/Menu.Item&gt;            &lt;Menu.Item key="8"&gt;option8&lt;/Menu.Item&gt;          &lt;/SubMenu&gt;          &lt;SubMenu key="sub3" title={&lt;span&gt;&lt;Icon type="notification" /&gt;subnav 3&lt;/span&gt;}&gt;            &lt;Menu.Item key="9"&gt;option9&lt;/Menu.Item&gt;            &lt;Menu.Item key="10"&gt;option10&lt;/Menu.Item&gt;            &lt;Menu.Item key="11"&gt;option11&lt;/Menu.Item&gt;            &lt;Menu.Item key="12"&gt;option12&lt;/Menu.Item&gt;          &lt;/SubMenu&gt;        &lt;/Menu&gt;      &lt;/Sider&gt;      &lt;Layout style={{ padding: '0 24px 24px' }}&gt;        &lt;Breadcrumb style={{ margin: '16px 0' }}&gt;          &lt;Breadcrumb.Item&gt;Home&lt;/Breadcrumb.Item&gt;          &lt;Breadcrumb.Item&gt;List&lt;/Breadcrumb.Item&gt;          &lt;Breadcrumb.Item&gt;App&lt;/Breadcrumb.Item&gt;        &lt;/Breadcrumb&gt;        &lt;Content style={{ background: '#fff', padding: 24, margin: 0, minHeight: 280 }}&gt;          Content        &lt;/Content&gt;      &lt;/Layout&gt;    &lt;/Layout&gt;    &lt;/Layout&gt;    )}}export default SiderDemo;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上面的为例，组件叫做SiderDemo。return里面的内容就是源码里面ReactDOM.renderd里面的东西，这里面最后的mountNode去掉了。<br>其余的东西放到class外面。<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/b2954d452d23433d8ecfd48074bf2c67.png" alt=""><br>引入：<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/19507c43b4a94db283f8c9bff258c5ce.png" alt=""></p><h3 id="组件中对a标签的href的带变量拼接"><a href="#组件中对a标签的href的带变量拼接" class="headerlink" title="组件中对a标签的href的带变量拼接"></a>组件中对a标签的href的带变量拼接</h3><p>关键点是外面加了大括号<br></p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">linkContent=&lt;a href=<span class="token punctuation">{</span><span class="token keyword">DATA</span><span class="token punctuation">.</span>serverUrl+<span class="token string">'service/apartment'</span><span class="token operator">+</span>url+<span class="token string">'?apartmentId='</span><span class="token operator">+</span>urlID<span class="token punctuation">}</span>&gt;&lt;p&gt;名称：<span class="token punctuation">{</span>this<span class="token punctuation">.</span>props<span class="token punctuation">.</span>name<span class="token punctuation">}</span>&lt;<span class="token operator">/</span>p&gt;&lt;<span class="token operator">/</span>a&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p><h3 id="向路由组件传递参数"><a href="#向路由组件传递参数" class="headerlink" title="向路由组件传递参数"></a>向路由组件传递参数</h3><p><a href="https://blog.csdn.net/zeroheitao/article/details/118057313?spm=1001.2101.3001.6661.1&amp;depth_1-utm_relevant_index=1">原文链接</a></p><h3 id="import导入时带与不带花括号"><a href="#import导入时带与不带花括号" class="headerlink" title="import导入时带与不带花括号{}"></a>import导入时带与不带花括号{}</h3><p><strong>一个模块中只能有一个默认导出export default，但是却可以有任意命名导出export（0个、1个、多个）</strong></p><ol><li>不带花括号{}，引用js文件中默认导出（export default）的模块</li></ol><p>import模块时的可随意命名。export default默认导出不能加花括号{}。</p><ol><li>带花括号{}，引用js文件中export导出的同名模块</li></ol><p>import模块时的命名必须一致。export命名导出必须加花括号{}。</p><h2 id="React-Hooks"><a href="#React-Hooks" class="headerlink" title="React Hooks"></a>React Hooks</h2><p><a href="https://www.ruanyifeng.com/blog/2019/09/react-hooks.html">原链接</a></p><p>Redux 的作者 Dan Abramov 总结了组件类的几个缺点：</p><ul><li>大型组件很难拆分和重构，也很难测试。</li><li>业务逻辑分散在组件的各个方法之中，导致重复逻辑或关联逻辑。</li><li>组件类引入了复杂的编程模式，比如 render props 和高阶组件。</li></ul><p>函数组件必须是纯函数，不能包含状态，也不支持生命周期方法，因此无法取代类。</p><p><strong>React Hooks 的设计目的，就是加强版函数组件，完全不使用”类”，就能写出一个全功能的组件。</strong></p><p>React Hooks 的意思是，组件尽量写成纯函数，如果需要外部功能和副作用，就用钩子把外部代码”钩”进来。 React Hooks 就是那些钩子。</p><p>四个最常用的钩子：<br>-useState()<br>-useContext()<br>-useReducer()<br>-useEffect()</p><h2 id="umijs"><a href="#umijs" class="headerlink" title="umijs"></a>umijs</h2><h3 id="加载组件出错"><a href="#加载组件出错" class="headerlink" title="加载组件出错"></a>加载组件出错</h3><p><strong>错误信息如下：</strong><br></p><pre class="line-numbers language-none"><code class="language-none">[@umijs/runtime] load component failed Error: Module "./antd/es/select/style" does not exist in container. while loading "./antd/es/select/style" from webpack/container/reference/mf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>如果增加了一个新的组件，不在构建范围之内，就会出错。<br><strong>解决办法：</strong><br>删除.umi缓存，然后重新启动，这个是 mfsu 没有自动编译导致的。<p></p><h2 id="React-基本使用"><a href="#React-基本使用" class="headerlink" title="React 基本使用"></a>React 基本使用</h2><p><a href="https://www.zhihu.com/question/469727631/answer/2527266963">原链接</a></p><h3 id="脚手架"><a href="#脚手架" class="headerlink" title="脚手架"></a>脚手架</h3><pre class="line-numbers language-none"><code class="language-none">npm install create-react-appnpx create-react-app myapp --template typescripe<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果create-react-app是全局安装的，那么前面的npx/npm可以省略</p><h3 id="组件开发"><a href="#组件开发" class="headerlink" title="组件开发"></a>组件开发</h3><h4 id="创建组件"><a href="#创建组件" class="headerlink" title="创建组件"></a>创建组件</h4><p>Vue 创建组件 index.vue</p><p>React 创建组件 index.jsx 或者 index.tsx，jsx 顾名思义是写 JS 的，tsx 肯定就是写 TS的哈 两者创建组件区别只是后缀名不一致</p><h4 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h4><p>Vue 是用 &lt; template &gt; “内容”&lt;/ template &gt;</p><p><strong>注意点：函数名首字母是要大写的</strong><br>React 是用 return 后面的内容是用 () 包起来的，里面用的是 JSX 语法来开发组件的</p><pre class="line-numbers language-none"><code class="language-none">// 函数式组件export default function HelloWorld() {    return (        &lt;div&gt;HelloWorld&lt;/div&gt;    )}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h4><p>Vue 语法: class=”类名”</p><p>React 语法: className=”类名”<br></p><pre class="line-numbers language-none"><code class="language-none">export default function HelloWorld() {    return (        &lt;div className="box"&gt;HelloWorld&lt;/div&gt;    )}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="Style"><a href="#Style" class="headerlink" title="Style"></a>Style</h4><pre class="line-numbers language-none"><code class="language-none">Vue 语法: style="{color: 'red'}"React 语法 style={{ color: 'red' }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>注意点：其中 style 接受的值是一个对象，且用 {} 括号传入，而且对象的属性名只能用驼峰式来命名</strong><br></p><pre class="line-numbers language-none"><code class="language-none">export default function HelloWorld() {        return (            &lt;div style={{ color: 'red' }}&gt;HelloWorld&lt;/div&gt;        )    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h3 id="组件的使用"><a href="#组件的使用" class="headerlink" title="组件的使用"></a>组件的使用</h3><p>Vue 使用组件先引入再注册最后使用组件</p><p>React 相当于函数，只有引入的概念，没有注册的概念，所以引入进来就可以使用<br></p><pre class="line-numbers language-none"><code class="language-none">import HelloWorld from './HelloWorld';    // &lt;&gt; &lt;/&gt; 相当于根标签    export default function Index() {        return (            &lt;&gt;                &lt;HelloWorld /&gt;            &lt;/&gt;        )    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h3 id="声明状态变量"><a href="#声明状态变量" class="headerlink" title="声明状态变量"></a>声明状态变量</h3><p>Vue 声明变量是在 data 里面定义的<br>React 使用 useState 返回的第一个值，进行声明变量的</p><p><strong>注意点：Vue 使用数据是双大括号 ,React 使用数据是单大括号</strong><br></p><pre class="line-numbers language-none"><code class="language-none">import React, { useState } from 'react';        export default function HelloWorld() {    const [title] = useState('豆豆'); // 括号里面是给初始值    const [count] = useState(20);        return (            &lt;&gt;                &lt;div&gt;{ title }&lt;/div&gt;                &lt;div&gt;{ count }&lt;/div&gt;            &lt;/&gt;        )    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><h3 id="绑定事件"><a href="#绑定事件" class="headerlink" title="绑定事件"></a>绑定事件</h3><h3 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h3><h3 id="父子组件通讯"><a href="#父子组件通讯" class="headerlink" title="父子组件通讯"></a>父子组件通讯</h3><h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="react-hook-重复不停的运行"><a href="#react-hook-重复不停的运行" class="headerlink" title="react hook 重复不停的运行"></a>react hook 重复不停的运行</h3><p>打开控制台就能看见不停的运行，原因目前还没找到，解决方法如下：<br><a href="https://www.csdn.net/tags/MtTaMg0sNTIyMzc1LWJsb2cO0O0O.html">相关链接</a><br><strong>给useEffect传递一个空数组（[]）作为第二个参数</strong><br></p><pre class="line-numbers language-none"><code class="language-none">useEffect(() =&gt; {  getModuleNameInfo(+productid, +projectId)},[])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p></p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Vue </tag>
            
            <tag> React </tag>
            
            <tag> Json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>零散知识</title>
      <link href="/posts/37060/"/>
      <url>/posts/37060/</url>
      
        <content type="html"><![CDATA[<h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><h3 id="充分条件和必要条件"><a href="#充分条件和必要条件" class="headerlink" title="充分条件和必要条件"></a>充分条件和必要条件</h3><ol><li><p>充分条件<br>A是B的充分条件（多因一果，多个原因都能单独地导致这一后果）<br><img src="https://pic1.zhimg.com/80/v2-90dcec2eab295830dded9288684c3ae3_1440w.webp?source=1940ef5c" alt=""></p><p>1）有前项必有后项：<br>2）无前项时可能有后项也可能没有，但都不影响前项是后项的充分条件</p></li><li>必要条件<br>前项是后项的必要条件（合因一果，多个原因共同作用导致这一结果）</li></ol><p><img src="https://pic1.zhimg.com/80/v2-1d7407e1c6a7d04b28631634332a86d6_1440w.webp?source=1940ef5c" alt=""></p><p>缺少任何一个原因都不能导致这一后果（无前项一定无后项）所以也可认为前项假后项真这个命题为假</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><h3 id="手机拍照专业模式"><a href="#手机拍照专业模式" class="headerlink" title="手机拍照专业模式"></a>手机拍照专业模式</h3><p><a href="https://www.bilibili.com/video/BV1FM41137Tt/?share_source=copy_web&amp;vd_source=0aac08942099868c6eaf781c9de8ebb1">【【小米13Ultra】相机专业模式不会用？进来看看，包教包会！】 </a><br>以小米系列手机为例，可以调节的参数依次有：</p><ol><li>WB<br>白平衡。能够调节画面的冷暖调。尽量不要动这个参数，自动就好。即使要调节，也可以通过调节色温来矫正色彩。</li><li>F<br>对焦。（在设置对焦前，建议把上方菜单栏中的峰值对焦打开，以辅助我们查看画面中的焦点位置）。可以让我们将焦点放到想拍摄的物体。</li><li>S<br>快门速度。快门动作可以理解为眨眼，快门速度可以理解为眨眼的速度。快门速度越短，进光量小，画面越暗；快门速度越快则反之。</li><li>ISO<br>感光度。感光度越低，画质越暗，画面越清晰；感光度高则反之。</li><li><p>EV<br>曝光补偿。想让画面越亮或越暗，直接设置曝光补偿。如果想拍摄白云或白雪，可以增加。如果拍摄黑色的景物或场景，可以降低。</p><p>总结：大部分的时候都设置为自动挡，改的最多的为快门和曝光补偿，有需要再改。</p></li></ol><h2 id="win10操作"><a href="#win10操作" class="headerlink" title="win10操作"></a>win10操作</h2><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><h4 id="desktopwindowxamlsource窗口"><a href="#desktopwindowxamlsource窗口" class="headerlink" title="desktopwindowxamlsource窗口"></a>desktopwindowxamlsource窗口</h4><p>某一次在任务栏下面出现了“desktopwindowxamlsource“字样的东西，点击没反应，如果右键关闭，那么onedirve也会被关闭。卸载onedrive，重新安装，一开始可以，但几天后又出现了。</p><p><em>*解决方法：</em><br>设置-&gt;搜索多任务处理-&gt;虚拟桌面。“在任务栏上，显示打开的窗口”。选择“仅限我正在使用的电脑”</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/Snipaste_2023-02-10_22-07-47.png" alt=""></p><h3 id="Windows-10每天定时执行脚本"><a href="#Windows-10每天定时执行脚本" class="headerlink" title="Windows 10每天定时执行脚本"></a>Windows 10每天定时执行脚本</h3><p>Windows键+R 调出此窗口，输入compmgmt.msc （调用的是计算机管理）<br><a href="https://blog.csdn.net/weixin_43336281/article/details/120146530">原文链接</a><br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/11a8dfbb395d4802bf900fc38e115359.png" alt=""><br>点击下面的框，创建一个基本任务<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/a8b17d9ac08842dc8bcf39a70b18f6b1.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/790aaf2ea74545e2a8f68210e00b63dc.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/bfa2a240ba1e4263b82eec7ddc4f04ae.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/dbbc4eec03724c6eb69a30ed082c303d.png" alt=""><br>后面跟着点就好</p><h3 id="Windows重启打印机服务"><a href="#Windows重启打印机服务" class="headerlink" title="Windows重启打印机服务"></a>Windows重启打印机服务</h3><p>有时候需要重启打印机，采用命令行的方式。</p><blockquote><p>Win+R ：services.msc  找到 Print Spooler 重启。</p></blockquote><h3 id="Win10开机自启动软件"><a href="#Win10开机自启动软件" class="headerlink" title="Win10开机自启动软件"></a>Win10开机自启动软件</h3><p>把该应用程序的快捷方式放到“系统启动文件夹”里；</p><blockquote><p>C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp</p></blockquote><h3 id="Win10查看电脑配置信息和型号"><a href="#Win10查看电脑配置信息和型号" class="headerlink" title="Win10查看电脑配置信息和型号"></a>Win10查看电脑配置信息和型号</h3><h4 id="使用dxdiag命令检查电脑配置"><a href="#使用dxdiag命令检查电脑配置" class="headerlink" title="使用dxdiag命令检查电脑配置"></a>使用dxdiag命令检查电脑配置</h4><p> 按下键盘上的Win+R组合键，打开运行窗口，输入dxdiag，点击确定。<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/7ac995ab180c4465968809c73ea881cd.png" alt=""><br>在打开的页面中就可以看到当前计算机名称、操作系统、CPU、内存等重要信息。</p><h4 id="使用diskmtgt-msc命令进入磁盘管理，查看硬盘大小及已使用的空间。"><a href="#使用diskmtgt-msc命令进入磁盘管理，查看硬盘大小及已使用的空间。" class="headerlink" title="使用diskmtgt.msc命令进入磁盘管理，查看硬盘大小及已使用的空间。"></a>使用diskmtgt.msc命令进入磁盘管理，查看硬盘大小及已使用的空间。</h4><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/b507309c987f41898b08f797c24c7f4c.png" alt=""><br>465.76GB就是500G的硬盘，不要怀疑是不是奸商给你的是假货，这是没有问题的，硬盘的生产厂家在生产硬盘时用的是1000进制，即1GB=1000MB；1MB=1000KB；1KB=1000B。而电脑的计算进制是1024，即1G=1024MB；1MB=1024KB；1kB=1024B，这样就会造成电脑检测出来的容量比标称容量小。</p><p>  此外，除了以上方法也可以进入设备管理器里查看电脑配置信息，步骤：右击桌面上的“计算机”—&gt;“设备管理器”，在设备管理器中就可以看见电脑配置情况了</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/a53bf33bf4894fb7b610d2cf291071d0.png" alt=""></p><h3 id="win10查看端口使用情况"><a href="#win10查看端口使用情况" class="headerlink" title="win10查看端口使用情况"></a>win10查看端口使用情况</h3><pre class="line-numbers language-none"><code class="language-none">netstat [选项]具体选项可自主查询<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用示例：</p><pre class="line-numbers language-none"><code class="language-none">netstat -a      # 列出所有端口netstat -at     # 列出所有TCP端口netstat -au    # 列出所有UDP端口netstat -ax    # 列出所有unix端口netstat -atnlp    # 直接使用ip地址列出所有处理监听状态的TCP端口，且加上程序名netstat -ano     # 端口+显示ip+显示计时器netstat -ano |findstr "端口号"    #这个端口被哪个应用占用，实际输入端口号需要用引号括起来tasklist |findstr "进程id号"    #查看到对应的进程id之后，就可以通过id查找对应的进程名称taskkill /f /t /im "进程id或者进程名称"    #通过命令杀掉进程，或者是直接根据进程的名称杀掉所有的进程<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="mathtype试用期到期-解决办法"><a href="#mathtype试用期到期-解决办法" class="headerlink" title="mathtype试用期到期 解决办法"></a>mathtype试用期到期 解决办法</h3><ol><li>win + R 打开运行窗口，输入regedit</li><li>找到注册表.计算机\HKEY_CURRENT_USER\SOFTWARE\Install Options</li><li>删掉options6.9</li></ol><h3 id="mathtype为word中的公式自动编号"><a href="#mathtype为word中的公式自动编号" class="headerlink" title="mathtype为word中的公式自动编号"></a>mathtype为word中的公式自动编号</h3><p><a href="https://www.mathtype.cn/jiqiao/mathtype-iiiz.html">原文链接</a></p><h2 id="bat脚本"><a href="#bat脚本" class="headerlink" title="bat脚本"></a>bat脚本</h2><p>案例1：拉取代码</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">cmd <span class="token operator">/</span>k <span class="token string">"cd /d 执行目录&amp;&amp;git pull origin dev1:dev1&amp;&amp;cd /d 执行目录&amp;&amp;git pull origin hexo:hexo"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>&amp;&amp; 表示前面的执行完才会执行后面的<br>执行目录要替换为具体的路径。</strong></p><h3 id="win-11-添加VSCode至右键菜单"><a href="#win-11-添加VSCode至右键菜单" class="headerlink" title="win 11 添加VSCode至右键菜单"></a>win 11 添加VSCode至右键菜单</h3><ol><li>新建一个文本文件，内容如下：<pre class="line-numbers language-none"><code class="language-none">Windows Registry Editor Version 5.00 [HKEY_CLASSES_ROOT\*\shell\VSCode]@="Open with Code""Icon"="S:\\Microsoft VS Code\\Microsoft VS Code\\Code.exe" [HKEY_CLASSES_ROOT\*\shell\VSCode\command]@="\"S:\\Microsoft VS Code\\Microsoft VS Code\\Code.exe\" \"%1\"" Windows Registry Editor Version 5.00 [HKEY_CLASSES_ROOT\Directory\shell\VSCode]@="Open with Code""Icon"="S:\\Microsoft VS Code\\Microsoft VS Code\\Code.exe" [HKEY_CLASSES_ROOT\Directory\shell\VSCode\command]@="\"S:\\Microsoft VS Code\\Microsoft VS Code\\Code.exe\" \"%V\"" Windows Registry Editor Version 5.00 [HKEY_CLASSES_ROOT\Directory\Background\shell\VSCode]@="Open with Code""Icon"="S:\\Microsoft VS Code\\Microsoft VS Code\\Code.exe" [HKEY_CLASSES_ROOT\Directory\Background\shell\VSCode\command]@="\"S:\\Microsoft VS Code\\Microsoft VS Code\\Code.exe\" \"%V\""<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>将vscode安装地址替换成你实际安装的地址<br><strong>注意：地址最好使用双斜杠，替换的时候要注意不要删掉其他的东西，上述中需要替换的只有S:\Microsoft VS Code\Microsoft VS Code\Code.exe这个地方</strong></p></li><li><p>将文件后缀名改成 .reg，最后双击执行就成功了。</p></li></ol><h2 id="模糊照片变高清"><a href="#模糊照片变高清" class="headerlink" title="模糊照片变高清"></a>模糊照片变高清</h2><p>访问 </p><blockquote><p>bigjpg.com</p></blockquote><p>将照片扔上去就好。</p><h2 id="右键菜单，用vscode打开文件和文件夹"><a href="#右键菜单，用vscode打开文件和文件夹" class="headerlink" title="右键菜单，用vscode打开文件和文件夹"></a>右键菜单，用vscode打开文件和文件夹</h2><p>效果如下：<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/f320d8884529cf25708db00cc2f68aa6.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/eab1d51894be1554cd6b254910004e94.png" alt=""></p><h3 id="方法1-重装软件"><a href="#方法1-重装软件" class="headerlink" title="方法1 重装软件"></a>方法1 重装软件</h3><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/2d3e9b77c41f48d7a4878cb4c67d2092.png" alt=""></p><h3 id="方法2-修改注册表"><a href="#方法2-修改注册表" class="headerlink" title="方法2 修改注册表"></a>方法2 修改注册表</h3><p><strong>1.右键打开文件</strong> </p><pre class="line-numbers language-none"><code class="language-none">1, Win+R 打开运行，输入regedit，打开注册表，找到HKEY_CLASSES_ROOT\*\shell分支，如果没有shell分支，则在*下点击右键，选择“新建－项”，建立shell分支。2, 在shell下新建“VisualCode”项，在右侧窗口的“默认”双击，在数据里输入“用VSCode打开”。这是右键上显示的文字，可以随便写，只是为了方便查看3, 在“VisualCode”下再新建Command项，在右侧窗口的“默认”键值栏内输入程序所在的安装路径，我的是："D:\anzhuang\Microsoft VS Code\Code.exe" "%1"。其中的%1表示要打开的文件参数。4, 配置缩略图。在VisualCode项上新建可扩充字符串值，命名为Icon，双击，把"D:\anzhuang\Microsoft VS Code\Code.exe"放进数据就可以了。5, 关闭注册表，即可生效。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/a7bc8278407649708c9dd5408425cfd3.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/e331e15352b245a7888d049d47429ae3.png" alt=""><br><strong>2.右键打开文件夹</strong></p><pre class="line-numbers language-none"><code class="language-none">1.Win+R 打开运行，输入regedit，打开注册表，找到HKEY_CLASSES_ROOT\Directory\Background\shell\分支2、同上面的2完全一样3、同上，把 %1 改为%V，例如："D:\anzhuang\Microsoft VS Code\Code.exe" "%V"4、5同上，完全一样<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/2adc1abe19bc4eb8bd6beca9ec3a4227.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/6fd595b4dac543b1939469bffe543e6e.png" alt=""></p><h2 id="专利"><a href="#专利" class="headerlink" title="专利"></a>专利</h2><h3 id="如何查询专利"><a href="#如何查询专利" class="headerlink" title="如何查询专利"></a>如何查询专利</h3><p>1.登录网站（国家知识产权）</p><p>2.专利检索</p><p>3.<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/8eeaf4dc126a4145a58f40de6f45b81c.png" alt=""><br>账号是:1gaofeng1<br>密码：110</p><p>输入申请号查询</p><h2 id="Hexo-相关内容"><a href="#Hexo-相关内容" class="headerlink" title="Hexo 相关内容"></a>Hexo 相关内容</h2><h3 id="添加自定义的内容"><a href="#添加自定义的内容" class="headerlink" title="添加自定义的内容"></a>添加自定义的内容</h3><p>我想给博客添加一些新内容，通过url访问，比如加密功能，但是不希望被模板渲染。</p><p>在source目录下新建一个目录，这里取名password，然后把要添加的内容放进去。内容里面要渲染的html文件名为index.html（可以起别的名字）。</p><p>然后要在_config.yml里面的”skip_render:”字段里面按固定格式加上文件名，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/Snipaste_2023-02-20_17-20-44.png" alt=""></p><p>然后提交，访问的时候在url后面跟上<br><strong>/password/index.html</strong>就可以访问对应页面</p><p><a href="https://blog.csdn.net/steven_zdg988/article/details/111240905">原文链接</a></p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>具体的教程网上自行搜索就好，下面重点列出几个容易出问题的地方。</p><ul><li>仓库名应该为：<strong>用户名</strong>.<a href="http://github.io">http://github.io</a> 这个用户名使用你的GitHub帐号名称代替，这是固定写法。</li><li>hexo配置文件里面的url要换成自己实际访问的url<br><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/550bbae31d85401b910e7d37c575bd7f.png" alt=""></li></ul><h3 id="hexo多终端同步管理"><a href="#hexo多终端同步管理" class="headerlink" title="hexo多终端同步管理"></a>hexo多终端同步管理</h3><p><strong>因为hexo只是将生成好的静态文件放在github上，没有源码。如果在另一台设备就没法。</strong><br><strong>思路：在原有仓库建一个分支，源码的拉取和推送都在分支上。但是hexo g &amp;&amp; hexo d会弄到主干上</strong></p><p><strong>实现</strong><br><strong>创建分支（在 Github上操作）</strong><br>首先在Github上面创建一个分支命名为hexo，hexo 是从master 拉取，所以分支的文件和 master 一样。</p><p><strong>初始化分支（PC1上面操作）</strong><br>在已经部署好Hexo环境的PC1上的安装Hexo的根目录下拉取 hexo 分支，步骤如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">git clone 仓库地址<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将仓库文件拉取到本地，生成的文件名为 username.github.io；进入username.github.io文件夹，除了 .git 文件夹以外，其他文件全部删除；</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">git add <span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将修改提交至暂存区；</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">git commit <span class="token operator">-</span>m “提交说明”<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>提交本次修改；</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">git push origin <span class="token class-name">Hexo</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将本次修改推送到远端 Hexo；将刚才未删除的 .git 文件夹拷贝至Hexo根目录，删除 username.github.io 文件夹，此时本地的Hexo目录已与 Github上面的 Hexo 文件夹关联了，而且默认的 .gitignore 已经配置了忽略规则，所以已经可以将根目录下的文件同步上去，还是依次调用 git add . 、git commit -m ‘comment’、 git push origin Hexo 三个命令将当前的文件推送至远程的 Hexo分支。</p><p><strong>同步分支（PC2上面操作）</strong><br>此时在PC2上，创建文件夹Blog，在Blog文件夹下面还行以下操作：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">git clone 仓库地址 <span class="token class-name">BlogName</span>git clone <span class="token operator">-</span>b hexo 仓库地址 hexo<span class="token punctuation">.</span>repo <span class="token comment">//这一步是将Hexo分支的代码拉到hexo.repo里面。名字可以自己起。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>在clone下来的仓库文件夹中将hexo.repo 文件夹下的文件拷贝到 BlogName 目录中（这里把hexo.repo里面的所有文件夹包括.git一起拷贝过去，这时候本地的分支就是Hexo。虽然远程和本地都有Hexo，但是PC2没有master。那么以后的推送或拉取都要把分支指定完全  git push origin Hexo:Hexo   git pull origin Hexo:Hexo）</strong></p><p><strong>其实上面的问题，在pc2上把hexo.repo的文件复制过去后，可以再建一个master，把远程仓库的master拉到本地master应该就可以了，虽然这个办法没尝试过，但是下次可以试试。</strong></p><p>然后安装和配置hexo环境，依次调用命令： npm install hexo、npm install、npm install hexo-deployer-git；（不需要hexo init）此时通过命令 hexo g、hexo s即可在本地开启同步下来的博客静态页面，并通过 <a href="http://localhost:4000/">http://localhost:4000/</a> 访问。</p><p><strong>在新设备上使用可能遇到的问题</strong></p><ol><li><p>npm安装好hexo后，把github上的代码拉下来，进入指定目录后，无法使用hexo命令。<br>原因：缺少node_modules包<br>可以使用npm install安装，如果不行的话，可以把其他设备的node_modules包拷贝过来</p></li><li><p>新设备hexo g 与 hexo s后，页面是空白的<br>原因：themes下面的主题文件夹内容为空<br>可能是当时主题文件夹里面有git文件夹，导致没有上传到github，所以新设备拉去的时候，里面的内容是空的。只需要把原来设备的主题拷贝过来就好</p></li></ol><p><strong>发布博文（PC1或者PC2）</strong><br>后续不管是PC1还是PC2，如果修改了主题或者新增了博文，按照以下步骤即可：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">git add <span class="token punctuation">.</span>git commit <span class="token operator">-</span>m “修改说明”git push origin <span class="token class-name">Hexo</span>hexo g <span class="token operator">-</span>d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="博客无法渲染出数学公式"><a href="#博客无法渲染出数学公式" class="headerlink" title="博客无法渲染出数学公式"></a>博客无法渲染出数学公式</h3><p>渲染出的页面，还是带有$$符号。</p><p>以我的模板(hexo-theme-matery)为例：</p><ol><li>要在每篇有数学公式文章的Front-matter中加上<code>mathjax: true</code></li></ol><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img/Snipaste_2023-03-15_15-36-17.png" alt=""></p><ol><li>把模板_config.yml中的mathjax配置项的值置为true，全局搜索就可以找到。</li></ol><p>如果上述方法都不行，考虑下下面的办法，每尝试一个办法，可以马上验证下是否可行。</p><ol><li><p>渲染引擎缺失</p><pre class="line-numbers language-none"><code class="language-none">npm uninstall hexo-renderer-marked --savenpm install hexo-renderer-kramed --save<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>语言冲突</p></li></ol><p>修改文件 node_modules\kramed\lib\rules\inline.js</p><pre class="line-numbers language-none"><code class="language-none">//  escape: /^\\([\\`*{}\[\]()#$+\-.!_&gt;])/,  escape: /^\\([`*\[\]()#$+\-.!_&gt;])/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">//  em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,  em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="hexo无缘无故出现404"><a href="#hexo无缘无故出现404" class="headerlink" title="hexo无缘无故出现404"></a>hexo无缘无故出现404</h3><p>访问的时候突然出现404。hexo clean ，hexo g , hexo d不行； hexo s也不行</p><p>访问url是404，hexo s出现的是cannot GET</p><p><strong>解决方法</strong></p><p>还一个可能产生404的原因便是因为缺少了index.html文件，解决方案如下：</p><p>在git bash中敲入</p><p><code>npm install hexo-generator-index --save</code></p><p>之后便有index.html文件了。不妨重新hexo clean，hexo g -d试试。</p><h1 id="第一次写博客，还有些生涩，希望可以帮到大家。有问题可直接评论，我会不定期登录博客，和大家一起探讨。"><a href="#第一次写博客，还有些生涩，希望可以帮到大家。有问题可直接评论，我会不定期登录博客，和大家一起探讨。" class="headerlink" title="第一次写博客，还有些生涩，希望可以帮到大家。有问题可直接评论，我会不定期登录博客，和大家一起探讨。"></a>第一次写博客，还有些生涩，希望可以帮到大家。有问题可直接评论，我会不定期登录博客，和大家一起探讨。</h1><h2 id="宽带、带宽、流量"><a href="#宽带、带宽、流量" class="headerlink" title="宽带、带宽、流量"></a>宽带、带宽、流量</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>宽带：通常别人会说你家能不能上网呀？其实这个意思就是你家有没有宽带，换句话说，就是一个名词，先有了宽带一词，然后才可以说你带宽是多少，宽带与上网的速度快慢没有直接关系。</li><li>带宽：带宽是量词，指的是网速的大小，比如1Mbps的意思是一兆比特每秒</li></ul><h3 id="下载速度"><a href="#下载速度" class="headerlink" title="下载速度"></a>下载速度</h3><p>如果申请的带宽是10Mb/s这个单位中的b是小写的，而我们刚才说的1B(字节)=8b(位),这里刚好是8倍的关系，即下载速度：10Mb / 8 = 1.25MB</p><p><strong>有的人就会问，为什么要除以8?</strong></p><ul><li>在计算机中，下载速度是以字节(B)为单位的，而提供商说的是以比特(b)为单位的。</li></ul><h3 id="流量"><a href="#流量" class="headerlink" title="流量"></a>流量</h3><p>流量是对外发送数据与接收数据包的大小总和，单位是采取1024进制的，单位有 B,KB,MB(M),GB(G)<br></p><pre class="line-numbers language-none"><code class="language-none">1G=1024MB1M=1024KB1KB=1024字节(B）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br><pre class="line-numbers language-none"><code class="language-none">一般我们手机有 5元30MB,10元70MB的流量套餐，当我们打开一个网页，需要多少流量呢？(2005)假设某一个网页上有 100个汉字与一张100KB的图片，一个汉字=2个字节即这个页面的数据大小为：100 * 2B / 1024 + 100KB = 0.2KB +100KB =100.2KB；每访问一次这个页面，将产生100.2KB的流量，如果是70MB的流量，那么访问几个网页基本没有了，所以更不要说看视频了。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h3 id="带宽、网速、流量的关系"><a href="#带宽、网速、流量的关系" class="headerlink" title="带宽、网速、流量的关系"></a>带宽、网速、流量的关系</h3><p>1.带宽单位是：比特/秒（bps）：10M=10Mbps</p><p>2.网速是数据传输的速度，单位是：字节/秒 (B/s， KB/s， MB/s)<br></p><pre class="line-numbers language-none"><code class="language-none">1MB/s=1024KB/s1KB/s=1024B/s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p></p><p>3.流量是用户上网 发送和接收 的 数据量总和 ，单位是：字节（Byte）；<br></p><pre class="line-numbers language-none"><code class="language-none">比特是信息的最小单位：1字节=8比特 也就是1B=8bit 或者 1B=8b1字节/秒=8比特/秒 (1B/s=8bps)1比特 (1b or 1位) 是信息技术中的最小存储单位，1位代表一个“1”或者“0”；1B（1字节）是比较小的存储单位：一般情况下1个英文字母占1个字节；一个汉字占2个字节；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>4.他们之间的换算：带宽大小 / 8</p><h2 id="传统下载、BT下载，磁链下载"><a href="#传统下载、BT下载，磁链下载" class="headerlink" title="传统下载、BT下载，磁链下载"></a>传统下载、BT下载，磁链下载</h2><h3 id="传统下载"><a href="#传统下载" class="headerlink" title="传统下载"></a>传统下载</h3><p>采用的是C/S模式，所有的用户都从指定服务器上拿东西，对服务器有较高的要求。如果请求量过大，容易崩</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/Snipaste_2023-06-03_21-10-35.png" alt=""></p><h3 id="BT下载"><a href="#BT下载" class="headerlink" title="BT下载"></a>BT下载</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>BitTorrent(简称BT)是一个文件分发协议，每个下载者在下载的同时不断向其他下载者上传已下载的数据。而在FTP，HTTP协议中，每个下载者在下载自己所需文件的同时，各个下载者之间没有交互。当非常多的用户同时访问和下载服务器上的文件时，由于FTP服务器处理能力和带宽的限制，下载速度会急剧下降，有的用户可能访问不了服务器。BT协议与FTP协议不同，特点是下载的人越多，下载速度越快，原因在于每个下载者将已下载的数据提供给其他下载者下载，充分利用了用户的上载带宽。通过一定的策略保证上传速度越快，下载速度也越快。在很短时间内，BitTorrent协议成为一种新的变革技术。</p><p><strong>BitTorrent 的发展依赖于peer-to-peer技术，在P2P网络中，每个参与的节点既是服务器又是客户端，既是信息的提供者又是信息的消费者。</strong></p><p><strong>为什么说下载的人越多，下载速度越快？</strong></p><p>假如目标文件目前有4个人持有，那我从4个人手里面取走一部分，拼凑起来就可以获得目标文件，但是理论用时为原来的1/4。</p><h4 id="大概流程"><a href="#大概流程" class="headerlink" title="大概流程"></a>大概流程</h4><p>种子会告诉我联系哪个追踪服务器，然后服务器告诉我该找谁要资源。</p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/Snipaste_2023-06-03_22-11-02.png" alt=""></p><p>但是这种方式存在一个弊端，没有存在真正的去中心化，如果tracker被干掉了，那么种子就会失效。（因为大量网民下载盗版的，有电源公司和唱片公司等会想办法干掉tracker）</p><h3 id="磁链接下载"><a href="#磁链接下载" class="headerlink" title="磁链接下载"></a>磁链接下载</h3><p><a href="https://www.youtube.com/watch?v=wifmWklnB1U">原视频</a></p><p><img src="https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/Snipaste_2023-06-03_22-15-50.png" alt=""></p><p><strong>没有种子，没有固定的追踪服务器</strong></p><p>追踪服务器都是临时工，由某一个下载者兼任。要找到这个下载者需要多方打听。看看自己名单里面谁和这个下载者最近，然后层层联系。</p>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDE </tag>
            
            <tag> 编辑器 </tag>
            
            <tag> vscode </tag>
            
            <tag> 照片模糊处理 </tag>
            
            <tag> win10 </tag>
            
            <tag> 专利 </tag>
            
            <tag> bat </tag>
            
            <tag> 博客 </tag>
            
            <tag> 带宽 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
