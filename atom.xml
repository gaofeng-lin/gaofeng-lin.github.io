<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://gaofeng-lin.github.io/atom.xml" rel="self"/>
  
  <link href="https://gaofeng-lin.github.io/"/>
  <updated>2022-07-23T04:40:03.370Z</updated>
  <id>https://gaofeng-lin.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>正则表达式</title>
    <link href="https://gaofeng-lin.github.io/posts/9809/"/>
    <id>https://gaofeng-lin.github.io/posts/9809/</id>
    <published>2022-07-03T16:00:00.000Z</published>
    <updated>2022-07-23T04:40:03.370Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实战按理"><a href="#实战按理" class="headerlink" title="实战按理"></a>实战按理</h2><h3 id="将markdown文章所有标题多加一级"><a href="#将markdown文章所有标题多加一级" class="headerlink" title="将markdown文章所有标题多加一级"></a>将markdown文章所有标题多加一级</h3><p>在markdown中,标题按照”#”标注，某次更换了主题，对于一级标题无法识别，导致目录树无法正常显示。如果直接使用替换。二级标题”##”会变成四个。</p><p><strong>解决方法:</strong><br><img src="https://s2.loli.net/2022/07/23/NOHAYuUkEDhwS6T.png" alt="Snipaste_2022-07-23_12-37-47.png"></p><pre class="line-numbers language-none"><code class="language-none">^#{1}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>^表示匹配文章开头</li><li>{1}匹配1次</li></ol><p><a href="https://c.runoob.com/front-end/854/">正则表达式在线工具</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;实战按理&quot;&gt;&lt;a href=&quot;#实战按理&quot; class=&quot;headerlink&quot; title=&quot;实战按理&quot;&gt;&lt;/a&gt;实战按理&lt;/h2&gt;&lt;h3 id=&quot;将markdown文章所有标题多加一级&quot;&gt;&lt;a href=&quot;#将markdown文章所有标题多加一级&quot; class</summary>
      
    
    
    
    <category term="Linux" scheme="https://gaofeng-lin.github.io/categories/Linux/"/>
    
    
    <category term="正则表达式" scheme="https://gaofeng-lin.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Typescript变量类型</title>
    <link href="https://gaofeng-lin.github.io/posts/62822/"/>
    <id>https://gaofeng-lin.github.io/posts/62822/</id>
    <published>2022-06-13T16:00:00.000Z</published>
    <updated>2022-07-23T02:29:11.054Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TS语法以及类型"><a href="#TS语法以及类型" class="headerlink" title="TS语法以及类型"></a>TS语法以及类型</h2><p><a href="https://github.com/iamswr/ts_react_demo_20181207">原链接</a></p><h2 id="js和ts的区别"><a href="#js和ts的区别" class="headerlink" title="js和ts的区别"></a>js和ts的区别</h2><h3 id="1-动态编程语言和静态编程语言的区别"><a href="#1-动态编程语言和静态编程语言的区别" class="headerlink" title="1 . 动态编程语言和静态编程语言的区别"></a>1 . 动态编程语言和静态编程语言的区别</h3><ul><li>js属于动态类型的编程语言<ul><li>边解析边执行的语言, 错误只能在运行阶段发现</li></ul></li><li>ts属于静态编程的语言<ul><li>先编译(编译成js),再执行(不能直接执行, TSC工具将ts转换为js)</li></ul></li></ul><h3 id="2-兼容性-ts包含js-js所有语法ts都支持"><a href="#2-兼容性-ts包含js-js所有语法ts都支持" class="headerlink" title="2 . 兼容性: ts包含js(js所有语法ts都支持)"></a>2 . 兼容性: ts包含js(js所有语法ts都支持)</h3><h3 id="3-ts-有类型约束"><a href="#3-ts-有类型约束" class="headerlink" title="3 . ts 有类型约束"></a>3 . ts 有类型约束</h3><ul><li>ts有类型的支持, 有强大的代码提示(在写代码的时候就能发现问题)</li></ul><h3 id="4-ts的前端生态"><a href="#4-ts的前端生态" class="headerlink" title="4 . ts的前端生态"></a>4 . ts的前端生态</h3><ul><li>vue : vue3源码使用TS重写</li><li>React : TS +  Hooks</li><li>Angular : 默认支持 TS</li></ul><h2 id="搭建-TypeScript-运行环境"><a href="#搭建-TypeScript-运行环境" class="headerlink" title="搭建 TypeScript 运行环境"></a>搭建 TypeScript 运行环境</h2><h3 id="全局安装编译-TS-的工具包"><a href="#全局安装编译-TS-的工具包" class="headerlink" title="全局安装编译 TS 的工具包"></a>全局安装编译 TS 的工具包</h3><p>安装包：<code>npm i -g typescript</code></p><ul><li>typescript 包：用来编译 TS 代码的包，提供了 <code>tsc</code> 命令，实现了 <code>ts -&gt; js</code> 的转化</li><li>验证是否安装成功：<code>tsc –v</code> (查看 typescript 的版本)</li></ul><p>注意：Mac 电脑安装全局包时，需要添加 <code>sudo</code> 获取权限：<code>sudo npm i -g typescript</code></p><h3 id="编译并运行-TS-代码"><a href="#编译并运行-TS-代码" class="headerlink" title="编译并运行 TS 代码"></a>编译并运行 TS 代码</h3><p>步骤</p><ol><li><p>创建ts文件。例如 hello.ts 文件（注意：**TS 文件的后缀名为 <code>.ts</code>**）</p></li><li><p>编译。将 TS 编译为 JS</p><p>在终端中输入命令，<code>tsc hello.ts</code>（此时，在同级目录中会出现一个同名的 JS 文件）</p></li><li><p>执行 JS 代码。</p><ol><li>在node中运行。在终端中输入命令，<code>node hello.js</code></li><li>在浏览器中运行。</li></ol></li></ol><h3 id="拓展：在线运行"><a href="#拓展：在线运行" class="headerlink" title="拓展：在线运行"></a>拓展：在线运行</h3><p><a href="https://www.typescriptlang.org/play">https://www.typescriptlang.org/play</a></p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p><code>npm bin -g </code> 可以查看全局安装的路径</p><p>环境变量 path 中有此路径即可 </p><h2 id="简化-ts-使用"><a href="#简化-ts-使用" class="headerlink" title="简化 ts 使用"></a>简化 ts 使用</h2><p>每次修改代码后，都要重复执行两个命令，才能运行 TS 代码，太繁琐。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">tsc  你的代码<span class="token punctuation">.</span>tsnode 你的代码<span class="token punctuation">.</span>js<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="简化方式"><a href="#简化方式" class="headerlink" title="简化方式"></a>简化方式</h3><p>使用 <code>ts-node</code> 包，直接在 Node.js 中执行 TS 代码。它提供了 <code>ts-node</code> 命令，可以简化执行命令。</p><h3 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h3><p><code>npm i -g ts-node</code></p><p>使用方式：<code>ts-node hello.ts</code> </p><p>相当于：1 tsc 命令  2 node（注意：ts-node 不会生成 js 文件）</p><p>解释：ts-node 命令在内部偷偷的将 TS -&gt; JS，然后，再运行 JS 代码</p><h2 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h2><p><strong>语法: <code>let 变量 :  类型 = 值</code></strong></p><p>约定了变量的类型 <code>: 类型</code></p><h2 id="ts-中的类型"><a href="#ts-中的类型" class="headerlink" title="ts 中的类型"></a>ts 中的类型</h2><h3 id="1-js中已有的类型"><a href="#1-js中已有的类型" class="headerlink" title="1 . js中已有的类型"></a>1 . js中已有的类型</h3><ol><li>原始类型 :  <code>number/string/boolean/null/undefined/symbol</code></li><li>对象类型 : <code> object</code>（包括，数组、对象、函数等对象）</li></ol><h3 id="2-ts-新增的类型"><a href="#2-ts-新增的类型" class="headerlink" title="2 .  ts 新增的类型"></a>2 .  ts 新增的类型</h3><ol><li><ol><li>联合类型</li><li>自定义类型(类型别名)</li><li>接口</li><li>元组</li><li>字面量类型</li><li>枚举</li><li>void</li><li>any </li><li>unkown</li><li>等</li></ol></li></ol><p>注意：</p><ol><li>原始类型在 TS 和 JS 中写法一致</li><li>对象类型在 TS 中更加细化，每个具体的对象（比如: 数组、对象、函数…）都有自己的类型语法</li></ol><h2 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h2><p>直接使用</p><p><strong>语法: <code>let 变量 :  类型 = 值</code></strong></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// 数值类型</span><span class="token keyword">let</span> age<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">18</span><span class="token comment">// 字符串类型</span><span class="token keyword">let</span> myName<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">'小花'</span><span class="token comment">// 布尔类型</span><span class="token keyword">let</span> isLoading<span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token comment">// undefined</span><span class="token keyword">let</span> un<span class="token operator">:</span> <span class="token keyword">undefined</span> <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token comment">// null</span><span class="token keyword">let</span> timer<span class="token operator">:</span><span class="token keyword">null</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token comment">// symbol</span><span class="token keyword">let</span> uniKey<span class="token operator">:</span><span class="token builtin">symbol</span> <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h2><p>在 ts 中没有明确指定类型时, 有些时候 ts 会帮助推断类型 ,不用指定类型</p><p>会推断类型的两种情况:</p><ul><li>声明变量并初始化时</li><li>决定函数返回值时</li></ul><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// 变量 age 的类型被自动推断为：number</span><span class="token keyword">let</span> age <span class="token operator">=</span> <span class="token number">18</span><span class="token comment">// 函数返回值的类型被自动推断为：number</span><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span>num1<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> num2<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> num1 <span class="token operator">+</span> num2<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为什么 vscode 上写 ts 代码有类型推论 </p><p>vscode 和 ts 都是微软的, 两者直接高度集成</p><h2 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h2><p><strong>语法 :</strong> <code>let 变量: 类型1 | 类型2 | 类型3 .... = 初始值</code></p><p><strong>解释：</strong><code>|</code>（竖线）在 TS 中叫做<strong>联合类型</strong>，即：由两个或多个其他类型组成的类型，表示可以是这些类型中的任意一种</p><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p><strong>type</strong>  关键字</p><p><strong>作用:</strong></p><ul><li>给类型取别名</li><li>定义一个新的类型</li></ul><p><strong>语法 :</strong> <code>type 别名 = 类型</code></p><p>搭配联合类型使用</p><p><strong>语法 :</strong> <code>type 别名 = 类型 | 类型1 | 类型2</code></p><h2 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h2><p><strong>两种定义格式</strong></p><p><strong>语法1 :</strong>   <code> let 变量 : 类型[ ] = [ 值...]</code></p><p><strong>语法2 :</strong>   <code> let 变量 : Array&lt;类型&gt; = [ 值...]</code></p><h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><h3 id="函数的类型"><a href="#函数的类型" class="headerlink" title="函数的类型"></a>函数的类型</h3><p>函数涉及的类型实际上指的是：**<code>函数参数</code><strong>和</strong><code>返回值</code>**的类型</p><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// 普通函数</span><span class="token keyword">function</span> <span class="token function">函数名</span><span class="token punctuation">(</span>形参<span class="token number">1</span>： 类型<span class="token operator">=</span>默认值， 形参<span class="token number">2</span>：类型<span class="token operator">=</span>默认值<span class="token punctuation">,</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token operator">:</span> 返回值类型 <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token comment">// 箭头函数</span><span class="token keyword">const</span> 函数名（形参<span class="token number">1</span>： 类型<span class="token operator">=</span>默认值， 形参<span class="token number">2</span>：类型<span class="token operator">=</span>默认值<span class="token punctuation">,</span> <span class="token operator">...</span><span class="token punctuation">)</span><span class="token operator">:</span>返回值类型 <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="type-自定义类型简化"><a href="#type-自定义类型简化" class="headerlink" title="type 自定义类型简化"></a>type 自定义类型简化</h3><p><code>type Fn = (参数:类型,参数2:类型)=&gt;类型</code></p><h2 id="函数的返回值类型-void"><a href="#函数的返回值类型-void" class="headerlink" title="函数的返回值类型 void"></a>函数的返回值类型 void</h2><p>**如果一个函数没有返回值 在js中是 undefined , 在ts中需要约定void **</p><h3 id="约定-void-类型-的三种情况"><a href="#约定-void-类型-的三种情况" class="headerlink" title="约定 void 类型 的三种情况"></a>约定 void 类型 的三种情况</h3><ul><li>函数没有返回值 （没有return 没有值）</li><li>返回 undefined</li><li>只有 return 没有值</li></ul><h3 id="函数的可选参数"><a href="#函数的可选参数" class="headerlink" title="函数的可选参数"></a>函数的可选参数</h3><p>调用时可以不传递的参数</p><p>例如：数组的 slice 方法，可以 <code>slice()</code> 也可以 <code>slice(1)</code> 还可以 <code>slice(1, 3)</code></p><p>语法 ： <code>function 函数名(形参1?： 类型， 形参2?：类型): 返回值类型 { }</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">mySlice</span><span class="token punctuation">(</span>start<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> end<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'起始索引：'</span><span class="token punctuation">,</span> start<span class="token punctuation">,</span> <span class="token string">'结束索引：'</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>注意：</strong> 必选参数要在可选参数之前</p><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p><strong>语法 ：</strong> <code>function 函数名(形参1：类型=默认值， 形参2：类型=默认值): 返回值类型 { }</code></p><p>默认和可选参数不能一起使用</p><h2 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h2><p><strong>定义对象的语法 :</strong></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> 对象名<span class="token operator">:</span> <span class="token punctuation">{</span>  属性名<span class="token number">1</span>：类型<span class="token number">1</span>，  属性名<span class="token number">2</span>：类型<span class="token number">2</span>，  <span class="token function">方法名1</span><span class="token punctuation">(</span>形参<span class="token number">1</span><span class="token operator">:</span> 类型<span class="token number">1</span>，形参<span class="token number">2</span><span class="token operator">:</span> 类型<span class="token number">2</span><span class="token punctuation">)</span>： 返回值类型<span class="token punctuation">,</span>  <span class="token function-variable function">方法名2</span><span class="token operator">:</span><span class="token punctuation">(</span>形参<span class="token number">1</span><span class="token operator">:</span> 类型<span class="token number">1</span>，形参<span class="token number">2</span><span class="token operator">:</span> 类型<span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> 返回值类型<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span> 属性名<span class="token number">1</span><span class="token operator">:</span> 值<span class="token number">1</span>，属性名<span class="token number">2</span>：值<span class="token number">2</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>可选属性</strong> </p><p><code>const 对象名: {属性名1？：类型1，属性名2：类型2 } = { 属性名2：值2 }  </code></p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>当一个对象类型需要被多次使用, 两种方法</p><ul><li>type : 类型别名</li><li>interface : 接口</li></ul><h3 id="interface-使用"><a href="#interface-使用" class="headerlink" title="interface  使用"></a>interface  使用</h3><p>语法 :</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">接口名</span>  <span class="token punctuation">{</span>    属性<span class="token number">1</span><span class="token operator">:</span> 类型<span class="token number">1</span><span class="token punctuation">,</span> 属性<span class="token number">2</span><span class="token operator">:</span> 类型<span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注意 : 接口名 要 <code>I </code>(<code>大写I </code>)开头</p><h3 id="接口和类型的区别"><a href="#接口和类型的区别" class="headerlink" title="接口和类型的区别"></a>接口和类型的区别</h3><p>interface（接口）和 type（类型别名）的对比：</p><ul><li>相同点：都可以给对象指定类型</li><li>不同点:<ul><li>接口，只能为对象指定类型。它可以继承。</li><li>类型别名，不仅可以为对象指定类型，实际上可以为任意类型指定别名</li></ul></li></ul><p>推荐：<strong>能使用 type 就用 type</strong></p><h3 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h3><p><strong>两个接口之间有相同的属性或者方法, 可以通过继承实现</strong></p><h3 id="继承的实现-extends-关键字"><a href="#继承的实现-extends-关键字" class="headerlink" title="继承的实现 extends 关键字"></a>继承的实现 extends 关键字</h3><p>语法 : <code>interface 接口2 extends 接口1 {属性： 类型}</code></p><p>继承后 , 接口2 ,会拥有 接口1 的所有属性</p><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>是一个特殊的数字</p><p>两个特殊点</p><ul><li>约定了个数</li><li>约定了每个数字所对应的类型</li></ul><p>语法 : <code>[类型,类型]</code></p><p><strong>React 中 <code>useState()</code> 的返回值类型就是一个元组</strong></p><h2 id="字面量类型"><a href="#字面量类型" class="headerlink" title="字面量类型"></a>字面量类型</h2><p>const 定义出来的字符串或者数字, 或者正则 都是字面量类型</p><p>任意一个字面量都可以当有个类型来使用</p><h3 id="字面量的作用"><a href="#字面量的作用" class="headerlink" title="字面量的作用"></a>字面量的作用</h3><p>单个字面量没有什么用处，它一般和<strong>联合类型</strong> 一起使用， 用来表示一组明确的可选值列表。</p><p>例如：约定 Gender类型只能取girl和boy这两个字符串其中之一。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Gender</span> <span class="token operator">=</span> <span class="token string">'girl'</span> <span class="token operator">|</span> <span class="token string">'boy'</span><span class="token keyword">let</span> g1<span class="token operator">:</span> Gender <span class="token operator">=</span> <span class="token string">'girl'</span> <span class="token comment">// 正确</span><span class="token keyword">let</span> g2<span class="token operator">:</span> Gender <span class="token operator">=</span> <span class="token string">'boy'</span> <span class="token comment">// 正确</span><span class="token keyword">let</span> g3<span class="token operator">:</span> Gender <span class="token operator">=</span> <span class="token string">'man'</span> <span class="token comment">// 错误</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>应用场景: </p><ol><li>redux 中 ActionType 的设置可以使用 字面量配合组合类型使用</li><li>游戏中，游戏的方向键值只能是上、下、左、右中的任意一个<ul><li>解释：参数 direction 的值只能是 up/down/left/right 中的任意一个</li><li>优势：相比于 string 类型，使用字面量类型更加精确、严谨</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;TS语法以及类型&quot;&gt;&lt;a href=&quot;#TS语法以及类型&quot; class=&quot;headerlink&quot; title=&quot;TS语法以及类型&quot;&gt;&lt;/a&gt;TS语法以及类型&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/iamswr/ts_react_de</summary>
      
    
    
    
    <category term="前端开发" scheme="https://gaofeng-lin.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="JavaScript" scheme="https://gaofeng-lin.github.io/tags/JavaScript/"/>
    
    <category term="Typescript" scheme="https://gaofeng-lin.github.io/tags/Typescript/"/>
    
  </entry>
  
  <entry>
    <title>前端语法+基础知识</title>
    <link href="https://gaofeng-lin.github.io/posts/43285/"/>
    <id>https://gaofeng-lin.github.io/posts/43285/</id>
    <published>2022-05-31T16:00:00.000Z</published>
    <updated>2022-07-23T02:50:34.630Z</updated>
    
    <content type="html"><![CDATA[<h2 id="javascript、ES6查漏补缺网址"><a href="#javascript、ES6查漏补缺网址" class="headerlink" title="javascript、ES6查漏补缺网址"></a>javascript、ES6查漏补缺网址</h2><p><a href="%5Bhttps%5D(https://wangdoc.com)">链接</a></p><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><span id="more"></span><h3 id="TS类型"><a href="#TS类型" class="headerlink" title="TS类型"></a>TS类型</h3><p>详见TS与JS区别</p><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p><strong>总结</strong><br>在来看一遍 箭头函数 与 普通函数，除了写法上的区别</p><blockquote><p>1、箭头函数没有自己的this。箭头函数会捕获其所在上下文的 this 值，作为自己的 this 值。<br>2、箭头函数 this不可变。call()、apply()、bind()、这些方法也 无法改变 箭头函数 this 的指向。<br>3、箭头函数 不能用 new关键字来实例化对象，不然会报错。<br>4、箭头函数没有arguments对象。</p></blockquote><p>可以看出，最重要的区别还是 在 this 上，所以要想用好 箭头函数，还是要对 this 有一定认识的。</p><p>箭头函数本质还是函数，我们来看看他与JavaScript中普通函数的区别，先看看写法上的区别。<br><img src="https://img-blog.csdnimg.cn/2b6243000b0d48f69f6baf1e77293818.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>解释</strong><br>写箭头函数，我们记住一个顺序就好，参数、箭头、函数体、这个顺序记住就足够了，参数、箭头、函数体、这三个是必须的，函数名可以没有，但这三项必须有，一些简写的方式也是简写这三项里的东西。</p><p><strong>简写</strong><br>1、只有一个参数时，() 可省略</p><pre class="line-numbers language-none"><code class="language-none">//不简写var demo = (x) =&gt;{    console.log(x);}//简写var demo = x =&gt;{    console.log(x);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2、函数体只有一句时， {} 可以省略</p><pre class="line-numbers language-none"><code class="language-none">//不简写var demo = (x) =&gt;{    console.log(x);}//简写var demo = x =&gt; console.log(x);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3、函数体只有一条返回语句时，{} 和 return 都可以省略</p><pre class="line-numbers language-none"><code class="language-none">//不简写var demo = (x) =&gt; {     return x;}//简写var demo = (x) =&gt; x;   //注意别写成这样  var demo = (x) =&gt;{ x };  //或者 这样  var demo = (x) =&gt; return  x;  //要省略就都省略，不省略就都不省，别省一半,不然会出错的。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意：</strong><br>箭头函数放 参数 的地方就在 () 内，<br>没有参数，() 必须写，<br>一个参数，() 可写可不写，<br>多个参数，() 必须写。</p><p>箭头函数放 函数体 的地方在 {}内，<br>函数体 就 一句 {} 可写可不写，<br>函数体 不止一句，{} 必须写。</p><p>如果不知道，() {} 写不写，该不该省略，那就写，写了不会错。</p><p><strong>箭头函数 如果要返回一个对象，要简写的话， 需要用()包住这个对象</strong></p><pre class="line-numbers language-none"><code class="language-none">//不简写var demo = () =&gt;{     return {x:1};}  //简写var demo = () =&gt;({x:1});<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为什么会这样？因为如果不加 () ，那{ } 就表示的是语法块，不是表示一个对象，而加上()，按照规范来说，() 里面 { } 就会被解析为对象了。</p><p>对于 {x:1} 这个情况，他不仅可以表示一个对象，这个对象有个x属性，值为1，也可以表示为语法块中含有 名为 x 的 label，忘记 label语法的话，可以看<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/label">这里</a><br>如果不是很明白，可以看看这个<a href="https://www.zhihu.com/question/40902815">回答</a>，应该会理解的更加深刻。<br>所以这也解释了为什么会出现下面代码中的情况</p><pre class="line-numbers language-none"><code class="language-none">// 不报错var demo = () =&gt;{x:1};// 报错var demo = (y) =&gt;{y,x:1};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>对象的方法用 箭头函数写时，this 的指向 可能和你想的不一样</strong></p><pre class="line-numbers language-none"><code class="language-none">window.name='window';var obj = {    name:'obj',    show_name:() =&gt;{        console.log(this.name);    }    }obj.show_name(); //window<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>JavaScript使用的是函数作用域，在上面这段代码中对象的括号是不能封闭作用域的，所以此时的this还是指向window。<br>我们换成普通函数看看</p><pre class="line-numbers language-none"><code class="language-none">window.name='window';var obj = {    name:'obj',    show_name: function (){        console.log(this.name);    }    }obj.show_name();  //obj<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>换成普通函数，this 就不是指向window，而是指向 obj 对象了</p><p>箭头函数 与 普通函数 其他的区别</p><blockquote><p>1、箭头函数没有自己的this。箭头函数会捕获其所在上下文的 this 值，作为自己的 this 值。<br> 2、箭头函数 this不可变。call()、apply()、bind()、这些方法也 无法改变 箭头函数 this 的指向。<br>  3、箭头函数 不能用 new关键字来实例化对象，不然会报错。<br>  4、箭头函数没有arguments对象。</p></blockquote><p>1、箭头函数没有自己的this。箭头函数会捕获其所在上下文的 this 值，作为自己的 this 值。</p><pre class="line-numbers language-none"><code class="language-none">window.name = 'window';var obj = {    name:'obj',    show_name:function (){        function fn (){            console.log(this.name);        }        fn();    },}obj.show_name();  // window<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>声明一个 obj 对象，有一个name属性 与 show_name方法，上面这段代码，我的本意是想显示 obj对象的name， 但是没和我想的一样，一般我们会用 一个变量 self 或者 that 之类的留住this,像这样</p><pre class="line-numbers language-none"><code class="language-none">window.name = 'window';var obj = {    name:'obj',    show_name:function (){        //留住this        var that = this;        function fn (){            console.log(that.name);        }        fn();    },}obj.show_name();  //obj<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通常来说，箭头函数内部的this就是外层代码块的this</p><pre class="line-numbers language-none"><code class="language-none">window.name = 'window';var obj = {    name:'obj',    show_name:function (){        var fn = () =&gt; {            console.log(this.name);        }        fn();    },}obj.show_name(); //obj<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2、箭头函数 this 不可变。call()、apply()、bind()、这些方法也 无法改变 箭头函数 this 的指向。</p><pre class="line-numbers language-none"><code class="language-none">window.name = 'window';var obj = {    name:'obj',}function show_name(){    //这里 show_name 是一个普通的全局函数，所以他的this指window    console.log(this.name);}//用了 call 方法，把 show_nam 的this 指向了 obj 对象show_name.call(obj);  //obj<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>箭头函数 this 不可变</p><pre class="line-numbers language-none"><code class="language-none">window.name = 'window';var obj = {    name:'obj',}var show_name = () =&gt; {    //这里 show_name 是箭头函数，他的this指window，并且不会变    console.log(this.name);}//用了 call 方法，但是 this 没变，所以打印了 windowshow_name.call(obj);  //window<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3、箭头函数 不能用 new 关键字来实例化对象，不然会报错，箭头函数的this 不可变，new 也改变不了 this的 指向，而且更为重要的是，箭头函数内部并没有 [[Construct]] 方法，所以会没有原型属性（prototype），所以箭头函数没法当构造函数。</p><p><img src="https://img-blog.csdnimg.cn/7803115884ae4f6ab5f8d4cd73cfe038.png" alt="在这里插入图片描述"><br>4、箭头函数没有arguments对象，不能通过arguments对象访问传入参数，但是可以用rest参数实现<br>。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Rest_parameters">不了解的看这里</a></p><pre class="line-numbers language-none"><code class="language-none">var demo = (...theArgs) =&gt; theArgs;demo(1,2,3); //[1,2,3]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="链判断运算符"><a href="#链判断运算符" class="headerlink" title="链判断运算符"></a>链判断运算符</h3><p>作用：当访问一个对象属性是用来判断对 象 是 否 存 在<br>为什么要判断？？？？？<br>在项目中如果你不去判断对象是否存在在去访问属性，项目就崩了</p><p><strong>在es5要这样判断</strong></p><pre class="line-numbers language-none"><code class="language-none">const userName = Obj &amp;&amp;Obj.userInfo &amp;&amp; Obj.userInfo.userName ；//这样判断是不是很繁琐<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>es6写法</strong></p><pre class="line-numbers language-none"><code class="language-none">const userName = Obj?.userInfo?.userName;  //对比上面少了一大串<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>在es5的是否我们经常使用”||” 来设置默认值</strong></p><pre class="line-numbers language-none"><code class="language-none">let a = a.name || 'default'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>es6提供了null判断符 ？ ？ 两个问号来判断，只有当左边的值为null、undefined右边的值才会生效</strong></p><pre class="line-numbers language-none"><code class="language-none">let a = undefined ?? 'default'let a2 = null ?? 'default';console.log(a); //defaultconsole.log(a2); //default<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="扩展运算符-三个点"><a href="#扩展运算符-三个点" class="headerlink" title="扩展运算符-三个点"></a>扩展运算符-三个点</h3><h4 id="对象的扩展运算"><a href="#对象的扩展运算" class="headerlink" title="对象的扩展运算"></a>对象的扩展运算</h4><p>对象中的扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中</p><pre class="line-numbers language-none"><code class="language-none">let bar = { a: 1, b: 2 };let baz = { ...bar }; // { a: 1, b: 2 }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上述方法实际上等价于:</p><pre class="line-numbers language-none"><code class="language-none">let bar = { a: 1, b: 2 };let baz = Object.assign({}, bar); // { a: 1, b: 2 }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</p><p>Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。**(如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性)。**</p><p>同样，如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。</p><pre class="line-numbers language-none"><code class="language-none">let bar = {a: 1, b: 2};let baz = {...bar, ...{a:2, b: 4}};  // {a: 2, b: 4}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>利用上述特性就可以很方便的修改对象的部分属性。在redux中的reducer函数规定必须是一个纯函数（如果不是很清楚什么是纯函数的可以参考这里），reducer中的state对象要求不能直接修改，可以通过扩展运算符把修改路径的对象都复制一遍，然后产生一个新的对象返回。</p><p>这里有点需要注意的是扩展运算符对对象实例的拷贝属于一种浅拷贝。肯定有人要问什么是浅拷贝？我们知道javascript中有两种数据类型，分别是基础数据类型和引用数据类型。基础数据类型是按值访问的，常见的基础数据类型有Number、String、Boolean、Null、Undefined，这类变量的拷贝的时候会完整的复制一份；引用数据类型比如Array，在拷贝的时候拷贝的是对象的引用，当原对象发生变化的时候，拷贝对象也跟着变化，比如：</p><pre class="line-numbers language-none"><code class="language-none">let obj1 = { a: 1, b: 2};let obj2 = { ...obj1, b: '2-edited'};console.log(obj1); // {a: 1, b: 2}console.log(obj2); //  {a: 1, b: "2-edited"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上面这个例子扩展运算符拷贝的对象是基础数据类型，因此对obj2的修改并不会影响obj1，如果改成这样：</p><pre class="line-numbers language-none"><code class="language-none">let obj1 = { a: 1, b: 2, c: {nickName: 'd'}};let obj2 = { ...obj1};obj2.c.nickName = 'd-edited';console.log(obj1); // {a: 1, b: 2, c: {nickName: 'd-edited'}}console.log(obj2); // {a: 1, b: 2, c: {nickName: 'd-edited'}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里可以看到，对obj2的修改影响到了被拷贝对象obj1，原因上面已经说了，因为obj1中的对象c是一个引用数据类型，拷贝的时候拷贝的是对象的引用。</p><h4 id="数组的扩展运算"><a href="#数组的扩展运算" class="headerlink" title="数组的扩展运算"></a>数组的扩展运算</h4><p>1.可以将数组转换为参数序列</p><pre class="line-numbers language-none"><code class="language-none">function add(x, y) {  return x + y;}const numbers = [4, 38];add(...numbers) // 42<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.可以复制数组</p><p>如果直接通过下列的方式进行数组复制是不可取的：</p><pre class="line-numbers language-none"><code class="language-none">const arr1 = [1, 2];const arr2 = arr1;arr2[0] = 2;arr1 // [2, 2]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>原因上面已经介绍过，用扩展运算符就很方便：</p><pre class="line-numbers language-none"><code class="language-none">const arr1 = [1, 2];const arr2 = [...arr1];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>还是记住那句话：<strong>扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中</strong>，这里参数对象是个数组，数组里面的所有对象都是基础数据类型，将所有基础数据类型重新拷贝到新的数组中。</p><p>3.扩展运算符可以与解构赋值结合起来，用于生成数组</p><pre class="line-numbers language-none"><code class="language-none">const [first, ...rest] = [1, 2, 3, 4, 5];first // 1rest  // [2, 3, 4, 5]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</strong></p><pre class="line-numbers language-none"><code class="language-none">const [...rest, last] = [1, 2, 3, 4, 5];// 报错const [first, ...rest, last] = [1, 2, 3, 4, 5];// 报错<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>扩展运算符还可以将字符串转为真正的数组</p><pre class="line-numbers language-none"><code class="language-none">[...'hello']// [ "h", "e", "l", "l", "o" ]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>比较常见的应用是可以将某些数据结构转为数组,比如：</p><pre class="line-numbers language-none"><code class="language-none">// arguments对象function foo() {  const args = [...arguments];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="控制台输出为输出内容为-object-Object"><a href="#控制台输出为输出内容为-object-Object" class="headerlink" title="控制台输出为输出内容为[object Object]"></a>控制台输出为输出内容为[object Object]</h3><p><a href="https://www.jianshu.com/p/d309d25789fd">原文链接</a></p><p><strong>解决方法：删掉其它字符（’+’这种符号），直接输出对象</strong></p><p><strong>问题原因：</strong></p><ol><li>加号的作用<br>首先，我们的代码中有+（加号）运算符，它在这种情况下（字符串 + 其它什么东西），会调用toString()方法，将其它类型的东西转化为字符串，再和原始字符串拼接成一个字符串；</li><li>toString()从哪里来，干了什么？</li></ol><ul><li>除了null和undefined之外，其他的类型(数值、布尔、字符串、对象)都有toString()方法，它返回相应值的字符串表现(并不修改原变量)。</li><li>每个对象都有一个toString()方法。</li><li>当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。</li><li>默认情况下，toString()方法被每个Object对象继承。如果此方法在自定义对象中未被覆盖，toString()返回 “[object type]”，其中type是对象的类型。</li></ul><p>而在上述项目中，res正是我们自定义的对象，所以res.toString()的结果为[object Object]，所以console.log(‘res:’ + res)的结果为res: [object Object]。</p><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="forEach-遍历"><a href="#forEach-遍历" class="headerlink" title="forEach 遍历"></a>forEach 遍历</h4><p>forEach 接收一个函数作为参数，在遍历每一项的时候，这个函数会被调用，同时将当前遍历到的项、当前项的下标（索引)、遍历的数组作为函数参数传递过来。</p><pre class="line-numbers language-none"><code class="language-none">var arr = ['第一项', '第二项', '第三项', '第四项', '第五项'];arr.forEach(function(item, index, arr) {  console.log('第' + (index + 1) + '项的值是：' + item);});<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p><a href="https://blog.csdn.net/wangdan_2013/article/details/78316844">原文链接</a></p><pre class="line-numbers language-none"><code class="language-none">let numbers = [1, 5, 10, 15];let doubles = numbers.map((x) =&gt; {   return x * 2;});// doubles is now [2, 10, 20, 30]// numbers is still [1, 5, 10, 15]let numbers = [1, 4, 9];let roots = numbers.map(Math.sqrt);// roots is now [1, 2, 3]// numbers is still [1, 4, 9]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>语法</strong></p><pre class="line-numbers language-none"><code class="language-none">let array = arr.map(function callback(currentValue, index, array) {     // Return element for new_array }[, thisArg])//currentValue，数组中正在处理的当前元素。//index，数组中正在处理的当前元素的索引。//array，map 方法被调用的数组。//thisArg可选的。执行 callback 函数时 使用的this 值。//返回值：一个新数组，每个元素都是回调函数的结果。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>描述</strong><br>map 方法会给原数组中的每个元素都按顺序调用一次 callback 函数。callback 每次执行后的返回值（包括 undefined）组合起来形成一个新数组。 callback 函数只会在有值的索引上被调用；那些从来没被赋过值或者使用 delete 删除的索引则不会被调用。</p><p>callback 函数会被自动传入三个参数：数组元素，元素索引，原数组本身。</p><p>如果 thisArg 参数有值，则每次 callback 函数被调用的时候，this 都会指向 thisArg 参数上的这个对象。如果省略了 thisArg 参数,或者赋值为 null 或 undefined，则 this 指向全局对象 。</p><p>map 不修改调用它的原数组本身（当然可以在 callback 执行时改变原数组）。</p><p>使用 map 方法处理数组时，数组元素的范围是在 callback 方法第一次调用之前就已经确定了。在 map 方法执行的过程中：原数组中新增加的元素将不会被 callback 访问到；若已经存在的元素被改变或删除了，则它们的传递到 callback 的值是 map 方法遍历到它们的那一时刻的值；而被删除的元素将不会被访问到。</p><p><strong>更多用法见原文</strong></p><h4 id="增减数组项"><a href="#增减数组项" class="headerlink" title="增减数组项"></a>增减数组项</h4><p><strong>慕课网javascript</strong></p><h4 id="Arrays-from"><a href="#Arrays-from" class="headerlink" title="Arrays.from"></a>Arrays.from</h4><p>先说下<strong>类数组</strong><br>类数组并不是数组，而是长得像数组的对象。</p><pre class="line-numbers language-none"><code class="language-none">var fakeArray = {  0: '第一项',  1: '第二项',  3: '第三项',  length: 3,};console.log(fakeArray[0]); // 输出："第一项"console.log(fakeArray.length); // 输出：3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>但是我们不能直接使用数组的方法，需要先把类数组转化为数组,用的就是Arrays.from</strong></p><p>功能：</p><ol><li>类数组转化为数组</li><li>从字符串生成数组</li><li>从Set生成数组</li><li>从Map生成数组</li></ol><p>具体使用见慕课网ES6</p><h4 id="判断数组是否为空"><a href="#判断数组是否为空" class="headerlink" title="判断数组是否为空"></a>判断数组是否为空</h4><pre class="line-numbers language-none"><code class="language-none">var arr = [];if(Array.isArray(arr) &amp;&amp; arr.length === 0){    console.log('是空数组');}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="数组是否存在某个值"><a href="#数组是否存在某个值" class="headerlink" title="数组是否存在某个值"></a>数组是否存在某个值</h4><p><a href="https://segmentfault.com/a/1190000014202195">详细内容见原文</a></p><ol><li><p>array.indexOf<br>判断数组中是否存在某个值，如果存在返回数组元素的<strong>下标</strong>，否则返回-1</p><pre class="line-numbers language-none"><code class="language-none">let arr = ['something', 'anything', 'nothing', 'anything'];let index = arr.indexOf('nothing');# 结果：2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>array.includes(searchElement[, fromIndex])</p><pre class="line-numbers language-none"><code class="language-none">let numbers = [12, 5, 8, 130, 44];let result = numbers.includes(8);# 结果： trueresult = numbers.includes(118);# 结果： false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h4 id="判断对象是否为空"><a href="#判断对象是否为空" class="headerlink" title="判断对象是否为空"></a>判断对象是否为空</h4><ol><li><p>1.通过JSON自带的stringify()方法来判断</p><pre class="line-numbers language-none"><code class="language-none">   function isEmptyObj(obj) {    return JSON.stringify(obj) === '{}'    }console.log('对象是否为空：', isEmptyObj({}))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>使用ES6的Object.keys()方法</p><pre class="line-numbers language-none"><code class="language-none">function isEmptyObj(obj) {    return Object.keys(obj).length === 0}console.log('对象是否为空：', isEmptyObj({}))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>for in 循环判断</p><pre class="line-numbers language-none"><code class="language-none">function isEmptyObj(obj) {    for(let item in obj) {        return true    }    return false}    console.log('对象是否为空：', isEmptyObj({}))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="Object-create-创建实例对象"><a href="#Object-create-创建实例对象" class="headerlink" title="Object.create() 创建实例对象"></a>Object.create() 创建实例对象</h4><p><strong>原文见网道</strong><br>构造函数作为模板，可以生成实例对象。但是，有时拿不到构造函数，只能拿到一个现有的对象。我们希望以这个现有的对象作为模板，生成新的实例对象，这时就可以使用Object.create()方法。</p><pre class="line-numbers language-none"><code class="language-none">var person1 = {  name: '张三',  age: 38,  greeting: function() {    console.log('Hi! I\'m ' + this.name + '.');  }};var person2 = Object.create(person1);person2.name // 张三person2.greeting() // Hi! I'm 张三.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码中，对象person1是person2的模板，后者继承了前者的属性和方法。</p><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><h3 id="同步、异步"><a href="#同步、异步" class="headerlink" title="同步、异步"></a>同步、异步</h3><p><strong>同步</strong> 行为通常指代码从上到下一行一行的顺序执行，后面的代码总是在前面的代码执行完成以后才会执行。</p><pre class="line-numbers language-none"><code class="language-none">let a, b;function foo() {    a = 1;}foo();b = a + 1;console.log(b); //2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>异步</strong> 行为则指代码并非按照顺序执行，后面的代码不一定总是在前面的代码执行完成以后才会执行。</p><pre class="line-numbers language-none"><code class="language-none">let a, b;function foo() {    a = 1;}setTimeout(foo, 1000); //1 秒以后再调用 foo()b = a + 1;console.log(b); //NaN<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><p>这里没有显式的调用 foo()，而是将函数名 foo 传递给 setTimeout，JavaScript 运行时在 1 秒以后会自动调用 foo()。</p></li><li><p>首先代码依然顺序执行，当执行到 setTimeout(foo, 1000); 时，JavaScript 主线程发现这是一个将要异步执行的任务，就会将 foo() 放入 任务队列 然后继续执行下面的同步代码 b = a + 1;，当 b = a + 1; 执行完毕，所有同步代码都被执行完成，此时 JavaScript 主线程再去 任务队列 中取出需要执行的任务来执行，也就是 1 秒后执行 foo()。</p></li><li><p>因为 b = a + 1; 先于 foo() 执行，所以这段异步操作执行后，变量 b 最终结果为 NaN。</p></li></ol><p>在 <strong>异步</strong> 操作示例中，<strong>setTimeout(foo, 1000)</strong>; 这句代码中的 <strong>foo</strong> 就可以被称作 回调函数。所谓 回调函数，就是被主线程放入到 任务队列 中的代码，这段代码通常以函数为单位，并且等到所有 同步 代码执行完成以后才会被执行。</p><p><strong>解决办法：</strong><br>所以上面的 <strong>异步</strong> 操作示例程序如果想得到与 <strong>同步</strong> 操作一样的结果，就得改成这样：</p><pre class="line-numbers language-none"><code class="language-none">let a, b;function foo() {    a = 1;    b = a + 1;    console.log(b); //2}setTimeout(foo, 1000); //1 秒以后再调用 foo()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为计算 b 的值时依赖 a 的值，而 a = 1; 是在 回调函数 中执行的，也就是说所有 同步 代码执行完成以后才会执行 回调函数 中的 异步 代码，所以 b = a + 1; 也要移动到 回调函数 中。回调函数 中的代码也是顺序执行的，所以 b = a + 1; 语句要放在 a = 1; 语句之后。这样就能使变量 b 最终结果为 2</p><h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3><p><a href="https://blog.csdn.net/qq_37860963/article/details/81539118?spm=1001.2101.3001.6650.8&amp;depth_1-utm_relevant_index=11">原文链接</a></p><pre class="line-numbers language-none"><code class="language-none">var isLiForget = false; //给一个布尔值判断小丽有没有忘记小花的生日var getCloth = new Promise(function(resolve,reject){    if(!isLiForget){ //没忘记        var cloth = {            color:'red',            price:'$120'        };        resolve(cloth); // 得到衣服    }else{        var err = new Error("forgot the promise"); //忘记了        reject(err);    }}); //之后就是调用Promise了var testFn = function(){    getCloth.then(function(fulfilled){        console.log(fulfilled);    }).catch(function(rejected){        console.log(rejected.message);    });}testFn();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于promise的理解</p><ol><li>resolve、reject会选择一个执行，这两个是调用这个对象的时候传过来的<strong>函数</strong></li><li>以上面代码为例。<code>resolve(cloth)</code>。resolve就是外面传过来的函数，其实就是``` function(fulfilled){<br> console.log(fulfilled);<br> <pre class="line-numbers language-这个函数不就是答应吗，参数cloth与fulfilled对应，就是打印cloth的值" data-language="这个函数不就是答应吗，参数cloth与fulfilled对应，就是打印cloth的值"><code class="language-这个函数不就是答应吗，参数cloth与fulfilled对应，就是打印cloth的值">3. 要调用或者获取promise里面的值，需要用到then。写发有点区别，不过逻辑就是正确执行这个函数，错误执行那个函数。具体可以看链接。### async/await取值（很重要！！）![t2.png](https://s2.loli.net/2022/06/17/e6wAUrRa3HQzdbV.png)![t3.png](https://s2.loli.net/2022/06/17/9pqnMu5TcPIDGli.png)**我要把opts这个值传给组件里面的option属性，opts是一个数组，数组的值如下图所示**![t1.png](https://s2.loli.net/2022/06/17/1w6SBlZx39PAgpK.png)之前的做法是把值赋给一个变量，然后传给需要用的地方，但是行不通，估计是异步的原因，**state**可以解决这个问题。**解决方法****用useState定义一个变量(Options)，然后用更新函数接(serOptions)收新的值，再把这个变量放到需要的位置(option属性)就好。**### async/await[原链接](https://blog.csdn.net/qq_46658751/article/details/123373909)#### async作用 函数返回的是一个 Promise 对象，即便是字符串，数值，也会包装成Promise对象<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>async function testAsync() {<br> return “hello async”;<br>}</li></ol><p>const result = testAsync();<br>console.log(result);</p><pre class="line-numbers language-none"><code class="language-none">![在这里插入图片描述](https://img-blog.csdnimg.cn/bd22592cd9fc45138b6cd8a70cbd50c6.png)#### await在等待什么await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值#### await等到要等的结果，之后呢？async 会将其后的函数（函数表达式或 Lambda）的返回值封装成一个 Promise 对象，而 await 会等待这个 Promise 完成，并将其 resolve 的结果返回出来。### 回调函数#### 用途**用途：一般情况下回调函数都用在页面与服务器的异步交互，以解决页面在提交请求后无法获得到服务器反馈的数据**为什么会出现面在提交请求后无法获得到服务器反馈的数据呢？首先来了解js的事件执行方式，如图![在这里插入图片描述](https://img-blog.csdnimg.cn/2020102020575826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY0OTIxMA==,size_16,color_FFFFFF,t_70#pic_center)js在执行程序时，所有代码都在执行栈中，此时都是同步在执行，但在运行代码时如果遇见事件绑定、计时器会将抛到异步任务队列里面等待js引擎执行，然后继续执行在执行栈中的代码，于此同时，被抛到异步执行队列里面的计时器会执行等待的时间，如果等待时间结束，则会将此事件抛到执行队列里面。执行栈里面的代码执行完成后，程序会去检查执行队列里面是否有事件，如果有，则拿出来执行。如果没有，则会一直循环检查，直到异步事件队列和执行队列里面都没有才结束程序#### 回调示例：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>var fs = require(“fs”);</p><p>function f(x) {<br>    console.log(x)<br>}</p><p>function writeFile(callback) { //callback，表示这个参数不是一个普通变量，而是一个函数<br>    fs.writeFile(‘input.txt’, ‘我是通过fs.writeFile 写入文件的内容’, function (err) {<br>        if (!err) {<br>            console.log(“文件写入完毕!”)<br>            c = 1<br>            callback(c) // 因为我们传进来的函数名是f()，所以此行相当于调用一次f(c)<br>        }<br>    });<br>}<br>var c = 0<br>writeFile(f) // 函数f作为一个参数传进writeFile函数</p><pre class="line-numbers language-none"><code class="language-none">1. 此处并不一定非要写为“callback”，你可以任意写成abc, iloveyou...等等随你高兴。callback只是一种约定俗成的写法，它明确地告诉代码阅读者：此处是一个回调函数。2. 在大多数编程语言中，函数的形参总是从外向内传递参数，但在JS中，如果形参碰到“关键字” callback 则完全相反，它表示从内向外反向调用某个外部函数。有时候，我们会看到一些函数的形参列表里直接嵌套一个函数的情况，其本质上仍然是回调函数，因为没有了函数名，所以也称**匿名函数**。如本例如果要写成这种风格的话就是长成这样了：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>var fs = require(“fs”);</p><p>function writeFile(callback) {<br>    fs.writeFile(‘input.txt’, ‘我是通过fs.writeFile 写入文件的内容’, function (err) {<br>        if (!err) {<br>            console.log(“文件写入完毕!”)<br>            c = 1<br>            callback(c)<br>        }<br>    });<br>}<br>var c = 0<br>writeFile(function (x) {<br>    console.log(x)<br>})</p><pre class="line-numbers language-none"><code class="language-none">### 获取异步函数返回值的方法在项目中会遇到通过ajax、setTimeout等异步操作向后台获取数据，而js自身不会等待数据拿到后再进行下一步操作，所以会导致其他函数无法获取异步操作函数内的数据。例如：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>function back(x,y){<br>    var ret;<br>    setTimeout(function(){<br>        ret = x + y;<br>    },1000)<br>    return ret;<br>};</p><p>console.log(back(10,20));    //undefined</p><pre class="line-numbers language-none"><code class="language-none">1. 回调函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>function back(x,y,callback){<br>    setTimeout(function(){<br>        var ret = x + y<br>        callback(ret)<br>    },1000)<br>}</p><p>back(10,20,function(a){<br>    //在这里面就可以进行对数据的操作了</p><pre><code>console.log(a)//a就是回调的结果，输出30</code></pre><p>})</p><pre class="line-numbers language-none"><code class="language-none">```function getSomething(cb) {    var r = 0;    setTimeout(function() {        r = 2;        cb(r)//回调函数    },10)}function compute(x) {    alert(x * 2);}getSomething(compute);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><p>通过promise的方式</p><pre class="line-numbers language-none"><code class="language-none">function getSomething() {    var r = 0;    return new Promise(function(resolve) {        setTimeout(function(){            r = 2;            resolve(r);        },10)    })}function compute(x) {    alert(x * 2);}getSomething().then(compute);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>通过async的方式</p><pre class="line-numbers language-none"><code class="language-none">function getSomething() {    var r = 0;    return new Promise(function(resolve) {        setTimeout(function() {            r = 2;            resolve(r);        },10)    })}async function compute() {    var x = await getSomething();    alert(x * 2);}compute();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>通过generator方式实现</p><pre class="line-numbers language-none"><code class="language-none">function getSomething() {    var r = 0;    setTimeout(function() {        r = 2;        it.next(r);    },10);}function *compute(it) {    var x = yield getSomething();    alert(x * 2);}var it = compute();it.next();//同步的写法实现异步的逻辑<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>通过promise和generator相结合的方式</p><pre class="line-numbers language-none"><code class="language-none">function getSomething() {    var r = 0;    return new Promise(function(resolve) {        setTimeout(function() {            r = 2;            resolve(r);        },10)    })}function *compute() {    var x = yield getSomething();    alert(x * 2);}var it = compute();it.next().value.then(function(value) {    it.next(value);})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><p><strong>AJAX（Asynchronous Javascript And XML）翻译成中文就是“异步的Javascript和XML”</strong><br><strong>实现前后端数据的交互</strong></p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.Ajax最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。 <span class="token punctuation">(</span>这一特点给用户的感受是在不知不觉中完成请求和响应过程<span class="token punctuation">)</span> <span class="token number">2</span>.Ajax不需要任何浏览器插件，但需要用户允许javaScript在浏览器上执行。同步交互: 客户端发出一个请求后，需要等待服务器响应结束后，才能发出第二个请求。异步交互: 客户端发出一个请求后，无需要等待服务器响应结束，就可以发出第二个请求。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Ajax使用JavaScript技术向服务器发送异步请求</p><p>Ajax请求无须刷新整个页面</p><p>因为服务器响应内容不再是整个页面，而是页面中的部分内容，所以Ajax性能高！</p><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p><img src="https://img-blog.csdnimg.cn/img_convert/a83d7857217f3e6d72b8fab68fb3adb9.gif#pic_center" alt="在这里插入图片描述"></p><h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><p><a href="%5Bhttps%5D(https://blog.csdn.net/a153375250/article/details/53434299)">原链接</a></p><h3 id="JSX是什么"><a href="#JSX是什么" class="headerlink" title="JSX是什么"></a>JSX是什么</h3><p>JSX是一种像下面这样的语法：</p><pre class="line-numbers language-none"><code class="language-none">const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>它是一种JavaScript语法扩展，在React中可以方便地用来描述UI。<br>质上，JSX为我们提供了创建React元素方法（React.createElement(component, props, …children)）的语法糖（syntactic sugar）。上面的代码实质上等价于：</p><pre class="line-numbers language-none"><code class="language-none">var element = React.createElement(  "h1",  null,  "Hello, world!");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="在JSX中使用JavaScript表达式"><a href="#在JSX中使用JavaScript表达式" class="headerlink" title="在JSX中使用JavaScript表达式"></a>在JSX中使用JavaScript表达式</h3><p>在JSX中插入JavaScript表达式十分简单，直接<strong>在JSX中将JS表达式用大括号括起来即可</strong>。例如：</p><pre class="line-numbers language-none"><code class="language-none">function formatName(user) {  return user.firstName + ' ' + user.lastName;}const user = {  firstName: 'Harper',  lastName: 'Perez'};const element = (  &lt;h1&gt;    Hello, {formatName(user)}!  &lt;/h1&gt;);ReactDOM.render(  element,  document.getElementById('root'));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码中用到了函数调用表达式fromatName(user)。</p><p>在JavaScript中，表达式就是一个短语，Javascript解释器会将其计算出一个结果，常量就是最简单的一类表达式。常用的表达式有：</p><ul><li>变量名；</li><li>函数定义表达式；</li><li>属性访问表达式；</li><li>函数调用表达式；</li><li>算数表达式；</li><li>关系表达式；</li><li>逻辑表达式；</li></ul><p>需要注意的是，if语句以及for循环不是JavaScript表达式，不能直接作为表达式写在{}中，但可以先将其赋值给一个变量（变量是一个JavaScript表达式）:</p><pre class="line-numbers language-none"><code class="language-none">function NumberDescriber(props) {  let description;  if (props.number % 2 == 0) {    description = &lt;strong&gt;even&lt;/strong&gt;;  } else {    description = &lt;i&gt;odd&lt;/i&gt;;  }  return &lt;div&gt;{props.number} is an {description} number&lt;/div&gt;;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="JSX属性值"><a href="#JSX属性值" class="headerlink" title="JSX属性值"></a>JSX属性值</h3><p>你可以使用引号将字符串字面量指定为属性值：<br><code>const element = &lt;div tabIndex="0"&gt;&lt;/div&gt;;</code><br><strong>注意这里的”0”是一个字符串字面量。</strong></p><p>或者你可以将一个JavaScript表达式嵌在一个大括号中作为属性值：<br><code>const element = &lt;img src={user.avatarUrl}&gt;&lt;/img&gt;;</code></p><p>这里用到的是JavaScript属性访问表达式，上面的代码将编译为：</p><p><code>const element = React.createElement("img", { src: user.avatarUrl });</code></p><h3 id="JSX的Children"><a href="#JSX的Children" class="headerlink" title="JSX的Children"></a>JSX的Children</h3><p>首先JSX可以是一个不包含Children的empty tag。如：</p><p><code>const element = &lt;img src={user.avatarUrl} /&gt;;</code></p><p>JSX也可以像HTML标签一样包含Children：</p><pre class="line-numbers language-none"><code class="language-none">const element = (  &lt;div&gt;    &lt;h1&gt;Hello!&lt;/h1&gt;    &lt;h2&gt;Good to see you here.&lt;/h2&gt;  &lt;/div&gt;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>后面一部分不是很重要，可看原文</strong><br>React自定义组件的chilren是不会像固有的HTML标签的子元素那样自动render的，我们看下面的例子：</p><pre class="line-numbers language-none"><code class="language-none">代码1class Test extends React.Component {    render() {      return (        &lt;div&gt;          Here is a list:          &lt;ul&gt;            &lt;li&gt;Item 1&lt;/li&gt;            &lt;li&gt;Item 2&lt;/li&gt;          &lt;/ul&gt;        &lt;/div&gt;      )     }};ReactDOM.render(    &lt;Test /&gt;,    document.getElementById('test'));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码定义的组件中都是build-in组件，类似div、p、ul、li等。它们中的子元素会直接render出来，像下面这样：</p><p><img src="http://wyuhao-img.oss-cn-shanghai.aliyuncs.com/img/blog_img/jsx/htmlrender.jpg" alt="在这里插入图片描述"></p><p>但是如果你使用用户定义组件，比如：</p><pre class="line-numbers language-none"><code class="language-none">class Test extends React.Component {    render() {      return (      &lt;Em&gt;        Here is a list:        &lt;ul&gt;          &lt;li&gt;Item 1&lt;/li&gt;          &lt;li&gt;Item 2&lt;/li&gt;        &lt;/ul&gt;      &lt;/Em&gt;    )     }};class Em extends React.Component {  render() {    return (&lt;div&gt;&lt;/div&gt;);  }}ReactDOM.render(    &lt;Test /&gt;,    document.getElementById('test'));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>并不能得到跟上面代码1一样的结果，我们得到的只是一个空的div标签：</p><p><img src="http://wyuhao-img.oss-cn-shanghai.aliyuncs.com/img/blog_img/jsx/userrender.jpg" alt="在这里插入图片描述"></p><p>如果你想得到和代码1一样的结果，需要显示地指定props.children，像下面这样：</p><pre class="line-numbers language-none"><code class="language-none">class Test extends React.Component {    render() {      return (          &lt;Em&gt;            Here is a list:            &lt;ul&gt;              &lt;li&gt;Item 1&lt;/li&gt;              &lt;li&gt;Item 2&lt;/li&gt;            &lt;/ul&gt;          &lt;/Em&gt;      )     }};class Em extends React.Component {  render() {    return (&lt;div&gt;{this.props.children}&lt;/div&gt;);  }}ReactDOM.render(    &lt;Test /&gt;,    document.getElementById('test'));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="JSX中的props"><a href="#JSX中的props" class="headerlink" title="JSX中的props"></a>JSX中的props</h3><p>指定JSX中的props有以下几种方式：</p><ol><li>使用JavaScript表达式</li></ol><p>任何有效的JavaScript表达式都可以作为prop的值，使用的时候将该表达式放在一对大括号中即可：</p><pre class="line-numbers language-none"><code class="language-none">&lt;MyComponent foo={1 + 2 + 3 + 4} /&gt;&lt;YourComponent clickTodo={(id) =&gt; this.props.handleClick(id)} /&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="2"><li>使用字符串字面量<br>字符串字面量可以作为prop值，下面的代码是等价的：</li></ol><pre class="line-numbers language-none"><code class="language-none">&lt;MyComponent message="hello world" /&gt;&lt;MyComponent message={'hello world'} /&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="3"><li>使用扩展运算符<br>如果你想将一个prop对象传入JSX，你可以使用扩展运算符…直接将整个prop对象传入。下面的2个组件是等价的：</li></ol><pre class="line-numbers language-none"><code class="language-none">function App1() {  return &lt;Greeting firstName="Ben" lastName="Hector" /&gt;;}function App2() {  const props = {firstName: 'Ben', lastName: 'Hector'};  return &lt;Greeting {...props} /&gt;;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>扩展运算符是一个es6特性。是一种传递属性的十分便利的方式。但请注意不要滥用该运算符，注意不要将一大堆毫不相关的prop一股脑全部传入下面的组件中。</p><h3 id="JSX中的Children"><a href="#JSX中的Children" class="headerlink" title="JSX中的Children"></a>JSX中的Children</h3><p>React组件中有一个特殊的prop–props.children。它指代了JSX表达式中开闭标签中包含的内容。</p><p>下面讨论的是几种指定JSX的children的方法：</p><p>(1)使用字符串字面量<br>(2)JSX元素作为children<br>(3)JavaScript表达式<br>(4)函数children</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>(1)使用JSX时要引入React库<br>(2)注意引入JSX中用到的自定义组件<br>(3)自定义组件首字母一定要大写<br>(4)元素标签名不能使用表达式<br>(5)设置style属性</p><p>在设置标签style属性的时候，要注意，我们是将一个描述style的对象以JavaScipt表达式的形式传入。因此应该有2层大括号：</p><pre class="line-numbers language-none"><code class="language-none">&lt;div style={{color:'red', margin:'10px auto'}}&gt;&lt;/div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="判断条件"><a href="#判断条件" class="headerlink" title="判断条件"></a>判断条件</h3><p>在react 组件return语句里面如果要使用判断语句，像下面这样。</p><pre class="line-numbers language-none"><code class="language-none">{judgeSchema(project)? (        &lt;div&gt;          &lt;Form1 schema={projtestParaHYPara}&gt;&lt;/Form1&gt;        &lt;/div&gt;    ):      null    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Dom"><a href="#Dom" class="headerlink" title="Dom"></a>Dom</h2><h3 id="Dom简介"><a href="#Dom简介" class="headerlink" title="Dom简介"></a>Dom简介</h3><p>DOM (Document Object Model，文档对象模型) 是 W3C 制定的访问、操作 HTML 和XML的标准。</p><p>DOM 节点是契合HTML标准的，可以对其细分：</p><p>整个文档是一个文档节点<br>HTML 元素内的文本是文本节点<br>每个 HTML 元素是元素节点<br>每个 HTML 属性是属性节点<br>注释为注释节点</p><p><img src="http://img.mukewang.com/wiki/5e82d6a40942890d12001242.jpg" alt="在这里插入图片描述"></p><h3 id="获取与操作Dom"><a href="#获取与操作Dom" class="headerlink" title="获取与操作Dom"></a>获取与操作Dom</h3><p><strong>详细的可以看慕课网</strong></p><p>获取 DOM 节点的方式有很多，这里例举几个常用的，所有的 DOM 元素都具有以下方法：</p><p>element.getElementById<br>element.getElementByName<br>element.getElementsByTagName<br>element.getElementsByClassName<br>element.querySelector<br>element.querySelectorAll</p><h2 id="Npm"><a href="#Npm" class="headerlink" title="Npm"></a>Npm</h2><h3 id="查看包信息"><a href="#查看包信息" class="headerlink" title="查看包信息"></a>查看包信息</h3><p>方案一：<br><strong>直接看package.json，项目相关的都在里面</strong></p><p>方案二：</p><p>查看全局已安装（-g 的意思是 global 全局的意思）</p><pre class="line-numbers language-none"><code class="language-none">$ npm ls -g<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看当前项目已安装包（项目跟目录必须有 package.json 文件）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看包本版</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> view <span class="token operator">&lt;</span>packagename<span class="token operator">&gt;</span> versions --json<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同样也是会把所有包的依赖显示出来。同上，加上 –depth 0 就好了。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">ls</span> --depth <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果只想显示生产环境依赖的包</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">ls</span> --depth <span class="token number">0</span> --prod<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>只显示开发环境依赖的包</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">ls</span> --depth <span class="token number">0</span> --dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="npm-与-npx"><a href="#npm-与-npx" class="headerlink" title="npm 与 npx"></a>npm 与 npx</h3><p>在npm的基础之上，npx让npm包中的命令行工具和其他可执行文件在使用上变得更加简单。它极大地简化了我们之前使用纯粹的npm时所需要的大量步骤。</p><p><strong>区别1.一个永久存在，一个临时安装，用完后删除</strong></p><pre class="line-numbers language-none"><code class="language-none">npm install -g create-react-appcreate-react-app test-app<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">npx create-react-app test-app<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>npm他会在本地全局性的安装create-react-app，这个包会存储在node目录下面去。以后创建react项目直接执行create-react-app命令就可以了。<br>npx命令他会把create-react-app安装包临时安装上，等项目初始化完成以后，他就删除掉。</p><p><strong>npx 会帮你执行依赖包里的二进制文件</strong></p><p>执行webpack里面的文件 npm执行</p><pre class="line-numbers language-none"><code class="language-none">npm i -D webpack ./node_modules/.bin/webpack -v结果是：6.9.0或者执行npm i -D webpack`npm bin`/webpack -v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>npx执行</p><pre class="line-numbers language-none"><code class="language-none">npm i -D webpacknpx webpack -v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> npx 会自动查找当前依赖包中的可执行文件，如果找不到，就会去环境变量里面的 PATH 里找。如果依然找不到，就会帮你安装！</p><p><strong>区别3.npx可以执行文件，但是npm不可以</strong></p><h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p><a href="https://blog.csdn.net/weixin_48837605/article/details/119494467">原文链接</a></p><h3 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h3><p> 当一个请求url的<strong>协议,域名,端口</strong>三者之间任意一个与当前的url不同都即为跨域</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"> 当前页面url                  被请求页面url                是否跨域            原因http://www.test.com/    http://www.test.com/index.html    否            同源（协议、域名、端口号相同）http://www.test.com/    https://www.test.com/index.html   跨域          协议不同（http/https）http://www.test.com/    http://www.baidu.com/             跨域          主域名不同（test/baidu）http://www.test.com/    http://blog.test.com/             跨域          子域名不同（www/blog）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="为什么会出现跨域"><a href="#为什么会出现跨域" class="headerlink" title="为什么会出现跨域"></a>为什么会出现跨域</h3><p>出于浏览器的同源策略限制.同源策略是一种约定,它是浏览器最核心也是最基本的安全功能,如果缺少了同源策略,则浏览器的正常的功能可能会受到影响,跨域收是Web是构建在同源策略基础上的,浏览器只是针对同源策略的一种实现,同源策略会阻止一个域的JavaScript脚本和另一个域的内容进行交互,所谓同源(即指同一个域)就是两个页面具备同样的协议(protocol),主机(host)和端口号(port)</p><p><strong>请求是跨域的，并不一定会报错。普通的图片请求，css文件请求是不会报错的</strong></p><h3 id="跨域会阻止什么操作"><a href="#跨域会阻止什么操作" class="headerlink" title="跨域会阻止什么操作"></a>跨域会阻止什么操作</h3><p>浏览器是从两个方面去做这个同源策略的，一是针对接口的请求，二是针对Dom的查询</p><h4 id="1-阻止接口请求"><a href="#1-阻止接口请求" class="headerlink" title="1.阻止接口请求"></a>1.阻止接口请求</h4><p>比如用ajax从<a href="http://192.168.100.150:8020/%E5%AE%9E%E9%AA%8C/jsonp.html%E9%A1%B5%E9%9D%A2%E5%90%91http://192.168.100.150:8081/zhxZone/webmana/dict/jsonp%E5%8F%91%E8%B5%B7%E8%AF%B7%E6%B1%82%EF%BC%8C%E7%94%B1%E4%BA%8E%E4%B8%A4%E4%B8%AAurl%E7%AB%AF%E5%8F%A3%E4%B8%8D%E5%90%8C%EF%BC%8C%E6%89%80%E4%BB%A5%E5%B1%9E%E4%BA%8E%E8%B7%A8%E5%9F%9F%EF%BC%8C%E5%9C%A8console%E6%89%93%E5%8D%B0%E5%8F%B0%E4%BC%9A%E6%8A%A5No">http://192.168.100.150:8020/实验/jsonp.html页面向http://192.168.100.150:8081/zhxZone/webmana/dict/jsonp发起请求，由于两个url端口不同，所以属于跨域，在console打印台会报No</a> ‘Access-Control-Allow-Origin’ header is present on the requested resource<br><img src="https://img-blog.csdnimg.cn/20181207092232976.png#pic_center" alt="在这里插入图片描述"><br>值得说的是虽然浏览器禁止用户对请求返回数据的显示和操作，但浏览器确实是去请求了，如果服务器没有做限制的话会返回数据的，在调试模式的network中可以看到返回状态为200，且可看到返回数据<br><img src="https://img-blog.csdnimg.cn/20181207092757327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpYW56aGFuZzg2MQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20181207092820725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpYW56aGFuZzg2MQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h4 id="2-阻止dom获取和操作"><a href="#2-阻止dom获取和操作" class="headerlink" title="2.阻止dom获取和操作"></a>2.阻止dom获取和操作</h4><p>比如a页面中嵌入了iframe，src为不同源的b页面，则在a中无法操作b中的dom，也没有办法改变b中dom中的css样式。</p><p>而如果ab是同源的话是可以获取并操作的。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">&lt;</span>html<span class="token operator">&gt;</span><span class="token operator">&lt;</span>head<span class="token operator">&gt;</span><span class="token operator">&lt;</span>meta <span class="token assign-left variable">charset</span><span class="token operator">=</span><span class="token string">"UTF-8"</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span>title<span class="token operator">&gt;</span><span class="token operator">&lt;</span>/title<span class="token operator">&gt;</span><span class="token operator">&lt;</span>style <span class="token assign-left variable">type</span><span class="token operator">=</span><span class="token string">"text/css"</span><span class="token operator">&gt;</span>iframe<span class="token punctuation">{</span>width:100%<span class="token punctuation">;</span>height:800px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">&lt;</span>/style<span class="token operator">&gt;</span><span class="token operator">&lt;</span>/head<span class="token operator">&gt;</span><span class="token operator">&lt;</span>body<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">!</span>--<span class="token operator">&lt;</span>iframe <span class="token assign-left variable">src</span><span class="token operator">=</span><span class="token string">"http://192.168.100.150:8081/zhxZone/webmana/attachment/imageManager"</span> <span class="token assign-left variable">frameborder</span><span class="token operator">=</span><span class="token string">"0"</span> <span class="token assign-left variable">id</span><span class="token operator">=</span><span class="token string">"iframe"</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span>/iframe<span class="token operator">&gt;</span>--<span class="token operator">&gt;</span><span class="token operator">&lt;</span>iframe <span class="token assign-left variable">src</span><span class="token operator">=</span><span class="token string">"http://192.168.100.150:8020/实验/jsonp.html"</span> <span class="token assign-left variable">frameborder</span><span class="token operator">=</span><span class="token string">"0"</span> <span class="token assign-left variable">id</span><span class="token operator">=</span><span class="token string">"iframe"</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span>/iframe<span class="token operator">&gt;</span><span class="token operator">&lt;</span>script <span class="token assign-left variable">type</span><span class="token operator">=</span><span class="token string">"text/javascript"</span><span class="token operator">&gt;</span>var <span class="token assign-left variable">i</span><span class="token operator">=</span>document.getElementById<span class="token punctuation">(</span><span class="token string">"iframe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i.onload<span class="token operator">=</span><span class="token function-name function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>/*console.log<span class="token punctuation">(</span>i.contentDocument<span class="token punctuation">)</span>console.log<span class="token punctuation">(</span>i.contentWindow.document.getElementById<span class="token punctuation">(</span><span class="token string">"text"</span><span class="token punctuation">)</span>.innerHTML<span class="token punctuation">)</span>*/var <span class="token assign-left variable">b</span><span class="token operator">=</span>i.contentWindow.document.getElementsByTagName<span class="token punctuation">(</span><span class="token string">"body"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>i.contentWindow.document.getElementById<span class="token punctuation">(</span><span class="token string">"text"</span><span class="token punctuation">)</span>.style.background<span class="token operator">=</span><span class="token string">"gray"</span><span class="token punctuation">;</span>i.contentWindow.document.getElementById<span class="token punctuation">(</span><span class="token string">"text"</span><span class="token punctuation">)</span>.innerHTML<span class="token operator">=</span><span class="token string">"111"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">&lt;</span>/script<span class="token operator">&gt;</span><span class="token operator">&lt;</span>/body<span class="token operator">&gt;</span><span class="token operator">&lt;</span>/html<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>改变了iframe中的元素 </p><p><img src="https://img-blog.csdnimg.cn/8b0167fa9e5647359acc6466b8e421bd.png" alt="在这里插入图片描述"></p><p>甚至是可以获取iframe中的cookie</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">var <span class="token assign-left variable">i</span><span class="token operator">=</span>document.getElementById<span class="token punctuation">(</span><span class="token string">"iframe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i.onload<span class="token operator">=</span><span class="token function-name function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>console.log<span class="token punctuation">(</span>i.contentDocument.cookie<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/681d3b6bcb6d4b039578fc23e6de073b.png" alt="在这里插入图片描述"></p><p>不用说也知道这是极为危险的，所以浏览器才会阻止非同源操作dom</p><p>浏览器的这个限制虽然不能保证完全安全，但是会增加攻击的困难性</p><p>虽然安全机制挺好，可以抵御坏人入侵，但有时我们自己需要跨域请求接口数据或者操作自己的dom，也被浏览器阻止了，所以就需要跨域</p><p>跨域的前提肯定是你和服务器是一伙的，你可以控制服务器返回的数据，否则跨域是无法完成的 </p><h3 id="解决跨域的方法"><a href="#解决跨域的方法" class="headerlink" title="解决跨域的方法"></a>解决跨域的方法</h3><h4 id="前端jsp"><a href="#前端jsp" class="headerlink" title="前端jsp"></a>前端jsp</h4><h4 id="CORS方案"><a href="#CORS方案" class="headerlink" title="CORS方案"></a>CORS方案</h4><p><strong>就是通过服务器设置响应头来实现跨域</strong></p><p>CORS才是解决跨域的真正解决方案。<br>前端需要做什么？<br>无需做任何事情，正常发送Ajax请求即可。<br>后端需要做什么？<br>需要加 响应头 。或者使用第三方模块 cors 。<br><img src="https://img-blog.csdnimg.cn/20210807230949959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80ODgzNzYwNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h4 id="代理服务器（一般用Nginx）"><a href="#代理服务器（一般用Nginx）" class="headerlink" title="代理服务器（一般用Nginx）"></a>代理服务器（一般用Nginx）</h4><p><img src="https://img-blog.csdnimg.cn/20210807231812945.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80ODgzNzYwNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>   1).代理服务和前端服务之间由于协议域名端口三者统一不存在跨域的问题,可以直接发送请求</p><p>   2).代理服务和后端服务之间并不通过浏览器没有同源策略的限制,可以直接发送请求</p><p>这里是一个nginx启用COSR的参考配置</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#</span><span class="token comment"># Wide-open CORS config for nginx</span><span class="token comment">#</span>location / <span class="token punctuation">{</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$request_method</span> <span class="token operator">=</span> <span class="token string">'OPTIONS'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        add_header <span class="token string">'Access-Control-Allow-Origin'</span> <span class="token string">'*'</span><span class="token punctuation">;</span>        add_header <span class="token string">'Access-Control-Allow-Methods'</span> <span class="token string">'GET, POST, OPTIONS'</span><span class="token punctuation">;</span>        <span class="token comment">#</span>        <span class="token comment"># Custom headers and headers various browsers *should* be OK with but aren't</span>        <span class="token comment">#</span>        add_header <span class="token string">'Access-Control-Allow-Headers'</span> <span class="token string">'DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type'</span><span class="token punctuation">;</span>        <span class="token comment">#</span>        <span class="token comment"># Tell client that this pre-flight info is valid for 20 days</span>        <span class="token comment">#</span>        add_header <span class="token string">'Access-Control-Max-Age'</span> <span class="token number">1728000</span><span class="token punctuation">;</span>        add_header <span class="token string">'Content-Type'</span> <span class="token string">'text/plain charset=UTF-8'</span><span class="token punctuation">;</span>        add_header <span class="token string">'Content-Length'</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token builtin class-name">return</span> <span class="token number">204</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$request_method</span> <span class="token operator">=</span> <span class="token string">'POST'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        add_header <span class="token string">'Access-Control-Allow-Origin'</span> <span class="token string">'*'</span><span class="token punctuation">;</span>        add_header <span class="token string">'Access-Control-Allow-Methods'</span> <span class="token string">'GET, POST, OPTIONS'</span><span class="token punctuation">;</span>        add_header <span class="token string">'Access-Control-Allow-Headers'</span> <span class="token string">'DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type'</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$request_method</span> <span class="token operator">=</span> <span class="token string">'GET'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        add_header <span class="token string">'Access-Control-Allow-Origin'</span> <span class="token string">'*'</span><span class="token punctuation">;</span>        add_header <span class="token string">'Access-Control-Allow-Methods'</span> <span class="token string">'GET, POST, OPTIONS'</span><span class="token punctuation">;</span>        add_header <span class="token string">'Access-Control-Allow-Headers'</span> <span class="token string">'DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type'</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="调试方法"><a href="#调试方法" class="headerlink" title="调试方法"></a>调试方法</h2><p><strong>快捷键：</strong></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token constant">F8</span>：进入下一个断点<span class="token constant">F10</span>：单步执行，不进入子函数<span class="token constant">F11</span>：单步执行，遇到子函数会进入子函数shift<span class="token operator">+</span><span class="token constant">F11</span>：跳出当前函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;javascript、ES6查漏补缺网址&quot;&gt;&lt;a href=&quot;#javascript、ES6查漏补缺网址&quot; class=&quot;headerlink&quot; title=&quot;javascript、ES6查漏补缺网址&quot;&gt;&lt;/a&gt;javascript、ES6查漏补缺网址&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;%5Bhttps%5D(https://wangdoc.com)&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;知识点&quot;&gt;&lt;a href=&quot;#知识点&quot; class=&quot;headerlink&quot; title=&quot;知识点&quot;&gt;&lt;/a&gt;知识点&lt;/h2&gt;</summary>
    
    
    
    <category term="前端开发" scheme="https://gaofeng-lin.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="JavaScript" scheme="https://gaofeng-lin.github.io/tags/JavaScript/"/>
    
    <category term="Vue" scheme="https://gaofeng-lin.github.io/tags/Vue/"/>
    
    <category term="React" scheme="https://gaofeng-lin.github.io/tags/React/"/>
    
    <category term="Json" scheme="https://gaofeng-lin.github.io/tags/Json/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="https://gaofeng-lin.github.io/posts/41682/"/>
    <id>https://gaofeng-lin.github.io/posts/41682/</id>
    <published>2022-05-25T16:00:00.000Z</published>
    <updated>2022-07-23T03:15:35.835Z</updated>
    
    <content type="html"><![CDATA[<h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>装饰模式为已有类动态附加额外的功能就像LOL、王者荣耀等类Dota游戏中，英雄升级一样。每次英雄升级都会附加一个额外技能点学习技能。具体的英雄就是ConcreteComponent，技能栏就是装饰器Decorator，每个技能就是ConcreteDecorator；</p><pre class="line-numbers language-none"><code class="language-none">//Component 英雄接口 public interface Hero {    //学习技能    void learnSkills();}//ConcreteComponent 具体英雄盲僧public class BlindMonk implements Hero {        private String name;        public BlindMonk(String name) {        this.name = name;    }    @Override    public void learnSkills() {        System.out.println(name + "学习了以上技能！");    }}//Decorator 技能栏public class Skills implements Hero{        //持有一个英雄对象接口    private Hero hero;        public Skills(Hero hero) {        this.hero = hero;    }    @Override    public void learnSkills() {        if(hero != null)            hero.learnSkills();    }    }//ConreteDecorator 技能：Qpublic class Skill_Q extends Skills{        private String skillName;    public Skill_Q(Hero hero,String skillName) {        super(hero);        this.skillName = skillName;    }    @Override    public void learnSkills() {        System.out.println("学习了技能Q:" +skillName);        super.learnSkills();    }}//ConreteDecorator 技能：Wpublic class Skill_W extends Skills{    private String skillName;    public Skill_W(Hero hero,String skillName) {        super(hero);        this.skillName = skillName;    }    @Override    public void learnSkills() {        System.out.println("学习了技能W:" + skillName);        super.learnSkills();    }}//ConreteDecorator 技能：Epublic class Skill_E extends Skills{        private String skillName;        public Skill_E(Hero hero,String skillName) {        super(hero);        this.skillName = skillName;    }    @Override    public void learnSkills() {        System.out.println("学习了技能E:"+skillName);        super.learnSkills();    }}//ConreteDecorator 技能：Rpublic class Skill_R extends Skills{            private String skillName;        public Skill_R(Hero hero,String skillName) {        super(hero);        this.skillName = skillName;    }        @Override    public void learnSkills() {        System.out.println("学习了技能R:" +skillName );        super.learnSkills();    }}//客户端：召唤师public class Player {    public static void main(String[] args) {        //选择英雄        Hero hero = new BlindMonk("李青");                Skills skills = new Skills(hero);        Skills r = new Skill_R(skills,"猛龙摆尾");        Skills e = new Skill_E(r,"天雷破/摧筋断骨");        Skills w = new Skill_W(e,"金钟罩/铁布衫");        Skills q = new Skill_Q(w,"天音波/回音击");        //学习技能        q.learnSkills();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-none"><code class="language-none">学习了技能Q:天音波/回音击学习了技能W:金钟罩/铁布衫学习了技能E:天雷破/摧筋断骨学习了技能R:猛龙摆尾李青学习了以上技能！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;装饰器模式&quot;&gt;&lt;a href=&quot;#装饰器模式&quot; class=&quot;headerlink&quot; title=&quot;装饰器模式&quot;&gt;&lt;/a&gt;装饰器模式&lt;/h2&gt;&lt;p&gt;装饰模式为已有类动态附加额外的功能就像LOL、王者荣耀等类Dota游戏中，英雄升级一样。每次英雄升级都会附加一个额外</summary>
      
    
    
    
    <category term="设计模式" scheme="https://gaofeng-lin.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://gaofeng-lin.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java框架+工具</title>
    <link href="https://gaofeng-lin.github.io/posts/10033/"/>
    <id>https://gaofeng-lin.github.io/posts/10033/</id>
    <published>2022-04-27T16:00:00.000Z</published>
    <updated>2022-07-23T03:15:49.308Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="IDEA创建spring"><a href="#IDEA创建spring" class="headerlink" title="IDEA创建spring"></a>IDEA创建spring</h3><p><a href="https://blog.csdn.net/m0_67393686/article/details/124104008">链接</a></p><h3 id="所遇错误-x2F-注意事项"><a href="#所遇错误-x2F-注意事项" class="headerlink" title="所遇错误/注意事项"></a>所遇错误/注意事项</h3><h4 id="基础包名不要设置为-org"><a href="#基础包名不要设置为-org" class="headerlink" title="基础包名不要设置为 org"></a>基础包名不要设置为 org</h4><p>这与 Spring 框架的包一致，所以会导致问题。</p><p>错误信息：</p><pre class="line-numbers language-none"><code class="language-none">@EnableAsync annotation metadata was not injected <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>AOP是通过代理的方式实现的，由代理对象持有原对象，在执行原对象目标方法的前后可以执行额外的增强代码。<br>代理对象需要是原对象接口的实现或原对象的子类，这样就可以在对象引用处直接替换原对象。</p><p><img src="https://img-blog.csdnimg.cn/20210514185607752.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIwOTgwMjE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>代理方式分静态代理和动态代理，区别在于代理对象生成方式不同</strong></p><p>不论是静态代理还是动态代理<br>AOP均有三个关注点：<strong>切面增强内容、何地切入、何时切入</strong></p><ul><li>切面增强内容：切面增强逻辑的代码段</li><li>何地切入：需要给哪个类哪个方法增强</li><li>何时切入：切入发生在何时，方法执行前、执行后、还是执行前后</li></ul><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><h3 id="不使用ide创建Servlet"><a href="#不使用ide创建Servlet" class="headerlink" title="不使用ide创建Servlet"></a>不使用ide创建Servlet</h3><p><a href="http://c.biancheng.net/servlet2/deploy.html">链接</a><br>有几个事情需要注意下：</p><ol><li>各个文件夹一定要写对，之前把classes写成了class</li><li>按照上面链接的教程，用javac编译出来的是一个文件夹，里面才是class文件，要把整个文件夹复制到指定目录，不能只复制class文件。</li><li>web.xml里面的&lt; servlet-class &gt;。Testone.MyServlet 。最后那个是类名，前面是包名。如果源文件没有package，那么web.xml里面可以只写类名；如果无妨正常访问，那么就在src目录下面加一个package包，在里面再创建java文件，再编译，web.xml里面d &lt; servlet-class &gt;加上包名。</li></ol><h3 id="ide创建Servlet"><a href="#ide创建Servlet" class="headerlink" title="ide创建Servlet"></a>ide创建Servlet</h3><p><a href="https://blog.csdn.net/weixin_44107140/article/details/119618734">原链接</a></p><p><strong>注意把servlet-jar(在tomcat安装路径的lib文件夹中)放到lib文件夹下面，不要放到classes里面了。</strong></p><h2 id="SSM"><a href="#SSM" class="headerlink" title="SSM"></a>SSM</h2><p><strong>springboot 只是组装了spring和springmvc。SSM中的SS指的是Spring SpringMVC，M是指MyBatis。</strong></p><h3 id="SSM（Spring-SpringMVC-MyBatis）架构"><a href="#SSM（Spring-SpringMVC-MyBatis）架构" class="headerlink" title="SSM（Spring+SpringMVC+MyBatis）架构"></a>SSM（Spring+SpringMVC+MyBatis）架构</h3><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>1.SSM系统架构<br><img src="https://img-blog.csdnimg.cn/fd51aa6838fd4315ac1df679eb3500e5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>2.执行流程<br><img src="https://img-blog.csdnimg.cn/0a57266814cb4fe395124ce40ea590a4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="MSCM-model-service-controller-mapper"><a href="#MSCM-model-service-controller-mapper" class="headerlink" title="MSCM(model ,service, controller ,mapper)"></a>MSCM(model ,service, controller ,mapper)</h3><p><em><strong>mapper的中文意思是映射器；mapper和dao是一个东西，叫法不同。</strong></em></p><p><strong>业务逻辑：</strong><br> Controller–&gt;service接口–&gt;serviceImpl–&gt;dao接口–&gt;daoImpl–&gt;mapper–&gt;db</p><p><strong>一：Dao(Data Access Object):数据存储对象</strong><br>       DAO = Data Access Object = 数据存取对象. 不管是什么框架，我们很多时候都会与数据库进行交互。如果遇到一个场景我们都要去写SQL语句，那么我们的代码就会很冗余。所以，我们就想到了把数据库封装一下，让我们的数据库的交道看起来像和一个对象打交道，这个对象通常就是DAO。当我们操作这个对象的时候，这个对象会自动产生SQL语句来和数据库进行交互，我们就只需要使用DAO就行了。</p><p>   通常我们在DAO层里面写接口，里面有与数据打交道的方法。SQL语句通常写在mapper文件里面的。</p><p>   优点：结构清晰，Dao层的数据源配置以及相关的有关数据库连接的参数都在Spring配置文件中进行配置。</p><p><strong>二：Service：服务</strong><br>       服务是一个相对独立的功能模块，主要负责业务逻辑应用设计。首先也要设计接口，然后再设计其实现该接口的类。这样我们就可以在应用中调用service接口进行业务处理。service层业务实现，具体调用到已经定义的DAO的接口，封装service层的业务逻辑有利于通用的业务逻辑的独立性和重复利用性 。<br>     如果把Dao层当作积木，则Service层则是对积木的搭建。</p><p><strong>三：Controller：控制器</strong><br>       主要负责具体业务模块流程的控制，此层要调用到Service层的接口去控制业务流程，控制的配置同样在Spring配置文件中配置。针对不同的业务流程有不同的控制器。在设计的过程可以设计出重复利用的子单元流程模块。</p><p> <strong>四：model：模型</strong><br> 模型就是指视图的数据Model，模型，通常来讲，我们会把模型和另一个东西放在一起来说：View，视图。</p><p>模型通常认为是视图的内核，何谓之视图？我们正在与之交互的网站的界面就是视图，而模型是指他的内核：数据。</p><p>   将Model和View的概念拆分开来，有助于我们关注不同的方面，也可以更有效的分工。有些工程师更关注于内核也就是模型，通常来说，他们被称之为后端工程师。有些工程师更关注于用户界面的交互和展示，通常来说，他们被称之为前端工程师。</p><p><strong>五: View层：</strong><br>       与Controller层关系紧密，View层主要负责前台jsp页面的表示。</p><p><strong>六: 它们之间的关系：</strong><br>      建立了DAO层后才可以建立Service层，而Service层又是在Controller层之下的，因而Service层应该既调用DAO层的接口，又要提供接口给Controller层的类来进行调用，它刚好处于一个中间层的位置。每个模型都有一个Service接口，每个接口分别封装各自的业务处理方法。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zczMuYmRzdGF0aWMuY29tLzcwY0Z2OFNoX1ExWW54R2twb1dLMUhGNmhoeS9pdC91PTY1ODc1NzYzNCwzMTUzMjQ0OTA1JmZtPTI2JmdwPTAuanBn?x-oss-process=image/format,png#pic_center" alt="在这里插入图片描述"><br>另一个图的解释：<br>实体类这一层，有的开发写成pojo，有的写成model，也有domain，也有dto（这里做参数验证，比如password不能为空等），实体类如果你不懂什么东西的话，那你就想成是范围。</p><p>mapper 是Mybatis 操作数据库的那一层，就是dao层。</p><p>service包含了serviceImpl（service接口的实现类） 是提供给controller 使用的，针对于某些业务将 dao 的对于某些表的crud进行组合，也就是说间接的和数据库打交道。</p><p>controller 通过调用service来完成业务逻辑。<br><img src="https://img-blog.csdnimg.cn/20190806101012614.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNjQ3OTk5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="JavaWeb三层架构"><a href="#JavaWeb三层架构" class="headerlink" title="JavaWeb三层架构"></a>JavaWeb三层架构</h3><p><strong>（Servlet(Controller),service,dao）</strong><br><img src="https://img-blog.csdnimg.cn/1f793bb259964619876d3efb18303f2e.png" alt="在这里插入图片描述"></p><p>第一层Servlet,也叫controller层，处理JSP页面传输的数据，一般通过request.getParameter获取表单中属性为name参数中的value值，在Servlet层中一般会通过new的方式创建一个Service。如</p><p>UserService userService = new UserServiceimpl();因为一般Service层会创建一个接口写一些方法（userService）,并创建一个实现类实现这个接口(UserServiceImpl)。</p><p><img src="https://img-blog.csdnimg.cn/a9a95bf4b1204f3cb542a1f22bb5094a.png" alt="在这里插入图片描述"><br>service层用来处理一些前端传输过来一些数据进行数据库的增删改查，或者处理DAO层从数据库获取的数据，例如对数据进行分页。因为需要调用DAO层，所以也需要new一个DAO层。</p><p><img src="https://img-blog.csdnimg.cn/9ef53b31f1034ac1bb14e47506482bed.png" alt="在这里插入图片描述"></p><p>对数据进行分页</p><p><img src="https://img-blog.csdnimg.cn/7ae167596761457c991e6dd569b2cc2b.png" alt="在这里插入图片描述"></p><p>UserDao userDao = new UserDaoImpl;</p><p><img src="https://img-blog.csdnimg.cn/9d1e342190fd41a7882915823fc74508.png" alt="在这里插入图片描述"><br>Dao层是用来与数据库进行交互，也就是增删改查。可以通过前端传输过来的数据对用户的信息进行增删改查。</p><p><img src="https://img-blog.csdnimg.cn/92f11628821e46c48e9dbedc1901b23d.png" alt="在这里插入图片描述"></p><h3 id="Spring-IOC"><a href="#Spring-IOC" class="headerlink" title="Spring IOC"></a>Spring IOC</h3><p>1.xml配置文件利用反射获取class对象<br><img src="https://img-blog.csdnimg.cn/4a0f6bab3f814b2eb88ce5bf7a0752dd.png" alt="在这里插入图片描述"><br>2. 获取容器、获得bean对象、使用方法。<br><img src="https://img-blog.csdnimg.cn/6a34e9ded1434451bd7a166d18c3aa5e.png" alt="在这里插入图片描述"></p><h3 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h3><p><a href="https://blog.51cto.com/u_14625481/3485049">原文</a></p><p><strong>IOC让模块之间解耦，AOP让JAVA动起来。</strong><br>AOP相对应的一个词叫OOP，AOP（Aspect Oriented Programming），即面向切面编程。OOP主要是为了实现编程的重用性、灵活性和扩展性。它的几个特征分别是继承、封装、多态和抽象。OOP重点体现在编程架构，强调的是类之间的层次关系。<br><img src="https://img-blog.csdnimg.cn/0f7647b2c8414917924b5be5a50f2f69.png" alt="在这里插入图片描述"><br>看到上面的图，我们暂时还不能发现有什么问题。为了大家便于理解，接下来我来给大家讲解一下上面类图的实现过程。描述如下：马戏团有一条表演的小狗，这条小狗可以跑和跳，但是它完成跑和跳两个动作之前必须是在接到驯兽师发出的命令后，同时完成跑和跳的动作之后，驯兽师会给与响应的奖励，比如一块肉。</p><p>了解了实现过程之后，我们在来看一下具体的代码。 </p><p><img src="https://img-blog.csdnimg.cn/5b3feb96c994426fbc8f89aab82a3e38.png" alt="在这里插入图片描述"><br>仔细看上面的代码，我们可以看出在run方法和jump方法中，存在一些相同的内容（驯兽师发出命令和给与奖励），这些内容并不能完全进行抽象，即不能按照OOP编程思想进行处理。类似这样的情况同样会出现在我们编程中的很多地方，例如：日志记录、性能统计、安全控制、事务处理、异常处理等等。但是这样的情况该如何解决呢？这就引入了AOP编程思想。</p><p>AOP为Aspect Oriented Programming的缩写，即面向切面编程（也叫面向方面），是一种可以通过预编译方式和运行期动态代理实现在不修改源代码的情况下给程序动态统一添加功能的一种技术。</p><p><strong>AOP实现实例</strong><br>为了大家更好的理解AOP如何实现，接下来我们优化一下上述代码。<br>首先是Dog类<br><img src="https://img-blog.csdnimg.cn/2332d45a5bb1451aa65977fca95a6f03.png" alt="在这里插入图片描述"></p><p>对比之前的代码我们可以明显看出，我们将关于驯兽师的相关内容从run和jump中进行了抽取，接下来，我们如何在程序运行中将关于驯兽师的动作加入到程序中呢？这就是我们这次用到的AOP实现的核心技术动态代理（Dynamic Proxy）。具体代码如下：</p><h2 id="常见缩写"><a href="#常见缩写" class="headerlink" title="常见缩写"></a>常见缩写</h2><h3 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h3><p><a href="https://www.runoob.com/jsp/jsp-tutorial.html">详情</a><br>JSP 与 PHP、ASP、ASP.NET 等语言类似，运行在服务端的语言。</p><p>JSP（全称Java Server Pages）是由 Sun Microsystems 公司倡导和许多公司参与共同创建的一种使软件开发者可以响应客户端请求，而动态生成 HTML、XML 或其他格式文档的Web网页的技术标准。</p><p>JSP 技术是以 Java 语言作为脚本语言的，JSP 网页为整个服务器端的 Java 库单元提供了一个接口来服务于HTTP的应用程序。</p><p>JSP文件后缀名为 *.jsp 。</p><p>JSP开发的WEB应用可以跨平台使用，既可以运行在 Linux 上也能运行在 Windows 上。</p><h3 id="POJO、JAVABean、Entity"><a href="#POJO、JAVABean、Entity" class="headerlink" title="POJO、JAVABean、Entity"></a>POJO、JAVABean、Entity</h3><p><strong>1.POJO</strong><br>  （Plain Ordinary Java Object）简单的Java对象，实际就是普通JavaBeans，是为了避免和EJB混淆所创造的简称。<br>  其中有一些属性及其getter、setter方法的类，没有业务逻辑，有时可以作为VO（value-object）或DTO（Data Transfer Object）来使用。不允许有业务方法，也不能携带connection之类的方法，实际就是普通JavaBeans。POJO类中有属性和get、set方法，但是没有业务逻辑。  </p><pre class="line-numbers language-none"><code class="language-none">/** * POJO类代码示例 */  public class UserInfoPojoDemo {    private int userId;// 用户帐号    private String pwd;// 用户密码    /**     * Constructor     */    public UserInfoPojoDemo() {    }    public UserInfoPojoDemo(String pwd) {        this.pwd = pwd;    }    public UserInfoPojoDemo(int userId) {        this.userId = userId;    }    public UserInfoPojoDemo(int userId, String pwd) {        this.userId = userId;        this.pwd = pwd;    }    /**     *Access      */    public int getUserId() {        return userId;    }    public void setUserId(int userId) {        this.userId = userId;    }    public String getPwd() {        return pwd;    }    public void setPwd(String pwd) {        this.pwd = pwd;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2.JAVABean</strong><br>一种JAVA语言写成的可重用组件。JavaBean符合一定规范编写的Java类，不是一种技术，而是一种规范。大家针对这种规范，总结了很多开发技巧、工具函数。符合这种规范的类，可以被其它的程序员或者框架使用。它的方法命名，构造及行为必须符合特定的约定：</p><p>1、所有属性为private。</p><p>2、这个类必须有一个公共的缺省构造函数。即是提供无参数的构造器。</p><p>3、这个类的属性使用getter和setter来访问，其他方法遵从标准命名规范。</p><p>4、这个类应是可序列化的。实现serializable接口。</p><p>因为这些要求主要是靠约定而不是靠实现接口，所以许多开发者把JavaBean看作遵从特定命名约定的POJO。</p><pre class="line-numbers language-none"><code class="language-none">public class UserInfo implements java.io.Serializable{  //实现serializable接口。  private static final long serialVersionUID = 1L;  private String name;  private int age;  //无参构造器  public UserInfo() {  }  public String getName() {      return name;  }  public void setName(String name) {      this.name = name;  }  public int getAge() {      return age;  }  public void setAge(int age) {      this.age = age;  }  //javabean当中可以有其它的方法  public void userInfoPrint(){      System.out.println("");   } }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>区别<br>POJO其实是比javabean更纯净的简单类或接口。POJO严格地遵守简单对象的概念，而一些JavaBean中往往会封装一些简单逻辑。<br>POJO主要用于数据的临时传递，它只能装载数据， 作为数据存储的载体，而不具有业务逻辑处理的能力。<br>Javabean虽然数据的获取与POJO一样，但是javabean当中可以有其它的方法。</strong></p><p><strong>3.entity（实体类）</strong><br>对java实体类的众多理解：</p><p>A .就是属性类，通常定义在model层里面</p><p>B. 一般的实体类对应一个数据表，其中的属性对应数据表中的字段。<br>好处：<br>1.对对象实体的封装，体现OO思想。<br>2.属性可以对字段定义和状态进行判断和过滤<br>3.把相关信息用一个实体类封装后，我们在程序中可以把实体类作为参数传递，更加方便。</p><p>C. 说白了就是为了让程序员在对数据库操作的时候不用写SQL语句</p><p>D. 就是一个数据库表生成一个类<br>这样做对数据库操作起来方便<br>编写代码较少 提高效率 可以使程序员专注逻辑关系</p><p>E. 实体类就是把对某一个表的操作全写在一个类中.</p><p>F. 在Java开发中经常要定义一些实体类，这些类的定义的好坏会直接影响，编写代码的质量和难易程度，以下是别人总结的一些经验。</p><p>一、实体类的名字尽量和数据库的表的名字对应相同。</p><p>二、实体类应该实现java.io.Serializable接口。</p><p>三、实体类应该有个无参的构造方法。</p><p>四、实体类应该有个有参（所有的参数）的构造方法。</p><p>五、实体类有属性和方法，属性对应数据库中表的字段，主要有getter和setter方法。</p><p>六、实体类还应该有个属性serialVersionUID。例如：private static final long serialVersionUID = -6125297654796395674L;</p><p>七、属性一般是private类型，方法位public类型，对于数据库自动生成的ID字段对应的属性的set方法应为private。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Spring&quot;&gt;&lt;a href=&quot;#Spring&quot; class=&quot;headerlink&quot; title=&quot;Spring&quot;&gt;&lt;/a&gt;Spring&lt;/h2&gt;&lt;h3 id=&quot;IDEA创建spring&quot;&gt;&lt;a href=&quot;#IDEA创建spring&quot; class=&quot;head</summary>
      
    
    
    
    <category term="Java" scheme="https://gaofeng-lin.github.io/categories/Java/"/>
    
    
    <category term="Spring" scheme="https://gaofeng-lin.github.io/tags/Spring/"/>
    
    <category term="Java" scheme="https://gaofeng-lin.github.io/tags/Java/"/>
    
    <category term="SpringBoot" scheme="https://gaofeng-lin.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>牛客网</title>
    <link href="https://gaofeng-lin.github.io/posts/43473/"/>
    <id>https://gaofeng-lin.github.io/posts/43473/</id>
    <published>2022-04-21T16:00:00.000Z</published>
    <updated>2022-07-23T03:15:23.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="牛客网"><a href="#牛客网" class="headerlink" title="牛客网"></a>牛客网</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p><strong>1.sc.haxNext()不是必须要加的</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">while</span><span class="token punctuation">(</span>sc<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">//核心代码</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这句话可以让你一直输入，输入都行，不会因为回车就结束，一般情况下可以不加它，因为题目一般会告诉你有几组数据，外面套个while循环就好。</p><p><strong>机考测试的数据是一次性全部放入控制台，如果没说几组数据，可以加<code>sc.hasNext()</code></strong></p><p><strong>如果样例过了，但测试用例没过或之过了一部分，先去检查代码，基本就是代码问题，逻辑问题或者有bug</strong></p><p><strong>如果要说了以某个字符终止输入，那么就把这个输入放到（）里面，用双引号包括。</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StandardInput</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Scanner</span> sc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>sc<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token string">"#"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> a <span class="token operator">=</span> sc<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> #<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>2.牛客网接受控制台输入</strong></p><p><strong>next()和nextInt()方法读取到任意间隔符（如空格和回车）就结束，nextLine()读取到回车结束也就是“\r”，next()返回值为String类型，nextLine()返回值为String类型，nextInt()返回值为Int类型。</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span>返回的是<span class="token keyword">int</span>型<span class="token punctuation">,</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>返回<span class="token class-name">String</span>。二者特点很相似<span class="token number">1</span>、一定要读取到有效字符后才可以结束输入。<span class="token number">2</span>、对输入有效字符之前遇到的空白，<span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 方法会自动将其去掉。<span class="token number">3</span>、只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。<span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 不能得到带有空格的字符串。<span class="token comment">//-----------------------------------------</span><span class="token function">nextLong</span><span class="token punctuation">(</span><span class="token punctuation">)</span>、<span class="token function">nextDouble</span><span class="token punctuation">(</span><span class="token punctuation">)</span>是一样的道理<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span>：<span class="token number">1</span>、以<span class="token class-name">Enter</span>为结束符<span class="token punctuation">,</span>也就是说 <span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法返回的是输入回车之前的所有字符。<span class="token number">2</span>、可以获得空白。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>也可以全部用naxtLine()，不过数字型需要转一下</strong><br>1.读取单个整数，字符串数字转int数字，int转String</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//        读取单个整数，字符串数字转int数字</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>sc<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//        int转String</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">3</span>；<span class="token class-name">String</span> s<span class="token operator">=</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.读取一行整数，以空格分开</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//        读取一行整数，以空格分开</span>        <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> s <span class="token operator">=</span> sc<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> num <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>s<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            num<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.单个char数字转int数字,减去’0’</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//                单个char数字转int数字,减去'0'</span>                res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token operator">-</span><span class="token char">'0'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>4.遍历字符串的每个字符，charAt(i)</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//        遍历字符串的每个字符，charAt(i)</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><h4 id="数组输出"><a href="#数组输出" class="headerlink" title="数组输出"></a>数组输出</h4><p><strong>Arrays.toString（）</strong><br>这个方法是是用来将数组转换成String类型输出的，入参可以是long，float，double，int，boolean，byte，object型的数组。<br><img src="https://img-blog.csdnimg.cn/20200209172114721.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM5ODQxOA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>如果直接i.toString()则是输出地址值<br><img src="https://img-blog.csdnimg.cn/20200209172525196.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM5ODQxOA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h4 id="四舍五入输出"><a href="#四舍五入输出" class="headerlink" title="四舍五入输出"></a>四舍五入输出</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//保留4位小数的输出</span><span class="token keyword">double</span> f <span class="token operator">=</span> <span class="token number">3.1415926</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%.4f"</span><span class="token punctuation">,</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><a href="https://www.jianshu.com/p/359d9001ebbc">String.format详细用法</a></p><h3 id="暴力遍历"><a href="#暴力遍历" class="headerlink" title="暴力遍历"></a>暴力遍历</h3><p>暴力有时候是一种搞笑简单的方法，比如三数之和，四数之和。再没有掌握到好的办法之前，暴力是一个选择。几个的遍历略有区别，需要注意。<br>1.二维数组</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>num<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>num<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.数组任意两个不同的数相加<br><strong>注意，i只能到倒数第二位，因为j=i+1</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>num<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>num<span class="token punctuation">.</span>length<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> sum <span class="token operator">=</span> num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>num<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.数组任意三个不同的数相加</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>num<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>num<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>              <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token operator">=</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>num<span class="token punctuation">.</span>length<span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                  <span class="token keyword">int</span> sum <span class="token operator">=</span> num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>num<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>num<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>              <span class="token punctuation">}</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Collections-sort-多重条件排序"><a href="#Collections-sort-多重条件排序" class="headerlink" title="Collections.sort() 多重条件排序"></a>Collections.sort() 多重条件排序</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">sort</span><span class="token punctuation">;</span> <span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">ArrayList</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Collections</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Comparator</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span><span class="token punctuation">;</span> <span class="token comment">/** * 排序规则，按照年龄排序，若年龄相同，按照工资排序，若工资相同，按照身高排序 * @author Administrator * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestObjectSort</span> <span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">&gt;</span></span> students<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>students<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"zhangsan"</span><span class="token punctuation">,</span><span class="token number">21</span><span class="token punctuation">,</span><span class="token number">3000</span><span class="token punctuation">,</span><span class="token number">180</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>students<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"zhangsan"</span><span class="token punctuation">,</span><span class="token number">27</span><span class="token punctuation">,</span><span class="token number">4000</span><span class="token punctuation">,</span><span class="token number">180</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>students<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"zhangsan"</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">,</span><span class="token number">180</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>students<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"zhangsan"</span><span class="token punctuation">,</span><span class="token number">21</span><span class="token punctuation">,</span><span class="token number">5000</span><span class="token punctuation">,</span><span class="token number">180</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>students<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"zhangsan"</span><span class="token punctuation">,</span><span class="token number">45</span><span class="token punctuation">,</span><span class="token number">4000</span><span class="token punctuation">,</span><span class="token number">180</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>students<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"zhangsan"</span><span class="token punctuation">,</span><span class="token number">21</span><span class="token punctuation">,</span><span class="token number">5000</span><span class="token punctuation">,</span><span class="token number">174</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>students<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"zhangsan"</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">4000</span><span class="token punctuation">,</span><span class="token number">180</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>students<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"zhangsan"</span><span class="token punctuation">,</span><span class="token number">33</span><span class="token punctuation">,</span><span class="token number">4000</span><span class="token punctuation">,</span><span class="token number">180</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>students<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"zhangsan"</span><span class="token punctuation">,</span><span class="token number">45</span><span class="token punctuation">,</span><span class="token number">4000</span><span class="token punctuation">,</span><span class="token number">180</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>students<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"zhangsan"</span><span class="token punctuation">,</span><span class="token number">76</span><span class="token punctuation">,</span><span class="token number">4000</span><span class="token punctuation">,</span><span class="token number">180</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>students<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"zhangsan"</span><span class="token punctuation">,</span><span class="token number">99</span><span class="token punctuation">,</span><span class="token number">4000</span><span class="token punctuation">,</span><span class="token number">180</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>students<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"zhangsan"</span><span class="token punctuation">,</span><span class="token number">21</span><span class="token punctuation">,</span><span class="token number">5000</span><span class="token punctuation">,</span><span class="token number">160</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>students<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Student</span> a1<span class="token punctuation">,</span> <span class="token class-name">Student</span> a2<span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token keyword">int</span> x <span class="token operator">=</span> a1<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> a2<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> y <span class="token operator">=</span> a1<span class="token punctuation">.</span><span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> a2<span class="token punctuation">.</span><span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token keyword">int</span> z <span class="token operator">=</span> a1<span class="token punctuation">.</span><span class="token function">getHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> a2<span class="token punctuation">.</span><span class="token function">getHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                 <span class="token keyword">if</span><span class="token punctuation">(</span>y<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        <span class="token keyword">return</span> z<span class="token punctuation">;</span>                  <span class="token punctuation">}</span>                <span class="token keyword">return</span> y<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> x<span class="token punctuation">;</span>        <span class="token punctuation">}</span>             <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">Student</span> s<span class="token operator">:</span>students<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\t"</span><span class="token operator">+</span>s<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\t"</span><span class="token operator">+</span>s<span class="token punctuation">.</span><span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\t"</span><span class="token operator">+</span>s<span class="token punctuation">.</span><span class="token function">getHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span>   <span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">{</span><span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span><span class="token keyword">int</span> age<span class="token punctuation">,</span><span class="token keyword">int</span> salary<span class="token punctuation">,</span><span class="token keyword">int</span> height<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">=</span>name<span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token operator">=</span>age<span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>salary<span class="token operator">=</span>salary<span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>height<span class="token operator">=</span>height<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">int</span>  age<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">int</span> salary<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">int</span> height<span class="token punctuation">;</span> <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> name<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> age<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> salary<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setSalary</span><span class="token punctuation">(</span><span class="token keyword">int</span> salary<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>salary <span class="token operator">=</span> salary<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> height<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setHeight</span><span class="token punctuation">(</span><span class="token keyword">int</span> height<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>height <span class="token operator">=</span> height<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="字典序排序"><a href="#字典序排序" class="headerlink" title="字典序排序"></a>字典序排序</h4><pre class="line-numbers language-none"><code class="language-none">str1.compareTo(str2);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-none"><code class="language-none">adobe454000180tom454000180zhangsan454000180<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这是一个多条件排序。后面三个数值相等就进行字典序排序。先比较第一个字母，从小到达排列。第一个相等就比较第二个，遇到不等的就里面出结果。<br>如果是倒着排列就是 <code>str2.compareTo(str1); </code></p><h4 id="HashMap排序"><a href="#HashMap排序" class="headerlink" title="HashMap排序"></a>HashMap排序</h4><p>先看一下遍历Map的方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"value1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"value2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"3"</span><span class="token punctuation">,</span> <span class="token string">"value3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//第一种：普遍使用，二次取值</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"通过Map.keySet遍历key和value："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> key <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"key= "</span><span class="token operator">+</span> key <span class="token operator">+</span> <span class="token string">" and value= "</span> <span class="token operator">+</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>      <span class="token comment">//第二种</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"通过Map.entrySet使用iterator遍历key和value："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> it <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> entry <span class="token operator">=</span> it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"key= "</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" and value= "</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>      <span class="token comment">//第三种：推荐，尤其是容量大时</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"通过Map.entrySet遍历key和value"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> entry <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"key= "</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" and value= "</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token comment">//第四种</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"通过Map.values()遍历所有的value，但不能遍历key"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> v <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"value= "</span> <span class="token operator">+</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为Collections.sort针对的是list，所以要对HashMap排序需要先转为List<br><strong>如果return 后面的值大于0，交换位置。所以下面的代码放回的是降序</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> font_end_list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>font_end_list<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> o1<span class="token punctuation">,</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> o2<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> o2<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>o1<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="常用数据结构及方法"><a href="#常用数据结构及方法" class="headerlink" title="常用数据结构及方法"></a>常用数据结构及方法</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h4><p>一般来说有int、double、string等类型数组，写法为</p><pre class="line-numbers language-none"><code class="language-none">int[] adouble[] bString[] c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>但还有一种数组比较特别，对象数组</strong><br>比如我定义了一个Studeng类，</p><pre class="line-numbers language-none"><code class="language-none">Student[] a <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> a就是一个Student类数组，a[0] 就是一个Student对象。</p><h4 id="数组取最大-x2F-小值"><a href="#数组取最大-x2F-小值" class="headerlink" title="数组取最大/小值"></a>数组取最大/小值</h4><p><strong>Arrays.stream</strong></p><pre class="line-numbers language-none"><code class="language-none">Arrays.stream(f[m - 1]).min().orElse(-1)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>f是一个二维数组，m-1是其中一行</li><li>后面可以跟min() 或者 max()</li><li>orElse(-1) 表示没有值就返回-1，括号里面也可也填其它值</li></ol><h4 id="数组之间的赋值"><a href="#数组之间的赋值" class="headerlink" title="数组之间的赋值"></a>数组之间的赋值</h4><pre class="line-numbers language-none"><code class="language-none">int[] nums = {1,2,3,4,5,6,20,24};int[] news = {1,2,3,5}news = nums;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上面的代码，打印news输出的是nums的结果；如果写成<code>nums = news</code>。打印nums，输出的是news的结果。</p><h4 id="数组复制-x2F-扩容"><a href="#数组复制-x2F-扩容" class="headerlink" title="数组复制/扩容"></a>数组复制/扩容</h4><p>Arrays.copyOf方法是复制数组中指定范围的元素，复制的长度大于被复制数组的长度，则填充类型默认值，String得默认值是null,int的默认值是0。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a1 <span class="token operator">=</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//复制指定的数组长度</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a2 <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copeOf</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>a<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//容量翻倍</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="数组截取"><a href="#数组截取" class="headerlink" title="数组截取"></a>数组截取</h4><p><strong>2.  Arrays.copyOfRange数组截取</strong></p><p>Arrays.copyOfRange(T[ ] original,int from,int to)<br>original：第一个参数为要拷贝的数组对象<br>from：第二个参数为拷贝的开始位置（包含）<br>to：第三个参数为拷贝的结束位置（不包含）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array2 <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>array2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h4><p> 这种形式是对一个数组的所有元素进行排序，并且是按从小到大的顺序。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Arrays</span><span class="token punctuation">;</span>   <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>                   <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>         <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>     <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2、Arrays.sort(int[] a, int fromIndex, int toIndex)<br>这种形式是对数组部分排序，也就是对数组a的下标从fromIndex到toIndex-1的元素排序，注意：下标为toIndex的元素不参与排序哦！</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Arrays</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3、public static void sort(T[] a,int fromIndex,int toIndex, Comparator c)</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"> <span class="token number">1</span> <span class="token keyword">package</span> <span class="token namespace">test</span><span class="token punctuation">;</span> <span class="token number">2</span>  <span class="token number">3</span> <span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Arrays</span><span class="token punctuation">;</span> <span class="token number">4</span> <span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Comparator</span><span class="token punctuation">;</span> <span class="token number">5</span>  <span class="token number">6</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span> <span class="token number">7</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token number">8</span>         <span class="token comment">//注意，要想改变默认的排列顺序，不能使用基本类型（int,double, char）</span> <span class="token number">9</span>         <span class="token comment">//而要使用它们对应的类</span><span class="token number">10</span>         <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token number">11</span>         <span class="token comment">//定义一个自定义类MyComparator的对象</span><span class="token number">12</span>         <span class="token class-name">Comparator</span> cmp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyComparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">13</span>         <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> cmp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">14</span>         <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token number">15</span>             <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">16</span>         <span class="token punctuation">}</span><span class="token number">17</span>     <span class="token punctuation">}</span><span class="token number">18</span> <span class="token punctuation">}</span><span class="token number">19</span> <span class="token comment">//Comparator是一个接口，所以这里我们自己定义的类MyComparator要implents该接口</span><span class="token number">20</span> <span class="token comment">//而不是extends Comparator</span><span class="token number">21</span> <span class="token keyword">class</span> <span class="token class-name">MyComparator</span> <span class="token keyword">implements</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span><span class="token number">22</span>     <span class="token annotation punctuation">@Override</span><span class="token number">23</span>     <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> o1<span class="token punctuation">,</span> <span class="token class-name">Integer</span> o2<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token number">24</span>         <span class="token comment">//如果n1小于n2，我们就返回正值，如果n1大于n2我们就返回负值，</span><span class="token number">25</span>         <span class="token comment">//这样颠倒一下，就可以实现反向排序了</span><span class="token number">26</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>o1 <span class="token operator">&lt;</span> o2<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token number">27</span>             <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token number">28</span>         <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>o1 <span class="token operator">&gt;</span> o2<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token number">29</span>             <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token number">30</span>         <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token number">31</span>             <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token number">32</span>         <span class="token punctuation">}</span><span class="token number">33</span>     <span class="token punctuation">}</span><span class="token number">34</span>     <span class="token number">35</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="数组填充"><a href="#数组填充" class="headerlink" title="数组填充"></a>数组填充</h4><p><strong>3.Arrays.fill  数组</strong><br>public static void fill(int[] a, int fromIndex, int toIndex, int val)<br>用来输入给定数组中元素值的。<br>1、两个参数<br>public static void fill(int[] a， int val)：给定一个数组，一个val值<br>含义为为数组a进行赋值，使得其所有元素值都为val。</p><p>2、四个参数<br>public static void fill(int[] a, int fromIndex, int toIndex, int val)：给定一个数组，起始位置fromIndex(包含)，末尾位置toIndex(不包含)，对范围内的元素进行赋值，示例如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//此时，arr的值为[60, 60, 60, 60, 60, 60]</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//此时，arr的值为[60, 60, 60,100, 100, 60]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.二维数组赋值</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>cache<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="数组转list"><a href="#数组转list" class="headerlink" title="数组转list"></a>数组转list</h4><p><strong>4.Arrays.asList</strong><br>该方法是将数组转化成List集合的方法。</p><p> List<string> list = Arrays.asList(“a”,”b”,”c”);<br><strong>注意：<br>（1）该方法适用于对象型数据的数组（String、Integer…）<br>（2）该方法不建议使用于基本数据类型的数组（byte,short,int,long,float,double,boolean）<br>（3）该方法将数组与List列表链接起来：当更新其一个时，另一个自动更新<br>（4）不支持add()、remove()、clear()等方法<br>  （5）长度不可变</strong></string></p><p>如果你的List只是用来遍历，就用Arrays.asList()。</p><p> 如果你的List还要添加或删除元素，还是乖乖地new一个java.util.ArrayList，然后一个一个的添加元素。</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="两个字符串是否相等"><a href="#两个字符串是否相等" class="headerlink" title="两个字符串是否相等"></a>两个字符串是否相等</h4><pre class="line-numbers language-none"><code class="language-none">A.equals(B)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>相等会返回true</p><h4 id="字符串与字符之间的转换"><a href="#字符串与字符之间的转换" class="headerlink" title="字符串与字符之间的转换"></a>字符串与字符之间的转换</h4><ol><li>遍历字符串<br><code>char c : str.toCharArray()</code></li><li>字符相减<br>字符直接相减，他们对应的ascill码相减，会返回一个整数。这个一般用做数组下标。</li><li>字符与整数相加会转换为整数<br><code>25 + 'A' </code><br>A的ASCII码是65，所以最后的结果是90</li><li>整数转换为字符<br><code>(char)(25 + 'A')</code><br>Z的ASCII码是90，所以最后的结果是Z</li><li>字符转字符串<br><code>"" + (char)(25 + 'A')</code><br>前面加上空字符串即可</li><li>判断字符是大写还是小写<pre class="line-numbers language-none"><code class="language-none">Character.isUpperCase(c) // 大写返回true，一般用于判断条件Character.isLowerCase(c) //小写返回true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="String对象创建"><a href="#String对象创建" class="headerlink" title="String对象创建"></a>String对象创建</h4><pre class="line-numbers language-none"><code class="language-none">String str1 = "Hello, 慕课网";String str2 = new String("Hello, Java");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h4><pre class="line-numbers language-none"><code class="language-none">int length = str.length();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意，hello world!中的空格也算一个字符。</p><h4 id="字符串查找"><a href="#字符串查找" class="headerlink" title="字符串查找"></a>字符串查找</h4><pre class="line-numbers language-none"><code class="language-none">char c = str.charAt(7);System.out.println("索引位置为7的字符为：" + c);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>获取字符在字符串中第一次出现的位置：</p><pre class="line-numbers language-none"><code class="language-none">int i = str.indexOf('a');System.out.println("字符a在字符串str第一次出现的位置为：" + i);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>获取子串在字符串中第一次出现的位置：</p><pre class="line-numbers language-none"><code class="language-none">int i = str.indexOf("love");System.out.println("子串love在字符串str第一次出现的位置为：" + i);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h4><pre class="line-numbers language-none"><code class="language-none">//将字符串的空格替换为%20，这是leetcode剑指offer05str.replace(" ","%20");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h4><pre class="line-numbers language-none"><code class="language-none">String substring = str.substring(2);String substring1 = str.substring(2, 6);System.out.println("从索引位置2到结束的子串为：" substring);System.out.println("从索引位置2到索引位置6的子串为：" substring1);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="字符串切割"><a href="#字符串切割" class="headerlink" title="字符串切割"></a>字符串切割</h4><pre class="line-numbers language-none"><code class="language-none">//以空格切割String str1 = "I love Java";String[] strArr = str1.split(" ");// 以*切割String str2 = "I*love*Java";String[] strArr2 = str2.split("\\*");// 以\切割String str3 = "I\\love\\Java";String[] strArr4 = str3.split("\\\\");// 以|切割String str4 = "I|love|Java";String[] strArr4 = str4.split("\\|");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="字符串与字节数组转换"><a href="#字符串与字节数组转换" class="headerlink" title="字符串与字节数组转换"></a>字符串与字节数组转换</h4><pre class="line-numbers language-none"><code class="language-none">// 将字符串转换为字节数组byte[] ascii = str2.getBytes();// 此处的ascii为上面通过字符串转换的字节数组String s = new String(ascii);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="字符串大小写转换"><a href="#字符串大小写转换" class="headerlink" title="字符串大小写转换"></a>字符串大小写转换</h4><pre class="line-numbers language-none"><code class="language-none">String str = "HELLO world";String s = str.toLowerCase();System.out.println("字符串str为转换为小写后为：" + s);String s1 = s.toUpperCase();System.out.println("字符串s为转换为大写后为：" + s1);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h4><pre class="line-numbers language-none"><code class="language-none">String str1 = "hello";String str2 = "hello";String str3 = new String("hello");System.out.println("使用equals()方法比较str1和str2的为：" + str1.equals(str2));System.out.println("使用==运算符比较str1和str2的结果" + (str1 == str2)); System.out.println("使用equals()方法比较str1和str3果为：" + str1.equals(str3));System.out.println("使用==运算符比较str1和str3的结果" + (str1 == str3));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><p>使用equals()方法比较str1和str2的结果为：true<br>使用==运算符比较str1和str2的结果为：true<br>使用equals()方法比较str1和str3的结果为：true<br>使用==运算符比较str1和str3的结果为：false</p><h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><h4 id="StringBuilder-与-String-互转"><a href="#StringBuilder-与-String-互转" class="headerlink" title="StringBuilder 与 String 互转"></a>StringBuilder 与 String 互转</h4><pre class="line-numbers language-none"><code class="language-none">StringBuilder sb = new StringBuilder();String s = sb.toString();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">String s1 = "world";StringBuilder sb1 = new StringBuilder(s);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/28992447d5e04357a1179eec6fd5e057.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/9eaf85f1bf0d47cda6147538824c447d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/ab5f360c9538404aa73508c6076c7be7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/ab3b657bf36c4215a642258daa60794b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/0a61eb472ec949ec8cd2e325b4ffa1b2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/d5e8a1bb47224fdab246fe803908782e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/38c27e77129f4a15950e0f196b7eed74.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>Arrays.asList的作用是将数组转化为list,一般是用于在初始化的时候,设置几个值进去,简化代码,省去add的部分。<br><strong>避免如下第一种方法太啰嗦！！！</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">&gt;</span></span> hash <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        hash<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token char">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        hash<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token char">'e'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        hash<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token char">'i'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        hash<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token char">'o'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        hash<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token char">'u'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        hash<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token char">'A'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        hash<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token char">'E'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        hash<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token char">'I'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        hash<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token char">'O'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        hash<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token char">'U'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">&gt;</span></span> hash1 <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token char">'a'</span><span class="token punctuation">,</span> <span class="token char">'e'</span><span class="token punctuation">,</span> <span class="token char">'i'</span><span class="token punctuation">,</span> <span class="token char">'o'</span><span class="token punctuation">,</span> <span class="token char">'u'</span><span class="token punctuation">,</span> <span class="token char">'A'</span><span class="token punctuation">,</span> <span class="token char">'E'</span><span class="token punctuation">,</span> <span class="token char">'I'</span><span class="token punctuation">,</span> <span class="token char">'O'</span><span class="token punctuation">,</span> <span class="token char">'U'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/9a89124f7d2d43bea2e59b46aab180d1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/81f792bc32934b468c0587c5cfa63259.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>java当中栈和队列可以使用LinkedList，重点关注头尾的插入删除，返回。</p><pre class="line-numbers language-none"><code class="language-none">//表头添加sites.addFirst("Wiki");//表头移除sites.removeFirst();//获取表头System.out.println(sites.getFirst());//表尾添加sites.addLast("Wiki");//表尾移除sites.removeLast();//获取表尾System.out.println(sites.getLast());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p><img src="https://img-blog.csdnimg.cn/79a7c9db6562419fa941f6de0093c4b0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p><img src="https://img-blog.csdnimg.cn/bdf17194a1cf498081fbef30a0bc184e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;牛客网&quot;&gt;&lt;a href=&quot;#牛客网&quot; class=&quot;headerlink&quot; title=&quot;牛客网&quot;&gt;&lt;/a&gt;牛客网&lt;/h2&gt;&lt;h3 id=&quot;输入&quot;&gt;&lt;a href=&quot;#输入&quot; class=&quot;headerlink&quot; title=&quot;输入&quot;&gt;&lt;/a&gt;输入&lt;/h3&gt;&lt;p</summary>
      
    
    
    
    <category term="Java" scheme="https://gaofeng-lin.github.io/categories/Java/"/>
    
    
    <category term="牛客网" scheme="https://gaofeng-lin.github.io/tags/%E7%89%9B%E5%AE%A2%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="https://gaofeng-lin.github.io/posts/40991/"/>
    <id>https://gaofeng-lin.github.io/posts/40991/</id>
    <published>2022-03-05T16:00:00.000Z</published>
    <updated>2022-07-23T04:33:37.076Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker下载"><a href="#docker下载" class="headerlink" title="docker下载"></a>docker下载</h2><h3 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h3><p>1）卸载旧版本<br>yum list installed | grep docker 列出当前所有docker的包<br>yum -y remove docker的包名称 卸载docker包<br>rm -rf /var/lib/docker 删除docker的所有镜像和容器<br>2）安装必要的软件包<br>sudo yum install -y yum-utils \ device-mapper-persistent-data \ lvm2<br>3）设置下载的镜像仓库<br>sudo yum-config-manager \ –add-repo \ <a href="https://download.docker.com/linux/centos/docker-ce.repo">https://download.docker.com/linux/centos/docker-ce.repo</a><br>如果下载失败，采用阿里源和清华源。（详见菜鸟教程）<br>4）列出需要安装的版本列表<br>yum list docker-ce –showduplicates | sort -r<br>5）安装指定版本（这里使用18.0.1版本）<br>sudo yum install docker-ce-18.06.1.ce<br>6）查看版本<br>docker -v<br>7）启动Docker<br>sudo systemctl start docker 启动<br>sudo systemctl enable docker 设置开机启动</p><pre class="line-numbers language-none"><code class="language-none">yum list docker-ce --showduplicates | sort -r<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>列出版本列表，看看是否下载成功</p><p>添加镜像地址：</p><pre class="line-numbers language-none"><code class="language-none">vi /etc/docker/daemon.json //没有这个文件也无妨，直接创建就好<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/cecd311ce895425cafdd7a8edf9a376a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>这个地址的来源：<br>访问阿里云这个网址，要先登录：<a href="https://cr.console.aliyun.com/?spm=a2c6h.12873639.0.0.7aec4073HlA7e2#/accelerator">镜像加速页面</a></p><p><img src="https://img-blog.csdnimg.cn/641489fc54e74da0b71ef979826d1a3f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="docker启动失败"><a href="#docker启动失败" class="headerlink" title="docker启动失败"></a>docker启动失败</h3><p><strong>错误1：</strong><br>如图所示：<br><img src="https://img-blog.csdnimg.cn/56ed8bac9f524db3b2dbf64efaff96a0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>原因：</p><p>当时在 /etc/docker/daemon.json  添加了一行，但是忘了在第一行后面添加 “逗号”，加上就好。<br><img src="https://img-blog.csdnimg.cn/7c623f0bb0114b33a4f91a93a9da0450.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p><strong>错误2：</strong><br>docker启动失败，有一个可能就是包（jar,war）有问题。可以先单独检测下包是否可以运行。如果包不能运行，就是代码有问题。<br><strong>如果代码逻辑没有问题，甚至没有改动。可能要注意格式问题，比如少敲或多敲空格这种，这种错误往往看不出来，或者编译器没有明显的错误提示（idea对于这个问题就是标黄，但有时候又不影响，很容易不注意）</strong></p><h2 id="镜像、仓库的关系"><a href="#镜像、仓库的关系" class="headerlink" title="镜像、仓库的关系"></a>镜像、仓库的关系</h2><p>docker可以把服务和需要的库一起打包</p><p><img src="https://img-blog.csdnimg.cn/b935cbc86c8646b9a348f85b833ee48f.png" alt="在这里插入图片描述"><br>1.拉取镜像<br>2.Docker build<br>3.镜像-&gt;容器 docker run<br>4.容器-&gt;镜像 docker commit。</p><p>上面这图说明了三个得到镜像的途径<br>1．从docker官方仓库拉取。<br>2．使用dockerfile构建。<br>3．从已有的镜像构建容器，进入容器里面（docker -it 容器名称 /bin/bash），做修改，再提交（docker commit）。//这里面 /bin/bash 是进入容器内部，交互运行，和前面的-it也有关系。</p><p><strong>可以做什么？</strong><br>比如我拉取一个centos7镜像，进入里面把私有云那一堆东西全部装好。下次我就可以直接拿来用，把服务扔上去就好。<br>这个过程或者我可以用dockerfile来实现。</p><h2 id="docke"><a href="#docke" class="headerlink" title="docke"></a>docke<img src="https://img-blog.csdnimg.cn/b09b2d48438e4f24916b1453fe2d3207.png" alt="在这里插入图片描述"></h2><p>r 基本操作</p><h3 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> search 镜像名称<span class="token function">docker</span> pull 镜像名 <span class="token function">docker</span> pull 镜像名:tag<span class="token function">docker</span> images   //查看本地所有镜像//提交镜像<span class="token function">docker</span> commit 容器id 镜像:版本号//删除镜像<span class="token function">docker</span> rmi -f 镜像名称  <span class="token comment">##删除多个 其镜像ID或镜像用用空格隔开即可 </span><span class="token function">docker</span> rmi -f 镜像名/镜像ID 镜像名/镜像ID 镜像名/镜像ID<span class="token comment">##删除全部镜像  -a 意思为显示全部, -q 意思为只显示ID</span><span class="token function">docker</span> rmi -f <span class="token variable"><span class="token variable">$(</span><span class="token function">docker</span> images -aq<span class="token variable">)</span></span>//强制删除镜像<span class="token function">docker</span> image <span class="token function">rm</span> 镜像名称/镜像ID//保存镜像//将我们的镜像 保存为tar 压缩文件 这样方便镜像转移和保存 ,然后 可以在任何一台安装了docker的服务器上 加载这//个镜像<span class="token function">docker</span> save 镜像名/镜像ID -o 镜像保存在哪个位置与名字<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h3><p>容器是由镜像创建而来。容器是Docker运行应用的载体，每个应用都分别运行在Docker的每个 容器中</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -i 镜像名称:标签   //运行容器（默认是前台运行） <span class="token function">docker</span> <span class="token function">ps</span>  //查看运行的容器 <span class="token function">docker</span> <span class="token function">ps</span> -a  //查询所有容器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>实际命令分析：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -d -it --hostname phdev -p <span class="token number">90</span>:80 -p <span class="token number">8899</span>:8899 -v /sys/fs/cgroup:/sys/fs/cgroup --privileged “镜像名字” /usr/sbin/init//-d 容器以后台方式运行，不会直接进入到容器里面//hostname 指定主机名称；//-p 是端口映射。90:80 访问服务器90端口就是访问容器80端口//-v 是挂载到指定目录//  privileged  /usr/sbin/init  是给容器赋予更高的权限<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">//以shell方式进入到一个已经运行的容器当中，和上一条命令搭配起来使用<span class="token function">docker</span> <span class="token builtin class-name">exec</span> -it “容器id” /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="传输文件命令"><a href="#传输文件命令" class="headerlink" title="传输文件命令"></a>传输文件命令</h3><p>传输文件命令——本地传到docker</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token function">cp</span> “文件”  镜像id：“路径”<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="导出-x2F-导入镜像"><a href="#导出-x2F-导入镜像" class="headerlink" title="导出/导入镜像"></a>导出/导入镜像</h3><p>方法1：save</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">//导出<span class="token function">docker</span> save imagesID <span class="token operator">&gt;</span> /存放位置/打包文件名.tar//导入<span class="token function">docker</span> load <span class="token operator">&lt;</span> 打包文件名.tar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方法2：export</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">//导出<span class="token function">docker</span> <span class="token builtin class-name">export</span> 容器名 <span class="token operator">&gt;</span> /位置/打包名.tar//导入<span class="token function">docker</span> <span class="token function">import</span> <span class="token operator">&lt;</span> 打包名.tar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>区别：<br>(1).export导出的镜像文件大小 小于 save保存的镜像</p><p>(2).export 导出（import导入）是根据容器拿到的镜像，再导入时会丢失镜像所有的历史，所以无法进行回滚操作（docker tag ）；而save保存（load加载）的镜像，没有丢失镜像的历史，可以回滚到之前的层（layer）。（查看方式：docker images –tree）</p><h3 id="删除镜像或容器"><a href="#删除镜像或容器" class="headerlink" title="删除镜像或容器"></a>删除镜像或容器</h3><p><a href="https://blog.csdn.net/qq_42006301/article/details/105102020">原文链接</a><br>方法一：删除所有未运行的容器（已经运行的删除不了，未运行的就一起被删除了）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token function">rm</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">docker</span> <span class="token function">ps</span> -a -q<span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>方法二：根据容器的状态，删除Exited状态的容器</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token function">rm</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">docker</span> <span class="token function">ps</span> -qf <span class="token assign-left variable">status</span><span class="token operator">=</span>exited<span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>方法三：docker 1.13版本以后，可以使用 docker system 或 docker container命令清理容器。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">//docker container prune 删除已停用容器<span class="token function">docker</span> container prune//删除关闭的容器、无用的数据卷和网络，以及dangling镜像<span class="token function">docker</span> system prune //命令清理得更加彻底，可以将没有容器使用Docker的镜像都删掉<span class="token function">docker</span> system prune -a <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查看docker信息"><a href="#查看docker信息" class="headerlink" title="查看docker信息"></a>查看docker信息</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> info<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到docker的根路径是 /var/lib/docker<br><img src="https://img-blog.csdnimg.cn/2020032518583212.png#pic_center" alt="在这里插入图片描述"><br>查看docker根路径的磁盘占用率</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">df</span> -Th /var/lib/docker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;docker下载&quot;&gt;&lt;a href=&quot;#docker下载&quot; class=&quot;headerlink&quot; title=&quot;docker下载&quot;&gt;&lt;/a&gt;docker下载&lt;/h2&gt;&lt;h3 id=&quot;Docker安装&quot;&gt;&lt;a href=&quot;#Docker安装&quot; class=&quot;head</summary>
      
    
    
    
    <category term="运维" scheme="https://gaofeng-lin.github.io/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="Docker" scheme="https://gaofeng-lin.github.io/tags/Docker/"/>
    
    <category term="运维" scheme="https://gaofeng-lin.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Mysql</title>
    <link href="https://gaofeng-lin.github.io/posts/62688/"/>
    <id>https://gaofeng-lin.github.io/posts/62688/</id>
    <published>2022-03-05T16:00:00.000Z</published>
    <updated>2022-07-23T03:16:08.192Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mysql变量定义与赋值"><a href="#Mysql变量定义与赋值" class="headerlink" title="Mysql变量定义与赋值"></a>Mysql变量定义与赋值</h2><p><a href="https://blog.csdn.net/H900302/article/details/123735007?spm=1001.2101.3001.6650.5&amp;depth_1-utm_relevant_index=10">原链接</a></p><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><h4 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h4><pre class="line-numbers language-none"><code class="language-none">declare a int default value 0;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h4><pre class="line-numbers language-none"><code class="language-none">//法一set a=10;//法二select user_name into uname from t_user where id = 2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="用户变量"><a href="#用户变量" class="headerlink" title="用户变量"></a>用户变量</h3><p>使用set或select直接赋值，变量名以 @ 开头.</p><h4 id="变量赋值-1"><a href="#变量赋值-1" class="headerlink" title="变量赋值"></a>变量赋值</h4><pre class="line-numbers language-none"><code class="language-none">SET @a=1,@b=2;//法二select @变量名:=变量值select @变量名:=字段名 from table where ... limit 1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h3><h2 id="MySQL理论知识"><a href="#MySQL理论知识" class="headerlink" title="MySQL理论知识"></a>MySQL理论知识</h2><h3 id="事务并发异常"><a href="#事务并发异常" class="headerlink" title="事务并发异常"></a>事务并发异常</h3><p>SQL 标准共定义了 3 种并发异常，这三种异常分别是脏读（Dirty Read）、不可重复读（Nnrepeatable Read）和幻读（Phantom Read）。</p><ol><li>脏读</li></ol><p>脏读指的是读到了其他事务未提交的数据，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。读到了并一定最终存在的数据，这就是脏读。</p><p><img src="https://pics7.baidu.com/feed/d01373f082025aaf5be5454896a1dd6d024f1a37.jpeg?token=15d738bce1e19daf55fa99c5fc036539" alt="在这里插入图片描述"></p><p><strong>脏读最大的问题就是可能会读到不存在的数据。</strong></p><ol start="2"><li>不可重复读</li></ol><p>不可重复读指的是在一个事务内，最开始读到的数据和事务结束前的任意时刻读到的同一批数据出现不一致的情况。</p><p><img src="https://pics1.baidu.com/feed/cf1b9d16fdfaaf51b5c3d1cbe318e2e7f01f7a73.jpeg?token=0a1d7df4e2f9fae479bc98bd763fd2ee"></p><p>事务 A 多次读取同一数据，但事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。</p><ol start="3"><li>幻读<br>幻读侧重的方面是某一次的 select 操作得到的结果所表征的数据状态无法支撑后续的业务操作。更为具体一些：select 某记录是否存在，不存在，准备插入此记录，但执行 insert 时发现此记录已存在，无法插入，此时就发生了幻读。</li></ol><p><strong>不可重复读侧重表达 读-读，幻读则是说 读-写，用写来证实读的是鬼影。</strong></p><p>举例：<br>假设有张用户表,这张表的 id 是主键。表中一开始有4条数据。<br><img src="https://pics6.baidu.com/feed/d52a2834349b033be131703c798240dad439bd75.jpeg?token=3e013deb540b45db9ad7ab03563d06ef"></p><p>我们再来看下出现 幻读 的场景</p><p><img src="https://pics3.baidu.com/feed/8435e5dde71190efb4aa7a77bb57eb1ffcfa609f.jpeg?token=5b271d6e820ca8770d6d6caf3955937c"></p><p>这里是在RR级别下研究(可重复读),因为 RU / RC 下还会存在脏读、不可重复读，故我们就以 RR 级别来研究 幻读，排除其他干扰。</p><p>1、事务A,查询是否存在 id=5 的记录，没有则插入，这是我们期望的正常业务逻辑。</p><p>2、这个时候 事务B 新增的一条 id=5 的记录，并提交事务。</p><p>3、事务A,再去查询 id=5 的时候,发现还是没有记录（因为这里是在RR级别下研究(可重复读)，所以读到依然没有数据）</p><p>4、事务A,插入一条 id=5 的数据。</p><p>最终 事务A 提交事务，发现报错了。这就很奇怪，查的时候明明没有这条记录，但插入的时候 却告诉我 主键冲突，这就好像幻觉一样。这才是所有的幻读。</p><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p><img src="https://s2.loli.net/2022/05/21/A3Gb6Rtfmr571yE.png" alt="Snipaste_2022-05-21_23-28-56.png"><br>上面的隔离级别由上往下，级别依次会提高，但消耗的性能也会依次提高。我们总结一下四种隔离级别：</p><ol><li>读未提交：允许读未提交数据，可能会发生脏读、不可重复读和幻读异常；</li><li>读已提交：只能读已经提交的数据，避免了脏读，但可能会出现不可重复读和幻读；</li><li>可重复读：即能保证在一个事务中多次读取，数据一致，但可能会出现幻读；</li><li>可串行化：最高的隔离级别，串行的执行事务，可以避免 3 种异常，但性能耗损最高。</li></ol><h2 id="Mysql语句"><a href="#Mysql语句" class="headerlink" title="Mysql语句"></a>Mysql语句</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>MySQL 支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型。</p><h4 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h4><p><img src="https://img-blog.csdnimg.cn/c1dbf744928b4225aca0777923efbdb9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h4 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h4><p><img src="https://img-blog.csdnimg.cn/dca2d56f9cf9450e92c8ecec362a8d05.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><p><img src="https://img-blog.csdnimg.cn/96f697d0ac234fb8b92b4b72a3da027e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h3><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE table_name (column_name column_type);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>实例1：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">CREATE TABLE IF NOT EXISTS <span class="token variable"><span class="token variable">`</span>runoob_tbl<span class="token variable">`</span></span><span class="token punctuation">(</span>   <span class="token variable"><span class="token variable">`</span>runoob_id<span class="token variable">`</span></span> INT UNSIGNED AUTO_INCREMENT,   <span class="token variable"><span class="token variable">`</span>runoob_title<span class="token variable">`</span></span> VARCHAR<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> NOT NULL,   <span class="token variable"><span class="token variable">`</span>runoob_author<span class="token variable">`</span></span> VARCHAR<span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span> NOT NULL,   <span class="token variable"><span class="token variable">`</span>submission_date<span class="token variable">`</span></span> DATE,   PRIMARY KEY <span class="token punctuation">(</span> <span class="token variable"><span class="token variable">`</span>runoob_id<span class="token variable">`</span></span> <span class="token punctuation">)</span><span class="token punctuation">)</span>ENGINE<span class="token operator">=</span>InnoDB DEFAULT <span class="token assign-left variable">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你不想字段为 NULL 可以设置字段的属性为 NOT NULL， 在操作数据库时如果输入该字段的数据为NULL ，就会报错。<br>AUTO_INCREMENT定义列为自增的属性，一般用于主键，数值会自动加1。<br>PRIMARY KEY关键字用于定义列为主键。 您可以使用多列来定义主键，列间以逗号分隔。<br>ENGINE 设置存储引擎，CHARSET 设置编码。</p><p>实例2：<br><img src="https://img-blog.csdnimg.cn/ff323136692f4472847f83481071002e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>int(10)的意思是假设有一个变量名为id，它的能显示的宽度能显示10位。在使用id时，假如我给id输入10，那么mysql会默认给你存储0000000010。当你输入的数据不足10位时，会自动帮你补全位数。假如我设计的id字段是int(20)，那么我在给id输入10时，mysql会自动补全18个0，补到20位为止。</p><p><strong>int(M)的作用于int的范围明显是无关的，int(M)只是用来显示数据的宽度，我们能看到的宽度。当字段被设计为int类型，那么它的范围就已经被写死了（看上面的1.1节的内容），与M无关。</strong></p><p><strong>以上面这个为例，有几个注意事项：<br>1.表名和字段名外面的符号 ` 不是单引号，而是英文输入法状态下的反单引号，也就是键盘左上角 esc 按键下面的那一个 ~ 按键。<br>2.comment 后面的字段用单引号括起来</strong></p><p>注意：MySQL命令终止符为分号 ; 。</p><h3 id="查看数据表"><a href="#查看数据表" class="headerlink" title="查看数据表"></a>查看数据表</h3><p>法一：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">DESCRIBE 表名<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或简写成：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">DESC 表名<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>法二：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">SHOW CREATE TABLE 表名<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 SHOW CREATE TABLE 语句的结尾处（分号前面）添加\g或者\G参数可以改变展示形式。</p><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><h4 id="1-插入一行"><a href="#1-插入一行" class="headerlink" title="1.插入一行"></a>1.插入一行</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">INSERT INTO table_name <span class="token punctuation">(</span> field1, field2,<span class="token punctuation">..</span>.fieldN <span class="token punctuation">)</span>                       VALUES                       <span class="token punctuation">(</span> value1, value2,<span class="token punctuation">..</span>.valueN <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>注意：这个是添加一行数据，不是添加一列。添加一列要增加新的字段。</strong></p><pre class="line-numbers language-none"><code class="language-none">INSERT INTO teacher (name,age,id_number) VALUES ('秦小贤',18,'42011720200604088X');<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>注意：表名后面的字段没有引号，插入的数据，如果是字符串，要加引号</strong></p><h4 id="2-插入多行"><a href="#2-插入多行" class="headerlink" title="2.插入多行"></a>2.插入多行</h4><pre class="line-numbers language-none"><code class="language-none">INSERT INTO teacher(name,age,id_number)VALUES('王小花',19,'42011720200604077X'),('张晓丽',18,'42011720200604099X'),('刘美丽',20,'42011720200604020X'),('吴帅',21,'42011720200604022X'),('张平',22,'42011720200604033X')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-插入一列"><a href="#3-插入一列" class="headerlink" title="3.插入一列"></a>3.插入一列</h4><p>前提是这一列已经建好（通过ALTER），如果不加where，那是这个字段（一列）全部更新。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">UPDATE table_name SET field1<span class="token operator">=</span>new<span class="token operator">-</span>value1<span class="token punctuation">,</span> field2<span class="token operator">=</span>new<span class="token operator">-</span>value2<span class="token punctuation">[</span>WHERE Clause<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="修改表名和字段（增、删、改）"><a href="#修改表名和字段（增、删、改）" class="headerlink" title="修改表名和字段（增、删、改）"></a>修改表名和字段（增、删、改）</h3><h4 id="删除、添加、修改字段"><a href="#删除、添加、修改字段" class="headerlink" title="删除、添加、修改字段"></a>删除、添加、修改字段</h4><pre class="line-numbers language-none"><code class="language-none">//删除字段i//如果数据表中只剩余一个字段则无法使用DROP来删除字段。mysql&gt; ALTER TABLE testalter_tbl  DROP i;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>添加字段：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">mysql<span class="token operator">&gt;</span> ALTER TABLE testalter_tbl ADD i INT<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果你需要指定新增字段的位置，可以使用MySQL提供的关键字 FIRST (设定位第一列)， AFTER 字段名（设定位于某个字段之后）。</p><p>尝试以下 ALTER TABLE 语句, 在执行成功后，使用 SHOW COLUMNS 查看表结构的变化：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">ALTER TABLE testalter_tbl DROP i<span class="token punctuation">;</span>ALTER TABLE testalter_tbl ADD i INT FIRST<span class="token punctuation">;</span>ALTER TABLE testalter_tbl DROP i<span class="token punctuation">;</span>ALTER TABLE testalter_tbl ADD i INT AFTER c<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>指定位置插入字段</strong></p><pre class="line-numbers language-none"><code class="language-none">//添加到第一个alter table 表名 add column 字段名 varchar(255) FIRST;//添加到指定字段后，记得加上符号，那个符号是esc按键下面的alter table person_param add column `module_name` VARCHAR(20) after `product_id`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="修改字段类型及名称"><a href="#修改字段类型及名称" class="headerlink" title="修改字段类型及名称"></a>修改字段类型及名称</h4><p><img src="https://img-blog.csdnimg.cn/3b1fe134a6ee4169be9014e24667eced.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><p>默认用户为root，但是在Linux和mysql中，可以认为root用户就是各自系统的皇帝，对其它用户的数据有生杀大权，所以最好创建其它的用户来执行。<br>1.先登录</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql -uroot -p<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2.创建一个只能在mysql服务器所在主机使用的用户，此处为localuser</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">create user <span class="token string">'用户名'</span>@<span class="token string">'localhost'</span> identified by <span class="token string">'用户的密码'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>localuser可以在mysql服务器所在主机正常使用</p><p>3.在另外一台主机登陆时，会报错</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">本机登陆：mysql -ulcocaluser -p远程登陆：mysql -h mysql服务器ip -ulocaluser -p<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>4、创建一个只能由特定远程主机使用的帐户，此处为limituser。</p><p>limituser只能在指定的主机使用。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">create user <span class="token string">'limituser'</span>@<span class="token string">'远程主机ip'</span> identified by <span class="token string">'123'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>本机登陆：mysql -ulcocaluser -p</p><p>远程登陆：mysql -h mysql服务器ip -ulocaluser -p</p><p>5、创建一个可以在本地和远程都可以登陆的用户，此处为unlimituser。</p><p>对，就是在创建用户时，host使用通配符%</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">create user <span class="token string">'unlimituser'</span>@<span class="token string">'%'</span> identified by <span class="token string">'123'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>unlimituser用户服务器主机和远程主机登陆</p><p>6.删除用户</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">drop user <span class="token string">'mysqluser'</span>@<span class="token string">'host'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="创建外键"><a href="#创建外键" class="headerlink" title="创建外键"></a>创建外键</h3><h4 id="创建表时增加外键"><a href="#创建表时增加外键" class="headerlink" title="创建表时增加外键"></a>创建表时增加外键</h4><p>首先创建第一张被关联表Vendors商品供应商表。</p><pre class="line-numbers language-none"><code class="language-none">-- 供应商列表CREATE TABLE Vendors (-- 供应商ID：主键列，自增长vend_id INT NOT NULL PRIMARY KEY AUTO_INCREMENT COMMENT '供应商ID',-- 供应商名：可变字符，非空vend_name VARCHAR (30) NOT NULL COMMENT '供应商名',-- 供应商地址vend_address VARCHAR (100) NOT NULL COMMENT '地址',-- 供应商城市vend_city VARCHAR (20) NOT NULL COMMENT '城市',-- 供应商州vend_state VARCHAR (20) NOT NULL COMMENT '州',-- 供应商邮编vend_zip VARCHAR (20) NOT NULL COMMENT '邮编',-- 供应商国家vend_country VARCHAR (20) NOT NULL COMMENT '国家');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后创建第二张关联表Products产品表。</p><pre class="line-numbers language-none"><code class="language-none">-- 产品目录表CREATE TABLE Products (-- 产品ID：主键列，自增长prod_id INT NOT NULL PRIMARY KEY AUTO_INCREMENT,-- 供应商ID：外键vend_id INT NOT NULL COMMENT '供应商ID',-- 产品名prod_name VARCHAR (30) NOT NULL COMMENT '产品名',-- 产品价格prod_price DOUBLE NOT NULL COMMENT '产品价格',-- 产品描述prod_desc VARCHAR (100) COMMENT '产品描述',FOREIGN KEY (vend_id) REFERENCES Vendors (vend_id));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="已存在表增加外键"><a href="#已存在表增加外键" class="headerlink" title="已存在表增加外键"></a>已存在表增加外键</h4><p>首先删除刚才两张表所创建的外键。<br>然后通过下面指令对已经存在的表增加外键。语法如下：</p><pre class="line-numbers language-none"><code class="language-none">-- 已存在表增加外键//(主键字段)和 (外键字段)没有加括号会报错ALTER TABLE ZDZ ADD FOREIGN KEY (sd) REFERENCES Ws_para (snum);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="连表查询"><a href="#连表查询" class="headerlink" title="连表查询"></a>连表查询</h3><p><a href="https://juejin.cn/post/7043811976270577672">详细介绍网址</a></p><pre class="line-numbers language-none"><code class="language-none">SELECT * from `products` a RIGHT JOIN `person_param` b ON a.product_id=b.product_id WHERE a.product_id=338;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>连表查的第一步就是两个表要关连起来，在上面的代码就是 ON 后面的<code> a.product_id=b.product_id</code></p><h2 id="Mysql常见问题"><a href="#Mysql常见问题" class="headerlink" title="Mysql常见问题"></a>Mysql常见问题</h2><h3 id="mysql官网下载老版本"><a href="#mysql官网下载老版本" class="headerlink" title="mysql官网下载老版本"></a>mysql官网下载老版本</h3><p><a href="https://dev.mysql.com/downloads/mysql/">下载网址，可选操作系统</a></p><p>进入后依次选择：DOWNLOADS（下载）——&gt;Community(社区)——MySQL Community Downloads<br><img src="https://img-blog.csdnimg.cn/d11d8469ebcd411faf3c9b67c4f4e02b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>进入后往下拉，如下图选择Looking for previous GA versions（寻找以前的GA版本）<br><img src="https://img-blog.csdnimg.cn/1371dd641c0e4c3ab54e10660e5907ed.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="centos安装mysql"><a href="#centos安装mysql" class="headerlink" title="centos安装mysql"></a>centos安装mysql</h3><p>本地下载mysql，但是xftp上传太慢，暂未找到解决的办法，所以尝试下面这个方法。</p><p><strong>1 下载并安装MySQL官方的 Yum Repository</strong></p><pre class="line-numbers language-none"><code class="language-none">wget -i -c http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用上面的命令就直接下载了安装用的Yum Repository，大概25KB的样子，然后就可以直接yum安装了。</p><pre class="line-numbers language-none"><code class="language-none">yum -y install mysql57-community-release-el7-10.noarch.rpm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 之后就开始安装MySQL服务器。</p><pre class="line-numbers language-none"><code class="language-none">yum -y install mysql-community-server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这步可能会花些时间，安装完成后就会覆盖掉之前的mariadb。<br><img src="https://img-blog.csdnimg.cn/000f9e71988a495bb16d7f886050e5f7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_18,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>至此MySQL就安装完成了，然后是对MySQL的一些设置。</p><p><strong>2 MySQL数据库设置</strong></p><pre class="line-numbers language-none"><code class="language-none">systemctl start  mysqld.service // 首先启动MySQLsystemctl status mysqld.service //查看MySQL运行状态<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/acda61b3da8b4837ad7bdf9020468ea1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>此时MySQL已经开始正常运行，不过要想进入MySQL还得先找出此时root用户的密码，通过如下命令可以在日志文件中找出密码：</p><pre class="line-numbers language-none"><code class="language-none">grep "password" /var/log/mysqld.log<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 如下命令进入数据库：</p><pre class="line-numbers language-none"><code class="language-none">mysql -u root -p<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输入初始密码，此时不能做任何事情，因为MySQL默认必须修改密码之后才能操作数据库：</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; ALTER USER 'root'@'localhost' IDENTIFIED BY 'new password';//密码需要设置复杂点，不然会报错。原因是因为MySQL有密码设置的规范，具体是与validate_password_policy的值有关：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>3.密码修改</strong><br><em><strong>上面那一步修改是必须的，否则没法二次修改密码</strong></em></p><p>先进入mysql</p><p>查看 mysql 初始的密码策略</p><pre class="line-numbers language-none"><code class="language-none">SHOW VARIABLES LIKE 'validate_password%';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/0d3db11aae794c05adf48c94ade4094b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>首先需要设置密码的验证强度等级，设置 validate_password_policy 的全局参数为 LOW 即可</p><pre class="line-numbers language-none"><code class="language-none">set global validate_password_policy=LOW; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当前密码长度为 8 ，如果不介意的话就不用修改了，按照通用的来讲，设置为 6 位的密码，设置 validate_password_length 的全局参数为 6 即可</p><pre class="line-numbers language-none"><code class="language-none">set global validate_password_length=6;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在可以为 mysql 设置简单密码了，只要满足六位的长度即可</p><pre class="line-numbers language-none"><code class="language-none">ALTER USER 'root'@'localhost' IDENTIFIED BY '123456';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>注：在默认密码的长度最小值为 4 ，由 大/小写字母各一个 + 阿拉伯数字一个 + 特殊字符一个， 只要设置密码的长度小于 3<br>，都将自动设值为 4 ，如下图：</p><br><p>关于 mysql 密码策略相关参数；<br> 1）、validate_password_length  固定密码的总长度；<br>2）、validate_password_dictionary_file 指定密码验证的文件路径；<br>3）、validate_password_mixed_case_count  整个密码中至少要包含大/小写字母的总个数；<br>4）、validate_password_number_count  整个密码中至少要包含阿拉伯数字的个数；<br>5）、validate_password_policy 指定密码的强度验证等级，默认为 MEDIUM； 关于<br>validate_password_policy 的取值： 0/LOW：只验证长度； 1/MEDIUM：验证长度、数字、大小写、特殊字符；<br>2/STRONG：验证长度、数字、大小写、特殊字符、字典文件；<br>6）、validate_password_special_char_count 整个密码中至少要包含特殊字符的个数；</p></blockquote><h3 id="重置密码（centos7）"><a href="#重置密码（centos7）" class="headerlink" title="重置密码（centos7）"></a>重置密码（centos7）</h3><p><a href="https://blog.csdn.net/cgtcsdn/article/details/101530671">原文链接</a></p><h4 id="忘记密码"><a href="#忘记密码" class="headerlink" title="忘记密码"></a>忘记密码</h4><p><strong>1.设置MySQL为免密码登录</strong><br><code>vi /etc/my.cnf</code> (部分Linux安装了vim，其命令则改为<code>vim /etc/my.cnf</code>)按【i】键进入编辑模式，在[mysqld]下面加上“skip-grant-tables”，按【Esc】键，然后输入“:wq”保存并退出vi。<br><img src="https://img-blog.csdnimg.cn/20190927141449601.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NndGNzZG4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><strong>重新启动MySQL服务（使配置生效，此步骤不能省略）</strong></p><pre class="line-numbers language-none"><code class="language-none">service mysqld restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>清空旧密码</strong></p><pre class="line-numbers language-none"><code class="language-none">mysql -u root –p （无需输入密码，直接按回车键进入）use mysqlupdate user set authentication_string = '' where user = 'root';quit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>删除免密码登录代码“skip-grant-tables”</strong></p><p>vi /etc/my.cnf，按【i】键进入编辑模式，删除[mysqld]下面的代码“skip-grant-tables”，按【Esc】键，然后输入“:wq”保存并退出vi。</p><p><strong>重设密码</strong></p><pre class="line-numbers language-none"><code class="language-none">service mysqld restartmysql -u root –p （无需输入密码，直接按回车键进入）use mysqlALTER USER 'root'@'%' IDENTIFIED BY 'snaiL_12';  //密码要用引号括起来<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h4><p><em><strong>问题1</strong></em></p><pre class="line-numbers language-none"><code class="language-none">ALTER USER 'root'@'localhost' IDENTIFIED BY 'snaiL_123';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>报错：<code>ERROR 1819 (HY000): Your password does not satisfy the current policy requirements</code></p><p><strong>解决：</strong></p><pre class="line-numbers language-none"><code class="language-none">SHOW VARIABLES LIKE 'validate_password%';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>1.2调整MySQL密码验证规则，修改 policy 和 length 的值。</p><pre class="line-numbers language-none"><code class="language-none">set global validate_password——policy=0;（“0”等价于“LOW”，含义是只验证密码长度）set global validate_password.length=8;（因为我之前动过密码长度，这里我将密码长度设为8）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><em><strong>问题2</strong></em></p><pre class="line-numbers language-none"><code class="language-none">ALTER USER 'root'@'localhost' IDENTIFIED BY 'snaiL_123';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>报错：<code>ERROR 1396 (HY000): Operation ALTER USER failed for 'root'@'localhost'</code></p><p><strong>查看root账户的host</strong></p><pre class="line-numbers language-none"><code class="language-none">select user,host from user;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20190927141940582.png#pic_center" alt="在这里插入图片描述"></p><p>2.2注意看，我的host是“%”，你输入的命令可能是：</p><pre class="line-numbers language-none"><code class="language-none">ALTERUSER 'root'@'localhost' IDENTIFIED BY 'Snail@10'; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将命令改成：</p><pre class="line-numbers language-none"><code class="language-none">ALTER USER 'root'@'%' IDENTIFIED BY 'Snail@10'; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Navicat连接mysql出现1130-Host-XXX-is-not-allowed-to-connect-to-this-MySQL-server"><a href="#Navicat连接mysql出现1130-Host-XXX-is-not-allowed-to-connect-to-this-MySQL-server" class="headerlink" title="Navicat连接mysql出现1130 - Host XXX is not allowed to connect to this MySQL server"></a>Navicat连接mysql出现1130 - Host XXX is not allowed to connect to this MySQL server</h3><p>接上一条，安装完成后，navicat无法正常连接，这是由于Mysql配置了不支持远程连接引起的。</p><p><strong>1.在安装Mysql数据库的主机上登录root用户</strong></p><pre class="line-numbers language-none"><code class="language-none">mysql -u root -p<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2.依次执行如下命令：</p><pre class="line-numbers language-none"><code class="language-none">use mysql; select host from user where user='root';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以看到当前主机配置信息为localhost.<br><img src="https://img-blog.csdnimg.cn/e4dee3a582374c6eba09244e9b947247.png" alt="在这里插入图片描述"><br>3.将Host设置为通配符%</p><p>Host列指定了允许用户登录所使用的IP，比如user=root Host=192.168.1.1。这里的意思就是说root用户只能通过192.168.1.1的客户端去访问。 user=root Host=localhost，表示只能通过本机客户端去访问。而%是个通配符，如果Host=192.168.1.%，那么就表示只要是IP地址前缀为“192.168.1.”的客户端都可以连接。如果Host=%，表示所有IP都有连接权限。 </p><p><strong>注意：在生产环境下不能为了省事将host设置为%，这样做会存在安全问题，具体的设置可以根据生产环境的IP进行设置；</strong></p><pre class="line-numbers language-none"><code class="language-none">update user set host = '%' where user ='root';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Host设置了“%”后便可以允许远程访问。</p><p><img src="https://img-blog.csdnimg.cn/8a3b8bb5074a4f8b9132a2eebdec3301.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_14,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>4..Host修改完成后记得执行flush privileges使配置立即生效</p><pre class="line-numbers language-none"><code class="language-none">flush privileges;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="批量插入数据很慢"><a href="#批量插入数据很慢" class="headerlink" title="批量插入数据很慢"></a>批量插入数据很慢</h3><p><a href="https://www.jianshu.com/p/127e79e20d1b">原文链接</a></p><h4 id="批量提交事务"><a href="#批量提交事务" class="headerlink" title="批量提交事务"></a>批量提交事务</h4><pre class="line-numbers language-none"><code class="language-none">## 3、批量提交事务drop procedure if exists insertIntoUser;delimiter $$ create procedure insertIntoUser(in num int, in batchNum int)    begin        declare i int default 0;                while i &lt; num do            set i = i + 1;            set @username = concat('beigua', LPAD(i, 9, 0));            set @nickname = concat('北瓜', LPAD(i, 9, 0));            set @password = replace(uuid(), "-", "");            set @password_salt = replace(uuid(), "-", "");            set @user_no = i;            set autocommit = 0;            INSERT INTO user(username, password, password_salt, nickname, user_no, ip, mobile, mail, gender, type, status, is_deleted, created_time, updated_time)             VALUES (@username, @password, @password_salt, @nickname, @user_no, '192.168.1.1', '18888888888', '18888888888@163.com', '0', '0', '0', '0', now(), now());                    if i mod batchNum = 0 then                commit;            end if;        end while;    end $$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="一次性提交所有事务"><a href="#一次性提交所有事务" class="headerlink" title="一次性提交所有事务"></a>一次性提交所有事务</h4><pre class="line-numbers language-none"><code class="language-none">## 4、一次性提交事务drop procedure if exists insertIntoUser;delimiter $$ create procedure insertIntoUser(in num int)    begin        declare i int default 0;        set autocommit = 0;                while i &lt; num do            set i = i + 1;            set @username = concat('beigua', LPAD(i, 9, 0));            set @nickname = concat('北瓜', LPAD(i, 9, 0));            set @password = replace(uuid(), "-", "");            set @password_salt = replace(uuid(), "-", "");            set @user_no = i;            INSERT INTO user(username, password, password_salt, nickname, user_no, ip, mobile, mail, gender, type, status, is_deleted, created_time, updated_time)             VALUES (@username, @password, @password_salt, @nickname, @user_no, '192.168.1.1', '18888888888', '18888888888@163.com', '0', '0', '0', '0', now(), now());        end while;                commit;    end $$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="数据插入前加索引与数据插入后加索引对比"><a href="#数据插入前加索引与数据插入后加索引对比" class="headerlink" title="数据插入前加索引与数据插入后加索引对比"></a>数据插入前加索引与数据插入后加索引对比</h4><p>在插入数据的时候不要加过多索引，插完再加</p><h4 id="修改参数"><a href="#修改参数" class="headerlink" title="修改参数"></a>修改参数</h4><p>set global innodb_flush_log_at_trx_commit = 0;</p><br><h2 id="如何设计数据库"><a href="#如何设计数据库" class="headerlink" title="如何设计数据库"></a>如何设计数据库</h2><p><a href="https://blog.csdn.net/LLLLQZ/article/details/110231569">原文链接</a></p><h2 id="游标、存储过程、函数"><a href="#游标、存储过程、函数" class="headerlink" title="游标、存储过程、函数"></a>游标、存储过程、函数</h2><p>存储过程是为了完成特定功能的SQL语句集，经编译创建并保存在数据库中，用户可通过指定存储过程的名字并给定参数(需要时)来调用执行。</p><p>存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用。</p><p><strong>使用存储过程需要注意一些问题</strong></p><ol><li>注意分号的使用，语句后面没加分号会报错</li><li>存储过程既可以放查询里面，也可以放存储里面（工具栏-》函数-》存储）</li><li>mysql存储过程每一句后面必须用;结尾，使用的<strong>临时字段</strong>需要在定义游标之前进行声明。</li></ol><p>上面第三点的解释如下：</p><pre class="line-numbers language-none"><code class="language-none">DECLARE s int DEFAULT 0;declare p_t_id bigint(20);declare varmodule int DEFAULT 0;declare varparam int DEFAULT 0; declare pid cursor for select product_id from products;DECLARE CONTINUE HANDLER FOR NOT FOUND SET s=1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所有的declare必须放在游标声明前面（declare pid cursor这句）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Mysql变量定义与赋值&quot;&gt;&lt;a href=&quot;#Mysql变量定义与赋值&quot; class=&quot;headerlink&quot; title=&quot;Mysql变量定义与赋值&quot;&gt;&lt;/a&gt;Mysql变量定义与赋值&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net</summary>
      
    
    
    
    <category term="数据库" scheme="https://gaofeng-lin.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="运维" scheme="https://gaofeng-lin.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="数据库" scheme="https://gaofeng-lin.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="Linux" scheme="https://gaofeng-lin.github.io/tags/Linux/"/>
    
    <category term="MySQL" scheme="https://gaofeng-lin.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Linux知识点+问题</title>
    <link href="https://gaofeng-lin.github.io/posts/54220/"/>
    <id>https://gaofeng-lin.github.io/posts/54220/</id>
    <published>2022-03-05T16:00:00.000Z</published>
    <updated>2022-07-23T03:16:06.253Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h2><h3 id="error-while-loading-shared-libraries错误解决办法"><a href="#error-while-loading-shared-libraries错误解决办法" class="headerlink" title="error while loading shared libraries错误解决办法"></a>error while loading shared libraries错误解决办法</h3><p><strong>背景：求解器执行的适合报找不到libmpiexec.so.12这个东西，但是在/opt/mpich/lib下面有这个东西。路径什么的也都加入到了 环境变量里面 （<del>/.bash_profile或</del>/.bashrc）。还是无法解决问题</strong><br><a href="https://blog.csdn.net/dumeifang/article/details/2963223?spm=1001.2101.3001.6650.1&amp;depth_1-utm_relevant_index=2">原文链接</a><br>出现这类错误表示，系统不知道xxx.so放在哪个目录下，这时候就要在/etc/ld.so.conf中加入xxx.so所在的目录。</p><p>运行命令 <code>sudo gedit /etc/ld.so.conf</code> 在第一行后面空一格 添加/usr/local/lib 保存。运行<code>sudo /sbin/ldconfig</code>更新</p><h2 id="make-和-cmake"><a href="#make-和-cmake" class="headerlink" title="make 和 cmake"></a>make 和 cmake</h2><p><a href="https://blog.csdn.net/KP1995/article/details/109569787">原文链接</a></p><h3 id="什么是make"><a href="#什么是make" class="headerlink" title="什么是make"></a>什么是make</h3><p>make工具可以看成是一个智能的批处理工具，它本身并没有编译和链接的功能，而是用类似于批处理的方式—通过调用makefile文件中用户指定的命令来进行编译和链接。</p><h3 id="什么是Makefile"><a href="#什么是Makefile" class="headerlink" title="什么是Makefile"></a>什么是Makefile</h3><p>简单的说就像一首歌的乐谱，make工具就像指挥家，指挥家根据乐谱指挥整个乐团怎么样演奏，make工具就根据makefile中的命令进行编译和链接。makefile命令中就包含了调用gcc（也可以是别的编译器）去编译某个源文件的命令。makefile在一些简单的工程完全可以用人工手写，但是当工程非常大的时候，手写makefile也是非常麻烦的，如果换了个平台makefile又要重新修改。这时候就出现了Cmake工具。</p><h3 id="什么是Cmake"><a href="#什么是Cmake" class="headerlink" title="什么是Cmake"></a>什么是Cmake</h3><p>cmake可以更加简单的生成makefile文件给上面那个make用。当然cmake还有其他功能，就是可以跨平台生成对应平台能用的makefile，你就不用再自己去修改了。cmake根据什么生成makefile呢？它又要根据一个叫CMakeLists.txt文件（学名：组态档）去生成makefile。到最后CMakeLists.txt文件谁写啊？亲，是你自己手写的。</p><p>当然如果你用IDE，类似VS这些一般它都能帮你弄好了，你只需要按一下那个三角形。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">简单总结cmake用来转译CMakeLists.txt，在linux下它会生成Makefile，来给make执行。Makefile+make可理解为类unix环境下的项目管理工具， 而cmake是抽象层次更高的项目管理工具。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>下面给出其关系图：<br><img src="https://img-blog.csdnimg.cn/20201109214319194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tQMTk5NQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="x2F-configure-amp-amp-make-amp-amp-make-install"><a href="#x2F-configure-amp-amp-make-amp-amp-make-install" class="headerlink" title="./configure &amp;&amp; make &amp;&amp; make install"></a>./configure &amp;&amp; make &amp;&amp; make install</h2><h3 id="x2F-configure"><a href="#x2F-configure" class="headerlink" title="./configure"></a>./configure</h3><p>源码的安装一般由3个步骤组成：**配置(configure)、编译(make)、安装(make install)**。</p><p>configure文件是一个可执行的脚本文件,是用来检测你的安装平台的目标特征的。比如它会检测你是不是有CC或GCC，并不是需要CC或GCC.<br>它有很多选项，在待安装的源码目录下使用命令<code>./configure –help</code>可以输出详细的选项列表。</p><p>其中–prefix选项是配置安装目录，如果不配置该选项，安装后可执行文件默认放在/usr /local/bin，库文件默认放在/usr/local/lib，配置文件默认放在/usr/local/etc，其它的资源文件放在/usr /local/share，比较凌乱。</p><p>如果配置了–prefix，如：</p><p>$ ./configure –prefix=/usr/local/test</p><p>安装后的所有资源文件都会被放在/usr/local/test目录中，不会分散到其他目录。</p><p>使用–prefix选项的另一个好处是方便卸载软件或移植软件；当某个安装的软件不再需要时，只须简单的删除该安装目录，就可以把软件卸载得干干净净；而移植软件只需拷贝整个目录到另外一个机器即可（相同的操作系统下）。</p><p>当然要卸载程序，也可以在原来的make目录下用一次make uninstall，但前提是Makefile文件有uninstall命令（nodejs的源码包里有uninstall命令，测试版本v0.10.35）。</p><p><strong>关于卸载：</strong><br>如果没有配置–prefix选项，源码包也没有提供make uninstall，则可以通过以下方式可以完整卸载：</p><p>找一个临时目录重新安装一遍，如：<br>$ ./configure –prefix=/tmp/to_remove &amp;&amp; make install</p><p>然后遍历/tmp/to_remove的文件，删除对应安装位置的文件即可（因为/tmp/to_remove里的目录结构就是没有配置–prefix选项时的目录结构）。</p><h3 id="make"><a href="#make" class="headerlink" title="make"></a>make</h3><p>make 是用来编译的，它从Makefile中读取指令，然后编译。可以使用多核来make。<code>make -j2</code><br>如果是8核，那就用make -j8。<br>这一步就是编译，大多数的源代码包都经过这一步进行编译（当然有些perl或python编写的软件需要调用perl或python来进行编译）。如果 在 make 过程中出现 error ，你就要记下错误代码（注意不仅仅是最后一行），然后你可以向开发者提交 bugreport（一般在 INSTALL 里有提交地址），或者你的系统少了一些依赖库等，这些需要自己仔细研究错误代码。</p><p>可能遇到的错误：make *** 没有指明目标并且找不到 makefile。 停止。问题很明了，没有Makefile，怎么办，原来是要先./configure 一下，再make。</p><h3 id="make-install"><a href="#make-install" class="headerlink" title="make install"></a>make install</h3><p>可以使用多核安装 make -j2 install</p><p>这条命令来进行安装（当然有些软件需要先运行 make check 或 make test 来进行一些测试），这一步一般需要你有 root 权限（因为要向系统写入文件）。</p><h2 id="Linux-权限的简单用法（使用者、目录、文件）"><a href="#Linux-权限的简单用法（使用者、目录、文件）" class="headerlink" title="Linux 权限的简单用法（使用者、目录、文件）"></a>Linux 权限的简单用法（使用者、目录、文件）</h2><p><a href="https://blog.csdn.net/sinat_36118270/article/details/63683393">原文链接</a></p><p>首先，我们需要知道Linux中的权限是十分重要的，而且权限分为两类：一类是使用者的权限，一类是文件以及目录的是否可读、写、执行的权限。</p><ol><li>拥有者–所属组–other</li></ol><p>  首先很多人不明白这三个使用者的权限是什么意思。一般情况下，拥有者是这个文件的创建者，即哪个用户创建的这个文件。并且在创建新用户的时候会创建出一个同名的组，这个拥有者默认包含在这个所属组中。我们先来理一理这三者的联系去区别，对于初学者来说，我们可以把这三者想象成数学中的集合，拥有者是元素，整个Linux大环境是全集，而所属组是一个一个的小集合，看张图吧。<br>  <img src="https://img-blog.csdnimg.cn/df5e37bc8da24291985501de3a71f207.png" alt="在这里插入图片描述"></p><p>拥有者就是一个一个的小红点，每个都在自己的所属组里，而且一个拥有者可以在多个所属组里。例如：1可以在所属组1，也可以在所属组2，也可以在所属组3…可以自定义设置。other就是对于所属组1来说，除所属组1中的所有拥有者外，其他的拥有者、所属组都是other。<br>　　值得注意的是，在Linux下，有一个超级用户–root，有全部的权限，凌驾一切之上。<br>　　下面是刚才所讲操作的具体命令：</p><pre class="line-numbers language-none"><code class="language-none">## user1是生成的用户名创建一个用户：useradd user给他加上密码：password user1删除一个用户：userdel user1写作 userdel -r user1  时会删除user1上的文件创建新增组：groupadd group1删除组：groupdel group1让user1用户归为usergroup1组：useradd -g usergroup1 user1让user1用户也归为usergroup2组：useradd -G usergroup2 user1切换用户：su user1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有时，可能我们会需要更改一个用户，或者更改一个所属组，以使其他拥有者或者其他所属组没有权限打开读写执行这个文件或目录。这时我们需要拥戴的命令是：</p><pre class="line-numbers language-none"><code class="language-none">修改拥有者：chmod 用户名 文件名/目录名   但注意：普通用户的操作命令要加上sudo chmod 用户名 文件名sudo的作用是仅当前操作暂时为超级权限。当然，回车过后要输入当前拥有者的密码修改所属组：普通用户--sudo chgrp 所属组名 文件名/目录名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Linux中，输入”ll”（小写L）或者”ls -l”可以显示文件的详细信息。<br><img src="https://img-blog.csdnimg.cn/1169c2fb3ee24cf7bc749ce312dfc6a4.png" alt="在这里插入图片描述"><br>6e.png)</p><p>若sudo失败，则进入超级用户权限，再执行chown root test.c<br>sudo失败的原因，需要将用户添加进sudoers文件:<br>报错信息为：dlm is not in the sudoers file. This incident will be reported.<br>解决方法可以看我的另一篇博客：<br><a href="http://blog.csdn.net/sinat_36118270/article/details/62899093">http://blog.csdn.net/sinat_36118270/article/details/62899093</a></p><p><strong>2.读、写、执行</strong><br>　　Linux中，一个文件或目录的权限有四种<br>　　分别是无、读、写、执行权限<br>　　分别用“-”“r”“w”“x”表示<br>　　在文件列表中，使用”ll”或者”ls -l”命令查看文件详细信息，如图：</p><p><img src="https://img-blog.csdnimg.cn/d56f4f128b6949d3b4707ec5dab42696.png" alt="在这里插入图片描述"></p><p>一个文件或者目录前面共有10位前置字符，第一位表示文件类型，说到这，插一句，在Linux中可以认为“一切皆文件”，且Linux下文件不以文件后缀名区分，而是以第一个字符区分。在细分一下，文件分为:</p><pre class="line-numbers language-none"><code class="language-none">普通文件：第一个字符为“ -  ”；目录：第一个字符为“d”；---directory链接文件：第一个字符为“l”，常见的有两类：软链接(相当于windows中的快捷方式)、硬链接；   ---link设备和设备文件　　块设备（硬盘）：第一个字符为“b”，最小单位为块（字节），支持随机访问。　　字符设备（键盘，显示器）：第一个字符为“c”，最小单位为字节，只允许按顺序读取。---char套接字：第一个字符为“s”；---sockets管道：第一个字符为“p”；---pine<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>图中所示，一个文件前有10个前缀字符，除第一个为文件类型外，剩下的9个都是文件的权限<br>　　三三一组，分别对应拥有者、所属组、other<br>　　即拥有者拥有三个权限，读写执行，所属组和other也相同<br>　　排列顺序为：读写执行<br>　　每个权限有则用对应的字母表示，无则使用“-”<br>　　例如：读写权限：“rw-”；写执行权限：“-wx”<br>　　且权限也可使用数字表示：每个位就相当于一个2进制数字，有此权限则为“1”，无则为“0”<br>　　例如：读写权限：“rw-”= 6；写执行权限：“-wx”= 3；<br>　　在命令输入时，更改拥有者的权限为“u (+/-) (r/w/x)”,括号是为了区分，“+”为增加权限，“-”为去除权限，还可对一个文件或者目录的不同权限修改“u+r-w+x”即为增加读、执行权限，去除写权限。<br>　　相关命令为：</p><pre class="line-numbers language-none"><code class="language-none">首先，给定一个文件，默认权限为"rw- rw- r--",即为"664"增加拥有者的执行权限：chmod u+x file(file为文件名)                  chmod 764 file增加other的写权限：chmod o+w file                chmod 666 file去除所属组的读权限：chmod o-r file                chmod 624 file增加拥有者的读权限，去除写。执行权限：chmod u+r-w-x file                               chmod 464 file<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么对于目录呢？对于一个目录来说，照上图来看，也有拥有者、 所素组、other，而每一个也有自己的读、写、执行权限，有什么用呢？<br>　　目录的读权限决定进入这个目录后，使用“ls”、“ll”以及这个家族的命令是否可以显示该目录的内容；<br>　　目录的写权限决定进入这个目录后，是否可以使用“mkdir”创建目录，是否可以使用“touch”创建文件…;<br>　　目录的执行权限决定是否可以进入这个目录。</p><p><img src="https://img-blog.csdnimg.cn/0f4aa69a622d433392e9bbad7f6e347b.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/a0b3663e0d2b4875a0b233142dcf8ea4.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/7484fbcf90034a62801d298698bc0629.png" alt="在这里插入图片描述"></p><p>那么，剩下的对于一个目录权限的多种操作就不用多少了吧。</p><p><strong>umask</strong><br>　　最后，还有个umask很重要，需要我们去理解记忆<br>　　umask是我们linux系统里面的默认权限的补集，一般在我们的系统中，umask=002。表示我们创建的文件的默认权限是664。<br>　　注意，我们创建的所有文件的默认权限为664，即“rw-rw-r–”。<br>　　不包含拥有者和所属组的执行权限以及other的写和执行权限。<br>　　所以我们要在更改umask后，计算文件权限时，基础上也不能加上拥有者和所属组的执行权限以及other的写和执行权限，除非更改的权限值给他们中的一个或多个赋上了相应的权限。<br>　　umask可以自己更改，直接敲出来umask “0xxx”就ok。此后，我们的权限就为“664-xxx”<br>　　<br><img src="https://img-blog.csdnimg.cn/3de223ac270642e6a5781b23c68da8d1.png" alt="在这里插入图片描述"></p><p>初始值为：“rw-rw-r–”即为“664”<br>　　我们设置的umask=032，即为“— -wx -w- ”,<br>　　因为二者是互补的关系，所以umask中出现的权限不能出现在新创建的文件中，又因为默认情况下新创建的文件没有拥有者和所属组的执行权限以及other的写和执行权限。<br>　　所以file_1的文件权限为：“rw- r– r–”。</p><h2 id="gcc升级到最新版本"><a href="#gcc升级到最新版本" class="headerlink" title="gcc升级到最新版本"></a>gcc升级到最新版本</h2><h3 id="Centos7"><a href="#Centos7" class="headerlink" title="Centos7"></a>Centos7</h3><p>Centos 7默认gcc版本为4.8，有时需要更高版本的，这里以升级至8.3.1版本为例，分别执行下面三条命令即可，无需手动下载源码编译</p><p>1、安装centos-release-scl</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> yum <span class="token function">install</span> centos-release-scl<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2、安装devtoolset，注意，如果想安装7.<em>版本的，就改成devtoolset-7-gcc</em>，以此类推</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> yum <span class="token function">install</span> devtoolset-8-gcc*<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3、激活对应的devtoolset，所以你可以一次安装多个版本的devtoolset，需要的时候用下面这条命令切换到对应的版本</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">scl <span class="token builtin class-name">enable</span> devtoolset-8 <span class="token function">bash</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>大功告成，查看一下gcc版本</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>显示为 gcc version 8.3.1 20190311 (Red Hat 8.3.1-3) (GCC)</p><p>补充：这条激活命令只对本次会话有效，重启会话后还是会变回原来的4.8.5版本，要想随意切换可按如下操作。</p><p>首先，安装的devtoolset是在 /opt/rh 目录下的，如图</p><p><img src="https://img-blog.csdnimg.cn/img_convert/ffc7754914805bcf1ad41891e9405fa5.png#pic_center" alt="在这里插入图片描述"><br>每个版本的目录下面都有个 enable 文件，如果需要启用某个版本，只需要执行</p><pre class="line-numbers language-none"><code class="language-none">source ./enable<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>所以要想切换到某个版本，只需要执行</p><pre class="line-numbers language-none"><code class="language-none">source /opt/rh/devtoolset-8/enable<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以将对应版本的切换命令写个shell文件放在配了环境变量的目录下，需要时随时切换，或者开机自启</p><p>4、直接替换旧的gcc<br>旧的gcc是运行的 /usr/bin/gcc，所以将该目录下的gcc/g++替换为刚安装的新版本gcc软连接，免得每次enable</p><pre class="line-numbers language-none"><code class="language-none">mv /usr/bin/gcc /usr/bin/gcc-4.8.5ln -s /opt/rh/devtoolset-8/root/bin/gcc /usr/bin/gccmv /usr/bin/g++ /usr/bin/g++-4.8.5ln -s /opt/rh/devtoolset-8/root/bin/g++ /usr/bin/g++gcc --versiong++ --version<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="分区-挂载"><a href="#分区-挂载" class="headerlink" title="分区+挂载"></a>分区+挂载</h2><h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><p>详细信息：<a href="https://blog.csdn.net/qq_30604989/article/details/81163270">来源该博客</a><br><img src="https://img-blog.csdnimg.cn/edd06e4319f24f1092d6f7bba9955937.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><ol><li>在linux下，一个硬盘要先分区，然后才能挂载到目录上。和windows相同。</li></ol><p> <img src="https://img-blog.csdnimg.cn/a8ef1355fa2f4595a7b69da0b0bb50ec.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p><strong>问题：如何确定文件或目录在那个磁盘分区？</strong></p><pre class="line-numbers language-none"><code class="language-none">df -h /homedf -h /home/test.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>通过上面的命令就可以看出文件或目录是在那个磁盘分区里面</p><p><img src="https://s2.loli.net/2022/05/19/8UEfapmwxb6zjSu.png" alt="Snipaste_2022-05-19_15-34-43.png"></p><h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><p><img src="https://img-blog.csdnimg.cn/0189f5afb0f24dde85c540fc5b8c887f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><pre class="line-numbers language-none"><code class="language-none">fdisk /dev/sdb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这一步是对sdb这个磁盘分区。<br><img src="https://img-blog.csdnimg.cn/bde5f9eba20b477bbeb551a9cb4bc246.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>接下来是格式化：</p><pre class="line-numbers language-none"><code class="language-none">mkfs -t ext4 /dev/sdb1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>挂载：将分区和目录联系起来</p><pre class="line-numbers language-none"><code class="language-none">mount 设备名 目录名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">mount /dev/sdb1 /home/newdisk<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个方法重启会失效，设置永久挂载。</p><pre class="line-numbers language-none"><code class="language-none">vim /etc/fstab<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="解除挂载"><a href="#解除挂载" class="headerlink" title="解除挂载"></a>解除挂载</h3><pre class="line-numbers language-none"><code class="language-none">umount 设备名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/d9ca57a5c9bf44589498a26a8baea9e5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题汇总&quot;&gt;&lt;a href=&quot;#问题汇总&quot; class=&quot;headerlink&quot; title=&quot;问题汇总&quot;&gt;&lt;/a&gt;问题汇总&lt;/h2&gt;&lt;h3 id=&quot;error-while-loading-shared-libraries错误解决办法&quot;&gt;&lt;a href=&quot;#err</summary>
      
    
    
    
    <category term="Linux" scheme="https://gaofeng-lin.github.io/categories/Linux/"/>
    
    
    <category term="运维" scheme="https://gaofeng-lin.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="Linux" scheme="https://gaofeng-lin.github.io/tags/Linux/"/>
    
    <category term="持续集成" scheme="https://gaofeng-lin.github.io/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
    <category term="gcc" scheme="https://gaofeng-lin.github.io/tags/gcc/"/>
    
    <category term="Linux权限用法" scheme="https://gaofeng-lin.github.io/tags/Linux%E6%9D%83%E9%99%90%E7%94%A8%E6%B3%95/"/>
    
    <category term="make&amp;cmake" scheme="https://gaofeng-lin.github.io/tags/make-cmake/"/>
    
  </entry>
  
  <entry>
    <title>Shell 命令</title>
    <link href="https://gaofeng-lin.github.io/posts/20005/"/>
    <id>https://gaofeng-lin.github.io/posts/20005/</id>
    <published>2022-03-05T16:00:00.000Z</published>
    <updated>2022-07-23T03:16:12.859Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本知识-x2F-命令"><a href="#基本知识-x2F-命令" class="headerlink" title="基本知识/命令"></a>基本知识/命令</h2><h3 id="变量赋值语句不能有空格"><a href="#变量赋值语句不能有空格" class="headerlink" title="变量赋值语句不能有空格"></a>变量赋值语句不能有空格</h3><p><strong>1、shell脚本变量名和等号及等号和值之间不能有空格，这可能和我们熟悉的所有编程语言都不一样，变量命名须遵循如下规则：</strong><br>•首个字符必须为字母（a-z，A-Z）。<br>•中间不能有空格，可以使用下划线（_）。<br>•不能使用标点符号。<br>•不能使用bash里的关键字（可用help命令查看保留关键字）。</p><p>赋值语句等号两边不能有空格，中间有空格时，shell是把变量当一个命令执行的，如：</p><p>PROV = anhui</p><p>执行时会提示：./tt.sh: line 14: PROV: command not found</p><p>正确的写法是：</p><p>PROV=anhui</p><p>如果所赋的值包含空格，可以用引号括起来（没有空格时也可以用引号，效果和不用一样），例如：</p><p>PROV=”anhui province”</p><p><strong>2、变量的引用是用$符号加上变量名，例如：</strong></p><p>echo  ../${PROV}/${DATDIR}</p><p>变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，建议给所有变量加上花括号，这是个好习惯，既便于阅读，又不易出错。 </p><p><strong>最后想说明一下，shell脚本对空格有严格的规定，赋值语句等号两边不能有空格，而字符串比较，等号两边必须有空格，如：</strong></p><p>if [ “${sdpt}” = “sdpt_js” ]; then</p><h3 id="将命令的输出结果赋值给变量"><a href="#将命令的输出结果赋值给变量" class="headerlink" title="将命令的输出结果赋值给变量"></a>将命令的输出结果赋值给变量</h3><p>Shell 中有两种方式可以完成命令替换，一种是反引号<code> </code>，一种是$()，使用方法如下：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">variable<span class="token operator">=</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">commands</span><span class="token template-punctuation string">`</span></span>variable<span class="token operator">=</span><span class="token function">$</span><span class="token punctuation">(</span>commands<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>但有种情况比较特殊</strong></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">file_path<span class="token operator">=</span><span class="token string">"/home/yskj/phopt/work/2/100/209/Ma0.8395H0α3.06"</span>version_num<span class="token operator">=</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">echo </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>file_path<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> | cut -d / -f 8</span><span class="token template-punctuation string">`</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>version_num 那一行是一个字符串的分割，最终得到209，我想把这个值作为变量。<br>如果不加echo是会报错，因为单独运行，会去执行<code>${file_path}这条命令，因为后面是管道</code>，而加上echo，就是输出，是一个正常的命令。<br>最后相当于把输出的结果赋值给了version_num这个变量</p><h3 id="shell脚本中登录mysql-执行sql"><a href="#shell脚本中登录mysql-执行sql" class="headerlink" title="shell脚本中登录mysql,执行sql"></a>shell脚本中登录mysql,执行sql</h3><p><strong>方式一：mysql -u root -pmysql &lt;&lt;EOF sql语句 EOF</strong><br>注：密码与-p之间不能有空格，否则不能识别密码，EOF中间的sql语句，与mysql正常语句无异</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span> <span class="token comment">#!/bin/bash</span><span class="token number">2</span> <span class="token builtin class-name">echo</span> <span class="token string">"链接mysql"</span><span class="token number">3</span> mysql -u root -pmysql <span class="token operator">&lt;&lt;</span>EOF<span class="token number">4</span> use shelltest<span class="token punctuation">;</span><span class="token number">5</span> <span class="token keyword">select</span> * from student<span class="token punctuation">;</span><span class="token number">6</span> EOF<span class="token number">7</span> <span class="token builtin class-name">echo</span> <span class="token string">"连接成功"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python@ubuntu:~/shellscrip$ ./mys_connec.sh 链接mysqlmysql: <span class="token punctuation">[</span>Warning<span class="token punctuation">]</span> Using a password on the <span class="token builtin class-name">command</span> line interface can be insecure.<span class="token function">id</span>name<span class="token number">1</span>tom连接成功<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方式二：mysql -u root -pmysql -e “${sql}”</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span> <span class="token comment">#!/bin/bash</span><span class="token number">2</span> <span class="token builtin class-name">echo</span> <span class="token string">"链接mysql"</span><span class="token number">3</span> <span class="token assign-left variable">sql</span><span class="token operator">=</span><span class="token string">"use shelltest;4 select * from student;"</span><span class="token number">5</span> mysql -u root -pmysql -e <span class="token string">"<span class="token variable">${sql}</span>"</span><span class="token number">6</span> <span class="token builtin class-name">echo</span> <span class="token string">"连接成功"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python@ubuntu:~/shellscrip$ ./mys_connec.sh 链接mysqlmysql: <span class="token punctuation">[</span>Warning<span class="token punctuation">]</span> Using a password on the <span class="token builtin class-name">command</span> line interface can be insecure.+------+------+<span class="token operator">|</span> <span class="token function">id</span>   <span class="token operator">|</span> name <span class="token operator">|</span>+------+------+<span class="token operator">|</span>    <span class="token number">1</span> <span class="token operator">|</span> tom  <span class="token operator">|</span>+------+------+连接成功<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="读取文件每一行并输出"><a href="#读取文件每一行并输出" class="headerlink" title="读取文件每一行并输出"></a>读取文件每一行并输出</h3><p>方案一：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">##!/bin/bash</span><span class="token keyword">while</span> <span class="token builtin class-name">read</span> line<span class="token keyword">do</span>    <span class="token builtin class-name">echo</span> <span class="token variable">$line</span><span class="token keyword">done</span> <span class="token operator">&lt;</span> test.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方案二：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">##!/bin/bash</span><span class="token function">cat</span> test.txt <span class="token operator">|</span> <span class="token keyword">while</span> <span class="token builtin class-name">read</span> line<span class="token keyword">do</span>    <span class="token builtin class-name">echo</span> <span class="token variable">$line</span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方案三：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">for</span> <span class="token for-or-select variable">line</span> <span class="token keyword">in</span> <span class="token variable"><span class="token variable">`</span><span class="token function">cat</span>  test.txt<span class="token variable">`</span></span><span class="token keyword">do</span>    <span class="token builtin class-name">echo</span> <span class="token variable">$line</span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>for 逐行读和 while 逐行读是有区别的，如:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> test.txtGoogleRunoobTaobao$ <span class="token function">cat</span> test.txt <span class="token operator">|</span> <span class="token keyword">while</span> <span class="token builtin class-name">read</span> line<span class="token punctuation">;</span> <span class="token keyword">do</span> <span class="token builtin class-name">echo</span> <span class="token variable">$line</span><span class="token punctuation">;</span> <span class="token keyword">done</span>GoogleRunoobTaobao$ <span class="token keyword">for</span> <span class="token for-or-select variable">line</span> <span class="token keyword">in</span> <span class="token variable"><span class="token variable">$(</span><span class="token operator">&lt;</span>test.txt<span class="token variable">)</span></span><span class="token punctuation">;</span> <span class="token keyword">do</span> <span class="token builtin class-name">echo</span> <span class="token variable">$line</span><span class="token punctuation">;</span> <span class="token keyword">done</span>GoogleRunoobTaobao<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="if-与-for-循环"><a href="#if-与-for-循环" class="headerlink" title="if 与 for 循环"></a>if 与 for 循环</h3><pre class="line-numbers language-none"><code class="language-none">getfilesordir(){    for file in `ls $1`    do        if test -f $file        then            echo "file:  $file"        elif test -d $file        then            echo "path: $file"        fi    done} path="./"getfilesordir $path<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="遍历文件夹"><a href="#遍历文件夹" class="headerlink" title="遍历文件夹"></a>遍历文件夹</h3><p><strong>遍历文件夹下所有文件，不包含子目录：</strong></p><pre class="line-numbers language-none"><code class="language-none">getfilesordir(){    for file in `ls $1`    do        if test -f $file        then            echo "file:  $file"        elif test -d $file        then            echo "path: $file"        fi    done} path="./"getfilesordir $path<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>遍历文件夹下所有文件不包含子目录</strong></p><pre class="line-numbers language-none"><code class="language-none">dir="/home/fut/Desktop/"ls $dir | while read linedo     file=${dir}${line}    echo file  fidone<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>遍历目录包含子目录</strong></p><pre class="line-numbers language-none"><code class="language-none">##!/bin/bashfunction getdir(){    for element in `ls $1`    do          dir_or_file=$1"/"$element        if [ -d $dir_or_file ]        then             getdir $dir_or_file        else            echo $dir_or_file        fi      done}root_dir="/home/test"getdir $root_dir<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以下命令均不包含”.”，”..”目录，以及”.”开头的隐藏文件，如需包含，ll 需要加上 -a参数#当前目录下文件个数，不包含子目录ll |grep “^-“|wc -l#当前目录下目录个数，不包含子目录ll |grep “^d”|wc -l#当前目录下文件个数，包含子目录ll -R|grep “^-“|wc -l#当前目录下目录个数，包含子目录ll -R|grep “^d”|wc -l</p><h3 id="字符串与整数比较"><a href="#字符串与整数比较" class="headerlink" title="字符串与整数比较"></a>字符串与整数比较</h3><pre class="line-numbers language-none"><code class="language-none">##!/bin/sh##字符串比较(比较大小以及是否相等)a=hellob=helloc=howif [[ "$a" == "$b" ]];then  #注意对于字符串的相等比较，使用=或==都可以，二者是等价的echo 'same'elseecho not samefiif [[ "$a"!="$c" ]];thenecho "a!=c"fiif [[ "$a" &lt; "$c" ]];thenecho "a&lt;c"fi##整数比较a=1b=2if(($a&lt;=$b));thenecho "a&lt;=b"fiif((a&lt;=b));thenecho "a&lt;=b"fi## 整数运算d=$(($a+$b))echo $dc=$((a+b))echo $c## 整数运算c=$((a+b))echo $c##浮点数运算a=1.223b=2.3c=$(echo $a+$b|bc)echo $c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="将shell命令的执行结果放入数组"><a href="#将shell命令的执行结果放入数组" class="headerlink" title="将shell命令的执行结果放入数组"></a>将shell命令的执行结果放入数组</h3><pre class="line-numbers language-none"><code class="language-none">arr=( `git branch | xargs` )echo ${arr[@]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="实际命令分析"><a href="#实际命令分析" class="headerlink" title="实际命令分析"></a>实际命令分析</h2><h3 id="shell脚本登录mysql并执行语句"><a href="#shell脚本登录mysql并执行语句" class="headerlink" title="shell脚本登录mysql并执行语句"></a>shell脚本登录mysql并执行语句</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">##!/bin/bash</span><span class="token comment">## get 7 days ago according to input date. e.g. if input date is 20180410,it will delete those records on or before 20180403</span><span class="token assign-left variable">wanted_date</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">date</span> -d <span class="token string">"<span class="token variable">$1</span> 7 days ago"</span> +%Y%m%d<span class="token variable">`</span></span><span class="token builtin class-name">echo</span> <span class="token string">"0==}=========&gt; CAUTION! Those records on or before <span class="token variable">$wanted_date</span> will be removed!"</span><span class="token builtin class-name">echo</span> <span class="token string">"0==}=========&gt; Are you sure to continue? yes/no"</span><span class="token builtin class-name">read</span> option<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$option</span>"</span> <span class="token operator">==</span> <span class="token string">"yes"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>  <span class="token builtin class-name">echo</span> You made a good choice.  <span class="token builtin class-name">echo</span> ----------<span class="token keyword">elif</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$option</span>"</span> <span class="token operator">==</span> <span class="token string">"no"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">then</span>  <span class="token builtin class-name">echo</span> Goodbye~  <span class="token builtin class-name">exit</span> <span class="token number">0</span><span class="token keyword">else</span>  <span class="token builtin class-name">echo</span> PLASE INPUT <span class="token function">yes</span> OR no THEN TRY AGAIN<span class="token operator">!</span>  <span class="token builtin class-name">exit</span> <span class="token number">0</span><span class="token keyword">fi</span><span class="token comment">## to call SQL statement at MySQL prompt</span>mysql -h <span class="token number">172.33</span>.101.123 -P <span class="token number">3306</span> -u tony -pYourPassword -D YourDbName <span class="token operator">&lt;&lt;</span><span class="token string">EOFselect current_date();use tony_db;desc confirmed_order_data;select count(*) from confirmed_order_data where paid_date&lt;="<span class="token variable">$wanted_date</span>";delete from confirmed_order_data WHERE paid_date&lt;="<span class="token variable">$wanted_date</span>";select count(*) from confirmed_order_data where paid_date&lt;="<span class="token variable">$wanted_date</span>";EOF</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="提取git中某个文件的所有版本并按顺序命名"><a href="#提取git中某个文件的所有版本并按顺序命名" class="headerlink" title="提取git中某个文件的所有版本并按顺序命名"></a>提取git中某个文件的所有版本并按顺序命名</h3><pre class="line-numbers language-none"><code class="language-none">git log --follow --pretty=format:%H 文件名 | xargs -I{} sh -c 'git show {}:文件名 &gt; 文件名.{}'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>简略解释版本：</p><pre class="line-numbers language-none"><code class="language-none">git log --follow --pretty=format:%H //按照一定的格式输出 ，--pretty=format:%H 输出某个文件的历史提交哈希值。//如果不加--pretty=format:%H，会输出哈希值，作者，时间等信息。//--pretty=format后面还可以跟其它值，//'%H': commit hash//'%h':abbreviated commit hash//'%T': tree hash| xargs -I{} //xargs 一般是和管道(I)一起使用 //-I{} //xargs 的一个选项 -I，使用 -I 指定一个替换字符串 {}，这个字符串在 xargs 扩展时会被替换掉；对应这里，前面输出的是哈希值，这里面"{}"代表的就是哈希值，后面的"{}"也是前面的哈希值。sh -c //暂时不清，下面有解释git show {}:文件名 &gt; 文件名.{}  //git show '哈希值':文件名：输出这次提交，这个文件夹的内容， "&gt;" 将内容输出到 后面的文件中，并覆盖后面文件内容。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><ol start="2"><li>| xargs -I{} sh c</li></ol></blockquote><pre class="line-numbers language-none"><code class="language-none">|  //表示管道，上一条命令的输出，作为下一条命令参数，如 echo ‘yes’ | wc -lxargs -I //<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">sh -cLinux使用 echo 并配合命令重定向是实现向文件中写入信息的快捷方式。【新建空文件】方式一 : $ touch test.sh方式二 : $ echo “” &gt; test.sh【写内容到文件】如 test.sh 文件中内容：$ echo “信息” &gt; test.sh但有时会出现权限不够的问题，这时就可以使用 sh -c利用 “sh -c” 命令，它可以让 bash 将一个字串作为完整的命令来执行，这样就可以将 sudo 的影响范围扩展到整条命令。具体用法如下：$ sudo sh -c ‘echo “第二条内容” &gt;&gt; test.sh’<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="给每一个远程分支在本地建立单独的文件夹，文件名就是分支名"><a href="#给每一个远程分支在本地建立单独的文件夹，文件名就是分支名" class="headerlink" title="给每一个远程分支在本地建立单独的文件夹，文件名就是分支名"></a>给每一个远程分支在本地建立单独的文件夹，文件名就是分支名</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> branch -r <span class="token operator">|</span> <span class="token function">xargs</span> -d/ -n1 <span class="token operator">|</span> <span class="token function">grep</span> -v <span class="token string">'origin'</span> <span class="token operator">|</span> <span class="token function">xargs</span> -I<span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token function">sh</span> -c <span class="token string">'mkdir "C:\Users\76585\Desktop\try\{}" '</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>分析：</p><pre class="line-numbers language-none"><code class="language-none">1.  git branch -r //显示远程分支。注意，本地分支可能只有一个，master这种。但远程分支可能有很多个。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">2. | xargs -d/ -n1 // -d -n都是xargs的参数，详细可以去查文档。-d/  以"/"为分隔符；-n1，每行输出一个。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">3. grep -v 'origin' // 遇到origin就不显示（删除这个字符串）。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>冷知识：在Windows下运行sh文件，在当前路径下，<code>./</code>;<br>如果是非当前路径，<code>c/xx/xxx/1.sh  //绝对路径到sh文件就好，前面不用加./</code> </p><h3 id="按提交信息来过滤提交-–grep"><a href="#按提交信息来过滤提交-–grep" class="headerlink" title="按提交信息来过滤提交 –grep"></a>按提交信息来过滤提交 –grep</h3><p>按提交信息来过滤提交，你可以使用–grep标记。它和上面的–author标记差不多，只不过它搜索的是提交信息而不是作者。</p><p>背景：提取主干某文件的提交，因为主干都是其它author合并上去的，所有没有主干这个author，无法使用–author这个参数来过滤。但是每次合并到主干的commit 都有一句 “into avtivebranch”，根据这一句筛选即可。</p><p>例子：</p><pre class="line-numbers language-none"><code class="language-none">git log --grep="JRA-224:" //也可以传入-i参数来忽略大小写匹配<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="获取for循环中按条件筛选出的变量值"><a href="#获取for循环中按条件筛选出的变量值" class="headerlink" title="获取for循环中按条件筛选出的变量值"></a>获取for循环中按条件筛选出的变量值</h3><p><strong>将这个功能写成一个函数，函数内部用echo输出这个值，外部用一个变量接受这个值。</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">##!/bin/bash</span><span class="token keyword">function</span> <span class="token function-name function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">cat</span> cfd.log <span class="token operator">|</span> <span class="token keyword">while</span> <span class="token builtin class-name">read</span> line<span class="token keyword">do</span>    <span class="token assign-left variable">OLD_IFS</span><span class="token operator">=</span><span class="token string">"<span class="token environment constant">$IFS</span>"</span>    <span class="token assign-left variable"><span class="token environment constant">IFS</span></span><span class="token operator">=</span><span class="token string">" "</span>    <span class="token assign-left variable">array</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token variable">$line</span><span class="token punctuation">)</span>    <span class="token assign-left variable"><span class="token environment constant">IFS</span></span><span class="token operator">=</span><span class="token string">"<span class="token variable">$OLD_IFS</span>"</span>    <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">${array<span class="token punctuation">[</span>0<span class="token punctuation">]</span>}</span>"</span> <span class="token operator">=</span> <span class="token string">"cfdversion"</span> <span class="token punctuation">]</span> <span class="token punctuation">;</span> <span class="token keyword">then</span>       <span class="token builtin class-name">echo</span> <span class="token variable">${array<span class="token punctuation">[</span>2<span class="token punctuation">]</span>}</span>       <span class="token builtin class-name">break</span>    <span class="token keyword">fi</span><span class="token keyword">done</span><span class="token punctuation">}</span><span class="token assign-left variable">res</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span>func<span class="token variable">)</span></span><span class="token builtin class-name">echo</span> <span class="token variable">$res</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><h3 id="读取文件夹中的文件名，并存入列表"><a href="#读取文件夹中的文件名，并存入列表" class="headerlink" title="读取文件夹中的文件名，并存入列表"></a>读取文件夹中的文件名，并存入列表</h3><pre class="line-numbers language-none"><code class="language-none">##!/bin/bash##读取文件夹中的文件名，并存入列表i=0for dir in $(ls 'C:\Users\76585\Desktop\cfdname1')do        # echo $dir &gt;&gt; arr[$i]    arr[$i]=$dir    i=$(($i+1))doneecho "${arr[@]}"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意的点：</strong></p><pre class="line-numbers language-none"><code class="language-none">1.for 循环循环体只能卸载do done之间，之前把 i 写在了for 和 do之间报错2.变量初始化不要放在函数体，不然每次循环都清 0 了。3.变量自增加方法：a=\$(($a+1))a=$[$a+1]a=\`expr $a + 1`let a++let a+=1((a++))4.打印数组的方法：${my_array[*]} 或者 ${my_array[@]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h2><h3 id="获取变量字符串长度"><a href="#获取变量字符串长度" class="headerlink" title="获取变量字符串长度"></a>获取变量字符串长度</h3><p>想要知道 “<a href="http://www.baidu.com&quot;/">www.baidu.com"</a> 的变量net的长度十分简单。</p><pre class="line-numbers language-none"><code class="language-none">[Neptuneyt]$ net="www.baidu.com"[Neptuneyt]$ echo ${#net}13<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当然，在Shell中获取字符串变量的长度的方法有许多种，但是下图法一作为一种系统内建的方法是最快的。</p><pre class="line-numbers language-none"><code class="language-none">[Neptuneyt]$ echo ${#net}13[Neptuneyt]$ echo ${net}|wc -L13[Neptuneyt]$ expr length ${net}13[Neptuneyt]$ echo ${net}|awk '{print length($0)}'13<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="变量截取"><a href="#变量截取" class="headerlink" title="变量截取"></a>变量截取</h3><p><strong>1.指定位置截取字符串</strong></p><pre class="line-numbers language-none"><code class="language-none">[Neptuneyt]$ net="www.baidu.com"[Neptuneyt]$ # 从第4个字符截取到baidu[Neptuneyt]$ echo ${net:4:5} #从第4个字符.开始截取5个字符baidu[Neptuneyt]$ # 截取baidu.com[Neptuneyt]$ echo ${net:4}   #起始位置后不接截取字符长度则默认截取之后所有的baidu.com[Neptuneyt]$ # 用倒数截取com[Neptuneyt]$ echo ${net:0-3} #从倒数第三个字符截取到末尾com[Neptuneyt]$ echo ${net: -3} #另外的写法，一定要注意冒号和-3之间有空格com[Neptuneyt]$ echo ${net:-3}  #不加空格，截取失败www.baidu.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2.匹配字符串截取</strong></p><pre class="line-numbers language-none"><code class="language-none">[Neptuneyt]$ echo $netwww.baidu.com## 删除匹配字符串的左边，留下剩余部分[Neptuneyt]$ echo ${net#*.} #这里用*.表示匹配到www.，用一个#表示删除匹配到的字符串，留下剩余的部分baidu.com## 用2个#号表示尽可能多的删除匹配到的字符串[Neptuneyt]$ echo ${net##*.}com## 同理也可以匹配字符串的右边，留下剩余部分[Neptuneyt]$ echo ${net%.*} #用.*匹配到.com,用%删除www.baidu## 用2个%号表示尽可能多的删除匹配到的字符串[Neptuneyt]$ echo ${net%%.*}    #因为2个%，这里.*表示匹配到最长的.baidu.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总的来说:<br><code>#*chr</code>表示删除从左到右第一个遇到的字符chr及其左侧的字符<br><code>##*chr</code>表示删除从左到右最后一个遇到的字符chr及其左侧的字符（贪婪模式）<br><code>%chr*</code>表示删除从右向左第一个遇到的字符chr及其右侧的字符<br><code>%%chr*</code>表示删除从右到左最后一个遇到的字符chr及其右侧的字符（贪婪模式）<br>在键盘上，#在$符的左边，%号在$符的右边，为了便于记忆，大家因此可以记住#删除左边字符，%删除右边字符</p><p><strong>3.窃取字符串</strong></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token number">1</span><span class="token punctuation">.</span>cut<span class="token operator">-</span>b ：以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 <span class="token operator">-</span>n 标志。<span class="token operator">-</span>c ：以字符为单位进行分割。<span class="token operator">-</span>d：自定义分隔符，默认为制表符。<span class="token operator">-</span>f：与<span class="token operator">-</span>d一起使用，指定显示哪个区域。<span class="token operator">-</span>n：取消分割多字节字符。仅和<span class="token operator">-</span>b标志一起使用。如果字符的最后一个字节落在由<span class="token operator">-</span>b标志的List参数指示的范围之内，该字符将被写出；否则，该字符将被排除。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>-d</strong></p><p> cut命令用于列提取，默认分隔符是tab键。</p><p>选项：-d指定分隔符，-f指定提取第几列</p><p>eg1： 以%作为分隔符 输出第一个%前的区域1的东西，输出区域2的东西     </p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">root@<span class="token constant">ROUTER</span><span class="token operator">:</span><span class="token operator">~</span># echo <span class="token string">"CPU:  busy 14%  (system=10% user=3% nice=0% idle=85%)"</span> <span class="token operator">|</span> cut <span class="token operator">-</span>d \<span class="token operator">%</span> <span class="token operator">-</span>f <span class="token number">1</span><span class="token constant">CPU</span><span class="token operator">:</span>  busy <span class="token number">14</span>root@<span class="token constant">ROUTER</span><span class="token operator">:</span><span class="token operator">~</span># echo <span class="token string">"CPU:  busy 14%  (system=10% user=3% nice=0% idle=85%)"</span> <span class="token operator">|</span> cut <span class="token operator">-</span>d \<span class="token operator">%</span> <span class="token operator">-</span>f <span class="token number">2</span>  <span class="token punctuation">(</span>system<span class="token operator">=</span><span class="token number">10</span>root@<span class="token constant">ROUTER</span><span class="token operator">:</span><span class="token operator">~</span># echo <span class="token string">"CPU:  busy 14%  (system=10% user=3% nice=0% idle=85%)"</span> <span class="token operator">|</span> cut <span class="token operator">-</span>b <span class="token number">11</span><span class="token operator">-</span><span class="token number">14</span> <span class="token operator">|</span> cut <span class="token operator">-</span>d \<span class="token operator">%</span> <span class="token operator">-</span>f <span class="token number">1</span> <span class="token number">14</span>root@<span class="token constant">ROUTER</span><span class="token operator">:</span><span class="token operator">~</span># echo <span class="token string">"CPU:  busy 14%  (system=10% user=3% nice=0% idle=85%)"</span> <span class="token operator">|</span> cut <span class="token operator">-</span>b <span class="token number">11</span><span class="token operator">-</span><span class="token number">14</span>  <span class="token number">14</span><span class="token operator">%</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>-b</strong><br>.eg1：然后调用cut，即剪切字符串中的第2和第5个字节。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">echo<span class="token string">"123abc"</span><span class="token operator">|</span>cut <span class="token operator">-</span>b <span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>先输出123abc</p><p>输出为2b</p><p><strong>-c</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/524756e2e6810b93cd8fac228f2b4b9d.png#pic_center" alt="在这里插入图片描述"></p><h3 id="变量的字符串替换"><a href="#变量的字符串替换" class="headerlink" title="变量的字符串替换"></a>变量的字符串替换</h3><p>想要将net的 baidu替换成google怎么写呢？只需<code>${net/baidu/google}</code>即可，需要注意的是原变量并未修改</p><pre class="line-numbers language-none"><code class="language-none">[Neptuneyt]$ echo ${net/baidu/google} #/匹配字符/替换字符www.google.com[Neptuneyt]$ echo $net  #原变量并未修改www.baidu.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果是替换所有匹配到的字符，应该通过<code>${variable//pattern/sub}</code><br>例如将net的.替换为-或/：</p><pre class="line-numbers language-none"><code class="language-none">[Neptuneyt]$ echo ${net//./-}www-baidu-com[Neptuneyt]$ echo ${net//.//}www/baidu/com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>除此之外，还有两种专门针对字符串开头和结尾的替换方式<br>只替换开头匹配的字符串<code>${variable/#pattern/sub}</code><br>只替换结尾匹配的字符串<code>${variable/%pattern/sub}</code><br>例如对于<code>add=www.xiaomi.com.www</code>的开头或者结尾的<code>www</code>替换为<code>-</code>：</p><pre class="line-numbers language-none"><code class="language-none">[Neptuneyt]$ add=www.xiaomi.com.www[Neptuneyt]$ echo ${add/#www/-}-.xiaomi.com.www[Neptuneyt]$ echo ${add/%www/-}www.xiaomi.com.-<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除字符串"><a href="#删除字符串" class="headerlink" title="删除字符串"></a>删除字符串</h3><p>其实学会了替换字符串删除字符串就更简单了，只需将替换部分写成空即可，即<code>${variable/pattern/null}</code>，例如将net的第一个.删除，只需</p><pre class="line-numbers language-none"><code class="language-none">[Neptuneyt]$ echo ${net/./}wwwbaidu.com[Neptuneyt]$ echo ${net/.}  #最后一个/可以不用写wwwbaidu.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>若要删除所有匹配到的只需即<code>${variable//pattern}</code>，例如将<code>net</code>的.都删除，只需</p><pre class="line-numbers language-none"><code class="language-none">[Neptuneyt]$ echo ${net//.}wwwbaiducom<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="变量为空时赋默认值"><a href="#变量为空时赋默认值" class="headerlink" title="变量为空时赋默认值"></a>变量为空时赋默认值</h3><p>当我们在写脚本时往往需要给脚本传递一些参数，在Shell中传递参数十分简单，只需利用特殊的位置参数变量诸如<code>$1,$2,$3...${10}...</code>即可，例如，以下脚本传递2个参数：</p><pre class="line-numbers language-none"><code class="language-none">## PassArgument.sh##!/bin/env bash## pass 2 argumentsarg1=$1arg2=$2echo $arg1 $arg2[Neptuneyt]$ bash PassArgument.sh Hello word #参数以空格隔开Hello word<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有时候，我们想省掉最后一个参数，让它使用默认值，这个时候只需通过<code>${variable:='default value'}</code>即可，即当变量有值的时候则使用原值，若没有值则使用括号中默认定义好的值。例如，如下脚本表示当第二个参数为空时默认使用定义好的值“word”,否则是用户自己传递的参数：</p><pre class="line-numbers language-none"><code class="language-none">## PassArgument.sh##!/bin/env basharg1=$1arg2=$2echo $arg1 ${arg2:='word'}  #第二个参数设置默认值[Neptuneyt]$ bash PassArgument.sh Hello #第二个参数为空时使用默认值Hello word[Neptuneyt]$ bash PassArgument.sh Hello Shell   #第二个参数不为空时使用参数传递的值Hello Shell<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了<code>${variable:='default value'}</code>外，还有<code>${variable:-'default value'}</code>,<code>${variable:+'default value'}</code>和<code>${variable:？'default value'}</code>，它们有什么区别呢？<br>对于<code>${variable:='default value'}</code>，表示变量为空时把默认值赋值给该变量，例如：</p><pre class="line-numbers language-none"><code class="language-none">[Neptuneyt]$ net=[Neptuneyt]$ echo ${net:='www.baidu.com'}www.baidu.com[Neptuneyt]$ echo $netwww.baidu.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于<code>${variable:-'default value'}</code>,表示变量为空时返回默认值<strong>但是并不把默认值赋值给该变量</strong>， 例如：</p><pre class="line-numbers language-none"><code class="language-none">[Neptuneyt]$ net=[Neptuneyt]$ echo ${net:-'www.baidu.com'}www.baidu.com[Neptuneyt]$ echo $net  #此时，变量依旧为空<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>对于<code>${variable:+'default value'}</code>,则表示变量不为空时，返回默认值，并且也不重新赋值，例如：</p><pre class="line-numbers language-none"><code class="language-none">[Neptuneyt]$ net=www.baidu.com[Neptuneyt]$ echo ${net:+'www.google.com'}www.google.com[Neptuneyt]$ echo $net  #不改变变量原值www.baidu.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后，对于<code>${variable:？'default value'}</code>,则表示当变量为空时，使用bash风格的报错，例如：</p><pre class="line-numbers language-none"><code class="language-none">[Neptuneyt]$ net=[Neptuneyt]$ echo ${net:?'error:null value'}-bash: net: error:null value<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p>在 PHP 中，使用.即可连接两个字符串；<br>在 JavaScript 中，使用+即可将两个字符串合并为一个。<br>在 Shell 中你不需要使用任何运算符，将两个字符串并排放在一起就能实现拼接，非常简单粗暴。请看下面的例子：</p><pre class="line-numbers language-none"><code class="language-none">##!/bin/bashname="Shell"url="http://c.biancheng.net/shell/"str1=$name$url  #中间不能有空格str2="$name $url"  #如果被双引号包围，那么中间可以有空格str3=$name": "$url  #中间可以出现别的字符串str4="$name: $url"  #这样写也可以str5="${name}Script: ${url}index.html"  #这个时候需要给变量名加上大括号echo $str1echo $str2echo $str3echo $str4echo $str5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">运行结果：Shellhttp://c.biancheng.net/shell/Shell http://c.biancheng.net/shell/Shell: http://c.biancheng.net/shell/Shell: http://c.biancheng.net/shell/ShellScript: http://c.biancheng.net/shell/index.html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于第 7 行代码，$name 和 $url 之间之所以不能出现空格，是因为当字符串不被任何一种引号包围时，遇到空格就认为字符串结束了，空格后边的内容会作为其他变量或者命令解析，这一点在《Shell字符串》中已经提到。</p><p>对于第 10 行代码，加{ }是为了帮助解释器识别变量的边界，这一点在《Shell变量》中已经提到。</p><h3 id="单引号内引入变量"><a href="#单引号内引入变量" class="headerlink" title="单引号内引入变量"></a>单引号内引入变量</h3><p><strong>方法：单引号内嵌套单引号即可使用变量</strong></p><pre class="line-numbers language-none"><code class="language-none">##!/bin/bashi=10echo $iecho '$i'echo '$i is : '$i''执行结果## ./test.sh 10$i$i is : 10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="shell中判断两个字符串相等"><a href="#shell中判断两个字符串相等" class="headerlink" title="shell中判断两个字符串相等"></a>shell中判断两个字符串相等</h3><pre class="line-numbers language-none"><code class="language-none">##! /bin/bashread -p "If you want to clean the trash?(y/n):" selectstr=yif [ "$select" = "y" ]then    rm -fr $HOME/.local/share/Trash/files/*    echo "Deleted successfully!"else    echo "Undelete!"fi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意的几点：</strong><br><strong>1、if和[ ]之间要空格。</strong></p><p><strong>2、[ ]和“ ”之间要空格</strong></p><p><strong>3、“ ”和=之间要空格，</strong></p><h3 id="实战：统计文章单词情况"><a href="#实战：统计文章单词情况" class="headerlink" title="实战：统计文章单词情况"></a>实战：统计文章单词情况</h3><p>这里想要统计Martin Luther King在1963年著名的<strong>I have a dream</strong>演讲中都使用了哪些词，哪些是高频词，单词字长如何。<br><img src="https://img-blog.csdnimg.cn/4f3976bb28594f89ab73d74c1d5b4448.png" alt="在这里插入图片描述"><br>思路：<br>高频词统计：将所有单词单行输出，删除空行，删除<code>,./?</code>等非字母符号，用sort排序后使用uniq统计即可。<br>字长频数统计：将所有单词单行输出，删除空行，删除<code>,./?</code>等非字母符号，使用while循环遍历每个单词，使用</p><pre class="line-numbers language-none"><code class="language-none">${#variable} //统计单词长读频数。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">## 高频词统计echo "高频词统计："echo "频数" "单词"tr " " "\n" &lt;IHaveADream.txt | \##使用tr将空格转换成换行符，使得每行一个单词，\续行符表示一行命令未写完可换行书写，切记其后什么字符也不能接，包括空格和注释sed -e "/[^a-Z]/d;/^$/d" | \##使用sed匹配非字母字符和空行并删除：-e 表示执行多个操作； /[^a-Z]/，双斜线//表示匹配部分，^表示匹配除开后面a-Z的所有字符，d表示对前面匹配部分删除；/^$/表示匹配空行，^、$分别表示行首和行尾sort |uniq -c |    \##排序之后使用uniq统计，-c表示统计单词出现的次数sort -nr | column -t|head #将次数最多的单词排在前面，-n表示按数值排序，-r从大到小倒序排，column -t表格式输出## 字长频数统计echoecho "字长频数统计："echo "频数" "单词长度"tr " " "\n" &lt;IHaveADream.txt | \sed -e "/[^a-Z]/d;/^$/d" | \while read worddo  echo ${#word}done |\## 用while和read每次读入一个单词，使用${#word}统计单词长度sort |uniq -c|sort -nr|column -t|head<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/bf86067e7f744920971af70e7249ade9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_12,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="字符串切割"><a href="#字符串切割" class="headerlink" title="字符串切割"></a>字符串切割</h2><p>将用到字符串切割，即将字符串切割为一个数组<br><a href="https://blog.csdn.net/u010003835/article/details/80750003?spm=1001.2101.3001.6650.5&amp;depth_1-utm_relevant_index=10">原文链接</a></p><h3 id="利用shell-中-变量-的字符串替换"><a href="#利用shell-中-变量-的字符串替换" class="headerlink" title="利用shell 中 变量 的字符串替换"></a>利用shell 中 变量 的字符串替换</h3><p>原理：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">${parameter<span class="token operator">/</span><span class="token operator">/</span>pattern<span class="token operator">/</span>string}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>用string来替换parameter变量中所有匹配的pattern</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">##!/bin/bash</span> <span class="token assign-left variable">string</span><span class="token operator">=</span><span class="token string">"hello,shell,split,test"</span>  <span class="token assign-left variable">array</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token variable">${string<span class="token operator">/</span><span class="token operator">/</span><span class="token operator">,</span><span class="token operator">/</span> }</span><span class="token punctuation">)</span>   <span class="token keyword">for</span> <span class="token for-or-select variable">var</span> <span class="token keyword">in</span> <span class="token variable">${array<span class="token punctuation">[</span>@<span class="token punctuation">]</span>}</span><span class="token keyword">do</span>   <span class="token builtin class-name">echo</span> <span class="token variable">$var</span><span class="token keyword">done</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdn.net/20180620184523515?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAwMDM4MzU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70#pic_center" alt="在这里插入图片描述"></p><h3 id="设置分隔符，通过-IFS-变量"><a href="#设置分隔符，通过-IFS-变量" class="headerlink" title="设置分隔符，通过 IFS 变量"></a>设置分隔符，通过 IFS 变量</h3><p>原理</p><p>自定义IFS变量, 改变分隔符, 对字符串进行切分</p><p>IFS介绍<br> Shell 脚本中有个变量叫 IFS(Internal Field Seprator) ，内部域分隔符。完整定义是The shell uses the value stored in IFS, which is the space, tab, and newline characters by default, to delimit words for the read and set commands, when parsing output from command substitution, and when performing variable substitution.</p><pre><code> Shell 的环境变量分为 set, env 两种，其中 set 变量可以通过 export 工具导入到 env 变量中。其中，set 是显示设置shell变量，仅在本 shell 中有效；env 是显示设置用户环境变量 ，仅在当前会话中有效。换句话说，set 变量里包含了 env 变量，但 set 变量不一定都是 env 变量。这两种变量不同之处在于变量的作用域不同。显然，env 变量的作用域要大些，它可以在 subshell 中使用。 而 IFS 是一种 set 变量，当 shell 处理"命令替换"和"参数替换"时，shell 根据 IFS 的值，默认是 space, tab, newline 来拆解读入的变量，然后对特殊字符进行处理，最后重新组合赋值给该变量。</code></pre><p>IFS 简单实例</p><p>1、查看变量 IFS 的值。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token environment constant">$IFS</span>    $ <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token environment constant">$IFS</span>"</span> <span class="token operator">|</span> od -b  0000000 040 011 012 012  0000004  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>直接输出IFS是看不到的，把它转化为二进制就可以看到了，”040”是空格，”011”是Tab，”012”是换行符”\n” 。最后一个 012 是因为 echo 默认是会换行的。</p><p><strong>示例：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">##!/bin/bash</span> <span class="token assign-left variable">string</span><span class="token operator">=</span><span class="token string">"hello,shell,split,test"</span>   <span class="token comment">##对IFS变量 进行替换处理</span><span class="token assign-left variable">OLD_IFS</span><span class="token operator">=</span><span class="token string">"<span class="token environment constant">$IFS</span>"</span><span class="token assign-left variable"><span class="token environment constant">IFS</span></span><span class="token operator">=</span><span class="token string">","</span><span class="token assign-left variable">array</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token variable">$string</span><span class="token punctuation">)</span><span class="token assign-left variable"><span class="token environment constant">IFS</span></span><span class="token operator">=</span><span class="token string">"<span class="token variable">$OLD_IFS</span>"</span> <span class="token keyword">for</span> <span class="token for-or-select variable">var</span> <span class="token keyword">in</span> <span class="token variable">${array<span class="token punctuation">[</span>@<span class="token punctuation">]</span>}</span><span class="token keyword">do</span>   <span class="token builtin class-name">echo</span> <span class="token variable">$var</span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdn.net/20180620203358805?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAwMDM4MzU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70#pic_center" alt="在这里插入图片描述"></p><h3 id="利用tr-指令实现字符替换"><a href="#利用tr-指令实现字符替换" class="headerlink" title="利用tr 指令实现字符替换"></a>利用tr 指令实现字符替换</h3><p>详细内容可自行查看</p><h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><h2 id="sed脚本命令"><a href="#sed脚本命令" class="headerlink" title="sed脚本命令"></a>sed脚本命令</h2><p><a href="http://c.biancheng.net/view/4028.html">原文链接</a><br><img src="https://img-blog.csdnimg.cn/1724ef524d524053baa16d8b017e1dab.png" alt="在这里插入图片描述"></p><h3 id="sed-s-替换脚本命令"><a href="#sed-s-替换脚本命令" class="headerlink" title="sed s 替换脚本命令"></a>sed s 替换脚本命令</h3><p><img src="https://img-blog.csdnimg.cn/5735a03bf5184e1f8dc331995681fe82.png" alt="在这里插入图片描述"></p><h3 id="sed-d-替换脚本命令"><a href="#sed-d-替换脚本命令" class="headerlink" title="sed d 替换脚本命令"></a>sed d 替换脚本命令</h3><p><img src="https://img-blog.csdnimg.cn/f4fff30466b04a079135ed30bba88b31.png" alt="在这里插入图片描述"></p><h3 id="sed-a-和-i-脚本命令-（插入）"><a href="#sed-a-和-i-脚本命令-（插入）" class="headerlink" title="sed a 和 i 脚本命令 （插入）"></a>sed a 和 i 脚本命令 （插入）</h3><p><img src="https://img-blog.csdnimg.cn/93d8f2644c724f7096a0e63ebee6f321.png" alt="在这里插入图片描述"></p><h3 id="sed-c-替换"><a href="#sed-c-替换" class="headerlink" title="sed c 替换"></a>sed c 替换</h3><p><img src="https://img-blog.csdnimg.cn/46aa3e463a4c4862a26f072b92ca7de6.png" alt="在这里插入图片描述"></p><h3 id="sed-y-转换"><a href="#sed-y-转换" class="headerlink" title="sed y 转换"></a>sed y 转换</h3><p><img src="https://img-blog.csdnimg.cn/3b2687b3243d4cfb9ae3eb4c573d7572.png" alt="在这里插入图片描述"></p><h3 id="sed-w-文本指定内容写入文件"><a href="#sed-w-文本指定内容写入文件" class="headerlink" title="sed w 文本指定内容写入文件"></a>sed w 文本指定内容写入文件</h3><p><img src="https://img-blog.csdnimg.cn/e45887cef70843378c1df10dc9b62d47.png" alt="在这里插入图片描述"></p><h3 id="sed-p-搜索符号条件的行，并输出该行的内容"><a href="#sed-p-搜索符号条件的行，并输出该行的内容" class="headerlink" title="sed p 搜索符号条件的行，并输出该行的内容"></a>sed p 搜索符号条件的行，并输出该行的内容</h3><p><img src="https://img-blog.csdnimg.cn/454d384ba076457bbd5f69cd0c15d87b.png" alt="在这里插入图片描述"></p><h3 id="sed-r-将一个独立文件的数据插入到当前数据流的指定位置"><a href="#sed-r-将一个独立文件的数据插入到当前数据流的指定位置" class="headerlink" title="sed r 将一个独立文件的数据插入到当前数据流的指定位置"></a>sed r 将一个独立文件的数据插入到当前数据流的指定位置</h3><p><img src="https://img-blog.csdnimg.cn/42d7c0ef765a4836b0f6c7c0428ff74d.png" alt="在这里插入图片描述"></p><h3 id="sed-q-使-sed-命令在第一次匹配任务结束后，退出-sed-程序，不再进行对后续数据的处理"><a href="#sed-q-使-sed-命令在第一次匹配任务结束后，退出-sed-程序，不再进行对后续数据的处理" class="headerlink" title="sed q 使 sed 命令在第一次匹配任务结束后，退出 sed 程序，不再进行对后续数据的处理"></a>sed q 使 sed 命令在第一次匹配任务结束后，退出 sed 程序，不再进行对后续数据的处理</h3><p><img src="https://img-blog.csdnimg.cn/f168c4bc5a7848d48c3d716256d8141f.png" alt="在这里插入图片描述"></p><h2 id="sed-address-寻址方式"><a href="#sed-address-寻址方式" class="headerlink" title="sed address 寻址方式"></a>sed address 寻址方式</h2><p><img src="https://img-blog.csdnimg.cn/b380fad553d041a08afc6106e4b23ccd.png" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基本知识-x2F-命令&quot;&gt;&lt;a href=&quot;#基本知识-x2F-命令&quot; class=&quot;headerlink&quot; title=&quot;基本知识/命令&quot;&gt;&lt;/a&gt;基本知识/命令&lt;/h2&gt;&lt;h3 id=&quot;变量赋值语句不能有空格&quot;&gt;&lt;a href=&quot;#变量赋值语句不能有空格&quot; c</summary>
      
    
    
    
    <category term="Linux" scheme="https://gaofeng-lin.github.io/categories/Linux/"/>
    
    
    <category term="运维" scheme="https://gaofeng-lin.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="Linux" scheme="https://gaofeng-lin.github.io/tags/Linux/"/>
    
    <category term="sed" scheme="https://gaofeng-lin.github.io/tags/sed/"/>
    
  </entry>
  
  <entry>
    <title>Go</title>
    <link href="https://gaofeng-lin.github.io/posts/56435/"/>
    <id>https://gaofeng-lin.github.io/posts/56435/</id>
    <published>2022-03-05T16:00:00.000Z</published>
    <updated>2022-07-23T03:15:47.282Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><pre class="line-numbers language-none"><code class="language-none">go version  //查看版本go env   //查看环境变量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="package"><a href="#package" class="headerlink" title="package"></a>package</h2><h3 id="包的定义"><a href="#包的定义" class="headerlink" title="包的定义"></a>包的定义</h3><pre class="line-numbers language-none"><code class="language-none">package 包名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意事项：</p><ul><li>一个文件夹下直接包含的文件只能归属于一个package，同样一个package的文件不能在多个文件夹下。</li><li>包名可以不和文件夹的名字一样。</li><li>包名为<code>main</code>的包为应用程序的入口包，这种包编译后会得到一个可执行文件，而编译不含main包的源代码则不会得到可执行文件</li></ul><h3 id="包的使用"><a href="#包的使用" class="headerlink" title="包的使用"></a>包的使用</h3><ol><li>有时候我们单独写一个go文件，测试或验证某个功能，包名都写main就好</li><li>如果要引入自定义的包。如果import失败，看一下保存的信息。一般会提示GOROOT GOPATH找不到这个包，这个时候把这个文件夹放到上面的目录里面就可以导入了。</li></ol><p>举例：<br>我目前的GOROOT是在这个目录下面，把文件夹放进去，里面是go文件，就可以引入了。<br><img src="https://s2.loli.net/2022/05/25/sy6aYNIOjX5dfuM.png" alt="03.png"></p><h3 id="go-mod配置"><a href="#go-mod配置" class="headerlink" title="go mod配置"></a>go mod配置</h3><p>go mod 主要用于管理第三方包，可以自动进行下载。要使用go mod，需要一些配置。<br><strong>需要配置GO111MODULE 、GOPROXY</strong></p><p><img src="https://s2.loli.net/2022/05/25/N4dmhtb628iVPyK.png" alt="01.png"></p><p><img src="https://s2.loli.net/2022/05/25/QDjPKNHc2pI8Mn3.png" alt="02.png"></p><h3 id="go-mod使用"><a href="#go-mod使用" class="headerlink" title="go mod使用"></a>go mod使用</h3><p>首先：</p><pre class="line-numbers language-none"><code class="language-none">go mod init "modname"//modname一般是文件所处文件夹的名字//go mod init dynamic<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果要某文件要引入一些包，在import处写入，然后执行下面命令：</p><pre class="line-numbers language-none"><code class="language-none">go mod tidy//或者go get -u<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h3><p><a href="https://zhuanlan.zhihu.com/p/139758275">原文链接</a><br><img src="https://img-blog.csdnimg.cn/img_convert/1298ce4931252dd9582b2d7571ab97c4.png#pic_center" alt="在这里插入图片描述"><br>输出为：</p><pre class="line-numbers language-none"><code class="language-none">{Aric 21 3-1}{Name:Aric Age:21 Class:3-1}main.Student{Name:"Aric", Age:21, Class:"3-1"}main.Student676f6c616e67676F6C616E670xc000062150<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/566b6c8f51f9f93e95c631aac7e69778.png#pic_center" alt="在这里插入图片描述"></p><h3 id="下划线-“-”"><a href="#下划线-“-”" class="headerlink" title="下划线  “_”"></a>下划线  “_”</h3><p>“_”是特殊标识符，用来忽略结果。</p><p><strong>1.下划线在import中</strong></p><p>在Golang里，import的作用是导入其他package。<br>　　 import 下划线（如：import _ hello/imp）的作用：当导入一个包时，该包下的文件里所有init()函数都会被执行，然而，有些时候我们并不需要把整个包都导入进来，仅仅是是希望它执行init()函数而已。这个时候就可以使用 import _ 引用该包。即使用【import _ 包路径】只是引用该包，仅仅是为了调用init()函数，所以无法通过包名来调用包中的其他函数。<br>示例：</p><pre class="line-numbers language-none"><code class="language-none">src |+--- main.go            |+--- hello       |       +--- hello.go<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>main.go</p><pre class="line-numbers language-none"><code class="language-none">package mainimport _ "./hello"func main() {    // hello.Print()     //编译报错：./main.go:6:5: undefined: hello}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>hello.go</p><pre class="line-numbers language-none"><code class="language-none">package helloimport "fmt"func init() {    fmt.Println("imp-init() come here.")}func Print() {    fmt.Println("Hello!")}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：</p><pre class="line-numbers language-none"><code class="language-none">imp-init() come here.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>2.下划线在代码中</strong></p><pre class="line-numbers language-none"><code class="language-none">package mainimport (    "os")func main() {    buf := make([]byte, 1024)    f, _ := os.Open("/Users/***/Desktop/text.txt")    defer f.Close()    for {        n, _ := f.Read(buf)        if n == 0 {            break            }        os.Stdout.Write(buf[:n])    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解释1：</p><pre class="line-numbers language-none"><code class="language-none">下划线意思是忽略这个变量.比如os.Open，返回值为*os.File，error普通写法是f,err := os.Open("xxxxxxx")如果此时不需要知道返回的错误值就可以用f, _ := os.Open("xxxxxx")如此则忽略了error变量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解释2：</p><pre class="line-numbers language-none"><code class="language-none">占位符，意思是那个位置本应赋给某个值，但是咱们不需要这个值。所以就把该值赋给下划线，意思是丢掉不要。这样编译器可以更好的优化，任何类型的单个值都可以丢给下划线。这种情况是占位用的，方法返回两个结果，而你只想要一个结果。那另一个就用 "_" 占位，而如果用变量的话，不使用，编译器是会报错的。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>补充：</p><pre class="line-numbers language-none"><code class="language-none">import "database/sql"import _ "github.com/go-sql-driver/mysql"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>第二个import就是不直接使用mysql包，只是执行一下这个包的init函数，把mysql的驱动注册到sql包里，然后程序里就可以使用sql包来访问mysql数据库了。</p><h3 id="x3D-和-x3D-的区别"><a href="#x3D-和-x3D-的区别" class="headerlink" title="= 和 :=的区别"></a>= 和 :=的区别</h3><pre class="line-numbers language-none"><code class="language-none">// = 使用必须使用先var声明例如：var aa=100//或var b = 100//或var c int = 100 // := 是声明并赋值，并且系统自动推断类型，不需要var关键字d := 100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="String-方法"><a href="#String-方法" class="headerlink" title="String()方法"></a>String()方法</h3><p>对于定于了String()方法的类型，默认输出的时候会调用该方法，实现字符串的打印。例如下面代码：</p><pre class="line-numbers language-none"><code class="language-none">package main import "fmt" type Man struct {    name string} func (m Man) String() string {    return "My name is :" + m.name} func main() {    var m Man    m.name = "SNS"    fmt.Println(m)} 输出：My name is :SNS<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>使用指针</strong><br>然而，如果使用func (m *Man) String() string方式定义函数，那么就不会自动调用该函数输出（go version go1.12.1 windows/amd64）。</p><pre class="line-numbers language-none"><code class="language-none">package main import "fmt" type Man struct {    name string} func (m *Man) String() string {    return "My name is :" + m.name} func main() {    var m Man    m.name = "SNS"    fmt.Println(m)} 输出:{SNS}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>String方法是接口方法，存在于fmt包里print.go文件下的Stringer接口。go使用fmt包的输出方法会自动调用String()方法。当重写的String是指针方法时，只有指针类型调用的时候才会正常调用，值类型调用的时候实际上没有执行重写的String方法；当重写的String方法是值方法时，无论指针类型和值类型均可调用重写的String方法。其实跟接口的实现有关，当值类型实现接口的时候，相当于值类型和该值的指针类型均实现了该接口；相反，当指针类型实现了该接口的时候，只有指针类型实现了接口，值类型是没有实现的。</p></blockquote><blockquote><p>最后一句改成<code>fmt.Println(&amp;m)</code><br>因为你只为<code>*Man</code>这个Man的指针类型重新定义了String()方法，所以只有在输出<code>*Man</code>类型的数据时才会调用自定义的String()方法。<br>而你定义的m是Man类型的，所以才不会调用你定义的String方法。<br>所要么向楼上那位一样定义<em>Man类型。要么就是在输出时，向Print函数传递</em>Man类型的数据(改成<code>fmt.Println(&amp;m)</code>)</p></blockquote><h3 id="方法接受者"><a href="#方法接受者" class="headerlink" title="方法接受者"></a>方法接受者</h3><p><a href="https://www.jianshu.com/p/316617954070">原文链接</a><br>在go语言中，没有类的概念但是可以给类型（结构体，自定义类型）定义方法。所谓方法就是定义了接受者的函数。接受者定义在func关键字和函数名之间:</p><pre class="line-numbers language-none"><code class="language-none">type Person struct {    name string    age int}func (p Person) say() {    fmt.Printf("I'm %s,%d years old\n",p.name,p.age)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有了对方法及接受者的简单认识之后，接下来主要谈一下接受者的类型问题。<br>接受者类型可以是struct,也可以是指向struc的指针。<br><strong>情况一：接受者是struct</strong></p><pre class="line-numbers language-none"><code class="language-none">package mainimport "fmt"type Person struct {name stringage int}func (p Person) say() {fmt.Printf("I'm %s,%d years old\n",p.name,p.age)}func (p Person) older(){    p.age = p.age +1}func main() {    var p1 Person = Person{"zhansan",16}    p1.older()    p1.say()    //output: I'm zhangsan，16 years old    var p2 *Person = &amp;Person{"lisi",17}    p2.older()    p2.say()    //output: I'm lisi，17 years old}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于p1的调用，读者应该不会有什么疑问。<br>对于p2的调用可能存在这样的疑问，p2明明是个指针，为什么再调用了older方法之后，打印结果还是17 years old?<br>方法的接受者是Person而调用者是*Person ，其实在p2调用时存在一个转换p2.older() -&gt; *p2.older(); p2.say() -&gt; *p2.say()<br>*p2是什么想必读者也是明白的（就一个p2指向Person实例）。那么疑问也就自然的解开了,方法执行时的接受者实际上还是一个值而非引用。</p><p><strong>情况二：接受者是指针</strong></p><pre class="line-numbers language-none"><code class="language-none">package mainimport "fmt"type Person struct {name stringage int}func (p *Person) say() {fmt.Printf("I'm %s,%d years old\n",p.name,p.age)}func (p *Person) older(){    p.age = p.age +1}func main() {    var p1 Person = Person{"zhansan",16}    p1.older()    p1.say()    //output: I'm zhangsan，17 years old    var p2 *Person = &amp;Person{"lisi",17}    p2.older()    p2.say()    //output: I'm lisi，18 years old}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>p1的调用中也存在一个转换，<br>p1.older -&gt; *p1.older<br>p1.say() -&gt; *p1.say()</p><p><strong>用例：</strong></p><pre class="line-numbers language-none"><code class="language-none">package mainimport (    "fmt")//面向对象//go仅支持封装，不支持继承和多态//go语言中没有class，只要struct//不论地址还是结构本身，一律使用.来访问成员//要改变内容必须使用指针接收者//结构过大考虑指针接收者//值接收者是go语言特有//封装//名字一般使用CamelCase//首字母大写： public//首字母小写：private//包//每个目录一个包，包名可以与目录不一样//main包包含可执行入口，只有一个main包//为结构定义的方法必须放在同一个包内，但是可以是不同文件type treeNode struct {    value int    left, right *treeNode}func (node treeNode) print() {  //显示定义和命名方法接收者（括号里）    fmt.Print(node.value)  //只有使用指针才可以改变结构内容    fmt.Println()}func (node *treeNode) setValue ( value int) {  //使用指针作为方法接收者    if node == nil {        fmt.Println("setting value to nil node") //nil指针也可以调用方法        return    }    node.value = value}func (node *treeNode ) traverse(){    if node == nil{        return    }    node.left.traverse()    node.print()    node.right.traverse()}func main() {    var  root  treeNode    fmt.Println(root)  //{0 &lt;nil&gt; &lt;nil&gt;}    root = treeNode{value:3}    root.left = &amp;treeNode{}    root.right = &amp;treeNode{5,nil,nil}    root.right.left = new(treeNode)    nodes := []treeNode {        {value: 3},        {},        {6,nil,&amp;root},    }    fmt.Println(nodes)  //[{3 &lt;nil&gt; &lt;nil&gt;} {0 &lt;nil&gt; &lt;nil&gt;} {6 &lt;nil&gt; 0xc04205a3e0}]    root.print()  // 3    fmt.Println()    root.right.left.setValue(100)    root.right.left.print()  //100    fmt.Println()    var pRoot *treeNode    pRoot.setValue(200)   //setting value to nil node    pRoot = &amp;root    pRoot.setValue(300)    pRoot.print()  //300    root.traverse()  //300 0 300 100 5}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="结构体定义中的-json-单引号（-96-96-）"><a href="#结构体定义中的-json-单引号（-96-96-）" class="headerlink" title="结构体定义中的 json 单引号（``）"></a>结构体定义中的 json 单引号（``）</h3><pre class="line-numbers language-none"><code class="language-none">package mainimport (    "encoding/json"    "fmt")//在处理json格式字符串的时候，经常会看到声明struct结构的时候，属性的右侧还有小米点括起来的内容。`TAB键左上角的按键，～线同一个键盘`type Student struct {    StudentId      string `json:"sid"`    StudentName    string `json:"sname"`    StudentClass   string `json:"class"`    StudentTeacher string `json:"teacher"`}type StudentNoJson struct {    StudentId      string    StudentName    string    StudentClass   string    StudentTeacher string}//可以选择的控制字段有三种：// -：不要解析这个字段// omitempty：当字段为空（默认值）时，不要解析这个字段。比如 false、0、nil、长度为 0 的 array，map，slice，string// FieldName：当解析 json 的时候，使用这个名字type StudentWithOption struct {    StudentId      string //默认使用原定义中的值    StudentName    string `json:"sname"`           // 解析（encode/decode） 的时候，使用 `sname`，而不是 `Field`    StudentClass   string `json:"class,omitempty"` // 解析的时候使用 `class`，如果struct 中这个值为空，就忽略它    StudentTeacher string `json:"-"`               // 解析的时候忽略该字段。默认情况下会解析这个字段，因为它是大写字母开头的}func main() {    //NO.1 with json struct tag    s := &amp;Student{StudentId: "1", StudentName: "fengxm", StudentClass: "0903", StudentTeacher: "feng"}    jsonString, _ := json.Marshal(s)    fmt.Println(string(jsonString))    //{"sid":"1","sname":"fengxm","class":"0903","teacher":"feng"}    newStudent := new(Student)    json.Unmarshal(jsonString, newStudent)    fmt.Println(newStudent)    //&amp;{1 fengxm 0903 feng}    //Unmarshal 是怎么找到结构体中对应的值呢？比如给定一个 JSON key Filed，它是这样查找的：    // 首先查找 tag 名字（关于 JSON tag 的解释参看下一节）为 Field 的字段    // 然后查找名字为 Field 的字段    // 最后再找名字为 FiElD 等大小写不敏感的匹配字段。    // 如果都没有找到，就直接忽略这个 key，也不会报错。这对于要从众多数据中只选择部分来使用非常方便。    //NO.2 without json struct tag    so := &amp;StudentNoJson{StudentId: "1", StudentName: "fengxm", StudentClass: "0903", StudentTeacher: "feng"}    jsonStringO, _ := json.Marshal(so)    fmt.Println(string(jsonStringO))    //{"StudentId":"1","StudentName":"fengxm","StudentClass":"0903","StudentTeacher":"feng"}    //NO.3 StudentWithOption    studentWO := new(StudentWithOption)    js, _ := json.Marshal(studentWO)    fmt.Println(string(js))    //{"StudentId":"","sname":""}    studentWO2 := &amp;StudentWithOption{StudentId: "1", StudentName: "fengxm", StudentClass: "0903", StudentTeacher: "feng"}    js2, _ := json.Marshal(studentWO2)    fmt.Println(string(js2))    //{"StudentId":"1","sname":"fengxm","class":"0903"}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="基本数据类型操作"><a href="#基本数据类型操作" class="headerlink" title="基本数据类型操作"></a>基本数据类型操作</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><pre class="line-numbers language-none"><code class="language-none"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="map相关操作"><a href="#map相关操作" class="headerlink" title="map相关操作"></a>map相关操作</h3><h4 id="创建map"><a href="#创建map" class="headerlink" title="创建map"></a>创建map</h4><pre class="line-numbers language-none"><code class="language-none">//初始化空mapprevNums := map[int]int{}//初始化countryCapitalMap := map[string]string{"France": "Paris", "Italy": "Rome", "Japan": "Tokyo", "India": "New delhi"}//value接收任意数据类型，用interfaceresMap := make(map[string]interface{})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="查看元素在集合中是否存在"><a href="#查看元素在集合中是否存在" class="headerlink" title="查看元素在集合中是否存在"></a>查看元素在集合中是否存在</h4><pre class="line-numbers language-none"><code class="language-none">capital, ok := countryCapitalMap [ "American" ] /*如果确定是真实的,则存在,否则不存在 */    /*fmt.Println(capital) */    /*fmt.Println(ok) */    if (ok) {        fmt.Println("American 的首都是", capital)    } else {        fmt.Println("American 的首都不存在")    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="判断key是否存在"><a href="#判断key是否存在" class="headerlink" title="判断key是否存在"></a>判断key是否存在</h4><pre class="line-numbers language-none"><code class="language-none">package main import "fmt" func main() {    demo := map[string]bool{        "a": false,    }     //错误，a存在，但是返回false    fmt.Println(demo["a"])     //正确判断方法    _, ok := demo["a"]    fmt.Println(ok)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">if _, ok := map[key]; ok {    // 存在}if _, ok := map[key]; !ok {    // 不存在}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="快速删除所有元素"><a href="#快速删除所有元素" class="headerlink" title="快速删除所有元素"></a>快速删除所有元素</h4><p><strong>直接重新生成map，名字相同</strong></p><h4 id="Map-实现去重与-set-的功能"><a href="#Map-实现去重与-set-的功能" class="headerlink" title="Map 实现去重与 set 的功能"></a>Map 实现去重与 set 的功能</h4><pre class="line-numbers language-none"><code class="language-none">package main var set = map[string]bool { } func main() {    ...    url := xxx    if set[url] {        // 表示集合中已经存在        return    }     set[url] = true           // 否则如果不存在，设置为true} // 完成后，set的所有的key值为不重复的值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="map转json"><a href="#map转json" class="headerlink" title="map转json"></a>map转json</h4><pre class="line-numbers language-none"><code class="language-none">// map to jsonpackage mainimport (    "encoding/json"    "fmt")func main() {    s := []map[string]interface{}{}    m1 := map[string]interface{}{"name": "John", "age": 10}    m2 := map[string]interface{}{"name": "Alex", "age": 12}    s = append(s, m1, m2)    s = append(s, m2)    b, err := json.Marshal(s)    if err != nil {        fmt.Println("json.Marshal failed:", err)        return    }    fmt.Println("b:", string(b))}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>切片是动态数组，可以搭配结构体或map形成多重嵌套</p><pre class="line-numbers language-none"><code class="language-none">var projects = make([]models.Project, 0)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的<code>models.Project</code>是一个结构体，前面加一个[]就变成了接片，用make生成，指定初始长度为0（必须要指定一个值，反正自动增加）。<br>这样这个projects变量是切片，里面的数据类型是models.Project结构体</p><p><a href="https://blog.csdn.net/youngwhz1/article/details/83026263?spm=1001.2101.3001.6661.1&amp;depth_1-utm_relevant_index=1">去重、插入、删除、清空原链接</a></p><h4 id="切片去重"><a href="#切片去重" class="headerlink" title="切片去重"></a>切片去重</h4><pre class="line-numbers language-none"><code class="language-none">/* 在slice中去除重复的元素，其中a必须是已经排序的序列。 * params: *   a: slice对象，如[]string, []int, []float64, ... * return: *   []interface{}: 已经去除重复元素的新的slice对象 */func SliceRemoveDuplicate(a interface{}) (ret []interface{}) {if reflect.TypeOf(a).Kind() != reflect.Slice {fmt.Printf("&lt;SliceRemoveDuplicate&gt; &lt;a&gt; is not slice but %T\n", a)return ret} va := reflect.ValueOf(a)for i := 0; i &lt; va.Len(); i++ {if i &gt; 0 &amp;&amp; reflect.DeepEqual(va.Index(i-1).Interface(), va.Index(i).Interface()) {continue}ret = append(ret, va.Index(i).Interface())} return ret}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试代码：</p><pre class="line-numbers language-none"><code class="language-none">func test_SliceRemoveDuplicate() {slice_string := []string{"a", "b", "c", "d", "a", "b", "c", "d"}slice_int := []int{1, 2, 3, 4, 5, 1, 2, 3, 4, 5}slice_float := []float64{1.11, 2.22, 3.33, 4.44, 1.11, 2.22, 3.33, 4.44} sort.Strings(slice_string)sort.Ints(slice_int)sort.Float64s(slice_float) fmt.Printf("slice_string = %v, %p\n", slice_string, slice_string)fmt.Printf("slice_int = %v, %p\n", slice_int, slice_int)fmt.Printf("slice_float = %v, %p\n", slice_float, slice_float) ret_slice_string := SliceRemoveDuplicate(slice_string)ret_slice_int := SliceRemoveDuplicate(slice_int)ret_slice_float := SliceRemoveDuplicate(slice_float) fmt.Printf("ret_slice_string = %v, %p\n", ret_slice_string, ret_slice_string)fmt.Printf("ret_slice_int = %v, %p\n", ret_slice_int, ret_slice_int)fmt.Printf("ret_slice_float = %v, %p\n", ret_slice_float, ret_slice_float) fmt.Printf("&lt;after&gt; slice_string = %v, %p\n", slice_string, slice_string)fmt.Printf("&lt;after&gt; slice_int = %v, %p\n", slice_int, slice_int)fmt.Printf("&lt;after&gt; slice_float = %v, %p\n", slice_float, slice_float)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-none"><code class="language-none">slice_string = [a a b b c c d d], 0xc042088000slice_int = [1 1 2 2 3 3 4 4 5 5], 0xc04200e1e0slice_float = [1.11 1.11 2.22 2.22 3.33 3.33 4.44 4.44], 0xc042014200 ret_slice_string = [a b c d], 0xc042034100ret_slice_int = [1 2 3 4 5], 0xc042088080ret_slice_float = [1.11 2.22 3.33 4.44], 0xc042034180 &lt;after&gt; slice_string = [a a b b c c d d], 0xc042088000&lt;after&gt; slice_int = [1 1 2 2 3 3 4 4 5 5], 0xc04200e1e0&lt;after&gt; slice_float = [1.11 1.11 2.22 2.22 3.33 3.33 4.44 4.44], 0xc042014200<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><pre class="line-numbers language-none"><code class="language-none">/* * 在Slice指定位置插入元素。 * params: *   s: slice对象，类型为[]interface{} *   index: 要插入元素的位置索引 *   value: 要插入的元素 * return: *   已经插入元素的slice，类型为[]interface{} */func SliceInsert(s []interface{}, index int, value interface{}) []interface{} {rear := append([]interface{}{}, s[index:]...)return append(append(s[:index], value), rear...)} /* * 在Slice指定位置插入元素。 * params: *   s: slice对象指针，类型为*[]interface{} *   index: 要插入元素的位置索引 *   value: 要插入的元素 * return: *   无 */func SliceInsert2(s *[]interface{}, index int, value interface{}) {rear := append([]interface{}{}, (*s)[index:]...)*s = append(append((*s)[:index], value), rear...)} /* * 在Slice指定位置插入元素。 * params: *   s: slice对象的指针，如*[]string, *[]int, ... *   index: 要插入元素的位置索引 *   value: 要插入的元素 * return: *   true: 插入成功 *   false: 插入失败（不支持的数据类型） */func SliceInsert3(s interface{}, index int, value interface{}) bool {if ps, ok := s.(*[]string); ok {if val, ok := value.(string); ok {rear := append([]string{}, (*ps)[index:]...)*ps = append(append((*ps)[:index], val), rear...)return true}} else if ps, ok := s.(*[]int); ok {if val, ok := value.(int); ok {rear := append([]int{}, (*ps)[index:]...)*ps = append(append((*ps)[:index], val), rear...)}} else if ps, ok := s.(*[]float64); ok {if val, ok := value.(float64); ok {rear := append([]float64{}, (*ps)[index:]...)*ps = append(append((*ps)[:index], val), rear...)}} else {fmt.Printf("&lt;SliceInsert3&gt; Unsupported type: %T\n", s)} return false}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：</p><ol><li>SliceInsert()方法是传入一个[]interface{}类型的slice对象，返回的也是一个[]interface{}类型的slice对象。</li><li>SliceInsert2()方法是传入一个[]interface{}类型的slice对象指针，直接修改这个slice对象。</li><li>SliceInsert3()方法是传入一个具体类型的slice对象指针（如*[]string, *[]int等），方法中直接修改这个slice对象，返回操作是否成功的状态(bool)。</li></ol><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><pre class="line-numbers language-none"><code class="language-none">/* * 删除Slice中的元素。 * params: *   s: slice对象，类型为[]interface{} *   index: 要删除元素的索引 * return: *   已经删除指定元素的slice，类型为[]interface{} * 说明：返回的序列与传入的序列地址不发生变化(但是传入的序列内容已经被修改，不能再使用) */func SliceRemove(s []interface{}, index int) []interface{} {return append(s[:index], s[index+1:]...)} /* * 删除Slice中的元素。 * params: *   s: slice对象指针，类型为*[]interface{} *   index: 要删除元素的索引 * return: *   无 * 说明：直接操作传入的Slice对象，传入的序列地址不变，但内容已经被修改 */func SliceRemove2(s *[]interface{}, index int) {*s = append((*s)[:index], (*s)[index+1:]...)} /* * 删除Slice中的元素。 * params: *   s: slice对象的指针，如*[]string, *[]int, ... *   index: 要删除元素的索引 * return: *   true: 删除成功 *   false: 删除失败（不支持的数据类型） * 说明：直接操作传入的Slice对象，不需要转换为[]interface{}类型。 */func SliceRemove3(s interface{}, index int) bool {if ps, ok := s.(*[]string); ok {*ps = append((*ps)[:index], (*ps)[index+1:]...)} else if ps, ok := s.(*[]int); ok {*ps = append((*ps)[:index], (*ps)[index+1:]...)} else if ps, ok := s.(*[]float64); ok {*ps = append((*ps)[:index], (*ps)[index+1:]...)} else {fmt.Printf("&lt;SliceRemove3&gt; Unsupported type: %T\n", s)return false} return true}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="清空"><a href="#清空" class="headerlink" title="清空"></a>清空</h4><pre class="line-numbers language-none"><code class="language-none">/* * 清空Slice，传入的slice对象地址发生变化。 * params: *   s: slice对象指针，类型为*[]interface{} * return: *   无 */func SliceClear(s *[]interface{}) {*s = append([]interface{}{})} /* * 清空Slice，传入的slice对象地址不变。 * params: *   s: slice对象指针，类型为*[]interface{} * return: *   无 */func SliceClear2(s *[]interface{}) {*s = (*s)[0:0]} /* * 清空Slice，传入的slice对象地址不变。 * params: *   s: slice对象的指针，如*[]string, *[]int, ... * return: *   true: 清空成功 *   false: 清空失败（不支持的数据类型） */func SliceClear3(s interface{}) bool {if ps, ok := s.(*[]string); ok {*ps = (*ps)[0:0]//*ps = append([]string{})} else if ps, ok := s.(*[]int); ok {*ps = (*ps)[0:0]//*ps = append([]int{})} else if ps, ok := s.(*[]float64); ok {*ps = (*ps)[0:0]//*ps = append([]float64{})} else {fmt.Printf("&lt;SliceClear3&gt; Unsupported type: %T\n", s)return false} return true}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><h3 id="单引号、双引号、反引号"><a href="#单引号、双引号、反引号" class="headerlink" title="单引号、双引号、反引号"></a>单引号、双引号、反引号</h3><p><strong>Golang限定字符或者字符串一共三种引号，单引号（’’)，双引号(“”) 以及反引号(``)。反引号就是标准键盘“Esc”按钮下面的那个键。</strong></p><ul><li><p>单引号，表示byte类型或rune类型，对应 uint8和int32类型，默认是 rune 类型。byte用来强调数据是raw data，而不是数字；而rune用来表示Unicode的code point。</p></li><li><p>双引号，才是字符串，实际上是字符数组。可以用索引号访问某字节，也可以用len()函数来获取字符串所占的字节长度。</p></li><li><p>反引号，表示字符串字面量，但不支持任何转义序列。字面量 raw literal string 的意思是，你定义时写的啥样，它就啥样，你有换行，它就换行。你写转义字符，它也就展示转义字符。</p></li></ul><p><strong>反引号有时候能起到很好的作用，比如一个字符串里面有双引号，分号这种，并且分布的还不规律，用反引号括起来就好</strong></p><h3 id="变量类型转换"><a href="#变量类型转换" class="headerlink" title="变量类型转换"></a>变量类型转换</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">string转成<span class="token keyword">int</span>：<span class="token keyword">int</span><span class="token punctuation">,</span> err <span class="token operator">:</span><span class="token operator">=</span> strconv<span class="token punctuation">.</span><span class="token function">Atoi</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span>string转成int64：int64<span class="token punctuation">,</span> err <span class="token operator">:</span><span class="token operator">=</span> strconv<span class="token punctuation">.</span><span class="token function">ParseInt</span><span class="token punctuation">(</span>string<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">)</span><span class="token keyword">int</span>转成string：string <span class="token operator">:</span><span class="token operator">=</span> strconv<span class="token punctuation">.</span><span class="token function">Itoa</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>int64转成string：string <span class="token operator">:</span><span class="token operator">=</span> strconv<span class="token punctuation">.</span><span class="token function">FormatInt</span><span class="token punctuation">(</span>int64<span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体例子：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">package main<span class="token function">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"strconv"</span><span class="token punctuation">)</span>func <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>cfdversion <span class="token operator">:</span><span class="token operator">=</span><span class="token string">"100"</span>newcfd<span class="token punctuation">,</span>_ <span class="token operator">:</span><span class="token operator">=</span>strconv<span class="token punctuation">.</span><span class="token function">Atoi</span><span class="token punctuation">(</span>cfdversion<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>newcfd<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意事项：<br>1.要导入包<br>2.转换变量类型后要重新用一个名字，不能用之前的变量名<br>3.下划线那个地方是err，被省略了</strong></p><h3 id="判断变量类型"><a href="#判断变量类型" class="headerlink" title="判断变量类型"></a>判断变量类型</h3><p>方法一：</p><pre class="line-numbers language-none"><code class="language-none">package mainimport ( "fmt")func main() {        v1 := "123456"        v2 := 12        fmt.Printf("v1 type:%T\n", v1)        fmt.Printf("v2 type:%T\n", v2)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方法二：</p><pre class="line-numbers language-none"><code class="language-none">package mainimport ( "fmt" "reflect")func main() {        v1 := "123456"        v2 := 12        // reflect        fmt.Println("v1 type:", reflect.TypeOf(v1))        fmt.Println("v2 type:", reflect.TypeOf(v2))}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="判断类型是否为map"><a href="#判断类型是否为map" class="headerlink" title="判断类型是否为map"></a>判断类型是否为map</h3><pre class="line-numbers language-none"><code class="language-none">if reflect.ValueOf(map1).Kind() == reflect.Map {    } else {    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="json相关操作"><a href="#json相关操作" class="headerlink" title="json相关操作"></a>json相关操作</h3><h4 id="解析json文件"><a href="#解析json文件" class="headerlink" title="解析json文件"></a>解析json文件</h4><pre class="line-numbers language-none"><code class="language-none">package mainimport (// "bytes""encoding/json""fmt""io/ioutil"// "reflect")func con_var_name (key string) string {var res stringbytes,_:=ioutil.ReadFile("C:/Users/76585/Desktop/para_compare_ver2.json")m :=make(map[string]interface{})err := json.Unmarshal([]byte(bytes),&amp;m)if err != nil {fmt.Println("err=",err)return ""}for _, value :=range m{// fmt.Println(reflect.TypeOf(value.([]interface{})[1].(map[string]interface{})["name"]))if key==value.([]interface{})[0].(map[string]interface{})["name"]{res=keyreturn res}if key==value.([]interface{})[1].(map[string]interface{})["name"]{tmp :=value.([]interface{})[0].(map[string]interface{})["name"]res=tmp.(string)return res}}res=keyreturn res}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="解析json文件，interface转int"><a href="#解析json文件，interface转int" class="headerlink" title="解析json文件，interface转int"></a>解析json文件，interface转int</h4><p><strong>因为json解析得到的数据是map[string]interface，里面的字段可能是数字，有时候需要取出来比较，<br>就需要将interface转为int。</strong><br><img src="https://img-blog.csdnimg.cn/1b607816b68645c5b5ceaebe1859abdc.png" alt="在这里插入图片描述"><br>需要先转为string，在用 <code>strconv.Atoi</code>，将string转为int。</p><h4 id="结构体解析为json"><a href="#结构体解析为json" class="headerlink" title="结构体解析为json"></a>结构体解析为json</h4><p>先上代码</p><p><strong>最为关键的是结构体里面的成员变量名，首字母必须是大写，否则无法解析，解析出来的是空。</strong></p><pre class="line-numbers language-none"><code class="language-none">package mainimport ("encoding/json""fmt")type Product struct {Name stringProductId int64Number intPrice float64IsOnSale bool}func main()  {var p Product// p := Product{}p.Name="apple"p.ProductId=1p.Number=100p.Price=3.45p.IsOnSale=falsedata, _ := json.Marshal(&amp;p)fmt.Println(string(data))}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="将json字符串解码到相应的数据结构"><a href="#将json字符串解码到相应的数据结构" class="headerlink" title="将json字符串解码到相应的数据结构"></a>将json字符串解码到相应的数据结构</h4><pre class="line-numbers language-none"><code class="language-none">type StuRead struct {    Name  interface{} `json:"name"`    Age   interface{}    HIgh  interface{}    sex   interface{}    Class interface{} `json:"class"`    Test  interface{}}type Class struct {    Name  string    Grade int}func main() {    //json字符中的"引号，需用\进行转义，否则编译出错    //json字符串沿用上面的结果，但对key进行了大小的修改，并添加了sex数据    data:="{\"name\":\"张三\",\"Age\":18,\"high\":true,\"sex\":\"男\",\"CLASS\":{\"naME\":\"1班\",\"GradE\":3}}"    str:=[]byte(data)    //1.Unmarshal的第一个参数是json字符串，第二个参数是接受json解析的数据结构。    //第二个参数必须是指针，否则无法接收解析的数据，如stu仍为空对象StuRead{}    //2.可以直接stu:=new(StuRead),此时的stu自身就是指针    stu:=StuRead{}    err:=json.Unmarshal(str,&amp;stu)    //解析失败会报错，如json字符串格式不对，缺"号，缺}等。    if err!=nil{        fmt.Println(err)    }    fmt.Println(stu)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="map转json-1"><a href="#map转json-1" class="headerlink" title="map转json"></a>map转json</h4><p>例子在前面 <strong>基本数据类型操作-》map相关操作</strong></p><h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><pre class="line-numbers language-none"><code class="language-none">package main​import (    "fmt"    "strings")​func main() {    s := "smallming"    //第一次出现的索引    fmt.Println(strings.Index(s, "l"))    //最后一次出现的索引    fmt.Println(strings.LastIndex(s, "l"))    //是否以指定内容开头    fmt.Println(strings.HasPrefix(s, "small"))    //是否以指定内容结尾    fmt.Println(strings.HasSuffix(s, "ming"))    //是否包含指定字符串    fmt.Println(strings.Contains(s, "mi"))    //全变小写    fmt.Println(strings.ToLower(s))    //全大写    fmt.Println(strings.ToUpper(s))    //把字符串中前n个old子字符串替换成new字符串,如果n小于0表示全部替换.    //如果n大于old个数也表示全部替换    fmt.Println(strings.Replace(s, "m", "k", -1))    //把字符串重复count遍    fmt.Println(strings.Repeat(s, 2))    //去掉字符串前后指定字符    fmt.Println(strings.Trim(s, " ")) //去空格可以使用strings.TrimSpace(s)    //根据指定字符把字符串拆分成切片    fmt.Println(strings.Split(s, "m"))    //使用指定分隔符把切片内容合并成字符串    arr := []string{"small", "ming"}    fmt.Println(strings.Join(arr, ""))}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h3><pre class="line-numbers language-none"><code class="language-none">str = strings.Replace(str, " ", "", -1)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>func Replace(s, old, new string, n int) string</p><p><strong>返回将s中前n个不重叠old子串都替换为new的新字符串，如果n&lt;0会替换所有old子串</strong></p><h3 id="字符串处理函数"><a href="#字符串处理函数" class="headerlink" title="字符串处理函数"></a>字符串处理函数</h3><p>Golang中的strings包：</p><pre class="line-numbers language-none"><code class="language-none">Count(s string, str string) int：计算字符串str在s中的非重叠个数。如果str为空串则返回s中的字符（非字节）个数+1。Index(s string, str string) int ：返回子串str在字符串s中第一次出现的位置。如果找不到则返回-1；如果str为空，则返回0。LastIndex(s string, str string) int： 返回子串str在字符串s中最后一次出现的位置。如果找不到则返回-1；如果str为空则返回字符串s的长度。IndexRune(s string, r rune) int ：返回字符r在字符串s中第一次出现的位置。如果找不到则返回-1。IndexAny(s string, str string) int ：返回字符串str中的任何一个字符在字符串s中第一次出现的位置。如果找不到或str为空则返回-1。LastIndexAny(s string, str string) int： 返回字符串str中的任何一个字符在字符串s中最后一次出现的位置。如果找不到或str为空则返回-1。Contains(s string, str string) bool：判断字符串s中是否包含个子串str。包含或者str为空则返回true。ContainsAny(s string, str string) bool：判断字符串s中是否包含个子串str中的任何一个字符。包含则返回true，如果str为空则返回false。ContainsRune(s string, r rune) bool：判断字符串s中是否包含字符r。SplitN(s, str string, n int) []string：以str为分隔符，将s切分成多个子串，结果中**不包含**str本身。如果str为空则将s切分成Unicode字符列表。如果s中没有str子串，则将整个s作为[]string的第一个元素返回。参数n表示最多切分出几个子串，超出的部分将不再切分，最后一个n包含了所有剩下的不切分。如果n为0，则返回nil；如果n小于0，则不限制切分个数，全部切分。SplitAfterN(s, str string, n int) []string：以str为分隔符，将s切分成多个子串，结果中**包含**str本身。如果str为空，则将s切分成Unicode字符列表。如果s 中没有str子串，则将整个s作为 []string 的第一个元素返回。参数n表示最多切分出几个子串，超出的部分将不再切分。如果n为0，则返回 nil；如果 n 小于 0，则不限制切分个数，全部切分。Split(s, str string) []string：以str为分隔符，将s切分成多个子切片，结果中**不包含**str本身。如果str为空，则将s切分成Unicode字符列表。如果s中没有str子串，则将整个s作为[]string的第一个元素返回。SplitAfter(s, str string) []string：以str为分隔符，将s切分成多个子切片，结果中**包含**str本身。如果 str 为空，则将 s 切分成Unicode字符列表。如果s中没有str子串，则将整个s作为[]string的第一个元素返回。Fields(s string) []string：以连续的空白字符为分隔符，将s切分成多个子串，结果中不包含空白字符本身。空白字符有：\t, \n, \v, \f, \r, ’ ‘, U+0085 (NEL), U+00A0 (NBSP) 。如果 s 中只包含空白字符，则返回一个空列表。FieldsFunc(s string, f func(rune) bool) []string：以一个或多个满足f(rune)的字符为分隔符，将s切分成多个子串，结果中不包含分隔符本身。如果s中没有满足f(rune)的字符，则返回一个空列表。Join(s []string, str string) string：将s中的子串连接成一个单独的字符串，子串之间用str分隔。HasPrefix(s string, prefix string) bool：判断字符串s是否以prefix开头。HasSuffix(s, suffix string) bool ：判断字符串s是否以prefix结尾。Map(f func(rune) rune, s string) string：将s中满足f(rune)的字符替换为f(rune)的返回值。如果f(rune)返回负数，则相应的字符将被删除。Repeat(s string, n int) string：将n个字符串s连接成一个新的字符串。ToUpper(s string) string：将s中的所有字符修改为其大写格式。对于非ASCII字符，它的大写格式需要查表转换。ToLower(s string) string：将s中的所有字符修改为其小写格式。对于非ASCII字符，它的小写格式需要查表转换。ToTitle(s string) string：将s中的所有字符修改为其Title格式，大部分字符的Title格式就是Upper格式，只有少数字符的Title格式是特殊字符。这里的ToTitle主要给Title函数调用。TrimLeftFunc(s string, f func(rune) bool) string：删除s头部连续的满足f(rune)的字符。TrimRightFunc(s string, f func(rune) bool) string：删除s尾部连续的满足f(rune)的字符。TrimFunc(s string, f func(rune) bool) string：删除s首尾连续的满足f(rune)的字符。IndexFunc(s string, f func(rune) bool) int：返回s中第一个满足f(rune) 的字符的字节位置。如果没有满足 f(rune) 的字符，则返回 -1。LastIndexFunc(s string, f func(rune) bool) int：返回s中最后一个满足f(rune)的字符的字节位置。如果没有满足 f(rune) 的字符，则返回 -1。Trim(s string, str string) string：删除s首尾连续的包含在str中的字符。TrimLeft(s string, str string) string：删除s头部连续的包含在str中的字符串。TrimRight(s string, str string) string：删除s尾部连续的包含在str中的字符串。TrimSpace(s string) string：删除s首尾连续的的空白字符。TrimPrefix(s, prefix string) string：删除s头部的prefix字符串。如果s不是以prefix开头，则返回原始s。TrimSuffix(s, suffix string) string：删除s尾部的suffix字符串。如果s不是以suffix结尾，则返回原始s。（只去掉一次，注意和TrimRight区别）Replace(s, old, new string, n int) string：返回s的副本，并将副本中的old字符串替换为new字符串，替换次数为n次，如果n为-1，则全部替换；如果 old 为空，则在副本的每个字符之间都插入一个new。EqualFold(s1, s2 string) bool：比较UTF-8编码在小写的条件下是否相等，不区分大小写，同时它还会对特殊字符进行转换。比如将“ϕ”转换为“Φ”、将“Ǆ”转换为“ǅ”等，然后再进行比较。“==”比较字符串是否相等，区分大小写，返回bool。Compare(s1 string, s2 string) int1：比较字符串，区分大小写，比”==”速度快。相等为0，不相等为-1。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><h4 id="常用的元字符："><a href="#常用的元字符：" class="headerlink" title="常用的元字符："></a>常用的元字符：</h4><pre class="line-numbers language-none"><code class="language-none">. 匹配除换行符以外的任意字符\w 匹配字母或数字或下划线或汉字\s 匹配任意的空白符\d 匹配数字\b 匹配单词的开始或结束^ 匹配字符串的开始$ 匹配字符串的结束<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>字符转义：</p><p>如果你想查找元字符本身的话，比如你查找.,或者*,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时你就得使用\来取消这些字符的特殊意义。因此，你应该使用.和*。当然，要查找\本身，你也得用\。</p><h4 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h4><p><img src="https://img-blog.csdnimg.cn/ed775dff59f64772a5e4b0c1339e55d5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>如果你想匹配没有预定义元字符的字符集合(比如元音字母a,e,i,o,u),应该怎么办？</p><p>很简单，你只需要在方括号里列出它们就行了，像[aeiou]就匹配任何一个英文元音字母，[.?!]匹配标点符号(.或?或!)。</p><p><strong>分枝条件：</strong></p><p>正则表达式里的分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用 “|”  把不同的规则分隔开。</p><p><strong>分组：</strong></p><p>重复单个字符（直接在字符后面加上限定符就行了）；但如果想要重复多个字符又该怎么办？你可以用小括号来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作。</p><h4 id="反义字符"><a href="#反义字符" class="headerlink" title="反义字符"></a>反义字符</h4><p><img src="https://img-blog.csdnimg.cn/b44bde0b2c634cac8c39987e26e035b1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>例子：\S+匹配不包含空白符的字符串。</p><p>&lt;a[^&gt;]+&gt;匹配用尖括号括起来的以a开头的字符串。</p><h4 id="常用的正则表达式函数："><a href="#常用的正则表达式函数：" class="headerlink" title="常用的正则表达式函数："></a>常用的正则表达式函数：</h4><pre class="line-numbers language-none"><code class="language-none">reg = regexp.MustCompile(`匹配模式`)reg.FindAllString( )reg.ReplaceAllString(）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><pre class="line-numbers language-none"><code class="language-none">func main() {text := `Hello 世界！123 Go.` // 查找连续的小写字母reg := regexp.MustCompile(`[a-z]+`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["ello" "o"] // 查找连续的非小写字母reg = regexp.MustCompile(`[^a-z]+`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["H" " 世界！123 G" "."] // 查找连续的单词字母reg = regexp.MustCompile(`[\w]+`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["Hello" "123" "Go"] // 查找连续的非单词字母、非空白字符reg = regexp.MustCompile(`[^\w\s]+`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["世界！" "."] // 查找连续的大写字母reg = regexp.MustCompile(`[[:upper:]]+`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["H" "G"] // 查找连续的非 ASCII 字符reg = regexp.MustCompile(`[[:^ascii:]]+`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["世界！"] // 查找连续的标点符号reg = regexp.MustCompile(`[\pP]+`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["！" "."] // 查找连续的非标点符号字符reg = regexp.MustCompile(`[\PP]+`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["Hello 世界" "123 Go"] // 查找连续的汉字reg = regexp.MustCompile(`[\p{Han}]+`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["世界"] // 查找连续的非汉字字符reg = regexp.MustCompile(`[\P{Han}]+`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["Hello " "！123 Go."] // 查找 Hello 或 Goreg = regexp.MustCompile(`Hello|Go`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["Hello" "Go"] // 查找行首以 H 开头，以空格结尾的字符串reg = regexp.MustCompile(`^H.*\s`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["Hello 世界！123 "] // 查找行首以 H 开头，以空白结尾的字符串（非贪婪模式）reg = regexp.MustCompile(`(?U)^H.*\s`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["Hello "] // 查找以 hello 开头（忽略大小写），以 Go 结尾的字符串reg = regexp.MustCompile(`(?i:^hello).*Go`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["Hello 世界！123 Go"] // 查找 Go.reg = regexp.MustCompile(`\QGo.\E`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["Go."] // 查找从行首开始，以空格结尾的字符串（非贪婪模式）reg = regexp.MustCompile(`(?U)^.* `)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["Hello "] // 查找以空格开头，到行尾结束，中间不包含空格字符串reg = regexp.MustCompile(` [^ ]*$`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// [" Go."] // 查找“单词边界”之间的字符串reg = regexp.MustCompile(`(?U)\b.+\b`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["Hello" " 世界！" "123" " " "Go"] // 查找连续 1 次到 4 次的非空格字符，并以 o 结尾的字符串reg = regexp.MustCompile(`[^ ]{1,4}o`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["Hello" "Go"] // 查找 Hello 或 Goreg = regexp.MustCompile(`(?:Hell|G)o`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["Hello" "Go"] // 查找 Hello 或 Go，替换为 Hellooo、Goooreg = regexp.MustCompile(`(?PHell|G)o`)fmt.Printf("%q\n", reg.ReplaceAllString(text, "${n}ooo"))// "Hellooo 世界！123 Gooo." // 交换 Hello 和 Goreg = regexp.MustCompile(`(Hello)(.*)(Go)`)fmt.Printf("%q\n", reg.ReplaceAllString(text, "$3$2$1"))// "Go 世界！123 Hello." // 特殊字符的查找reg = regexp.MustCompile(`[\f\t\n\r\v\123\x7F\x{10FFFF}\\\^\$\.\*\+\?\{\}\(\)\[\]\|]`)fmt.Printf("%q\n", reg.ReplaceAllString("\f\t\n\r\v\123\x7F\U0010FFFF\\^$.*+?{}()[]|", "-"))// "----------------------"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="按行读文件"><a href="#按行读文件" class="headerlink" title="按行读文件"></a>按行读文件</h3><p><strong>注意下这里的第二个方法，读到最后字符串为空，有时候可能会报错（被坑过），加一个判断条件，判断长度是否为0。（代码里面自己已经加了）</strong></p><pre class="line-numbers language-none"><code class="language-none">func Readlines(filename string) {// go 按行读取文件的方式有两种，// 第一 将读取到的整个文件内容按照 \n 分割// 使用bufio// 第一种lines, err := ioutil.ReadFile(filename)if err != nil {fmt.Println(err)} else {contents := string(lines)lines := strings.Split(contents, "\n")for _, line := range lines {fmt.Println(line)}}// 第二种fd, err := os.Open(filename)defer fd.Close()if err != nil {fmt.Println("read error:", err)}buff := bufio.NewReader(fd)for {data, _, eof := buff.ReadLine()if eof == io.EOF {break}if(len(data)==0){           break        }fmt.Println(string(data))}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="字符串与切片的转换"><a href="#字符串与切片的转换" class="headerlink" title="字符串与切片的转换"></a>字符串与切片的转换</h3><pre class="line-numbers language-none"><code class="language-none">package mainimport ("fmt""strings")func main() {s := []string{"1", "2", "3"}ss := fmt.Sprintf(strings.Join(s, ","))fmt.Println(ss)slice := strings.Split(ss, ",")fmt.Println(slice)//r := gin.Default()//r.GET("/", func(context *gin.Context) {//context.JSON(http.StatusOK,gin.H{//"message":"demo",//})//})//r.Run()}//D:\GoProject\gin-demo&gt;go run main.go//1,2,3//[1 2 3]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><p><a href="https://www.cnblogs.com/believepd/p/10951763.html">原文链接</a></p><h4 id="打开关闭文件"><a href="#打开关闭文件" class="headerlink" title="打开关闭文件"></a>打开关闭文件</h4><pre class="line-numbers language-none"><code class="language-none">import (    "fmt"    "os")func main() {    // 打开文件    file, err := os.Open("e:/a.txt")    if err != nil {        fmt.Printf("打开文件出错：%v\n", err)    }    fmt.Println(file) // &amp;{0xc00006a780}    // 关闭文件    err = file.Close()    if err != nil {        fmt.Printf("关闭文件出错：%v\n", err)    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h4><p><strong>法一：带缓冲</strong></p><pre class="line-numbers language-none"><code class="language-none">import (    "bufio"    "fmt"    "io"    "os")func main() {    // 打开文件    file, err := os.Open("e:/a.txt")    if err != nil {        fmt.Printf("打开文件出错：%v\n", err)    }    // 及时关闭文件句柄    defer file.Close()    // bufio.NewReader(rd io.Reader) *Reader    reader := bufio.NewReader(file)    // 循环读取文件的内容    for {        line, err := reader.ReadString('\n') // 读到一个换行符就结束        if err == io.EOF { // io.EOF表示文件的末尾            break        }        // 输出内容        fmt.Print(line)    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>法二：一次性读入，不适用于大文件</strong></p><pre class="line-numbers language-none"><code class="language-none">import (    "fmt"    "io/ioutil")func main() {    // 使用 io/ioutil.ReadFile 方法一次性将文件读取到内存中    filePath := "e:/.txt"    content, err := ioutil.ReadFile(filePath)    if err != nil {        // log.Fatal(err)        fmt.Printf("读取文件出错：%v", err)    }    fmt.Printf("%v\n", content)    fmt.Printf("%v\n", string(content))}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h4><p>示例1：<br>创建一个新文件，写入3行：”Hello World”<br>打开一个存在的文件，将原来的内容覆盖成新的内容，3行：”你好，世界”<br>打开一个存在的文件，在原来的内容基础上，追加3行：”你好，Golang”<br>打开一个存在的文件，将原来的内容读出显示在终端，并且追加3行：”你好，World”</p><pre class="line-numbers language-none"><code class="language-none">import (    "bufio"    "fmt"    "os")func main() {    filePath := "e:/a.txt" // 此文件事先不存在    file, err := os.OpenFile(filePath, os.O_WRONLY | os.O_CREATE, 0666) // O_CREATE 能创建文件    if err != nil {        fmt.Printf("打开文件出错：%v", err)        return    }    // 及时关闭文件句柄    defer file.Close()    // 准备写入的内容    str := "Hello World\r\n"    // 写入时，使用带缓冲方式的 bufio.NewWriter(w io.Writer) *Writer    writer := bufio.NewWriter(file)    // 使用for循环写入内容    for i := 0; i &lt; 3; i++ {        _, err := writer.WriteString(str) // func (b *Writer) WriteString(s string) (int, error)        if err != nil {            fmt.Printf("文件写入出错：%s", err)        }    }    // 因为 writer 是带缓存的，所以需要 Flush 方法将缓冲中的数据真正写入到文件中    _ = writer.Flush()}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将 O_CREATE 修改为 O_TRUNC 模式即可，表示：打开文件并清空内容<br>将 O_TRUNC 修改为 O_APPEND 模式即可，表示：打开文件并在最后追加内容</p><pre class="line-numbers language-none"><code class="language-none">import (    "bufio"    "fmt"    "io"    "os")func main() {    filePath := "e:/a.txt"    file, err := os.OpenFile(filePath, os.O_RDWR | os.O_APPEND, 0666)    if err != nil {        fmt.Printf("打开文件出错：%v", err)        return    }    defer file.Close()    // 先读取原来文件的内容，并显示在终端    reader := bufio.NewReader(file)    for {        str, err := reader.ReadString('\n') // 读到一个换行符就结束        if err == io.EOF { // io.EOF表示文件的末尾            break        }        // 输出内容        fmt.Print(str)    }    // 准备写入的内容    str := "你好，World\r\n"    // 写入时，使用带缓冲方式的 bufio.NewWriter(w io.Writer) *Writer    writer := bufio.NewWriter(file)    // 使用for循环写入内容    for i := 0; i &lt; 3; i++ {        _, err := writer.WriteString(str) // func (b *Writer) WriteString(s string) (int, error)        if err != nil {            fmt.Printf("文件写入出错：%s", err)        }    }    // 因为 writer 是带缓存的，所以需要 Flush 方法将缓冲中的数据真正写入到文件中    _ = writer.Flush()}4：读写模式（O_RDWR）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例二：将一个文件写道另一个文件（两个文件均存在）</p><pre class="line-numbers language-none"><code class="language-none">import (    "fmt"    "io/ioutil")func main() {    filePath1 := "e:/a.txt"    filePath2 := "e:/b.txt"    content, err := ioutil.ReadFile(filePath1)    if err != nil {        fmt.Printf("读取文件出错：%v", err)        return    }    err = ioutil.WriteFile(filePath2, content, 0666)    if err != nil {        fmt.Printf("写入文件出错：%v", err)        return    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="判断文件是否存在"><a href="#判断文件是否存在" class="headerlink" title="判断文件是否存在"></a>判断文件是否存在</h4><p>golang判断文件或文件夹是否存在的方法为使用 os.Stat() 函数返回的错误值进行判断：</p><p>如果返回的错误为 nil，说明文件或文件夹存在；<br>如果返回的错误类型使用 os.IsNotExist() 判断为 true，说明文件或文件夹不存在；<br>如果返回的错误为其他类型，则不确定是否存在。</p><pre class="line-numbers language-none"><code class="language-none">package mainimport (    "fmt"    "os")// 判断文件或文件夹是否存在func PathExist(path string) (bool, error) {    _, err := os.Stat(path)    if err == nil {        return true, nil    }    if os.IsNotExist(err) {        return false, nil    }    return false, err}func main() {    filePath := "e:/a.txt"    flag, err := PathExist(filePath)    if err != nil {        fmt.Println(err)    }    fmt.Println(flag) // true}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="拷贝文件"><a href="#拷贝文件" class="headerlink" title="拷贝文件"></a>拷贝文件</h4><p>将src的数据拷贝到dst，直到在src上到达EOF或发生错误。返回拷贝的字节数和遇到的第一个错误。</p><p>对成功的调用，返回值err为nil而非EOF，因为Copy定义为从src读取直到EOF，它不会将读取到EOF视为应报告的错误。如果src实现了WriterTo接口，本函数会调用src.WriteTo(dst)进行拷贝；否则如果dst实现了ReaderFrom接口，本函数会调用dst.ReadFrom(src)进行拷贝。</p><pre class="line-numbers language-none"><code class="language-none">package mainimport (    "bufio"    "fmt"    "io"    "os")// 将 srcFilePath 拷贝到 dstFilePathfunc CopyFile(dstFilePath string, srcFilePath string) (written int64, err error) {    // 打开srcFilePath    srcFile, err := os.Open(srcFilePath)    if err != nil {        fmt.Printf("打开文件出错：%s\n", err)        return    }    defer srcFile.Close()    // 通过 bufio/NewReader，传入 srcFile，获取到 reader    reader := bufio.NewReader(srcFile)    // 打开dstFilePath    dstFile, err := os.OpenFile(dstFilePath, os.O_WRONLY | os.O_CREATE, 0666)    if err != nil {        fmt.Printf("打开文件出错：%s\n", err)        return    }    defer dstFile.Close()    // 通过 bufio/NewWriter，传入 dstFile，获取到 writer    writer := bufio.NewWriter(dstFile)    return io.Copy(writer, reader)}func main() {    srcFilePath := "e:/a.mp4"    dstFilePath := "f:/b.mp4"    _, err := CopyFile(dstFilePath, srcFilePath)    if err != nil {        fmt.Printf("拷贝文件出错：%s", err)    }    fmt.Println("拷贝文件完成")}自己写一个函数完成拷贝文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="遍历目录"><a href="#遍历目录" class="headerlink" title="遍历目录"></a>遍历目录</h4><pre class="line-numbers language-none"><code class="language-none">package mainimport (    "fmt"    "os")func main() {    fmt.Println("请输入一个目录的路径：")    var path string    _, _ = fmt.Scan(&amp;path)    // 打开目录    f, err := os.OpenFile(path, os.O_RDONLY, os.ModeDir)    if err != nil {        fmt.Printf("Open file failed:%s.\n", err)        return    }    defer f.Close()    // 读取目录    info, err := f.Readdir(-1) // -1 表示读取目录中所有目录项    // 遍历返回的切片    for _, fileInfo := range info {        if fileInfo.IsDir() {            fmt.Printf("%s是一个目录\n", fileInfo.Name())        } else {            fmt.Printf("%s是一个文件\n", fileInfo.Name())        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><p>统计一个文件中含有的英文、数字、空格以及其他字符数量。</p><pre class="line-numbers language-none"><code class="language-none">package mainimport (    "bufio"    "fmt"    "io"    "os")// 定义一个结构体，用于保存统计结果type CharCount struct {    AlphaCount     int // 记录英文个数    NumCount     int // 记录数字的个数    SpaceCount     int // 记录空格的个数    OtherCount     int // 记录其它字符的个数}func main() {    // 思路: 打开一个文件, 创一个 reader    // 每读取一行，就去统计该行有多少个 英文、数字、空格和其他字符    // 然后将结果保存到一个结构体    filePath := "e:/a.txt"    file, err := os.Open(filePath)    if err != nil {        fmt.Printf("打开文件出错：%s\n", err)        return    }    defer file.Close()    // 定义一个 CharCount 实例    var count CharCount    //创建一个Reader    reader := bufio.NewReader(file)    // 开始循环的读取文件的内容    for {        line, err := reader.ReadString('\n')        if err == io.EOF { // 读到文件末尾就退出            break        }        // 遍历每一行（line），进行统计        for _, v := range line {            switch {                case v &gt;= 'a' &amp;&amp; v &lt;= 'z':                    fallthrough // 穿透                case v &gt;= 'A' &amp;&amp; v &lt;= 'Z':                    count.AlphaCount++                case v &gt;= '0' &amp;&amp; v &lt;= '9':                    count.NumCount++                case v == ' ' || v == '\t':                    count.SpaceCount++                default :                    count.OtherCount++            }        }    }    // 输出统计的结果看看是否正确    fmt.Printf("字符的个数为：%v\n数字的个数为：%v\n空格的个数为：%v\n其它字符个数：%v\n",        count.AlphaCount, count.NumCount, count.SpaceCount, count.OtherCount)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="map类型interface-转换"><a href="#map类型interface-转换" class="headerlink" title="map类型interface{}转换"></a>map类型interface{}转换</h3><p>有时候我们在map里面嵌套map<br>想取内存map的值就会出现以下问题</p><pre class="line-numbers language-none"><code class="language-none">cannot range over v (type interface {})<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>interface{} 与其他数据类型不能直接赋值</p><p><strong>解决方法</strong></p><ol><li><p>转为map</p><pre class="line-numbers language-none"><code class="language-none">v.(map[string] interface {})<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>转为int<br><code>value.(int)</code><br>在目标变量后面用. 括号int</p></li><li><p>转为map</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;环境变量&quot;&gt;&lt;a href=&quot;#环境变量&quot; class=&quot;headerlink&quot; title=&quot;环境变量&quot;&gt;&lt;/a&gt;环境变量&lt;/h2&gt;&lt;pre class=&quot;line-numbers language-none&quot;&gt;&lt;code class=&quot;language-non</summary>
      
    
    
    
    <category term="Go" scheme="https://gaofeng-lin.github.io/categories/Go/"/>
    
    
    <category term="Go" scheme="https://gaofeng-lin.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="https://gaofeng-lin.github.io/posts/48230/"/>
    <id>https://gaofeng-lin.github.io/posts/48230/</id>
    <published>2022-03-05T16:00:00.000Z</published>
    <updated>2022-07-23T03:05:17.096Z</updated>
    
    <content type="html"><![CDATA[<h2 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h2><h3 id="修改文件用户组"><a href="#修改文件用户组" class="headerlink" title="修改文件用户组"></a>修改文件用户组</h3><p>chgrp： change group的简写，修改文件所属的用户组。</p><pre class="line-numbers language-none"><code class="language-none">chgrp users test.log<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果要修改该目录下所有文件和目录，使用-R参数。</p><pre class="line-numbers language-none"><code class="language-none">chgrp -R users test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="修改文件所有者"><a href="#修改文件所有者" class="headerlink" title="修改文件所有者"></a>修改文件所有者</h3><p>chown ：change owner的简写， 修改文件的所有者。</p><pre class="line-numbers language-none"><code class="language-none">chown [-R] 账号名称  文件或目录<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将所有者和组名称都修改为root。</p><pre class="line-numbers language-none"><code class="language-none">chown root:root test.log<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h3><p><img src="https://img-blog.csdnimg.cn/f08c5be5513c4aea88cb3c13b3a2b3d7.png" alt="在这里插入图片描述"></p><h2 id="运行sh文件命令"><a href="#运行sh文件命令" class="headerlink" title="运行sh文件命令"></a>运行sh文件命令</h2><p><strong>第一种（这种办法需要用chmod使得文件具备执行条件(x): chmod u+x datelog.sh）：</strong></p><pre class="line-numbers language-none"><code class="language-none">/xx/xxx/xxx.sh   //任意路径 ./XXX.sh  //当前路径<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>第二种（这种办法不需要文件具备可执行的权限也可运行）：</strong></p><pre class="line-numbers language-none"><code class="language-none">sh xxx.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="解压缩命令"><a href="#解压缩命令" class="headerlink" title="解压缩命令"></a>解压缩命令</h2><h3 id="ZIP"><a href="#ZIP" class="headerlink" title="ZIP"></a>ZIP</h3><pre class="line-numbers language-none"><code class="language-none">zip [选项] 压缩包名 源文件或源目录-r：压缩目录示例：zip ana.zip anaconda-ks.cfg压缩多个文件：zip test.zip abc abcd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">zip对应的解压缩命令为unzip：命令所在目录为/usr/bin/unzip，所有用户可执行unzip [选项] 压缩包名-d：指定解压缩位置-o:不必先询问用户，unzip执行后覆盖原有文件。//其它参数可自行查看unzip -d /tmp/ test.zipunzip -d /tmp -o test.zip //这条命令和上一条相比，可以不用询问直接覆盖<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="gz"><a href="#gz" class="headerlink" title="gz"></a>gz</h3><p><img src="https://img-blog.csdnimg.cn/20190604225601664.png#pic_center" alt="在这里插入图片描述"><br>注意：使用gzip压缩文件后会将原文件删除，如果想保留原文件则可以使用-c选项将压缩过程产生的标准输出写入一个新的文件中，示例如下：&gt;的作用是覆盖内容，&gt;&gt;的作用是追加内容<br><img src="https://img-blog.csdnimg.cn/20190604230304985.png#pic_center" alt="在这里插入图片描述"><br>压缩目录下的每个文件：下述命令会将123这个目录下的每个文件分别进行压缩，而不是将整个123目录进行压缩，也就是说<strong>gzip命令不会打包压缩</strong></p><p>解压缩也可以使用gunzip：<br><img src="https://img-blog.csdnimg.cn/20190604225930966.png#pic_center" alt="在这里插入图片描述"></p><h3 id="bz2"><a href="#bz2" class="headerlink" title="bz2"></a>bz2</h3><p>.bz2格式是Linux中的另一种常用压缩格式，该格式的压缩算法更先进，压缩比更高，但是压缩的时间要比.gz长，.bz2格式的压缩命令是bzip2，<strong>注意bzip2不能压缩目录，会报错</strong></p><p><img src="https://img-blog.csdnimg.cn/20190604231244456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3J1YnVsYWk=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>解压时如果原文件已存在则会报错，因此最好先将原文件删除</p><p><img src="https://img-blog.csdnimg.cn/20190604231835998.png#pic_center" alt="在这里插入图片描述"></p><h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><p><strong>只是打包并不会压缩文件，.gz，.xz。这些才是压缩</strong><br>.tar格式的打包和解打包都是使用tar命令，区别只是选项不同<br><img src="https://img-blog.csdnimg.cn/20190604232717559.png#pic_center" alt="在这里插入图片描述"><br>打包示例：<br><img src="https://img-blog.csdnimg.cn/20190604232744240.png#pic_center" alt="在这里插入图片描述"><br>打包多个文件：<br><img src="https://img-blog.csdnimg.cn/20190604232921456.png#pic_center" alt="在这里插入图片描述"><br>解打包：<br><img src="https://img-blog.csdnimg.cn/20190604232957741.png#pic_center" alt="在这里插入图片描述"></p><h3 id="tar-gz和-tar-bz2"><a href="#tar-gz和-tar-bz2" class="headerlink" title=".tar.gz和.tar.bz2"></a>.tar.gz和.tar.bz2</h3><p><strong>tar 压缩、解压缩都可以使用多线程</strong></p><p>.tar.gz格式和.tar.bz2格式：使用tar命令后跟选项的方式实现tar命令和gzip或者bzip2命令的组合，实现同时进行打包和压缩，这也是最经常使用的压缩和解压缩方式<br><img src="https://img-blog.csdnimg.cn/20190604233644257.png#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20190604233704887.png#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20190604234051220.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190604234541328.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3J1YnVsYWk=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="tar-xz"><a href="#tar-xz" class="headerlink" title=".tar.xz"></a>.tar.xz</h3><p>默认压缩后的文件后缀为 xz，速度慢一些，但是压缩的会更小。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">//常用参数-z强制执行压缩, 默认不保留源文件。压缩后的文件名为源文件.xz-d强制执行解压缩-l列出压缩文件的信息-k保留源文件不要删除-f强制覆盖输出文件和压缩链接-c写入到标准输出，输入文件不要删除-0<span class="token punctuation">..</span>-9压缩比例，默认为6-e  使用更多的 CPU <span class="token function">time</span> 来进行压缩，提高压缩率。不会影响解压时所需要的内存。-T  指定线程数，默认是 <span class="token number">1</span> ，当设置为 <span class="token number">0</span> 时使用和机器核心一样多的线程。--format<span class="token operator">=</span>  指定压缩输出格式，可以是 raw、xz、lzma-v显示更详细的信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意点： 压缩后的文件时在和源文件同一个目录。当我们压缩的文件为 /home/nginx/logs/error.log-20191126 ，当我们在任意目录执行完 xz /home/nginx/logs/error.log-20191126 后，压缩后的文件路径是 /home/nginx/logs/error.log-20191126.xz.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">//不保留源文件xz   /home/nginx/logs/error.log-20191126//保留源文件xz -k /home/nginx/logs/error.log-20191126//解压缩文件xz -d  /home/nginx/logs/error.log-20191126.xz//指定多线程数来进行压缩xz -T <span class="token number">4</span>  /home/nginx/logs/error.log-20191126<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="查询命令"><a href="#查询命令" class="headerlink" title="查询命令"></a>查询命令</h2><h3 id="查找文件及文件夹"><a href="#查找文件及文件夹" class="headerlink" title="查找文件及文件夹"></a>查找文件及文件夹</h3><pre class="line-numbers language-none"><code class="language-none">find的主要用来查找文件，查找文件的用法我们比较熟悉，也可用它来查找文件夹，用法跟查找文件类似，只要在最后面指明查找的文件类型 -type d,如果不指定type类型，会将包含查找内容的文件和文件夹一起输出。find基本语法如下：find [PATH] [Option] [action]-newer file:file为一个存在的文件，列出比file还要新的文件名find / -mtime 0———0代表当前的时间，即从现在开始到24小时前，有改动过内容的文件都会被列出来find /etc -newer /etc/passwd———寻找/etc下面的文件，如果文件日期比/etc/passwd新就列出find / -name file——/代表全文搜索find /home -user Anmy——查找/home下属于Anmy的文件find / -nouser—— 查找系统中不属于任何人的文件，可以轻易找出那些不太正常的文件find / -name passed—— 查找文件名为passed的文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>若不指定查找类型，使用命令：find / -name AnmyTest 则会将目录和文件一同输出<br><img src="https://img-blog.csdn.net/20180918104346399?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NTY4ODE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70#pic_center" alt="在这里插入图片描述"><br>若指定查找类型，使用命令：find / -name AnmyTest -type d 则只会将目录输出<br><img src="https://img-blog.csdn.net/20180918104448278?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NTY4ODE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70#pic_center" alt="在这里插入图片描述"></p><h2 id="复制-x2F-移动文件、文件改名"><a href="#复制-x2F-移动文件、文件改名" class="headerlink" title="复制/移动文件、文件改名"></a>复制/移动文件、文件改名</h2><p>Linux 将一个文件夹的所有内容拷贝到另外一个文件夹</p><p>cp 命令使用 -r 参数可以将 packageA 下的所有文件拷贝到 packageB 中：</p><pre class="line-numbers language-none"><code class="language-none">cp -r /home/packageA/* /home/cp/packageB/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将一个文件夹复制到另一个文件夹下，以下实例 packageA 文件会拷贝到 packageB 中：</p><pre class="line-numbers language-none"><code class="language-none">cp -r /home/packageA /home/packageB<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行命令之后 packageB 文件夹下就有 packageA 文件夹了。</p><ol><li><code>cp /xx/xx(a)  /xx/xx(a)</code>   :复制   ~~~~  //将a复制到b</li><li><code>mv /xx /xx /xx/xx</code> :剪切</li><li><code>mv 旧文件夹名 新文件夹名</code>   //更改名字</li></ol><h2 id="查看端口"><a href="#查看端口" class="headerlink" title="查看端口"></a>查看端口</h2><h3 id="查看某个服务的状态"><a href="#查看某个服务的状态" class="headerlink" title="查看某个服务的状态"></a>查看某个服务的状态</h3><pre class="line-numbers language-none"><code class="language-none">service ‘servicename’ status//centos7以上用 systemctl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>例子</p><pre class="line-numbers language-none"><code class="language-none">service sshd status //查看sshd服务的状态，可以看到它的进程号，如果不需要可以kill 杀死<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="lsof-i-端口号"><a href="#lsof-i-端口号" class="headerlink" title="lsof -i:端口号"></a>lsof -i:端口号</h3><p><img src="https://img-blog.csdnimg.cn/76c06a2619c04918af8a7331869739fd.png" alt="在这里插入图片描述"><br>可以看到 8000 端口已经被轻 nodejs 服务占用。</p><p><img src="https://img-blog.csdnimg.cn/a9bdaa252c8c4083baf16c1e664416ac.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="netstat-tunlp-grep-端口号"><a href="#netstat-tunlp-grep-端口号" class="headerlink" title="netstat -tunlp | grep 端口号  "></a>netstat -tunlp | grep 端口号  <br></h3><p><strong>用于显示 tcp，udp 的端口和进程等相关情况</strong></p><blockquote><p>-t (tcp) 仅显示tcp相关选项<br>-u (udp)仅显示udp相关选项<br>-n 拒绝显示别名，能显示数字的全部转化为数字<br>-l 仅列出在Listen(监听)的服务状态<br>-p 显示建立相关链接的程序名</p></blockquote><p><img src="https://img-blog.csdnimg.cn/b16427d1c6cc430080b1dae37360358c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="kill-杀死进程"><a href="#kill-杀死进程" class="headerlink" title="kill(杀死进程)"></a>kill(杀死进程)</h3><p><img src="https://img-blog.csdnimg.cn/e228676961554ebaa0725d3cad3b14c6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="telnet-检测端口是否可用"><a href="#telnet-检测端口是否可用" class="headerlink" title="telnet(检测端口是否可用)"></a>telnet(检测端口是否可用)</h3><p>有时我们想知道端口是否开启。</p><pre class="line-numbers language-none"><code class="language-none">tenlet ip 端口<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/46ee47447ace457e95d472fef5ea9ea8.png" alt="在这里插入图片描述">上图表示：80端口开放，8899端口未开放。</p><h2 id="touch命令-创建文件"><a href="#touch命令-创建文件" class="headerlink" title="touch命令(创建文件)"></a>touch命令(创建文件)</h2><p><code>touch</code>命令用于修改文件或者目录的时间属性，包括存取时间和更改时间，若文件不存在，系统会建立一个新的文件。</p><p>创建一个空白文件，如果文件已经存在，它将更改文件的访问时间。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">touch</span> /tmp/file.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建多个文件。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">touch</span> /tmp/file1.txt /tmp/file2.txt /tmp/file3.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改文件的修改时间并查看文件属性。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">touch</span> -m /tmp/file.txt <span class="token operator">&amp;&amp;</span> <span class="token function">stat</span> /tmp/file.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同时修改访问时间和修改时间并设置一个特定的访问与修改时间。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">touch</span> -am -t <span class="token number">202007010000.00</span> /tmp/file.txt <span class="token operator">&amp;&amp;</span> <span class="token function">stat</span> /tmp/file.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="cat命令-显示文件内容"><a href="#cat命令-显示文件内容" class="headerlink" title="cat命令(显示文件内容)"></a>cat命令(显示文件内容)</h2><p><code>cat</code>命令属于文件管理，用于连接文件并打印到标准输出设备上，<code>cat</code>经常用来显示文件的内容，注意，当文件较大时，文本在屏幕上迅速闪过，会出现滚屏现象，此时往往看不清所显示的内容，为了控制滚屏，可以按<code>Ctrl+S</code>键停止滚屏，按<code>Ctrl+Q</code>键可以恢复滚屏，此外可以用<code>more</code>等命令进行读文件并分页显示。</p><p>使用<code>cat</code>命令创建一个文件，输入文件信息后按<code>Ctrl+D</code>输出<code>EOF</code>标识后结束输入。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">&gt;</span> file.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出<code>file.txt</code>文件中的内容。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> file.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同时输出<code>file.txt</code>与<code>file2.txt</code>文件中的内容。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> file.txt file2.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>把<code>file.txt</code>文件的内容加上行号后追加到<code>file2.txt</code>文件中。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> -n file.txt <span class="token operator">&gt;&gt;</span> file2.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>清空<code>file2.txt</code>文件，<code>/dev/null</code>称为空设备，是一个特殊的设备文件，其会丢弃一切写入其中的数据，但报告写入操作成功，读取它则会立即得到一个<code>EOF</code>。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> /dev/null <span class="token operator">&gt;</span> file2.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将<code>file.txt</code>与<code>file2.txt</code>文件内容合并输出到<code>file3.txt</code>。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> file.txt file2.txt <span class="token operator">&gt;</span> file3.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="Centos7特性"><a href="#Centos7特性" class="headerlink" title="Centos7特性"></a>Centos7特性</h2><p>服务相关命令使用systemctl，之前的版本是service</p><blockquote><p>systemctl (stop/restart/start)  (服务)<br>systemctl restart nginx</p></blockquote><h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><h3 id="开启端口（以80为例）"><a href="#开启端口（以80为例）" class="headerlink" title="开启端口（以80为例）"></a>开启端口（以80为例）</h3><blockquote><p>firewall-cmd –zone=public –add-port=80/tcp –permanent<br>//zone add permanent前面是两个横杠</p></blockquote><h3 id="重启防火墙"><a href="#重启防火墙" class="headerlink" title="重启防火墙"></a>重启防火墙</h3><blockquote><p>systemctl restart firewalld.service</p></blockquote><p><strong>不同的系统命令可能不同</strong></p><h2 id="修改主机名"><a href="#修改主机名" class="headerlink" title="修改主机名"></a>修改主机名</h2><h3 id="debian-x2F-ubuntu系列"><a href="#debian-x2F-ubuntu系列" class="headerlink" title="debian/ubuntu系列"></a>debian/ubuntu系列</h3><pre class="line-numbers language-none"><code class="language-none">第一步：vi /etc/hostname写入HOSTNAME=yourhostname保存后执行以下：hostname yourhostname 查看设置后的hostnamehostname<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">第二步：vi /etc/hosts修改成新的主机名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="redhat-x2F-centos系列"><a href="#redhat-x2F-centos系列" class="headerlink" title="redhat/centos系列"></a>redhat/centos系列</h3><pre class="line-numbers language-none"><code class="language-none">vi /etc/sysconfig/network输入以下：HOSTNAME=yourhostname保存后执行以下：hostname yourhostname 查看设置后的hostnamehostname<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="vim相关操作"><a href="#vim相关操作" class="headerlink" title="vim相关操作"></a>vim相关操作</h2><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>1）单行复制</p><p>在命令模式下，将光标移动到将要复制的行处，按“yy”进行复制；</p><p>2）多行复制 在命令模式下，将光标移动到将要复制的首行处，按“nyy”复制n行；其中n为1、2、3……</p><p>【yy】 复制光标所在的那一行<br>【nyy】 复制光标所在的向下n行</p><h3 id="粘贴"><a href="#粘贴" class="headerlink" title="粘贴"></a>粘贴</h3><p>在命令模式下，将光标移动到将要粘贴的行处，按“p”进行粘贴</p><p>【p,P】 p为将已经复制的数据在光标下一行粘贴；P为将已经复制的数据在光标上一行粘贴</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除一行：dd</p><p>删除一个单词/光标之后的单词剩余部分：dw</p><p>删除当前字符：x</p><p>光标之后的该行部分：d$</p><p>文本删除</p><p>dd 删除一行</p><p>d$ 删除以当前字符开始的一行字符</p><p>ndd 删除以当前行开始的n行</p><p>dw 删除以当前字符开始的一个字</p><p>ndw 删除以当前字符开始的n个字</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>【/word】 在文件中查找内容为word的字符串（向下查找）<br>【?word】 在文件中查找内容为word的字符串（向上查找）<br>【[n]】 表示重复查找动作，即查找下一个<br>【[N]】 反向查找下一个</p><h3 id="取消高亮"><a href="#取消高亮" class="headerlink" title="取消高亮"></a>取消高亮</h3><p>搜索后，我们打开别的文件，发现也被高亮了，怎么关闭高亮？</p><p>命令模式下，输入:nohlsearch  也可以:set nohlsearch； 当然，可以简写，noh或者set noh。<br>PS：nohlsearch是（no highlight search缩写）</p><h3 id="设置行号"><a href="#设置行号" class="headerlink" title="设置行号"></a>设置行号</h3><p>如果编辑后，又想显示行号，同样操作按一下esc键，并输入:（冒号），输入set number    ，并按回车键，完成后即显示行号</p><h3 id="跳到指定行"><a href="#跳到指定行" class="headerlink" title="跳到指定行"></a>跳到指定行</h3><p>在知道所查找的内容在文件中的具体位置时可以使用以下命令直接定位：<br>跳到文件指定行：比如跳到66行</p><p>66+G（也就是66+shift+g）<br>当然你可以选择另一种跳转方式：</p><p>命令行输入“ : n ” 然后回车<br>跳到文件第一行：gg （两个小写的G）</p><p>跳到文件最后一行：shift+g （也就是G）</p><h3 id="文件上下翻转"><a href="#文件上下翻转" class="headerlink" title="文件上下翻转"></a>文件上下翻转</h3><p>页翻转可以直接使用PgUp和PgDn</p><p>向前滚动一屏：Ctrl+F</p><p>向后滚动一屏：Ctrl+B</p><p>向前滚动半屏：Ctrl+D（向下）</p><p>向后滚动半屏：Ctrl+U（向上）</p><p>向下滚动一行，保持当前光标不动：Ctrl+E</p><p>向上滚动一行，保持当前光标不动：Ctrl+Y</p><p>当前行滚动：<br>当前行移动到屏幕顶部并滚动：Z+Enter<br>滚动指定行到屏幕顶部： 10Z+Enter（指定第十行）<br>当前行移动到屏幕中央并滚动：Z + .<br>当前行移动到屏幕底部并滚动：Z + -<br>当前屏幕操作：<br>H：大写h，移动到当前屏幕首行；nH移动到首行下的第n行<br>M：大写m，移动到当前屏幕中间行<br>L：大写l，移动到当前屏幕末行；nL移动到末行上面的第n行</p><h3 id="撤销上一步操作"><a href="#撤销上一步操作" class="headerlink" title="撤销上一步操作"></a>撤销上一步操作</h3><p>【u】 撤消上一个操作<br>【[Ctrl] + r】 多次撤消<br>【.】 这是小数点键，重复上一个操作</p><p>  缩进：</p><p>  插入模式下，ctrl+shift+d 减少缩进，ctrl+shift+t 增加缩进</p><h3 id="vim编辑"><a href="#vim编辑" class="headerlink" title="vim编辑"></a>vim编辑</h3><p>1、进入插入模式（６个命令）<br>【i】 从目前光标所在处插入<br>【I】 从目前光标<br>【a】 从当前光标所在的下一个字符处开始插入<br>【A】 从光标所在行的最后一个字符处开始插入<br>【o】 英文小写字母o，在目前光标所在行的下一行处插入新的一行并开始插入<br>【O】 英文大写字母O，在目前光标所在行的上一行处插入新的一行并开始插入</p><p> 2、进入替换模式（2个命令）<br>【r】 只会替换光标所在的那一个字符一次<br>【R】 会一直替换光标所在字符，直到按下[ESC]键为止<br>【[ESC]】 退出编辑模式回到一般模式</p><p>  3、一般模式切换到命令行模式<br>【:w】 保存文件<br>【:w!】 若文件为只读，强制保存文件<br>【:q】 离开vi<br>【:q!】 不保存强制离开vi<br>【:wq】 保存后离开<br>【:wq!】 强制保存后离开<br>【:! command】 暂时离开vi到命令行下执行一个命令后的显示结果<br>【:set nu】 显示行号<br>【:set nonu】 取消显示行号<br>【:w newfile】 另存为<br>【:set fileencoding】 查看当前文件编码格式<br>【:set fileencoding=utf-8】 设置当前文件编码格式为utf-8，也可以设置成其他编码格式<br>【:set fileformat】 查看当前文件的断行格式（dos\windows,unix或macintosh）<br>【:set fileformat=unix】 将当前文件的断行格式设置为unix格式</p><h3 id="多窗口功能"><a href="#多窗口功能" class="headerlink" title="多窗口功能"></a>多窗口功能</h3><p>【:sp [filename]】 打开一个新窗口，显示新文件，若只输入:sp，则两窗口显示同一个文件<br>【[Ctrl] + w + j】 光标移动到下方窗口<br>【[Ctrl] + w + k】 光标移动到上方窗口<br>【[Ctrl] + w + q】 离开当前窗口</p><h3 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h3><p>批量缩进</p><p>在程序代码界面，按esc，退出编辑模式，到命令模式，并在英语输入法下输入“：”</p><p>将所要批量缩进的行号写上，按照格式：“行号1，行号2&gt;”输入命令，如要将2至9行批量缩进一个tab值，则命令为“2,9&gt;”</p><p>输入完毕后，按回车可以执行，就可以看到2至9行全部缩进了一个tab值了，同样的，如果要缩回来一个tab值，则用命令“行号1，行号2&lt;”即可</p><p>可视模式缩进</p><p>方法二是在可视模式下选择要移动的列，操作为，esc从编辑模式退到命令模式，将光标移到需要缩进的行的行首，然后按shift+v，可以看到该行已被选中，且左下角提示为“可视”</p><p>此时，按键盘上的上下左右方向键，如这里按向下的箭头，选中所有需要批量缩进的行</p><p>选择好了之后，按shift+&gt;,是向前缩进一个tab值，按shift+&lt;，则是缩回一个tab值，</p><h2 id="vscode-Remote-SSH"><a href="#vscode-Remote-SSH" class="headerlink" title="vscode Remote SSH"></a>vscode Remote SSH</h2><p>ssh登录命令：</p><pre class="line-numbers language-none"><code class="language-none">ssh username@ip -p port  //密码登录 ，-p port可以不用输入，不输默认是22，因为linux默认也确实是22ssh username@ip -p port –i id_rsa //密钥登录//密钥生成的时候建议命名，不要使用默认的，否则多了容易分不清。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用Remote SSH 插件访问linux，用密钥登录。需要把公钥放在服务器，私钥放在<code>.ssh</code>目录下</p><p><img src="https://img-blog.csdnimg.cn/300494cec18445139acafaa165d99186.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>再配置VScode<br>点击Remote SSH的图标后再点击箭头所指的齿轮<br><img src="https://img-blog.csdnimg.cn/img_convert/a1b38b4440e85b519ea1004ad23ae66f.png#pic_center" alt="在这里插入图片描述"><br>会弹出菜单让你选择需要编辑的配置文件，一般选第一个<br><img src="https://img-blog.csdnimg.cn/img_convert/112e1d35b8003716395a4ecbcf2946ac.png#pic_center" alt="在这里插入图片描述"><br>参数的含义分别为：</p><p>Host 连接的主机的名称，可自定</p><p>Hostname 远程主机的IP地址</p><p>User 用于登录远程主机的用户名</p><p>Port 用于登录远程主机的端口</p><p>IdentityFile 本地的id_rsa的路径</p><p>右键点击Connect<img src="https://img-blog.csdnimg.cn/img_convert/78b37be94d60822412e1640e5f980c6a.png#pic_center" alt="在这里插入图片描述"></p><h2 id="设置-SSH-通过密钥登录"><a href="#设置-SSH-通过密钥登录" class="headerlink" title="设置 SSH 通过密钥登录"></a>设置 SSH 通过密钥登录</h2><h3 id="制作密钥对"><a href="#制作密钥对" class="headerlink" title="制作密钥对"></a>制作密钥对</h3><blockquote><p>我们一般使用 PuTTY 等 SSH 客户端来远程管理 Linux<br>服务器。但是，一般的密码方式登录，容易有密码被暴力破解的问题。所以，一般我们会将 SSH 的端口设置为默认的 22 以外的端口，或者禁用<br>root 账户登录。其实，有一个更好的办法来保证安全，而且让你可以放心地用 root 账户从远程登录——那就是通过密钥方式登录。</p><p>密钥形式登录的原理是：利用密钥生成器制作一对密钥——一只公钥和一只私钥。将公钥添加到服务器的某个账户上，然后在客户端利用私钥即可完成认证并登录。这样一来，没有私钥，任何人都无法通过<br>SSH 暴力破解你的密码来远程登录到系统。此外，如果将公钥复制到其他账户甚至主机，利用私钥也可以登录。</p><p>下面来讲解如何在 Linux 服务器上制作密钥对，将公钥添加给账户，设置 SSH，最后通过客户端登录。</p></blockquote><pre class="line-numbers language-none"><code class="language-none">首先在服务器上制作密钥对。首先用密码登录到你打算使用密钥登录的账户，然后执行以下命令：[root@host ~]$ ssh-keygen  &lt;== 建立密钥对Generating public/private rsa key pair.Enter file in which to save the key (/root/.ssh/id_rsa): &lt;== 按 Enter。如果输入其它字符，比如test，那么生产的私钥是test，公钥是test.pub。说白了就是让你输入密钥文件名，不输入就采用默认的。Created directory '/root/.ssh'.Enter passphrase (empty for no passphrase): &lt;== 输入密钥锁码，后续使用私钥登录的时候会要求输密码，建议输入；或直接按 Enter 留空Enter same passphrase again: &lt;== 再输入一遍密钥锁码Your identification has been saved in /root/.ssh/id_rsa. &lt;== 私钥Your public key has been saved in /root/.ssh/id_rsa.pub. &lt;== 公钥The key fingerprint is:0f:d3:e7:1a:1c:bd:5c:03:f1:19:f1:22:df:9b:cc:08 root@host密钥锁码在使用私钥时必须输入，这样就可以保护私钥不被盗用。当然，也可以留空，实现无密码登录。现在，在 root 用户的家目录中生成了一个 .ssh 的隐藏目录，内含两个密钥文件。id_rsa 为私钥，id_rsa.pub 为公钥。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="在服务器上安装公钥"><a href="#在服务器上安装公钥" class="headerlink" title="在服务器上安装公钥"></a>在服务器上安装公钥</h3><pre class="line-numbers language-none"><code class="language-none">键入以下命令，在服务器上安装公钥：[root@host ~]$ cd .ssh[root@host .ssh]$ cat id_rsa.pub &gt;&gt; authorized_keys如此便完成了公钥的安装。为了确保连接成功，请保证以下文件权限正确：[root@host .ssh]$ chmod 600 authorized_keys[root@host .ssh]$ chmod 700 ~/.ssh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="设置-SSH，打开密钥登录功能"><a href="#设置-SSH，打开密钥登录功能" class="headerlink" title="设置 SSH，打开密钥登录功能"></a>设置 SSH，打开密钥登录功能</h3><pre class="line-numbers language-none"><code class="language-none">编辑 /etc/ssh/sshd_config 文件，进行如下设置：RSAAuthentication yesPubkeyAuthentication yes另外，请留意 root 用户能否通过 SSH 登录：PermitRootLogin yes当你完成全部设置，并以密钥方式登录成功后，再禁用密码登录：PasswordAuthentication no最后，重启 SSH 服务：[root@host .ssh]$ service sshd restart<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="将私钥下载到客户端，然后转换为-PuTTY-能使用的格式"><a href="#将私钥下载到客户端，然后转换为-PuTTY-能使用的格式" class="headerlink" title="将私钥下载到客户端，然后转换为 PuTTY 能使用的格式"></a>将私钥下载到客户端，然后转换为 PuTTY 能使用的格式</h3><p>使用 WinSCP、SFTP 等工具将私钥文件 id_rsa 下载到客户端机器上。然后打开 PuTTYGen，单击 Actions 中的 Load 按钮，载入你刚才下载到的私钥文件。如果你刚才设置了密钥锁码，这时则需要输入。</p><p>载入成功后，PuTTYGen 会显示密钥相关的信息。在 Key comment 中键入对密钥的说明信息，然后单击 Save private key 按钮即可将私钥文件存放为 PuTTY 能使用的格式。</p><p>今后，当你使用 PuTTY 登录时，可以在左侧的 Connection -&gt; SSH -&gt; Auth 中的 Private key file for authentication: 处选择你的私钥文件，然后即可登录了，过程中只需输入密钥锁码即可。</p><h3 id="ssh客户端–xshell登录linux服务器"><a href="#ssh客户端–xshell登录linux服务器" class="headerlink" title="ssh客户端–xshell登录linux服务器"></a>ssh客户端–xshell登录linux服务器</h3><p>将服务器上生成的私钥，id_rsa下载到本地。<br><img src="https://img-blog.csdnimg.cn/8aa2ee35095b499c9cddaf21b877ca01.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/a96ed4029057488f9ee7a6b9acae0fd3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="ssh-keygen命令详解"><a href="#ssh-keygen命令详解" class="headerlink" title="ssh-keygen命令详解"></a>ssh-keygen命令详解</h3><p>这条命令目的是为了本地机器ssh登录远程服务器无需输入密码</p><p><strong>1.ssh-keygen</strong></p><blockquote><p>SSH 为 Secure Shell 的缩写，SSH 为建立在应用层基础上的安全协议。SSH<br>是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。<br><br><br>从客户端来看，SSH提供两种级别的安全验证：<br><br><br>第一种级别（基于口令的安全验证）：只要你知道自己帐号和口令，就可以登录到远程主机。所有传输的数据都会被加密，但是不能保证你正在连接的服务器就是你想连接的服务器。可能会有别的服务器在冒充真正的服务器，也就是受到“中间人”这种方式的攻击。<br>    <br><br>第二种级别（基于密匙的安全验证）ssh-keygen：需要依靠密匙，你必须为自己创建一对密匙，并把公用密匙放在需要访问的服务器上。如果你要连接到SSH服务器上，客户端软件就会向服务器发出请求，请求用你的密匙进行安全验证。服务器收到请求之后，先在该服务器上你的主目录下寻找你的公用密匙，然后把它和你发送过来的公用密匙进行比较。如果两个密匙一致，服务器就用公用密匙加密“质询”（challenge）并把它发送给客户端软件。客户端软件收到“质询”之后就可以用你的私人密匙解密再把它发送给服务器。用这种方式，你必须知道自己密匙的口令。但是，与第一种级别相比，第二种级别不需要在网络上传送口令。第二种级别不仅加密所有传送的数据，而且“中间人”这种攻击方式也是不可能的（因为他没有你的私人密匙）。但是整个登录的过程可能需要10秒。<br><br>ssh-keygen有很多的参数，比如这里的-t -b -C都是他的一些参数</p></blockquote><p><strong>2.-t rsa</strong></p><blockquote><p>-t即指定密钥的类型，密钥的类型有两种，一种是RSA，一种是DSA：<br><br>RSA：RSA加密算法是一种非对称加密算法，是由三个麻省理工的牛人弄出来的，RSA是他们三个人姓的开头首字母组合。<br><br>DSA：Digital Signature Algorithm (DSA)是Schnorr和ElGamal签名算法的变种。<br><br>为了让两个linux机器之间使用ssh不需要用户名和密码。所以采用了数字签名RSA或者DSA来完成这个操作。ssh-keygen默认使用rsa密钥，所以不加-t rsa也行，如果你想生成dsa密钥，就需要加参数-t dsa。</p></blockquote><p><strong>3.-b 4096</strong></p><blockquote><p>-b 指定密钥长度。对于RSA密钥，最小要求768位，默认是2048位。命令中的4096指的是RSA密钥长度为4096位。<br><br>DSA密钥必须恰好是1024位(FIPS 186-2 标准的要求)。</p></blockquote><p><strong>这里额外补充一个知识</strong></p><blockquote><p>命令后面还可以增加-C “注释内容”<br><br>-C表示要提供一个新注释，用于识别这个密钥，可以是任何内容,一个用来识别的key</p></blockquote><p><strong>小结：当你创建ssh的时候：-t 表示密钥的类型 ，-b表示密钥的长度，-C 用于识别这个密钥的注释 ，这个注释你可以输入任何内容</strong></p><h2 id="Centos-启动-x2F-停止-x2F-重启-x2F-开机自启动服务"><a href="#Centos-启动-x2F-停止-x2F-重启-x2F-开机自启动服务" class="headerlink" title="Centos 启动/停止/重启/开机自启动服务"></a>Centos 启动/停止/重启/开机自启动服务</h2><pre class="line-numbers language-none"><code class="language-none">systemctl start sshd //启动ssh服务systemctl stop sshd //停止ssh服务 systemctl restart sshd //重启ssh服务systemctl enable sshd //开机自启动ssh服务docker 和其他服务也适用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="文件内容覆盖-x2F-追加内容（cat命令）"><a href="#文件内容覆盖-x2F-追加内容（cat命令）" class="headerlink" title="文件内容覆盖/追加内容（cat命令）"></a>文件内容覆盖/追加内容（cat命令）</h2><pre class="line-numbers language-none"><code class="language-none">cat  textfile1 &gt; textfile2 //使用“&gt;” 重定向后 文件 中原本的内容会被覆盖cat  textfile1 &gt;&gt; textfile2 //"&gt;&gt;" 代表 将输出的内容已追加的方式重定向到文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>cat 原单词concatenate(用途是连接文件或标准输入并打印。)<br>cat 命令用于将所有文件内容打印到屏幕上。<br>语法:</p><pre class="line-numbers language-none"><code class="language-none">cat 文件<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="linux中的-amp-amp-和-amp-，-和"><a href="#linux中的-amp-amp-和-amp-，-和" class="headerlink" title="linux中的&amp;&amp; 和 &amp;，| 和 ||"></a>linux中的&amp;&amp; 和 &amp;，| 和 ||</h2><blockquote><p>在linux中，&amp;和&amp;&amp;,|和||介绍如下：<br><br><br>&amp;  表示任务在后台执行，如要在后台运行redis-server,则有  redis-server &amp;<br><br><br>&amp;&amp; 表示前一条命令执行成功时，才执行后一条命令 ，如 echo ‘1‘ &amp;&amp; echo ‘2’<br><br><br>| 表示管道，上一条命令的输出，作为下一条命令参数，如 echo ‘yes’ | wc -l<br><br><br>|| 表示上一条命令执行失败后，才执行下一条命令，如 cat nofile || echo “fail”</p></blockquote><p>具体案例：<br>1.rpm -qa | grep mysql</p><blockquote><p>rpm -qa会输出符合筛选条件的软件套件，然后使用grep 筛选与mysql相关的软件套件</p></blockquote><h2 id="rpm命令"><a href="#rpm命令" class="headerlink" title="rpm命令"></a>rpm命令</h2><blockquote><p>Linux rpm 命令用于管理套件。<br><br><br>rpm（英文全拼：redhat package manager） 原本是 Red Hat Linux 发行版专门用来管理 Linux<br>各项套件的程序，由于它遵循 GPL 规则且功能强大方便，因而广受欢迎。逐渐受到其他发行版的采用。RPM 套件管理方式的出现，让 Linux<br>易于安装，升级，间接提升了 Linux 的适用度。<br><br>因为是redhat的，所以这个命令对ubuntu不适用，一般就是centos用，看看是否安装了或有某个软件的套件</p></blockquote><p>实例：</p><p>1.安装软件</p><pre class="line-numbers language-none"><code class="language-none"># rpm -hvi dejagnu-1.4.2-10.noarch.rpm 警告：dejagnu-1.4.2-10.noarch.rpm: V3 DSA 签名：NOKEY, key ID db42a60e准备...           ################################################################ [100%]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>2.显示软件安装信息</p><pre class="line-numbers language-none"><code class="language-none"># rpm -qi dejagnu-1.4.2-10.noarch.rpm【第1次更新 教程、类似命令关联】<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>3.检查是否已经安装过mysql</p><pre class="line-numbers language-none"><code class="language-none">rpm -qa | grep mysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4.删除mysql</p><pre class="line-numbers language-none"><code class="language-none">rpm -e --nodeps mysql-libs-5.1.73-5.el6_6.x86_64  //-e&lt;套件档&gt;或--erase&lt;套件档&gt; 　删除指定的套件。//--nodeps 　不验证套件档的相互关联性。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="查看系统版本"><a href="#查看系统版本" class="headerlink" title="查看系统版本"></a>查看系统版本</h2><h3 id="centos"><a href="#centos" class="headerlink" title="centos"></a>centos</h3><pre class="line-numbers language-none"><code class="language-none">cat /etc/redhat-release<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="更换yum源"><a href="#更换yum源" class="headerlink" title="更换yum源"></a>更换yum源</h2><p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/centos/">更换为清华源</a></p><ol><li>建议先备份 /etc/yum.repos.d/ 内的文件（CentOS 7 及之前为 CentOS-Base.repo，CentOS 8 为CentOS-Linux-*.repo）</li><li>然后编辑 /etc/yum.repos.d/ 中的相应文件，在 mirrorlist= 开头行前面加 # 注释掉；并将 baseurl= 开头行取消注释（如果被注释的话），把该行内的域名（例如mirror.centos.org）替换为 mirrors.tuna.tsinghua.edu.cn。</li><li>以上步骤可以被下方的命令一步完成</li></ol><pre class="line-numbers language-none"><code class="language-none">sudo sed -e 's|^mirrorlist=|#mirrorlist=|g' \        -e 's|^#baseurl=http://mirror.centos.org|baseurl=https://mirrors.tuna.tsinghua.edu.cn|g' \        -i.bak \        /etc/yum.repos.d/CentOS-*.repo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意其中的*通配符，如果只需要替换一些文件中的源，请自行增删。<br><br><br>注意，如果需要启用其中一些 repo，需要将其中的 enabled=0 改为 enabled=1。<br><br></p></blockquote><p>4.最后，更新软件包缓存</p><pre class="line-numbers language-none"><code class="language-none">sudo yum makecache<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="make-install"><a href="#make-install" class="headerlink" title="make install"></a>make install</h2><p>这个命令用与安装，可以携带一个参数。<code>PREFIX=/home/lgf</code><br>表示安装路径，在安装mpi的时候出现过这个参数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;修改权限&quot;&gt;&lt;a href=&quot;#修改权限&quot; class=&quot;headerlink&quot; title=&quot;修改权限&quot;&gt;&lt;/a&gt;修改权限&lt;/h2&gt;&lt;h3 id=&quot;修改文件用户组&quot;&gt;&lt;a href=&quot;#修改文件用户组&quot; class=&quot;headerlink&quot; title=&quot;修改文</summary>
      
    
    
    
    <category term="Linux" scheme="https://gaofeng-lin.github.io/categories/Linux/"/>
    
    
    <category term="运维" scheme="https://gaofeng-lin.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="Linux" scheme="https://gaofeng-lin.github.io/tags/Linux/"/>
    
    <category term="ssh" scheme="https://gaofeng-lin.github.io/tags/ssh/"/>
    
    <category term="Vim" scheme="https://gaofeng-lin.github.io/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>工具快捷键集合</title>
    <link href="https://gaofeng-lin.github.io/posts/300/"/>
    <id>https://gaofeng-lin.github.io/posts/300/</id>
    <published>2022-03-05T16:00:00.000Z</published>
    <updated>2022-07-23T03:14:38.616Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用软件或IDE"><a href="#常用软件或IDE" class="headerlink" title="常用软件或IDE"></a>常用软件或IDE</h2><h3 id="postman"><a href="#postman" class="headerlink" title="postman"></a>postman</h3><h4 id="模拟后端数据"><a href="#模拟后端数据" class="headerlink" title="模拟后端数据"></a>模拟后端数据</h4><ol><li><p>选择 Mock Servers。 创建一个mock。记下这个url<br><img src="https://s2.loli.net/2022/05/22/tLCDn7hRwHeFuMo.png" alt="1.png"></p></li><li><p>在集合里面新建request，<br><img src="https://s2.loli.net/2022/05/22/ZoxS7czAkjv6XFq.png" alt="2.png"></p></li><li><p>再add example<br><img src="https://s2.loli.net/2022/05/22/FgH7stpNEn5zfWI.png" alt="3.png"></p></li><li><p>将之前赋值的url，放上去，可以加一个/test 这个符号。下面可以放数据。浏览器访问这个网址就返回这个数据<br><img src="https://s2.loli.net/2022/05/22/GpIWSXxhPBoydw7.png" alt="4.png"></p></li></ol><h3 id="jupyter"><a href="#jupyter" class="headerlink" title="jupyter"></a>jupyter</h3><h4 id="Cell中-Code-和-Markdown的切换"><a href="#Cell中-Code-和-Markdown的切换" class="headerlink" title="Cell中 Code 和 Markdown的切换"></a>Cell中 Code 和 Markdown的切换</h4><blockquote><p>在一个cell中（在command模式下） 按下 y, 进入Code 按下m, 进入Markdown</p></blockquote><h3 id="VSCode"><a href="#VSCode" class="headerlink" title="VSCode"></a>VSCode</h3><h4 id="快速重启"><a href="#快速重启" class="headerlink" title="快速重启"></a>快速重启</h4><p>打开命令面板：</p><pre class="line-numbers language-none"><code class="language-none">Ctrl+shift+p<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输入：</p><pre class="line-numbers language-none"><code class="language-none">Reload Window<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><ol><li>寻找文件夹中的文本内容 <br></li></ol><blockquote><p> 工具栏，编辑-&gt;查找</p></blockquote><ol start="2"><li>查找文件夹中的文件：</li></ol><blockquote><p>ctrl+p</p></blockquote><h4 id="列选择快捷键"><a href="#列选择快捷键" class="headerlink" title="列选择快捷键"></a>列选择快捷键</h4><p><img src="https://img-blog.csdnimg.cn/99fdf312492c4b4db617bfc61546bffc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h4 id="保证打开新文件不覆盖旧文件"><a href="#保证打开新文件不覆盖旧文件" class="headerlink" title="保证打开新文件不覆盖旧文件"></a>保证打开新文件不覆盖旧文件</h4><p>首先进行搜索，快捷键ctrl+shift+p，在搜索框里输入settings进行搜索，看到User Setting选项，点击打开<br><img src="https://img-blog.csdnimg.cn/img_convert/cc15f737ae23cae6be0cf2e8d521beea.png#pic_center" alt="在这里插入图片描述"></p><p>打开以后看到如下界面，输入enablePreview(选项在Workbench工作台中)搜索，然后将箭头指示的地方的对勾取消即可，再次打开文件就不会覆盖原窗口文件了<br><img src="https://img-blog.csdnimg.cn/img_convert/bad54313e45d6dcd629fe32ca1d217be.png#pic_center" alt="在这里插入图片描述"></p><h3 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h3><h4 id="springboot中的pom-xml没有变蓝色"><a href="#springboot中的pom-xml没有变蓝色" class="headerlink" title="springboot中的pom.xml没有变蓝色"></a>springboot中的pom.xml没有变蓝色</h4><p>新建一个springboot项目，pom.xml没有变蓝色，前面没有蓝色的m。也不能run和debug。<br>解决办法：<br><img src="https://img-blog.csdnimg.cn/20201102125508404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE3NTA1OA==,size_16,color_FFFFFF,t_70#pic_center#pic_center" alt="在这里插入图片描述"></p><h4 id="intellij-idea折叠文件夹展开"><a href="#intellij-idea折叠文件夹展开" class="headerlink" title="intellij idea折叠文件夹展开"></a>intellij idea折叠文件夹展开</h4><p><img src="https://img-blog.csdnimg.cn/2020091812214994.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI2MDEyMw==,size_16,color_FFFFFF,t_70#pic_center#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200918122331608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI2MDEyMw==,size_16,color_FFFFFF,t_70#pic_center#pic_center" alt="在这里插入图片描述"></p><h4 id="intellij-idea快速生成main方法、for循环、out输出"><a href="#intellij-idea快速生成main方法、for循环、out输出" class="headerlink" title="intellij idea快速生成main方法、for循环、out输出"></a>intellij idea快速生成main方法、for循环、out输出</h4><p><img src="https://img-blog.csdnimg.cn/ff17e40bd4ea43169a3ef746cbb36550.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述">2.快速向下复制一行</p><pre class="line-numbers language-none"><code class="language-none">Ctrl+d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="替换指定内容"><a href="#替换指定内容" class="headerlink" title="替换指定内容"></a>替换指定内容</h4><pre class="line-numbers language-none"><code class="language-none">idea替换快捷键有两种：1、“ctrl+r”快捷键，用于当前文件内容替换，指的是在当前打开的文件中替换匹配的字符，只操作一个文件；2、“ctrl+shift+r”快捷键，用于在路径中替换。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="快速添加-getter、setter-方法"><a href="#快速添加-getter、setter-方法" class="headerlink" title="快速添加 getter、setter 方法"></a>快速添加 getter、setter 方法</h4><pre class="line-numbers language-none"><code class="language-none">Alt+Insert<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="代码对比工具"><a href="#代码对比工具" class="headerlink" title="代码对比工具"></a>代码对比工具</h3><h4 id="sublime"><a href="#sublime" class="headerlink" title="sublime"></a>sublime</h4><p><img src="https://img-blog.csdnimg.cn/3d989651b0d14c65a56aea98f857013d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="SSH客户端"><a href="#SSH客户端" class="headerlink" title="SSH客户端"></a>SSH客户端</h3><h4 id="MobaXterm"><a href="#MobaXterm" class="headerlink" title="MobaXterm"></a>MobaXterm</h4><p>选择它的原因是因为可以直接将windonws下的文件拖拽过来，不用通过专门的传输软件（xftp），且不用命令可以看到目录结构<br><img src="https://img-blog.csdnimg.cn/e86c8f5d1e0f4262a73dc4dc958a4cd8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h5 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h5><p>不用设置，MobaXTerm 里面选取内容就已经复制了，如图，白色的内容就已经成功复制了哈哈哈哈，真方便。<br><img src="https://img-blog.csdnimg.cn/ff09c618917940a79a19b1da827f9b59.png" alt="在这里插入图片描述"><br>如果不行，看看是否是这里没有勾上（在 setting 里的 Configuration里面）：<br><img src="https://img-blog.csdnimg.cn/2cbe8be79b734c069e1f1920e9080f12.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h5 id="粘贴"><a href="#粘贴" class="headerlink" title="粘贴"></a>粘贴</h5><p>MobaXterm默认的复制键不是 ctrl+v，当初复制服务器密码的时候老出错，一度怀疑密码错了。<br>这个快捷键可以设置</p><p><img src="https://img-blog.csdnimg.cn/cc6fb7c9545f447b902bc8af4ea94ba3.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/fa9344127b15405cbc97e18c8cb92998.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>好了，现在 复制-粘贴 就是：选中，Ctrl + V</p><h5 id="下载文件到本地"><a href="#下载文件到本地" class="headerlink" title="下载文件到本地"></a>下载文件到本地</h5><p>选中目标文件，右击 ，Download。<br><img src="https://img-blog.csdnimg.cn/95fc0ebdbabd46918713cb124e31ace9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h5 id="修改字体"><a href="#修改字体" class="headerlink" title="修改字体"></a>修改字体</h5><p>修改完成后要重新新建会话才会生效。<br><img src="https://img-blog.csdnimg.cn/217b607feab24741a1d55f3abd15c627.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="Everything"><a href="#Everything" class="headerlink" title="Everything"></a>Everything</h3><h4 id="很多文件搜索不到"><a href="#很多文件搜索不到" class="headerlink" title="很多文件搜索不到"></a>很多文件搜索不到</h4><p>工具-&gt;选项-&gt;左侧找”索引”-&gt;点击里面的”强制重建”</p><p>可解决这个问题，以避免卸载重装</p><h2 id="Microsoft"><a href="#Microsoft" class="headerlink" title="Microsoft"></a>Microsoft</h2><h3 id="visio"><a href="#visio" class="headerlink" title="visio"></a>visio</h3><h4 id="快捷键集合"><a href="#快捷键集合" class="headerlink" title="快捷键集合"></a>快捷键集合</h4><p>箭头反转</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">点箭头，然后Ctrl<span class="token operator">+</span>h即可<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Word"><a href="#Word" class="headerlink" title="Word"></a>Word</h3><h4 id="项目封面问题"><a href="#项目封面问题" class="headerlink" title="项目封面问题"></a>项目封面问题</h4><p><img src="https://img-blog.csdnimg.cn/66dad9a8d7944bb98f925bcff19989fe.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>封面经常会对不齐，可以新建一个<strong>3列表格</strong>。在表格里面调整对齐。</p><h4 id="显示word文档所有格式"><a href="#显示word文档所有格式" class="headerlink" title="显示word文档所有格式"></a>显示word文档所有格式</h4><p>在模板处直接改动，会出现格式突然不一样，即使<strong>只粘贴文字</strong>也不行；如果自己制作格式，有可能不知不觉会影响其它部分的格式。</p><p><strong>还是按照模板的要求制作格式，最后两个相互对比</strong></p><p>先看下效果图<br><img src="https://s2.loli.net/2022/06/10/E2rJMdF9tZhDUQO.png" alt="Snipaste_2022-06-10_09-32-53.png"></p><p>光标指到那一部分就显示那一部分的格式。</p><p>如何制作：</p><ol><li>打开word软件，菜单栏中选择“文件”，在弹出的界面中，选中“选项”。</li><li>在弹出的word选项属性中，点击选择“自定义功能区”。</li><li>在选择命令区中，下拉列表框，选择“不在功能区命令”，按字母排序的顺序，在列中快速找到“显示格式”，</li><li>在右侧的中，选择主选项卡，展开视图—-显示，并选中。</li><li>再点击新建组，输入名字“显示格式”，然后点击添加，将显示格式添加进去，然后确定。</li><li>接着我们就可以在视图中找“显示格式”，点击起用显示格，在右边就可以看到显示格式的属性。</li></ol><h3 id="PPT"><a href="#PPT" class="headerlink" title="PPT"></a>PPT</h3><h3 id="Excel"><a href="#Excel" class="headerlink" title="Excel"></a>Excel</h3><h2 id="不小心关闭了某个页面"><a href="#不小心关闭了某个页面" class="headerlink" title="不小心关闭了某个页面"></a>不小心关闭了某个页面</h2><p>恢复： </p><blockquote><p>ctrl+shift+t</p></blockquote><h2 id="快速开启powershell"><a href="#快速开启powershell" class="headerlink" title="快速开启powershell"></a>快速开启powershell</h2><p>在需要启动powershell的文件里面</p><pre class="line-numbers language-none"><code class="language-none">shift+右键<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/a3d91843cc7245db81df0ba36eeadc29.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;常用软件或IDE&quot;&gt;&lt;a href=&quot;#常用软件或IDE&quot; class=&quot;headerlink&quot; title=&quot;常用软件或IDE&quot;&gt;&lt;/a&gt;常用软件或IDE&lt;/h2&gt;&lt;h3 id=&quot;postman&quot;&gt;&lt;a href=&quot;#postman&quot; class=&quot;header</summary>
      
    
    
    
    <category term="工具" scheme="https://gaofeng-lin.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="office" scheme="https://gaofeng-lin.github.io/tags/office/"/>
    
    <category term="IDE" scheme="https://gaofeng-lin.github.io/tags/IDE/"/>
    
    <category term="编辑器" scheme="https://gaofeng-lin.github.io/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
    <category term="快捷键" scheme="https://gaofeng-lin.github.io/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    
    <category term="vscode" scheme="https://gaofeng-lin.github.io/tags/vscode/"/>
    
    <category term="visio" scheme="https://gaofeng-lin.github.io/tags/visio/"/>
    
    <category term="postman" scheme="https://gaofeng-lin.github.io/tags/postman/"/>
    
  </entry>
  
  <entry>
    <title>计算机基础知识</title>
    <link href="https://gaofeng-lin.github.io/posts/7909/"/>
    <id>https://gaofeng-lin.github.io/posts/7909/</id>
    <published>2022-03-05T16:00:00.000Z</published>
    <updated>2022-07-23T04:33:10.645Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>环境变量是系统变量当中的一种，就是PATH。Windows和DOS操作系统中的path环境变量，当要求系统运行一个程序而没有告诉它程序所在的完整路径时，系统除了在当前目录下面寻找此程序外，还应到path中指定的路径去找。用户通过设置环境变量，来更好的运行进程。</p><p><strong>说白了，把可执行程序的路径放到环境变量里面，那么以后在任意的理解下就可以直接使用这个可执行程序，而不用输入绝对路径，方便。</strong></p><p>1.在Windows中，是由可视化的窗口模式展现出来的<br><img src="https://img-blog.csdnimg.cn/20190906150416564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNDQyNTI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>2.linux中，在 <code>/etc/profile</code>文件中设置<br>可以直接用vim进入文件进行设置，也可以用下面的语句</p><pre class="line-numbers language-none"><code class="language-none">echo "export PATH=${PATH}:/usr/local/go/bon" &gt;&gt; /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最好还是用vim进行修改，用echo输入到为你文件中，会出现冗余，直接添加比较好。用冒号分隔。</p><p>修改好以后，需要更新环境变量</p><pre class="line-numbers language-none"><code class="language-none">source /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="正向代理和反向代理区别"><a href="#正向代理和反向代理区别" class="headerlink" title="正向代理和反向代理区别"></a>正向代理和反向代理区别</h3><p><a href="https://www.cnblogs.com/taostaryu/p/10547132.html">原文链接</a></p><p><strong>一 什么是代理</strong></p><p>代理其实就是一个中介，A和B本来可以直连，中间插入一个C，C就是中介。<br>刚开始的时候，代理多数是帮助内网client访问外网server用的<br>后来出现了反向代理，”反向”这个词在这儿的意思其实是指方向相反，即代理将来自外网客户端的请求转发到内网服务器，从外到内</p><p><strong>二 正向代理</strong></p><p>正向代理类似一个跳板机，代理访问外部资源</p><p>比如我们国内访问谷歌，直接访问访问不到，我们可以通过一个正向代理服务器，请求发到代理服，代理服务器能够访问谷歌，这样由代理去谷歌取到返回数据，再返回给我们，这样我们就能访问谷歌了<br><img src="https://img-blog.csdnimg.cn/cd381c5de09a40f2bfedae52042eb66d.png#pic_center" alt="在这里插入图片描述"></p><p><strong>正向代理的用途：</strong></p><p>　　（1）访问原来无法访问的资源，如google</p><p>（2） 可以做缓存，加速访问资源</p><p>　　（3）对客户端访问授权，上网进行认证</p><p>　　（4）代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息　　</p><p><strong>三 反向代理</strong><br>反向代理（Reverse Proxy）实际运行方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器</p><p><img src="https://img-blog.csdnimg.cn/85649ed3b62c40d38de64b5170114f5b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><p><strong>反向代理的作用：</strong><br>（1）保证内网的安全，阻止web攻击，大型网站，通常将反向代理作为公网访问地址，Web服务器是内网</p><p>（2）负载均衡，通过反向代理服务器来优化网站的负载</p><p><strong>四 总结<br>正向代理即是客户端代理, 代理客户端, 服务端不知道实际发起请求的客户端.<br>反向代理即是服务端代理, 代理服务端, 客户端不知道实际提供服务的服务端</strong></p><p>看图理解一：<br><img src="https://img-blog.csdnimg.cn/img_convert/0c3860e58d2cffd66b808fe07631e358.png#pic_center" alt="在这里插入图片描述"></p><p>看图理解二：<br><img src="https://img-blog.csdnimg.cn/img_convert/7cc6fc2baf342df6a450a54ca2ad6b8a.png#pic_center" alt="在这里插入图片描述"></p><p>正向代理中，proxy和client同属一个LAN，对server透明；<br>反向代理中，proxy和server同属一个LAN，对client透明。<br>实际上proxy在两种代理中做的事都是代为收发请求和响应，不过从结构上来看正好左右互换了下，所以把后出现的那种代理方式叫成了反向代理</p><p><strong>总结：</strong><br>正向代理: 买票的黄牛</p><p>反向代理: 租房的代理</p><h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><p><a href="https://juejin.cn/post/6844904129987526663">原文链接</a><br>“Nginx 是一款轻量级的 HTTP 服务器，采用事件驱动的异步非阻塞处理方式框架，这让其具有极好的 IO 性能，时常用于服务端的<strong>反向代理</strong>和<strong>负载均衡</strong>。”<br>Nginx 是一款 http 服务器 （或叫web服务器）。它是由俄罗斯人 伊戈尔·赛索耶夫为俄罗斯访问量第二的 Rambler.ru 站点开发的，并于2004年首次公开发布的。</p><pre class="line-numbers language-none"><code class="language-none">web服务器：负责处理和响应用户请求，一般也称为http服务器，如 Apache、IIS、Nginx应用服务器：存放和运行系统程序的服务器，负责处理程序中的业务逻辑，如 Tomcat、Weblogic、Jboss（现在大多数应用服务器也包含了web服务器的功能）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Nginx 是什么，总结一下就是这些：</p><ul><li>一种轻量级的web服务器</li><li>设计思想是事件驱动的异步非阻塞处理（类node.js）</li><li>占用内存少、启动速度快、并发能力强</li><li>使用C语言开发</li><li>扩展性好，第三方插件非常多</li><li>在互联网项目中广泛应用</li></ul><h4 id="Nginx配置"><a href="#Nginx配置" class="headerlink" title="Nginx配置"></a>Nginx配置</h4><p><strong>安装/卸载</strong></p><p><em><strong>安装、卸载、启动自查找资料</strong></em></p><p>修改配置<br>经常要用到的几个文件路径：</p><pre class="line-numbers language-none"><code class="language-none">/usr/local/etc/nginx/nginx.conf （nginx配置文件路径）/usr/local/var/www （nginx服务器默认的根目录）/usr/local/Cellar/nginx/1.17.9 （nginx的安装路径）/usr/local/var/log/nginx/error.log (nginx默认的日志路径)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>nginx 默认配置文件简介：</p><pre class="line-numbers language-none"><code class="language-none">## 首尾配置暂时忽略server {          # 当nginx接到请求后，会匹配其配置中的service模块        # 匹配方法就是将请求携带的host和port去跟配置中的server_name和listen相匹配        listen       8080;                server_name  localhost; # 定义当前虚拟主机（站点）匹配请求的主机名        location / {            root   html; # Nginx默认值            # 设定Nginx服务器返回的文档名            index  index.html index.htm; # 先找根目录下的index.html，如果没有再找index.htm        }}## 首尾配置暂时忽略<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>server{ } 其实是包含在 http{ } 内部的。每一个 server{ } 是一个虚拟主机（站点）。<br>上面代码块的意思是：当一个请求叫做localhost:8080请求nginx服务器时，该请求就会被匹配进该代码块的 server{ } 中执行。<br>当然 nginx 的配置非常多，用的时候可以根据文档进行配置。</p><p>英文文档：nginx.org/en/docs/<br>中文文档：<a href="http://www.nginx.cn/doc/">www.nginx.cn/doc/</a></p><p>Nginx有哪些应用？<br>主要有4大应用（动静分离、正向代理、反向代理、负载均衡）</p><h4 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h4><p><img src="https://img-blog.csdnimg.cn/img_convert/e9d551a4479341cca95a54fbe13f3ebe.webp?x-oss-process=image/format,png#pic_center" alt="在这里插入图片描述"></p><p>如上图所示，动静分离其实就是 Nginx 服务器将接收到的请求分为动态请求和静态请求。<br>静态请求直接从 nginx 服务器所设定的根目录路径去取对应的资源，动态请求转发给真实的后台（前面所说的应用服务器，如图中的Tomcat）去处理。<br>这样做不仅能给应用服务器减轻压力，将后台api接口服务化，还能将前后端代码分开并行开发和部署。（传送门：<a href="https://www.php.cn/nginx/424631.html">nginx动静分离的好处</a>）</p><pre class="line-numbers language-none"><code class="language-none">server {          listen       8080;                server_name  localhost;        location / {            root   html; # Nginx默认值            index  index.html index.htm;        }                # 静态化配置，所有静态请求都转发给 nginx 处理，存放目录为 my-project        location ~ .*\.(html|htm|gif|jpg|jpeg|bmp|png|ico|js|css)$ {            root /usr/local/var/www/my-project; # 静态请求所代理到的根目录        }                # 动态请求匹配到path为'node'的就转发到8002端口处理        location /node/ {              proxy_pass http://localhost:8002; # 充当服务代理        }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>访问静态资源 nginx 服务器会返回 my-project 里面的文件，如获取 index.html：<br><img src="https://img-blog.csdnimg.cn/img_convert/34472ca6f5724173402dbaf6d4e6f8b3.webp?x-oss-process=image/format,png#pic_center" alt="在这里插入图片描述"></p><p>访问动态请求 nginx 服务器会将它从8002端口请求到的内容，原封不动的返回回去：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/1f897ee545286a0b59fc4243f6af84b2.webp?x-oss-process=image/format,png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/img_convert/ec6173b234f9c06fe646c9b709abb44e.webp?x-oss-process=image/format,png#pic_center" alt="在这里插入图片描述"></p><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>负载均衡是什么？<br>随着业务的不断增长和用户的不断增多，一台服务已经满足不了系统要求了。这个时候就出现了服务器 集群。<br>在服务器集群中，Nginx 可以将接收到的客户端请求“均匀地”（严格讲并不一定均匀，可以通过设置权重）分配到这个集群中所有的服务器上。这个就叫做负载均衡。<br>负载均衡的示意图如下：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/06ee1083810d768945b4234ba3e18204.webp?x-oss-process=image/format,png#pic_center" alt="在这里插入图片描述"><br>负载均衡的作用</p><p>分摊服务器集群压力<br>保证客户端访问的稳定性</p><p>前面也提到了，负载均衡可以解决分摊服务器集群压力的问题。除此之外，Nginx还带有健康检查（服务器心跳检查）功能，会定期轮询向集群里的所有服务器发送健康检查请求，来检查集群中是否有服务器处于异常状态。<br>一旦发现某台服务器异常，那么在这以后代理进来的客户端请求都不会被发送到该服务器上（直健康检查发现该服务器已恢复正常），从而保证客户端访问的稳定性。</p><p><strong>配置负载均衡</strong></p><p>配置一个简单的负载均衡并不复杂，代码如下：</p><pre class="line-numbers language-none"><code class="language-none">## 负载均衡：设置domainupstream domain {    server localhost:8000;    server localhost:8001;}server {          listen       8080;                server_name  localhost;        location / {            # root   html; # Nginx默认值            # index  index.html index.htm;                        proxy_pass http://domain; # 负载均衡配置，请求会被平均分配到8000和8001端口            proxy_set_header Host $host:$server_port;        }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>8000和8001是我本地用 Node.js 起的两个服务，负载均衡成功后可以看到访问 localhost:8080 有时会访问到8000端口的页面，有时会访问到8001端口的页面。<br><img src="https://img-blog.csdnimg.cn/img_convert/2299761055052914c2f089ab072b37fd.webp?x-oss-process=image/format,png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/img_convert/3440c0ca236da8de821da682fcf157b1.webp?x-oss-process=image/format,png#pic_center" alt="在这里插入图片描述"><br>能看到这个效果，就说明你配置的负载均衡策略生效了。<br>实际项目中的负载均衡远比这个案例要更加复杂，但是万变不离其宗，都是根据这个理想模型衍生出来的。<br>受集群单台服务器内存等资源的限制，负载均衡集群的服务器也不能无限增多。但因其良好的容错机制，负载均衡成为了实现高可用架构中必不可少的一环。</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>不同的语言，不同的开发环境，编译出的东西不一定一样。</p><blockquote><p>比如C/C++，windows下编出的是后缀为exe的可执行程序，双击就能直接运行。但如果在linux下编出的后缀是没有exe的，是一个可运行的二进制文件。原因是因为编译器不同，linux环境的编译器一般是gcc，windows下一般是MinGW等（用VSCODE跑C一般就是这个编译器）</p></blockquote><blockquote><p>不过java比较特殊，因为编出来的class文件是运行在JVM上，在os上一层，与操作系统没有直接联系。所以windows编出来的class，或者打包的tar/war可以直接扔到服务器（linux）上使用（B站黑马程序员的jenkins教程–（SpringCloud微服务部署）就是这样的）</p></blockquote><h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><h3 id="Session-与-Cookie"><a href="#Session-与-Cookie" class="headerlink" title="Session 与 Cookie"></a>Session 与 Cookie</h3><p><a href="https://www.cnblogs.com/l199616j/p/11195667.html">原文链接</a></p><p><strong>会话（Session）跟踪是Web程序中常用的技术，用来跟踪用户的整个会话。常用的会话跟踪技术是Cookie与Session。Cookie通过在客户端记录信息确定用户身份，Session通过在服务器端记录信息确定用户身份。</strong></p><h4 id="Cookie机制"><a href="#Cookie机制" class="headerlink" title="Cookie机制"></a>Cookie机制</h4><p>在程序中，会话跟踪是很重要的事情。理论上，一个用户的所有请求操作都应该属于同一个会话，而另一个用户的所有请求操作则应该属于另一个会话，二者不能混淆。例如，用户A在超市购买的任何商品都应该放在A的购物车内，不论是用户A什么时间购买的，这都是属于同一个会话的，不能放入用户B或用户C的购物车内，这不属于同一个会话。</p><p>　　而Web应用程序是使用HTTP协议传输数据的。HTTP协议是无状态的协议。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话。即用户A购买了一件商品放入购物车内，当再次购买商品时服务器已经无法判断该购买行为是属于用户A的会话还是用户B的会话了。要跟踪该会话，必须引入一种机制。</p><p>　　Cookie就是这样的一种机制。它可以弥补HTTP协议无状态的不足。在Session出现之前，基本上所有的网站都采用Cookie来跟踪会话。</p><h4 id="什么是Cookie"><a href="#什么是Cookie" class="headerlink" title="什么是Cookie"></a>什么是Cookie</h4><p>Cookie意为“甜饼”，是由W3C组织提出，最早由Netscape社区发展的一种机制。目前Cookie已经成为标准，所有的主流浏览器如IE、Netscape、Firefox、Opera等都支持Cookie。</p><p>　　由于HTTP是一种无状态的协议，服务器单从网络连接上无从知道客户身份。怎么办呢？就给客户端们颁发一个通行证吧，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。这就是Cookie的工作原理。</p><p>　　Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/f8e326e26add2797b05d3ed8c17a8f8b.png#pic_center" alt="在这里插入图片描述"></p><h4 id="Session机制"><a href="#Session机制" class="headerlink" title="Session机制"></a>Session机制</h4><p>Session是服务器端使用的一种记录客户端状态的机制，使用上比Cookie简单一些，相应的也增加了服务器的存储压力。</p><h4 id="什么是Session"><a href="#什么是Session" class="headerlink" title="什么是Session"></a>什么是Session</h4><p>Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。</p><p>　　如果说<strong>Cookie机制是通过检查客户身上的“通行证”来确定客户身份的话，那么Session机制就是通过检查服务器上的“客户明细表”来确认客户身份。Session相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。</strong>　　</p><h4 id="cookie和session的区别"><a href="#cookie和session的区别" class="headerlink" title="cookie和session的区别"></a>cookie和session的区别</h4><p><strong>1、cookie数据存放在客户的浏览器上，session数据放在服务器上.</strong></p><p>简单的说，当你登录一个网站的时候，如果web服务器端使用的是session,那么所有的数据都保存在服务器上面，</p><p>客户端每次请求服务器的时候会发送 当前会话的session_id，服务器根据当前session_id判断相应的用户数据标志，以确定用户是否登录，或具有某种权限。</p><p>由于数据是存储在服务器 上面，所以你不能伪造，但是如果你能够获取某个登录用户的session_id，用特殊的浏览器伪造该用户的请求也是能够成功的。</p><p>session_id是服务器和客户端链接时候随机分配的，一般来说是不会有重复，但如果有大量的并发请求，也不是没有重复的可能性。</p><p>Session是由应用服务器维持的一个服务器端的存储空间，用户在连接服务器时，会由服务器生成一个唯一的SessionID,用该SessionID 为标识符来存取服务器端的Session存储空间。而SessionID这一数据则是保存到客户端，用Cookie保存的，用户提交页面时，会将这一 SessionID提交到服务器端，来存取Session数据。这一过程，是不用开发人员干预的。所以一旦客户端禁用Cookie，那么Session也会失效。</p><p><strong>2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。</strong></p><p><strong>3、设置cookie时间可以使cookie过期。但是使用session-destory（），我们将会销毁会话。</strong></p><p><strong>4、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用cookie。</strong></p><p><strong>5、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。(Session对象没有对存储的数据量的限制，其中可以保存更为复杂的数据类型)</strong></p><h2 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h2><h3 id="MD5加密"><a href="#MD5加密" class="headerlink" title="MD5加密"></a>MD5加密</h3><p><strong>为什么要对密码MD5</strong><br>密码明文传递或者直接写到数据库中，都有被偷看的风险</p><p><strong>为什么要对密码做两次MD5</strong><br>现在存在的一些反查md5的软件，做两次为了更好的保密</p><p><strong>整体流程如何实现</strong></p><p><strong>1.整体加密流程</strong></p><pre class="line-numbers language-none"><code class="language-none">MD5(MD5(pass明文+固定salt)+随机salt)第一次固定salt写死在前端第二次加密采用随机的salt 并将每次生成的salt保存在数据库中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>2.登录流程：</strong></p><pre class="line-numbers language-none"><code class="language-none">前端对用户输入的密码进行md5加密（固定的salt）将加密后的密码传递到后端后端使用用户id取出用户信息后端对加密后的密码在进行md5加密（取出盐），然后与数据库中存储的密码进行对比，ok登录成功，否则登录失败<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3.注册流程</strong></p><pre class="line-numbers language-none"><code class="language-none">前端对用户输入的密码进行md5加密（固定的salt）将加密后的密码传递到后端后端随机生成一个salt，使用生成salt对前端传过来的密码进行加密，然后将加密后密码和salt一起保存到db中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="硬件知识"><a href="#硬件知识" class="headerlink" title="硬件知识"></a>硬件知识</h2><h3 id="cpu核心数与线程数"><a href="#cpu核心数与线程数" class="headerlink" title="cpu核心数与线程数"></a>cpu核心数与线程数</h3><p><a href="https://zhuanlan.zhihu.com/p/86855590">原文链接</a></p><p><strong>物理 cpu 数（physical cpu）</strong></p><p>指主板上实际插入的 cpu 硬件个数（socket）。（但是这一概念经常被泛泛的说成是 cpu 数，这很容易导致与 core 数，processor 数等概念混淆，所以此处强调是物理 cpu 数）。</p><p>由于在主板上引入多个 cpu 插槽需要更复杂的硬件支持（连接不同插槽的 cpu 到内存和其他资源），通常只会在服务器上才这样做。在家用电脑中，一般主板上只会有一个 cpu 插槽。</p><p><strong>核心（core）</strong><br>一开始，每个物理 cpu 上只有一个核心（a single core），对操作系统而言，也就是同一时刻只能运行一个进程/线程。 为了提高性能，cpu 厂商开始在单个物理 cpu 上增加核心（实实在在的硬件存在），也就出现了双核心 cpu（dual-core cpu）以及多核心 cpu（multiple cores），这样一个双核心 cpu 就是同一时刻能够运行两个进程/线程的。</p><p><strong>同时多线程技术（simultaneous multithreading）和 超线程技术（hyper–threading/HT）</strong></p><p>本质一样，是为了提高单个 core 同一时刻能够执行的多线程数的技术（充分利用单个 core 的计算能力，尽量让其“一刻也不得闲”）。</p><p>simultaneous multithreading 缩写是 SMT，AMD 和其他 cpu 厂商的称呼。 hyper–threading 是 Intel 的称呼，可以认为 hyper–threading 是 SMT 的一种具体技术实现。</p><p>在类似技术下，产生了如下等价术语：</p><ul><li>虚拟 core： virtual core </li><li>逻辑 processer： logical processor </li><li>线程：thread</li></ul><p>所以可以这样说：某款采用 SMT 技术的 4 核心 AMD cpu 提供了 8 线程同时执行的能力；某款采用 HT 技术的 2 核心 Intel cpu 提供了 4 线程同时执行的能力。</p><p><strong>查看 cpu 信息</strong><br>1.linux系统：</p><pre class="line-numbers language-none"><code class="language-none">//法一lscpu<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">CPU(s):                24On-line CPU(s) list:   0-23Thread(s) per core:    2Core(s) per socket:    6Socket(s):             2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">//法二cat /proc/cpuinfo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">processor   : 0vendor_id   : GenuineIntelcpu family  : 6model       : 60model name  : Intel(R) Core(TM) i7-4700MQ CPU @ 2.40GHzstepping    : 3microcode   : 0x22cpu MHz     : 2393.631cache size  : 6144 KBphysical id : 0siblings    : 8core id     : 0cpu cores   : 4...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中有几个physical id,机器上就安装了几个物理CPU<br>cpu core记录了每个物理CPU,内部有几个物理核<br>siblings 代表每个物理CPU有多少个逻辑核</p><p>2.windows<br><img src="https://img-blog.csdnimg.cn/img_convert/c82b797044d88e27b217706604a29bc7.png#pic_center" alt="在这里插入图片描述"><br><strong>多线程程序线程数</strong><br>为了让我们的多线程程序更好的利用 cpu 资源，我们通常会先了解机器拥有的 processor 数，有若干手段可以获取这一信息：</p><ul><li>cpuinfo 中查看：比如上文中的 cat /proc/cpuinfo | grep “processor” | wc -l</li><li>top 命令查看：cpu0,cpu1,…</li><li>编程：比如在 Java 中用 Runtime.getRuntime().availableProcessors()</li></ul><p>具体在多线程程序中设置线程数多大，对计算密集型的程序有的建议是 processor count + 1，有的建议是 processor count 的 1.5 倍，都是经验值，实测为准。</p><p><strong>小结</strong></p><ul><li>一台完整的计算机可能包含一到多个物理 cpu </li><li>从单个物理 cpu （physical cpu）的角度看，其可能是单核心、双核心甚至多核心的</li><li>从单个核心（core）的角度看，还有 SMT / HT 等技术让每个 core 对计算机操作系统而言用起来像多个物理 core 差不多</li></ul><p>总的逻辑 cpu 数 = 物理 cpu 数 * 每颗物理 cpu 的核心数 * 每个核心的超线程数</p><h3 id="cpu-线程与进程关系"><a href="#cpu-线程与进程关系" class="headerlink" title="cpu 线程与进程关系"></a>cpu 线程与进程关系</h3><p><a href="https://juejin.cn/post/6844904120684396552">原文链接</a></p><h4 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h4><p>两种常见解释</p><p>1.进程和线程都是一个时间段的描述，是CPU工作时间段的描述。<br>2.进程是资源分配的最小单位，线程是CPU调度的最小单位</p><p>解释：</p><ol><li>CPU太快了,只有缓存存储器SRAM才能勉强追上它的速度,因此,一台机器上同时开30个程序,CPU可以把这30个程序变成顺序执行，每个只执行一小段，立马切换到下一个程序，再执行一小段，再切回来，人是无感知的。</li><li><em><strong>一个程序准备开始执行的时候，相关资源必须要准备好，比如RAM地址，显卡，磁盘资源，这些准备好的东西打包一起就叫做上下文环境</strong></em>，然后CPU开始执行程序A，当然只执行了一小段时间，CPU就要切换到别的程序执行B，以保证几个程序的并发，切换之前要把A的上下问状态保存起来，下次切回来的时候接着用。</li><li>因此，进程就是包换上下文切换的程序执行时间总和 = CPU加载上下文+CPU执行+CPU保存上下文</li><li>进程的颗粒度太大，每次都要有上下的调入，保存，调出。线程就是进程的小分支，比如进程A有a，b，c三个线程，那么线程a，b，c就共享了进程A的上下文环境，成为了更细小的执行时间。</li></ol><h4 id="程序中的线程与CPU线程"><a href="#程序中的线程与CPU线程" class="headerlink" title="程序中的线程与CPU线程"></a>程序中的线程与CPU线程</h4><p>看到这里会懵逼，假设一台8CPU32核的服务器，是不是跑的程序最多只能开32个线程呢？</p><p>答案当然是否定的，我们常说的进程中的线程，与CPU的线程，虽然都叫线程，但完全不是一回事。</p><p>程序的线程是软件概念，一个程序可以有多个线程，可以在一个CPU核上轮流<strong>并发</strong>执行。<br>CPU的线程是硬件的概念,就是核。八线程就是能让八个线程<strong>并行</strong>执行。</p><h4 id="linux中的线程"><a href="#linux中的线程" class="headerlink" title="linux中的线程"></a>linux中的线程</h4><p>暂时来不及总结，原文链接有。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="脚手架、框架、架构"><a href="#脚手架、框架、架构" class="headerlink" title="脚手架、框架、架构"></a>脚手架、框架、架构</h3><ul><li>脚手架是指一个项目模板，通过这个模板可以生成固定模板的项目。 </li><li>框架一般是说应用框架，就是别人已经搭建好的成熟组件，我们只需要填代码就行，比如Spring<br>Boot就是一个框架，我们要开发spring应用，就可以在这个框架里面按照它的规范去写代码。</li><li>架构是指解决特定业务场景的技术解决方案。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;环境变量&quot;&gt;&lt;a href=&quot;#环境变量&quot; class=&quot;headerlink&quot; title=&quot;环境变量&quot;&gt;&lt;/a&gt;环境变量&lt;/h2&gt;&lt;p&gt;环境变量是系统变量当中的一种，就是PATH。Windows和DOS操作系统中的path环境变量，当要求系统运行一个程序而没有</summary>
      
    
    
    
    <category term="计算机基础知识" scheme="https://gaofeng-lin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="web" scheme="https://gaofeng-lin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/web/"/>
    
    <category term="操作系统" scheme="https://gaofeng-lin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/web/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="nginx" scheme="https://gaofeng-lin.github.io/tags/nginx/"/>
    
    <category term="编译" scheme="https://gaofeng-lin.github.io/tags/%E7%BC%96%E8%AF%91/"/>
    
    <category term="环境变量" scheme="https://gaofeng-lin.github.io/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    
    <category term="Cookie" scheme="https://gaofeng-lin.github.io/tags/Cookie/"/>
    
    <category term="Session" scheme="https://gaofeng-lin.github.io/tags/Session/"/>
    
    <category term="密码学" scheme="https://gaofeng-lin.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    <category term="硬件知识" scheme="https://gaofeng-lin.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%9F%A5%E8%AF%86/"/>
    
    <category term="线程、进程" scheme="https://gaofeng-lin.github.io/tags/%E7%BA%BF%E7%A8%8B%E3%80%81%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>下载过慢</title>
    <link href="https://gaofeng-lin.github.io/posts/58712/"/>
    <id>https://gaofeng-lin.github.io/posts/58712/</id>
    <published>2022-03-05T16:00:00.000Z</published>
    <updated>2022-07-23T03:15:40.437Z</updated>
    
    <content type="html"><![CDATA[<h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><p>windows不要开全局模式，使用命令行下载会出一些问题。用直连或者PAC模式，用浏览器代理，使用插件switchyomega</p><h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><p>npm在windows下载过慢一般两个办法，换源或设置代理，linux也是这个思路。</p><h3 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h3><p>先打开小飞机。使用命令行</p><pre class="line-numbers language-none"><code class="language-none">npm config set proxy http://server:port<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>server一般就是127.0.0.1<br>port一般是1080</p></blockquote><p>因为是在本地使用的，所以server为localhost</p><p>查看状态：</p><pre class="line-numbers language-none"><code class="language-none">npm config list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除代理：</p><pre class="line-numbers language-none"><code class="language-none">npm config delete proxy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h3><pre class="line-numbers language-none"><code class="language-none">npm config set registry https://registry.npm.taobao.org<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果淘宝源不好，可以尝试清华源</p><h3 id="设置代理和换源的区别"><a href="#设置代理和换源的区别" class="headerlink" title="设置代理和换源的区别"></a>设置代理和换源的区别</h3><blockquote><p>代理的话，是设置代理服务器，代理服务器帮你转发下载请求；镜像源的话，是镜像站点已经提前镜像(下载)了所有的npm包，你是直接从它的服务器上获取到的包</p></blockquote><h2 id="git-linux相同"><a href="#git-linux相同" class="headerlink" title="git(linux相同)"></a>git(linux相同)</h2><h3 id="http-https协议"><a href="#http-https协议" class="headerlink" title="http||https协议"></a>http||https协议</h3><pre class="line-numbers language-none"><code class="language-none">//设置全局代理//httpgit config --global https.proxy http://127.0.0.1:1080//httpsgit config --global https.proxy https://127.0.0.1:1080//使用socks5代理的 例如ss，ssr 1080是windows下ss的默认代理端口,mac下不同，或者有自定义的，根据自己的改git config --global http.proxy socks5://127.0.0.1:1080git config --global https.proxy socks5://127.0.0.1:1080//只对github.com使用代理，其他仓库不走代理git config --global http.https://github.com.proxy socks5://127.0.0.1:1080git config --global https.https://github.com.proxy socks5://127.0.0.1:1080//取消github代理git config --global --unset http.https://github.com.proxygit config --global --unset https.https://github.com.proxy//取消全局代理git config --global --unset http.proxygit config --global --unset https.proxy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ssh协议"><a href="#ssh协议" class="headerlink" title="ssh协议"></a>ssh协议</h3><pre class="line-numbers language-none"><code class="language-none">//对于使用git@协议的，可以配置socks5代理//在~/.ssh/config 文件后面添加几行，没有可以新建一个//socks5Host github.comUser gitProxyCommand connect -S 127.0.0.1:1080 %h %p//http || httpsHost github.comUser gitProxyCommand connect -H 127.0.0.1:1080 %h %p<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Linux下设置代理"><a href="#Linux下设置代理" class="headerlink" title="Linux下设置代理"></a>Linux下设置代理</h2><p>换源的方法和windows一样，设置代理有些不同。</p><h3 id="npm设置代理"><a href="#npm设置代理" class="headerlink" title="npm设置代理"></a>npm设置代理</h3><p>需要下载代理客户端–clash<br>可以去Github直接搜索。<br><img src="https://img-blog.csdnimg.cn/8986f5c2d1ec4c1eb9143f50a80b613e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>这里面有个关键的东西：</p><pre class="line-numbers language-none"><code class="language-none">wget -O config.yml https://dingyue.suying666.info/link/1mrTmf9SI8DxkW5c?clash=1&amp;log-level=info<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>http那一块是由厂家提供的，每个厂家的不一样。</p><p>按照这个教程会生成两个配置文件，.yml和.yaml。把yml里面的内容复制到.yaml，再删除yml。.yaml是新版的。</p><p>如果这个时候输出的信息不大对，或者无法使用clahs dashboard 访问，可能是配置文件有问题。</p><p>使用：</p><pre class="line-numbers language-none"><code class="language-none">./clash -f 配置文件<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到是否有错误。</p><p>关于clash的命令可以使用help来尝试。</p><h3 id="npm-查看一个包的版本信息"><a href="#npm-查看一个包的版本信息" class="headerlink" title="npm 查看一个包的版本信息"></a>npm 查看一个包的版本信息</h3><p><strong>假设现在我们已经成功下载了jquery，过了一段时间，我忘记了下载的jquery的版本信息，这个时候，我们就需要查看本地下载的jquery版本信息，怎么做呢？</strong></p><p>第一种方式：<code>npm ls jquery</code> 即可（查看本地安装的jQuery），下面我的本地没有安装jquery，所以返回empty的结果；</p><p>第二种方式：<code>npm ls jquery -g</code> (查看全局安装的jquery)</p><p>有了npm 我们能够简单的一段代码就下载我们需要的包，但是包是不断更新的，</p><p>所以我们要关注包的版本信息；</p><p><strong>现在，假设我们需要 jquery ，但是jquery现在有很多版本，我们如何通过npm查看呢？<br>要知道，现在的jquery包在npm服务器的上，我们使用下面的命令查看：</strong></p><p>一种方式：使用<code>npm view jquery versions</code>这种方式可以查看npm服务器上所有的jquery版本信息；</p><p>第二种方式：使用<code>npm view jquery version</code>这种方式只能查看jquery的最新的版本是哪一个；</p><p>第三种方式：使用<code>npm info jquery</code>这种方式和第一种类似，也可以查看jquery所有的版本，但是能查出更多的关于jquery的信息；</p><h3 id="npm-安装指定版本的包"><a href="#npm-安装指定版本的包" class="headerlink" title="npm 安装指定版本的包"></a>npm 安装指定版本的包</h3><p><strong>安装指定版本的jquery-1.11.2</strong></p><pre class="line-numbers language-none"><code class="language-none">npm install jquery@1.11.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>安装1.0中的最新版本</strong></p><pre class="line-numbers language-none"><code class="language-none">npm install jquery@1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>安装2.0版本中的最新版本</strong></p><pre class="line-numbers language-none"><code class="language-none">npm install jquery@2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="yarn"><a href="#yarn" class="headerlink" title="yarn"></a>yarn</h2><h3 id="yarn安装"><a href="#yarn安装" class="headerlink" title="yarn安装"></a>yarn安装</h3><pre class="line-numbers language-none"><code class="language-none">npm install -g yarn //成功npm install yarn //失败<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="pip-下载过慢"><a href="#pip-下载过慢" class="headerlink" title="pip 下载过慢"></a>pip 下载过慢</h2><p>由于pip/pypi默认为国外源，下载和安装Python第三方库会非常慢，建议配置国内源：<br>清华源：<br><code>pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</code></p><p>然后 pip install ***</p><h2 id="swithcyomegy-v2ray"><a href="#swithcyomegy-v2ray" class="headerlink" title="swithcyomegy  v2ray"></a>swithcyomegy  v2ray</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>目的：让浏览器既可以访问outside，访问国内网址也不慢</p><p><img src="https://img-blog.csdnimg.cn/cabf32f8757d45c58bc49ac69d58aa74.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>默认注意几个模式的选择，默认情景模式是直接连接</p><p>规则列表如果网上找的更新失败，可以去github上面找。<br><img src="https://img-blog.csdnimg.cn/57d74b4807c14dba9e65f3dd18f989f5.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/94f842edafb9435e844181e2245b3d74.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>随便选一个<br><img src="https://img-blog.csdnimg.cn/5f590171d65c488db4c6deebc57acd0b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>复制输入框里面的网址就好了。<br><img src="https://img-blog.csdnimg.cn/62667fc0fd2d4a25b932d201dcb1f7db.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>第一次更新情景模式要调成直连模式，后面换为PAC模式。然后switchyomegy换位auto switch</p><h3 id="更新订阅遇到问题"><a href="#更新订阅遇到问题" class="headerlink" title="更新订阅遇到问题"></a>更新订阅遇到问题</h3><p>当需要更新订阅时（购买了套餐，或续费）。一定要先关闭http链接，再选择更新订阅。<br><img src="https://img-blog.csdnimg.cn/6cf1b31547d54325bea8cf40ee0129a2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;浏览器&quot;&gt;&lt;a href=&quot;#浏览器&quot; class=&quot;headerlink&quot; title=&quot;浏览器&quot;&gt;&lt;/a&gt;浏览器&lt;/h2&gt;&lt;p&gt;windows不要开全局模式，使用命令行下载会出一些问题。用直连或者PAC模式，用浏览器代理，使用插件switchyomega&lt;/p</summary>
      
    
    
    
    <category term="小知识" scheme="https://gaofeng-lin.github.io/categories/%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="git" scheme="https://gaofeng-lin.github.io/tags/git/"/>
    
    <category term="npm" scheme="https://gaofeng-lin.github.io/tags/npm/"/>
    
    <category term="yarn" scheme="https://gaofeng-lin.github.io/tags/yarn/"/>
    
    <category term="梯子" scheme="https://gaofeng-lin.github.io/tags/%E6%A2%AF%E5%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>Java知识</title>
    <link href="https://gaofeng-lin.github.io/posts/53165/"/>
    <id>https://gaofeng-lin.github.io/posts/53165/</id>
    <published>2022-02-27T16:00:00.000Z</published>
    <updated>2022-07-23T03:15:53.440Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java基础知识"><a href="#Java基础知识" class="headerlink" title="Java基础知识"></a>Java基础知识</h2><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p><a href="https://blog.csdn.net/weixin_43271086/article/details/106023108?spm=1001.2101.3001.6650.1&amp;depth_1-utm_relevant_index=2">原文链接</a></p><p><strong>JAVA反射机制是在运行状态中，对于任意一个实体类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</strong></p><p><strong>反射的好处：<br>      1.可以在程序运行过程中，操作这些对象。<br>      2.可以进行解耦，提高程序的扩展性。</strong></p><p>Java代码在计算机中的三个阶段</p><ul><li>1.Sources源代码阶段：*.java被编译成*.class字节码文件。</li><li>2.Class类对象阶段：*.class字节码文件被类加载器加载进内存，并将其封装成Class对象（用于描述在内存中描述字节码文件），Class对象将原字节码文件中的成员变量，构造函数，方法等的做了封装。</li><li>3.Runtime运行阶段：创建对象的过程new</li></ul><p><img src="https://img-blog.csdnimg.cn/20200509170218257.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI3MTA4Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h4 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h4><p>获取Class对象的三种方式对应着java代码在计算机中的三个阶段：</p><p>1.源代码阶段<br>Class.forName(“全类名”)：将字节码文件加载进内存，返回Class对象。</p><p>2.Class类对象阶段<br>类名.class:通过类名的属性class获取</p><p>3.Runtime运行时阶段<br>对象.getClass():getClass()方法是定义在Object类中的方法。</p><p><strong>结论：同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，无论通过哪一种方式获取的Class对象都是同一个。</strong></p><p>测试代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>company<span class="token punctuation">.</span>reflect</span><span class="token punctuation">;</span> <span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>company<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>domain<span class="token punctuation">.</span></span><span class="token class-name">Person</span><span class="token punctuation">;</span> <span class="token comment">/** * ⊙﹏⊙&amp;&amp;&amp;&amp;&amp;&amp;⊙▽⊙ * * @Auther: pangchenbo * @Date: 2020/5/9 10:37 * @Description: */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReflectDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{</span>        <span class="token comment">//方式一：Class.forName("全类名")</span>        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> aClass <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.company.reflect.domain.Person"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>aClass<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//方式二：类名.class</span>        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">&gt;</span></span> personClass <span class="token operator">=</span> <span class="token class-name">Person</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>personClass<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//方式三：对象.getClass()</span>        <span class="token class-name">Person</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span><span class="token punctuation">&gt;</span></span> aClass1 <span class="token operator">=</span> person<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>aClass1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//比较 == 三个对象</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>aClass <span class="token operator">==</span> aClass1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>personClass<span class="token operator">==</span>aClass1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20200509171516530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI3MTA4Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>两个true表示Class对象是同一个。</p><h4 id="获取Class对象功能"><a href="#获取Class对象功能" class="headerlink" title="获取Class对象功能"></a>获取Class对象功能</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">（<span class="token number">1</span>）获取成员变量们<span class="token class-name">Field</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getFields</span><span class="token punctuation">(</span><span class="token punctuation">)</span> ：获取所有<span class="token keyword">public</span>修饰的成员变量<span class="token class-name">Field</span> <span class="token function">getField</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span>   获取指定名称的 <span class="token keyword">public</span>修饰的成员变量 <span class="token class-name">Field</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getDeclaredFields</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  获取所有的成员变量，不考虑修饰符<span class="token class-name">Field</span> <span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span>（<span class="token number">2</span>）获取构造方法们<span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getConstructors</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">getConstructor</span><span class="token punctuation">(</span>类<span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> parameterTypes<span class="token punctuation">)</span>   <span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getDeclaredConstructors</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span>类<span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> parameterTypes<span class="token punctuation">)</span>  （<span class="token number">3</span>）获取成员方法们<span class="token class-name">Method</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token class-name">Method</span> <span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> 类<span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> parameterTypes<span class="token punctuation">)</span>   <span class="token class-name">Method</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getDeclaredMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token class-name">Method</span> <span class="token function">getDeclaredMethod</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> 类<span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> parameterTypes<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <strong>Field：成员变量</strong><br>先写一个测试类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> a<span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token class-name">String</span> b<span class="token punctuation">;</span>    <span class="token class-name">String</span> c<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> d<span class="token punctuation">;</span>     <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">Integer</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Person{"</span> <span class="token operator">+</span>                <span class="token string">"name='"</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token char">'\''</span> <span class="token operator">+</span>                <span class="token string">", age="</span> <span class="token operator">+</span> age <span class="token operator">+</span>                <span class="token string">", a='"</span> <span class="token operator">+</span> a <span class="token operator">+</span> <span class="token char">'\''</span> <span class="token operator">+</span>                <span class="token string">", b='"</span> <span class="token operator">+</span> b <span class="token operator">+</span> <span class="token char">'\''</span> <span class="token operator">+</span>                <span class="token string">", c='"</span> <span class="token operator">+</span> c <span class="token operator">+</span> <span class="token char">'\''</span> <span class="token operator">+</span>                <span class="token string">", d='"</span> <span class="token operator">+</span> d <span class="token operator">+</span> <span class="token char">'\''</span> <span class="token operator">+</span>                <span class="token char">'}'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//无参方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"eat..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token comment">//重载有参方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token class-name">String</span> food<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"eat..."</span><span class="token operator">+</span>food<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>获取所有的public修饰的成员变量</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//0.获取Person对象</span>        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">&gt;</span></span> personClass <span class="token operator">=</span> <span class="token class-name">Person</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>        <span class="token comment">//1.获取所有public修饰的成员变量</span>        <span class="token class-name">Field</span><span class="token punctuation">[</span><span class="token punctuation">]</span> fields <span class="token operator">=</span> personClass<span class="token punctuation">.</span><span class="token function">getFields</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Field</span> field <span class="token operator">:</span> fields<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>field<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/2020050917325871.png#pic_center" alt="在这里插入图片描述"><br><strong>获取特定的成员变量（public）</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//2.Field getField(String name)</span>        <span class="token class-name">Field</span> a <span class="token operator">=</span> personClass<span class="token punctuation">.</span><span class="token function">getField</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//获取成员变量a 的值 [也只能获取公有的，获取私有的或者不存在的字符会抛出异常]</span>        <span class="token class-name">Person</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Object</span> o <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"o  value: "</span><span class="token operator">+</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//设置属性a的值</span>        a<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span><span class="token string">"haha"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20200509173350461.png#pic_center" alt="在这里插入图片描述"></p><p><strong>获取全部的成员变量</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//Field[] getDeclaredFields()：获取所有的成员变量，不考虑修饰符</span>        <span class="token class-name">Field</span><span class="token punctuation">[</span><span class="token punctuation">]</span> declaredFields <span class="token operator">=</span> personClass<span class="token punctuation">.</span><span class="token function">getDeclaredFields</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Field</span> declaredField <span class="token operator">:</span> declaredFields<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>declaredField<span class="token operator">+</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"=============================="</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20200509173421562.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI3MTA4Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>获取特定的成员变量，在这里如果需要对private进行修改，就必须进行暴力反射，将d.setAccessible(true);设置为true</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"=============================="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Field</span> d <span class="token operator">=</span> personClass<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"d"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        d<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//暴力反射</span>        d<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>        d<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span><span class="token string">"222"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20200509173436455.png#pic_center" alt="在这里插入图片描述"><br> <strong>普通方法获取</strong><br>获取指定名称的方法（不带参数的获取）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">&gt;</span></span> personClass <span class="token operator">=</span> <span class="token class-name">Person</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>        <span class="token comment">//获取指定名称的方法</span>        <span class="token class-name">Method</span> eat <span class="token operator">=</span> personClass<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"eat"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Person</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        eat<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//执行方法</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/202005091739379.png#pic_center" alt="在这里插入图片描述"><br>获取指定名称的方法（带参数获取）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//获取具有参数的构造方法</span>        <span class="token class-name">Method</span> eat1 <span class="token operator">=</span> personClass<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"eat"</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        eat1<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span><span class="token string">"fans"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"==============================="</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20200509173946494.png#pic_center" alt="在这里插入图片描述"><br>获取方法列表</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Method</span><span class="token punctuation">[</span><span class="token punctuation">]</span> methods <span class="token operator">=</span> personClass<span class="token punctuation">.</span><span class="token function">getMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Method</span> method <span class="token operator">:</span> methods<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//继承的方法也会被访问（前提是方法是public）</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20200509174104725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI3MTA4Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>如果设置的方法中含有私有的方法，也可以设置d.setAccessible(true);设置为true，然后就可以访问私有方法。</p><p><strong>构造方法</strong><br>获取无参数的构造器</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">&gt;</span></span> personClass <span class="token operator">=</span> <span class="token class-name">Person</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>        <span class="token comment">//Constructor&lt;?&gt;[] getConstructors()</span>        <span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> constructors <span class="token operator">=</span> personClass<span class="token punctuation">.</span><span class="token function">getConstructors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> constructor <span class="token operator">:</span> constructors<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>constructor<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes)</span>        <span class="token comment">//获取无参</span>        <span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">&gt;</span></span> constructor1 <span class="token operator">=</span> personClass<span class="token punctuation">.</span><span class="token function">getConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>constructor1<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//利用获取的构造器创建对象</span>        <span class="token class-name">Person</span> person <span class="token operator">=</span> constructor1<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20200509174551558.png#pic_center" alt="在这里插入图片描述"><br>获取有参数的构造器</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//获取有参</span>        <span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">&gt;</span></span> constructor <span class="token operator">=</span> personClass<span class="token punctuation">.</span><span class="token function">getConstructor</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>constructor<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Person</span> person1 <span class="token operator">=</span> constructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token string">"PCB"</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>person1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//理应Class类对象进行对象的构建获取</span>        <span class="token class-name">Person</span> person2 <span class="token operator">=</span> personClass<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>person2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//对于getDeclaredConstructor方法和getDeclaredConstructors方法,此外在构造器的对象内也有setAccessible(true);方法，并设置成true就可以操作了。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20200509174655701.png#pic_center" alt="在这里插入图片描述"></p><h4 id="简单框架设计、理解反射好处"><a href="#简单框架设计、理解反射好处" class="headerlink" title="简单框架设计、理解反射好处"></a>简单框架设计、理解反射好处</h4><p>准备测试类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>company<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>domain</span><span class="token punctuation">;</span> <span class="token comment">/** * ⊙﹏⊙&amp;&amp;&amp;&amp;&amp;&amp;⊙▽⊙ * * @Auther: pangchenbo * @Date: 2020/5/9 13:27 * @Description: */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"sleep..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 准备文件properties文件</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">className <span class="token operator">=</span> <span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>company<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>domain<span class="token punctuation">.</span></span>Student</span>methodName <span class="token operator">=</span> sleep<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> <strong>需求</strong><br>写一个”框架”，不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且执行其中任意方法。</p><p><strong>实现</strong><br>（1）配置文件 （2）反射</p><p><strong>步骤</strong></p><p>（1）将需要创建的对象的全类名和需要执行的方法定义在配置文件中 （2）在程序中加载读取配置文件 （3）使用反射技术来加载类文件进内存 （4）创建对象 （5）执行方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>company<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span>反射案例<span class="token punctuation">;</span> <span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">InputStream</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token class-name">Method</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Properties</span><span class="token punctuation">;</span> <span class="token comment">/** * ⊙﹏⊙&amp;&amp;&amp;&amp;&amp;&amp;⊙▽⊙ * * @Auther: pangchenbo * @Date: 2020/5/9 13:30 * @Description: */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReflectTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token comment">/**         * 前提：不能改变该类的任何代码。可以创建任意类的对象，可以执行任意方法         */</span>        <span class="token comment">//1.加载配置文件</span>        <span class="token comment">//1.1创建Properties对象</span>        <span class="token class-name">Properties</span> properties <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//1.2加载配置文件，转换为一个集合</span>        <span class="token comment">//1.2.1获取class目录下的配置文件  使用类加载器</span>        <span class="token class-name">ClassLoader</span> classLoader <span class="token operator">=</span> <span class="token class-name">ReflectTest</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">InputStream</span> resourceAsStream <span class="token operator">=</span> classLoader<span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span><span class="token string">"pro.properties"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        properties<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>resourceAsStream<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2.获取配置文件中定义的数据</span>        <span class="token class-name">String</span> className <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"className"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> methodName <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"methodName"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">//加载类到内存中</span>        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> aClass <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>className<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//创建对象</span>        <span class="token class-name">Object</span> o <span class="token operator">=</span> aClass<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//获取对象方法</span>        <span class="token class-name">Method</span> method <span class="token operator">=</span> aClass<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span>methodName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//执行方法</span>        method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/2020050917521036.png#pic_center" alt="在这里插入图片描述"><br>改变配置文件</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">className <span class="token operator">=</span> <span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>company<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>domain<span class="token punctuation">.</span></span>Person</span>methodName <span class="token operator">=</span> eat<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20200509175301411.png#pic_center" alt="在这里插入图片描述"></p><p>好处<br>我们这样做有什么好处呢，对于框架来说，是人家封装好的，我们拿来直接用就可以了，而不能去修改框架内的代码。但如果我们使用传统的new形式来实例化，那么当类名更改时我们就要修改Java代码，这是很繁琐的。修改Java代码以后我们还要进行测试，重新编译、发布等等一系列的操作。而如果我们仅仅只是修改配置文件，就来的简单的多，配置文件就是一个实实在在的物理文件。</p><h3 id="String类与StringBuilder类的区别"><a href="#String类与StringBuilder类的区别" class="headerlink" title="String类与StringBuilder类的区别"></a>String类与StringBuilder类的区别</h3><p><a href="https://www.cnblogs.com/huameitang/p/10528646.html">原文链接</a></p><h4 id="StringBuilder类介绍"><a href="#StringBuilder类介绍" class="headerlink" title="StringBuilder类介绍"></a>StringBuilder类介绍</h4><p><strong>StringBuilder类是一个可变的字符序列。</strong></p><p>StringBuilder()<br>          构造一个不带任何字符的字符串生成器，其初始容量为 16 个字符。<br>StringBuilder(CharSequence seq)<br>          构造一个字符串生成器，它包含与指定的 CharSequence 相同的字符。<br>StringBuilder(int capacity)<br>          构造一个不带任何字符的字符串生成器，其初始容量由 capacity 参数指定。<br>StringBuilder(String str)<br>          构造一个字符串生成器，并初始化为指定的字符串内容。</p><h4 id="StringBuilder类的几个常用方法"><a href="#StringBuilder类的几个常用方法" class="headerlink" title="StringBuilder类的几个常用方法"></a>StringBuilder类的几个常用方法</h4><pre class="line-numbers language-none"><code class="language-none">append(任意类型)  追加到字符串后面reverse 反转字符串insert(int offset, 任意类型)  在某个index后插入字符串toString()  返回String类的对象<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先看一段String类的字符串拼接的代码。<br><img src="https://img-blog.csdnimg.cn/img_convert/388de719a9f6ee002b965e622dc87c46.png#pic_center" alt="在这里插入图片描述"></p><p>String s = “hello” 会在常量池开辟一个内存空间来存储”hello”。</p><p>s += “world”会先在常量池开辟一个内存空间来存储“world”。然后再开辟一个内存空间来存储”helloworld“。</p><p>这么以来，001与002就成为了垃圾内存空间了。这么简单的一个操作就产生了两个垃圾内存空间，如果有大量的字符串拼接，将会造成极大的浪费。</p><h4 id="StringBuilder的作用"><a href="#StringBuilder的作用" class="headerlink" title="StringBuilder的作用"></a>StringBuilder的作用</h4><p>上面的例子可以知道String类的字符串拼接会产生大量的垃圾内存空间。但是StringBuilder的字符串拼接是直接在原来的内存空间操作的，即直接在hello这个内存空间把hello拼接为helloworld。</p><p>来证明下：</p><pre class="line-numbers language-none"><code class="language-none">public class StringBuilderTest {    public static void main(String[] args){        StringBuilder sb = new StringBuilder();        StringBuilder sb2 = sb.append("hello");        System.out.println(sb);        System.out.println(sb2);        // 引用类型，判断的是他们的内存地址是否一样        System.out.println(sb == sb2);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果是：</p><p>hello<br>hello<br>true</p><h4 id="String类与StringBuilder类的相互转换"><a href="#String类与StringBuilder类的相互转换" class="headerlink" title="String类与StringBuilder类的相互转换"></a>String类与StringBuilder类的相互转换</h4><p><strong>1.String类转换为StringBuilder类</strong></p><pre class="line-numbers language-none"><code class="language-none">public class String12 {    public static void main(String[] args){        String s = "hello";        StringBuilder sb = new StringBuilder(s);        System.out.println(sb);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2.StringBuilder类转换为String类</strong></p><pre class="line-numbers language-none"><code class="language-none">public class String12 {    public static void main(String[] args){        StringBuilder sb = new StringBuilder();        sb.append("abc").append("efg");        String s = sb.toString();        System.out.println(s);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h4 id="接口的作用"><a href="#接口的作用" class="headerlink" title="接口的作用"></a>接口的作用</h4><p>接口的最主要的作用是达到统一访问，就是在创建对象的时候用接口创建，<code>【接口名】 【对象名】=new 【实现接口的类】</code>，这样你像用哪个类的对象就可以new哪个对象了，不需要改原来的代码，就和你的USB接口一样，插什么读什么，就是这个原理。如果我用接口，<code>one.method1();</code> 那样我<code>new a()；</code>就是用<code>a</code>的方法，<code>new b()</code>就是用<code>b</code>的方法</p><p>这个就叫统一访问，因为你实现这个接口的类的方法名相同，但是实现内容不同。</p><h4 id="为什么使用接口"><a href="#为什么使用接口" class="headerlink" title="为什么使用接口"></a>为什么使用接口</h4><p><strong>解耦，可扩展这是设计接口的主要原因之一</strong></p><p>如果你开发业务逻辑代码，当你好不容易的实现了它全部的功能，突然用户需求要改，你在修改你代码的同时，调用你代码的其它人也会改，如果代码关联性强的话，会有很多人都要改动代码，这样一来二去，程序会变得相当的不稳定，而且可能还会出现更多的新Bug,所有人都可能会陷入混乱。</p><p>但如果使用接口的话，在你使用它之前，就要想好它要实现的全部功能（接口实际上就是将功能的封装）。确定下这个接口后，如果用户需求变了，你只要重新写它的实现类，而其它人只会调用你的接口，他不管你是怎么实现的，它只需要接口提供的功能。这样，很可能只需要把你的代码修改就可以了，其他人什么都不用做。</p><p>同时：<br>这样做的话，使得开发人员能够分工明确，只要确定下来接口了，就可以同时进行开发，提高开发效率。另外，使用接口还有使用方便，可读性强，结构清晰等优点。</p><h2 id="Java内存分配"><a href="#Java内存分配" class="headerlink" title="Java内存分配"></a>Java内存分配</h2><p><a href="https://blog.csdn.net/shimiso/article/details/8595564">原文链接</a></p><h3 id="内存表示图"><a href="#内存表示图" class="headerlink" title="内存表示图"></a>内存表示图</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/02e0fdf7e9d05a24f1b00895c1726f04.png#pic_center" alt="在这里插入图片描述"></p><ul><li>l 寄存器：JVM内部虚拟寄存器，存取速度非常快，程序不可控制。</li><li>l 栈：保存局部变量的值，包括：1.用来<strong>保存基本数据类型的值</strong>；2.保存<strong>类的实例</strong>，即堆区对象的引用(指针)。也可以用来保存加载方法时的帧。</li><li>| 堆：用来存放动态产生的数据，比如new出来的对象。注意创建出来的对象只包含属于各自的成员变量，并不包括成员方法。因为同一个类的对象拥有各自的成员变量，存储在各自的堆中，但是他们共享该类的方法，并不是每创建一个对象就把成员方法复制一次。</li><li>l 常量池：JVM为每个已加载的类型维护一个常量池，常量池就是这个类型用到的常量的一个有序集合。包括直接常量(基本类型，String)和对其他类型、方法、字段的符号引用(1)。池中的数据和数组一样通过索引访问。由于常量池包含了一个类型所有的对其他类型、方法、字段的符号引用，所以常量池在Java的动态链接中起了核心作用。常量池存在于堆中。</li><li>l 代码段：用来存放从硬盘上读取的源程序代码。</li><li>l 数据段：用来存放static定义的静态成员。</li></ul><p><img src="https://img-blog.csdn.net/20180607221353561#pic_center" alt="在这里插入图片描述"></p><ul><li><p>Byte Short Double等包装类也是类，属于引用数据类型。</p></li><li><p>除了8个基本数据类型，其余都是引用。包括String(只是编译器对其做了特殊处理（使其和基本数据类型一样）)</p></li></ul><h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><p>1.一个Java文件，只要有main入口方法，我们就认为这是一个Java程序，可以单独编译运行。</p><p>2.无论是普通类型的变量还是引用类型的变量(俗称实例)，都可以作为局部变量，他们都可以出现在栈中。只不过普通类型的变量在栈中直接保存它所对应的值，而引用类型的变量保存的是一个指向堆区的指针，通过这个指针，就可以找到这个实例在堆区对应的对象。因此，普通类型变量只在栈区占用一块内存，而引用类型变量要在栈区和堆区各占一块内存。</p><h3 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/e66638ef11aa279b0b6fd9cd9d559044.png#pic_center" alt="在这里插入图片描述"><br>1.JVM自动寻找main方法，执行第一句代码，创建一个Test类的实例，在栈中分配一块内存，存放一个指向堆区对象的指针110925。</p><p>2.创建一个int型的变量date，由于是基本类型，直接在栈中存放date对应的值9。</p><p>3.创建两个BirthDate类的实例d1、d2，在栈中分别存放了对应的指针指向各自的对象。他们在实例化时调用了有参数的构造方法，因此对象中有自定义初始值。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/705d238bc74dcccff8b69184132da30c.png#pic_center" alt="在这里插入图片描述"><br>调用test对象的change1方法，并且以date为参数。JVM读到这段代码时，检测到i是局部变量，因此会把i放在栈中，并且把date的值赋给i。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/352eb6cc1d1356088c01eff85f968f29.png#pic_center" alt="在这里插入图片描述"></p><p>把1234赋给i。很简单的一步。<br><img src="https://img-blog.csdnimg.cn/img_convert/17a915e436d6d65fac2429a7a11b8866.png#pic_center" alt="在这里插入图片描述"><br>change1方法执行完毕，立即释放局部变量i所占用的栈空间。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/c26f92c212ed59baec902643ce847cdb.png#pic_center" alt="在这里插入图片描述"><br>调用test对象的change2方法，以实例d1为参数。JVM检测到change2方法中的b参数为局部变量，立即加入到栈中，由于是引用类型的变量，所以b中保存的是d1中的指针，此时b和d1指向同一个堆中的对象。在b和d1之间传递是指针。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/de5ed94481f833da822dae4b0ba7829c.png#pic_center" alt="在这里插入图片描述"></p><p>change2方法中又实例化了一个BirthDate对象，并且赋给b。在内部执行过程是：在堆区new了一个对象，并且把该对象的指针保存在栈中的b对应空间，此时实例b不再指向实例d1所指向的对象，但是实例d1所指向的对象并无变化，这样无法对d1造成任何影响。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/a5962e6481115a3701e9af607d7dbef5.png#pic_center" alt="在这里插入图片描述"><br>change2方法执行完毕，立即释放局部引用变量b所占的栈空间，注意只是释放了栈空间，堆空间要等待自动回收。<br><img src="https://img-blog.csdnimg.cn/img_convert/320c1cc9ffa2cb1765dce52ab4e78512.png#pic_center" alt="在这里插入图片描述"></p><p>调用test实例的change3方法，以实例d2为参数。同理，JVM会在栈中为局部引用变量b分配空间，并且把d2中的指针存放在b中，此时d2和b指向同一个对象。再调用实例b的setDay方法，其实就是调用d2指向的对象的setDay方法。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/7085e0609e9a98b2cd813f7321083938.png#pic_center" alt="在这里插入图片描述"><br>调用实例b的setDay方法会影响d2，因为二者指向的是同一个对象。<br><img src="https://img-blog.csdnimg.cn/img_convert/20781e5bcd02ed64fce2f1f20a8f4c8d.png#pic_center" alt="在这里插入图片描述"><br>change3方法执行完毕，立即释放局部引用变量b。</p><p>以上就是Java程序运行时内存分配的大致情况。其实也没什么，掌握了思想就很简单了。无非就是两种类型的变量：基本类型和引用类型。二者作为局部变量，都放在栈中，基本类型直接在栈中保存值，引用类型只保存一个指向堆区的指针，真正的对象在堆里。作为参数时基本类型就直接传值，引用类型传指针。</p><p>小结：</p><p>1.分清什么是实例什么是对象。Class a= new Class();此时a叫实例，而不能说a是对象。实例在栈中，对象在堆中，操作实例实际上是通过实例的指针间接操作对象。多个实例可以指向同一个对象。</p><p>2.栈中的数据和堆中的数据销毁并不是同步的。方法一旦结束，栈中的局部变量立即销毁，但是堆中对象不一定销毁。因为可能有其他变量也指向了这个对象，直到栈中没有变量指向堆中的对象时，它才销毁，而且还不是马上销毁，要等垃圾回收扫描时才可以被销毁。</p><p>3.以上的栈、堆、代码段、数据段等等都是相对于应用程序而言的。每一个应用程序都对应唯一的一个JVM实例，每一个JVM实例都有自己的内存区域，互不影响。并且这些内存区域是所有线程共享的。这里提到的栈和堆都是整体上的概念，这些堆栈还可以细分。</p><p>4.类的成员变量在不同对象中各不相同，都有自己的存储空间(成员变量在堆中的对象中)。而类的方法却是该类的所有对象共享的，只有一套，对象使用方法的时候方法才被压入栈，方法不使用则不占用内存。</p><p>以上分析只涉及了栈和堆，还有一个非常重要的内存区域：常量池，这个地方往往出现一些莫名其妙的问题。常量池是干嘛的上边已经说明了，也没必要理解多么深刻，只要记住它维护了一个已加载类的常量就可以了。接下来结合一些例子说明常量池的特性。</p><h3 id="预备知识2"><a href="#预备知识2" class="headerlink" title="预备知识2"></a>预备知识2</h3><p>基本类型和基本类型的包装类。基本类型有：byte、short、char、int、long、boolean。基本类型的包装类分别是：Byte、Short、Character、Integer、Long、Boolean。注意区分大小写。二者的区别是：基本类型体现在程序中是普通变量，基本类型的包装类是类，体现在程序中是引用变量。因此二者在内存中的存储位置不同：基本类型存储在栈中，而基本类型包装类存储在堆中。上边提到的这些包装类都实现了常量池技术，另外两种浮点数类型的包装类则没有实现。另外，String类型也实现了常量池技术。</p><h3 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">public class <span class="token builtin class-name">test</span> <span class="token punctuation">{</span>    public static void main<span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>            objPoolTest<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     public static void <span class="token function-name function">objPoolTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        int i <span class="token operator">=</span> <span class="token number">40</span><span class="token punctuation">;</span>        int i0 <span class="token operator">=</span> <span class="token number">40</span><span class="token punctuation">;</span>        Integer i1 <span class="token operator">=</span> <span class="token number">40</span><span class="token punctuation">;</span>        Integer i2 <span class="token operator">=</span> <span class="token number">40</span><span class="token punctuation">;</span>        Integer i3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        Integer i4 <span class="token operator">=</span> new Integer<span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Integer i5 <span class="token operator">=</span> new Integer<span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Integer i6 <span class="token operator">=</span> new Integer<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Double <span class="token assign-left variable">d1</span><span class="token operator">=</span><span class="token number">1.0</span><span class="token punctuation">;</span>        Double <span class="token assign-left variable">d2</span><span class="token operator">=</span><span class="token number">1.0</span><span class="token punctuation">;</span>                System.out.println<span class="token punctuation">(</span><span class="token string">"i=i0<span class="token entity" title="\t">\t</span>"</span> + <span class="token punctuation">(</span>i <span class="token operator">==</span> i0<span class="token punctuation">))</span><span class="token punctuation">;</span>        System.out.println<span class="token punctuation">(</span><span class="token string">"i1=i2<span class="token entity" title="\t">\t</span>"</span> + <span class="token punctuation">(</span>i1 <span class="token operator">==</span> i2<span class="token punctuation">))</span><span class="token punctuation">;</span>        System.out.println<span class="token punctuation">(</span><span class="token string">"i1=i2+i3<span class="token entity" title="\t">\t</span>"</span> + <span class="token punctuation">(</span>i1 <span class="token operator">==</span> i2 + i3<span class="token punctuation">))</span><span class="token punctuation">;</span>        System.out.println<span class="token punctuation">(</span><span class="token string">"i4=i5<span class="token entity" title="\t">\t</span>"</span> + <span class="token punctuation">(</span>i4 <span class="token operator">==</span> i5<span class="token punctuation">))</span><span class="token punctuation">;</span>        System.out.println<span class="token punctuation">(</span><span class="token string">"i4=i5+i6<span class="token entity" title="\t">\t</span>"</span> + <span class="token punctuation">(</span>i4 <span class="token operator">==</span> i5 + i6<span class="token punctuation">))</span><span class="token punctuation">;</span>            System.out.println<span class="token punctuation">(</span><span class="token string">"d1=d2<span class="token entity" title="\t">\t</span>"</span> + <span class="token punctuation">(</span>d1<span class="token operator">==</span>d2<span class="token punctuation">))</span><span class="token punctuation">;</span>                 System.out.println<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">i</span><span class="token operator">=</span>i0    <span class="token boolean">true</span><span class="token assign-left variable">i1</span><span class="token operator">=</span>i2   <span class="token boolean">true</span><span class="token assign-left variable">i1</span><span class="token operator">=</span>i2+i3        <span class="token boolean">true</span><span class="token assign-left variable">i4</span><span class="token operator">=</span>i5   <span class="token boolean">false</span><span class="token assign-left variable">i4</span><span class="token operator">=</span>i5+i6        <span class="token boolean">true</span><span class="token assign-left variable">d1</span><span class="token operator">=</span>d2   <span class="token boolean">false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>结果分析：</strong></p><p>1.i和i0均是普通类型(int)的变量，所以数据直接存储在栈中，而栈有一个很重要的特性：栈中的数据可以共享。当我们定义了int i = 40;，再定义int i0 = 40;这时候会自动检查栈中是否有40这个数据，如果有，i0会直接指向i的40，不会再添加一个新的40。</p><p>2.i1和i2均是引用类型，在栈中存储指针，因为Integer是包装类。由于Integer包装类实现了常量池技术，因此i1、i2的40均是从常量池中获取的，均指向同一个地址，因此i1=12。</p><p>3.很明显这是一个加法运算，Java的数学运算都是在栈中进行的，Java会自动对i1、i2进行拆箱操作转化成整型，因此i1在数值上等于i2+i3。</p><p>4.i4和i5均是引用类型，在栈中存储指针，因为Integer是包装类。但是由于他们各自都是new出来的，因此不再从常量池寻找数据，而是从堆中各自new一个对象，然后各自保存指向对象的指针，所以i4和i5不相等，因为他们所存指针不同，所指向对象不同。</p><p>5.这也是一个加法运算，和3同理。</p><p>6.d1和d2均是引用类型，在栈中存储指针，因为Double是包装类。但Double包装类没有实现常量池技术，因此Doubled1=1.0;相当于Double d1=new Double(1.0);，是从堆new一个对象，d2同理。因此d1和d2存放的指针不同，指向的对象不同，所以不相等。</p><p><strong>小结：</strong></p><p>1.以上提到的几种基本类型包装类均实现了常量池技术，但他们维护的常量仅仅是【-128至127】这个范围内的常量，如果常量值超过这个范围，就会从堆中创建对象，不再从常量池中取。比如，把上边例子改成Integer i1 = 400; Integer i2 = 400;，很明显超过了127，无法从常量池获取常量，就要从堆中new新的Integer对象，这时i1和i2就不相等了。</p><p>2.String类型也实现了常量池技术，但是稍微有点不同。String型是先检测常量池中有没有对应字符串，如果有，则取出来；如果没有，则把当前的添加进去。</p><h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><h4 id="三种使用方式"><a href="#三种使用方式" class="headerlink" title="三种使用方式"></a>三种使用方式</h4><p>Java 中每一个对象都可以作为锁，这是 synchronized 实现同步的基础。synchronized 的三种使用方式如下：</p><ul><li>普通同步方法（实例方法）：锁是当前实例对象 ，进入同步代码前要获得当前实例的锁；</li><li>静态同步方法：锁是当前类的 class 对象 ，进入同步代码前要获得当前类对象的锁；</li><li>同步方法块：锁是括号里面的对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</li></ul><ol><li>类锁所有对象一把锁</li><li>对象锁一个对象一把锁，多个对象多把锁</li><li>同步是对同一把锁而言的，同步这个概念是在多个线程争夺同一把锁的时候才能实现的，如果多个线程争夺不同的锁，那多个线程是不能同步的</li><li>两个线程一个取对象锁，一个取类锁，则不能同步</li><li>两个线程一个取a对象锁，一个取b对象锁，则不能同步</li></ol><h4 id="修饰普通方法："><a href="#修饰普通方法：" class="headerlink" title="修饰普通方法："></a>修饰普通方法：</h4><ol><li>修饰普通方法锁的是当前对象实例，但是如果两个线程调用的是同一个对象的普通synchronized方法，持有的是不同的锁，是不会block的。<pre class="line-numbers language-none"><code class="language-none">public static void main(String[] args) throws InterruptedException {        DemoTest test = new DemoTest();        DemoTest testNew = new DemoTest();        Thread t1 = new Thread(test);        Thread t2 = new Thread(testNew);        t1.setName("threadOne");        t2.setName("threadTwo");        t1. start();        t2. start();    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>结果：</p><pre class="line-numbers language-none"><code class="language-none">threadTwo 获取到锁，其他线程在我执行完毕之前，不可进入。threadOne 获取到锁，其他线程在我执行完毕之前，不可进入。threadTwo: 1threadOne: 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果把 <code> DemoTest testNew = new DemoTest();</code>删掉，调用同一个对象，那么就能阻塞</p><h4 id="修饰静态方法"><a href="#修饰静态方法" class="headerlink" title="修饰静态方法"></a>修饰静态方法</h4><p><strong>静态方法不属于任何一个实例对 象，是属于类成员。所以当线程A访问调用一个实例对象的synchronized方法，线程B调用这个实例对象的静态synchronized方法是允许的，即synchronized修饰静态方法，会对该类的所有实例加同步锁</strong></p><pre class="line-numbers language-none"><code class="language-none">public static synchronized void increase() throws InterruptedException {        System.out.println(Thread.currentThread().getName() + "获取到锁，其他线程在我执行完毕之前，不可进入。" );        sleep(1000);        count++;        System.out.println(Thread.currentThread().getName() + ": " + count);    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="修饰代码块"><a href="#修饰代码块" class="headerlink" title="修饰代码块"></a>修饰代码块</h4><p><strong>对于 synchronized 作用于同步代码，锁为任何我们创建的对象，只要是个对象即可，如 new Object () 可以作为锁，new String () 也可作为锁，当然如果传入 this，那么此时代表当前对象。</strong></p><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><ol><li>只能修饰变量，被修饰的变量，线程读写都会直接和主内存打交道，绕过缓存。</li><li>该关键字可以确保当一个线程更新共享变量时，更新操作对其他线程马上可见</li></ol><h4 id="volatile-amp-synchronized"><a href="#volatile-amp-synchronized" class="headerlink" title="volatile &amp; synchronized"></a>volatile &amp; synchronized</h4><ul><li>volatile 本质是在告诉 jvm 当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；</li><li>synchronized 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住；</li><li>volatile 仅能使用在变量级别；synchronized 则可以使用在变量、方法、和类级别的；</li><li>volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性；</li><li>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞；</li></ul><h2 id="辅助知识"><a href="#辅助知识" class="headerlink" title="辅助知识"></a>辅助知识</h2><h3 id="JAVA环境变量JAVA-HOME、CLASSPATH、PATH配置说明"><a href="#JAVA环境变量JAVA-HOME、CLASSPATH、PATH配置说明" class="headerlink" title="JAVA环境变量JAVA_HOME、CLASSPATH、PATH配置说明"></a>JAVA环境变量JAVA_HOME、CLASSPATH、PATH配置说明</h3><p>首先明白一个基础概念：</p><h4 id="current-directory-当前目录-：当前在用的目录就是当前目录"><a href="#current-directory-当前目录-：当前在用的目录就是当前目录" class="headerlink" title="current directory(当前目录)：当前在用的目录就是当前目录"></a>current directory(当前目录)：当前在用的目录就是当前目录</h4><p>比如说当你打开NOTEPAD，并处于运行状态时候，当前目录就是c:/windows；<br>如果你用cmd命令打开命令行窗口，    当前目录就是c:/windows/system32;</p><p>如果你在用java这条指令，当前目录就是JAVA下的BIN目录所在的路径，因为java.exe在bin里面。在java开发配置环境变量时，系统默认(我们对classpath不做任何设定时)的路径也是当前目录。</p><h4 id="JAVA-HOME：它是指jdk的安装目录"><a href="#JAVA-HOME：它是指jdk的安装目录" class="headerlink" title="JAVA_HOME：它是指jdk的安装目录"></a>JAVA_HOME：它是指jdk的安装目录</h4><p>像D:/j2sdk1.4.2_16，在这路径下你应该能够找到bin、lib等目录。<br> 为什么要设置它呢，不设定可不可以呢？不设定也是可以滴，但是最好还是设置一下。<br> 我们现在就当它是一个变量代换 JAVA_HOME = D:/j2sdk1.4.2_16，就是为了避免多写字，它还有一个好处就是当我们需要改变某个jdk时，只需要改JAVA_HOME的值就可以了。等在后面看了Tomcat的启动分析时你就明白了。当在环境变量中引用它的时候要用%JAVA_HOME%来表示      D:/j2sdk1.4.2_16。</p><h4 id="Path：系统变量Path告诉操作系统可执行文件-exe、-bat等-所在的路径"><a href="#Path：系统变量Path告诉操作系统可执行文件-exe、-bat等-所在的路径" class="headerlink" title="Path：系统变量Path告诉操作系统可执行文件(.exe、.bat等)所在的路径"></a>Path：系统变量Path告诉操作系统可执行文件(<em>.exe、</em>.bat等)所在的路径</h4><p> 当OS(操作系统)发现某个*.exe时，windows默认从当前目录开始查找这      个命令，若查不到，OS就会到Path所设定的路径中去寻找该命令，然后执行。</p><p>   系统默认的系统变量为：Path = %SystemRoot%;%SystemRoot%/system32;%SystemRoot%/System32/Wbem<br>   就是说处于上面3个目录(多个变量用分号隔开)中的*.exe文件，可以在任意地方被执行(在 运行 窗口能直接执行的命令，像cmd、notepad等，基本都    在上面的3个目录里面)，所以他们可以直接运行。<br>   上面的%SystemRoot%是什么意思呢？%SystemRoot%就是安装操作系统的时候，系统默认的安装路径<br>    若你的windows xp装在C:/WINDOWS<br>    则你的%systemRoot%路径就是c:/windows<br>     %systemRoot%只是一个符号,代表你的系统安装目录<br>     下面是常见系统默认安装路径:<br>    98—-c:/windows<br>    2000–c:/winnt<br>    2003–c:/windows<br>    xp—-c:/windows<br>     当我们要进行java开发时，OS经常需要用到java.exe、javac.exe等，（若jdk安装在D:/j2sdk1.4.2_16）因此应该将      D:/j2sdk1.4.2_16/bin（%JAVA_HOME%/bin）加入到系统的path中去。<br>    注意：如果你加入的位置不是在最后，那还需要在bin后面加上英文状态下的分号：%JAVA_HOME%/bin；多个变量之间要用分号隔开，如果它前面    没有，你就加一个。<br>   明确一下：%JAVA_HOME%/jre/bin 这个路径是不需要加入Path的。参考：<a href="http://java.sun.com/javase/6/docs/technotes/tools/windows/jdkfiles.html">http://java.sun.com/javase/6/docs/technotes/tools/windows/jdkfiles.html</a></p><h4 id="CLASSPATH：告诉java虚拟机-jvm-要使用或执行的-class文件放在什么地方"><a href="#CLASSPATH：告诉java虚拟机-jvm-要使用或执行的-class文件放在什么地方" class="headerlink" title="CLASSPATH：告诉java虚拟机(jvm)要使用或执行的*.class文件放在什么地方"></a>CLASSPATH：告诉java虚拟机(jvm)要使用或执行的*.class文件放在什么地方</h4><p>CLASSPATH是专门针对java的，它相当于windows的path；path是针对整个windows的。<br>所谓的JVM就好像是在微软OS上面再激活另外一个OS，对JVM来说CLASSPATH就好像是对微软OS来说的PATH，所以要用jvm开运行程序就需要设定classpath，然而jvm像windows一样它也有个默认的查找class文件的路径，对刚开始学习java的我们来说，默认的已经够我们用了，那就是当前路径，因此不设置classpath也可以。</p><p>在windows中 classpath 大小写没有关系，其他的环境变量名称也一样。<br> 当我们不设定classpath时，系统默认的classpath是当前目录，如果你个人想设置classpath的话，那么务必在classpath中加入”.”，这个英文状态下的点就表示当前目录。至于classpath中要不要加入其他的路径(包括文件目录、包的根目录等)，这要看开发的需要，一般我们初学者是用不到的。</p><p>JAVA_HOME = D:/j2sdk1.4.2_16<br>Path 环境变量中在最前面加入(若系统原来没有就新建) %JAVA_HOME%/bin; （加在最前面可以提高查找速度）<br>CLASSPATH = . 这一步可以不用设。</p><h3 id="JDK-和-JRE-的区别"><a href="#JDK-和-JRE-的区别" class="headerlink" title="JDK 和 JRE 的区别"></a>JDK 和 JRE 的区别</h3><p><img src="https://img-blog.csdnimg.cn/7b9ff76b66e949fc9a04515e960b9de4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_18,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>从图中可以看出JDK包含JRE包含JVM…</p><p>JDK：java development kit （java开发工具）</p><p>JRE：java runtime environment （java运行时环境）</p><p>引申出JVM</p><p>JVM：java virtual machine （java虚拟机）</p><p>一、JDK——开发环境（核心）</p><p>java development kit 的缩写，意思是JAVA开发工具，我们写文档做PPT需要office 办公软件，开发当然需要开发工具了，说到开发工具大家肯定会想到Eclipse，但是如果直接安装Eclipse你会发现它是运行不起来 是会报错的，只有安装了JDK，配置好了环境变量和path才可以运行成功。这点相信很多人都深有体会。</p><p>JDK主要包含三部分，</p><p>第一部分就是Java运行时环境，JVM。</p><p>第二部分就是Java的基础类库，这个类库的数量还是非常可观的。</p><p>第三部分就是Java的开发工具，它们都是辅助你更好的使用Java的利器。</p><p>详寻《玩好JDK，面试不用愁》</p><p>二、JRE——运行环境</p><p>java runtime environment （java运行时环境）的缩写</p><p>1,1_JDK中的JRE</p><p>如下图：jdk中包含的jre，在jre的bin目录里有个jvm.dll，既然JRE是运行时环境，那么运行在哪？肯定是JVM虚拟机上了。另，jre的lib目录中放的是一些JAVA类库的class文件，已经打包成jar文件。</p><p>1.2_第二个JRE（独立出来的运行时环境）</p><p>如下图，不管是JDK中的JRE还是JRE既然是运行时环境必须有JVM。所以JVM也是有两个的。</p><p>三、JVM——转换环境</p><p>java virtual machine （java虚拟机）的缩写。</p><p>大家一提到JAVA的优点就会想到：一次编译，随处运行，说白了就是跨平台性好，这点JVM功不可没。</p><p>JAVA的程序也就是我们编译的代码都会编译为Class文件，Class文件就是在JVM上运行的文件，</p><p>只有JVM还不能成class的执行，因为在解释class的时候JVM需要调用解释所需要的类库lib，而jre包含lib类库。</p><p>JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。</p><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="Math方法"><a href="#Math方法" class="headerlink" title="Math方法"></a>Math方法</h3><p>1： java取整</p><pre><code> a：floor向下取整   用法：Math.floor(num)   Math.floor(1.9)//1                      Math.floor(-1.9)//-2b:  round四舍五入  用法：Math.round(num)实际上是等价于Math.floor(num+0.5)  Math.round(1.5)//2                     Math.round(1.4)//1  Math.round(-1.4)//-1                  Math.round(-1.5)//-1               Math.round(-1.6)//-2c:  ceil取不小于num的最小整数   用法: Math.ceil(num)   Math.ceil(1.4)//2      Math.ceil(1.5)//2             Math.ceil(1.6)//2   Math.ceil(-1.4)//-1   Math.ceil(-1.5)//-1           Math.ceil(-1.6)//-1d:  神级方法直接加(int)强制转换，直接去掉小数点位，没有任何向上向下，需要时最好用的方法</code></pre><p>2： java求绝对值</p><pre><code> Math.abs(num) Math.abs(-30.5)//30.5</code></pre><p>3:   java随机数</p><pre><code> Math.random()随机去0~1的数 (int)(100*Math.random())这样就可以取0~100随机整数</code></pre><p>4： java幂函数</p><pre><code> Math.pow(a,b)a的b次方 Math.pow(x,2)就是平方 Math.pow(x,3)就是立方</code></pre><p>5： java开根号</p><pre><code> Math.sqrt(num)num的平方根</code></pre><h3 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h3><p>使用步骤：</p><p>1.导入包</p><p>import java.util.Random;</p><p>2.创建对象</p><p>Random r = new Random();</p><p>3.产生随机数</p><p>int num = r.nextInt(10);<br>代码解析：10代表的是一个范围，如果括号写10，产生的随机数就是0-9，括号写20，参数的随机数则是0-19</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Random</span><span class="token punctuation">;</span> <span class="token comment">//1. 导入包</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo1Random</span> <span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">// 2. 创建对象</span><span class="token class-name">Random</span> r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">// 3. 获取随机数</span><span class="token keyword">int</span> num <span class="token operator">=</span> r<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">// 1-10</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><h4 id="substring-返回字符串字串"><a href="#substring-返回字符串字串" class="headerlink" title="substring() 返回字符串字串"></a>substring() 返回字符串字串</h4><pre class="line-numbers language-none"><code class="language-none">public String substring(int beginIndex)或public String substring(int beginIndex, int endIndex)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参数<br>beginIndex – 起始索引（包括）, 索引从 0 开始。</p><p>endIndex – 结束索引（不包括）。</p><pre class="line-numbers language-none"><code class="language-none">public class RunoobTest {    public static void main(String args[]) {        String Str = new String("This is text");         System.out.print("返回值 :" );        System.out.println(Str.substring(4) );         System.out.print("返回值 :" );        System.out.println(Str.substring(4, 10) );    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：<br>返回值 : is text<br>返回值 : is te</p><h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><h4 id="字符串某个位置插入一个字符"><a href="#字符串某个位置插入一个字符" class="headerlink" title="字符串某个位置插入一个字符"></a>字符串某个位置插入一个字符</h4><pre class="line-numbers language-none"><code class="language-none">StringBuffer sb = new StringBuffer("原字符串"); sb.insert(index,"需要插入的字符串");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h4><pre class="line-numbers language-none"><code class="language-none">s.length()//数组长度是 num.length<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="字符串修改"><a href="#字符串修改" class="headerlink" title="字符串修改"></a>字符串修改</h4><p>当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。</p><p>和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。</p><p><img src="https://img-blog.csdnimg.cn/cdb4cc2d3e374b40bdb8a0a5897606c1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>在使用 StringBuffer 类时，每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，所以如果需要对字符串进行修改推荐使用 StringBuffer。</p><p>StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。</p><p><strong>由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。</strong></p><pre class="line-numbers language-none"><code class="language-none">public class RunoobTest{    public static void main(String args[]){        StringBuilder sb = new StringBuilder(10);        //也可以直接 new StringBuilder()        sb.append("Runoob..");        System.out.println(sb);          sb.append("!");        System.out.println(sb);         sb.insert(8, "Java");        System.out.println(sb);         sb.delete(5,8);        System.out.println(sb);      }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="返回指定索引处的字符"><a href="#返回指定索引处的字符" class="headerlink" title="返回指定索引处的字符"></a>返回指定索引处的字符</h4><p>实例：</p><pre class="line-numbers language-none"><code class="language-none">public class Test {    public static void main(String args[]) {        String s = "www.runoob.com";        char result = s.charAt(6);        System.out.println(result);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="删除字符串首尾空白符"><a href="#删除字符串首尾空白符" class="headerlink" title="删除字符串首尾空白符"></a>删除字符串首尾空白符</h4><pre class="line-numbers language-none"><code class="language-none">str=str.trim();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="返回字符串的子字符串"><a href="#返回字符串的子字符串" class="headerlink" title="返回字符串的子字符串"></a>返回字符串的子字符串</h4><pre class="line-numbers language-none"><code class="language-none">public String substring(int beginIndex, int endIndex)beginIndex -- 起始索引（包括）, 索引从 0 开始。endIndex -- 结束索引（不包括）。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">public class RunoobTest {    public static void main(String args[]) {        String Str = new String("This is text");         System.out.print("返回值 :" );        System.out.println(Str.substring(4) );         System.out.print("返回值 :" );        System.out.println(Str.substring(4, 10) );    }}//结果返回值 : is text返回值 : is te<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="字符串反转"><a href="#字符串反转" class="headerlink" title="字符串反转"></a>字符串反转</h4><p>使用<code>StringBuilder</code></p><pre class="line-numbers language-none"><code class="language-none">Scanner in = new Scanner(System.in);        String str = in.nextLine();        StringBuffer strb = new StringBuffer(str);        strb.reverse();        System.out.println(strb.toString());  //要求返回String类可用这句        System.out.println(strb);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="数组长度"><a href="#数组长度" class="headerlink" title="数组长度"></a>数组长度</h4><pre class="line-numbers language-none"><code class="language-none">num.length//字符串长度是 s.length()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><pre class="line-numbers language-none"><code class="language-none">//声明int类型的二维数组int[][] intArray;//创建一个三行四列的int类型数组intArray = new int[3][4];//声明数组的同时进行创建char[][] ch = new char[3][5];/二维数组的初始化int[][] num = {{1,2,3},{4,5,6},{9,8,7}};//获取行和列num.length //行数num[0].length //列数//循环输出二维数组的内容for(int i=0;i&lt;num1.length;i++){    for(int j=0;j&lt;num1[i].length;j++){         System.out.print(num1[i][j]+" ");       }    System.out.println(); }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h4><pre class="line-numbers language-none"><code class="language-none">Arrays.sort(arr);Arrays.sort()重载了四类方法sort(T[] a)：对指定T型数组按数字升序排序。sort(T[] a,int formIndex, int toIndex)：对指定T型数组的指定范围按数字升序排序。sort(T[] a, Comparator&lt;? supre T&gt; c): 根据指定比较器产生的顺序对指定对象数组进行排序。sort(T[] a, int formIndex, int toIndex, Comparator&lt;? supre T&gt; c): 根据指定比较器产生的顺序对指定对象数组的指定对象数组进行排序。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="数组拷贝"><a href="#数组拷贝" class="headerlink" title="数组拷贝"></a>数组拷贝</h4><p><strong>Arrays.copyOf方法</strong></p><pre class="line-numbers language-none"><code class="language-none">Arrays.copyOf(array, to_index);// to_index是1，就是拷贝从头往后数的1个数，5就是从头往后数的5个数Arrays.fill(array, from_index, to_index);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>第一个方法其实就是返回一个数组，而这个数组就等于数组array的前to_index个数，也就是array[0] ~ array[to_index - 1]。</p><p>而第二种方法也只是加了一个初始的位置，即返回一个数组等于array[from_index] ~ array[to_index - 1]。</p><p>这里要注意一下，不管是上面哪种使用方法，都务必记住时不包含array[to_index]这个数。</p><p><strong>还有一点差点忘了说了，这里得提前导入Arrays类，即在开头写如下代码<br>import java.utl.Arrays;</strong></p><h3 id="构造函数（方法）"><a href="#构造函数（方法）" class="headerlink" title="构造函数（方法）"></a>构造函数（方法）</h3><p><strong>作用：一般用来初始化成员属性和成员方法的，即new对象产生后，就调用了对象了属性和方法。</strong></p><p>一个对象建立，构造函数只运行一次。</p><p> 而一般函数可以被该对象调用多次。</p><p>特点：<br>1、函数名与类名相同</p><p>2、不用定义返回值类型。（不同于void类型返回值，void是没有具体返回值类型；构造函数是连类型都没有）</p><p>3、不可以写return语句。（返回值类型都没有，也就不需要return语句了）</p><p> 注：一般函数不能调用构造函数，只有构造函数才能调用构造函数。</p><p>示例：<br>1、无参构造函数中只定义了一个方法。new对象时，就调用与之对应的构造函数，执行这个方法。不必写“.方法名”。 </p><pre class="line-numbers language-none"><code class="language-none">package javastudy;public class ConfunDemo {    public static void main(String[] args) {        Confun c1=new Confun();            //输出Hello World。new对象一建立，就会调用对应的构造函数Confun()，并执行其中的println语句。    }}class Confun{            Confun(){        //定义构造函数，输出Hello World        System.out.println("Hellow World");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2、有参构造函数，在new对象时，将实参值传给private变量，相当于完成setter功能。</p><pre class="line-numbers language-none"><code class="language-none">package javastudy;public class ConfunDemo3 {    public static void main(String[] args){        Person z=new Person("zhangsan",3);        //实例化对象时，new Person()里直接调用Person构造函数并转转实参，相当于setter功能        z.show();    }}class Person{    private String name;    private int age;    public Person(String n,int m){                //有参数构造函数，实现给private成员变量传参数值的功能        name=n;        age=m;            }    //getter                                      //实例化对象时，完成了sett功能后，需要getter，获取实参值。    public String getName(){        return name;    }    public int getAget(){        return age;    }    public void show(){                           //获取private值后，并打印输出        System.out.println(name+"\n"+age);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码，我们也可以将show()方法中的输出语句直接放在构造函数中，new对象时，即可直接输出值，如下</p><pre class="line-numbers language-none"><code class="language-none">package javastudy;public class ConfunDemo3 {    public static void main(String[] args){        Person z=new Person("zhangsan",3);        //实例化对象时，new Person()里直接调用Person构造函数并转转实参，同时执行输出语句    }}class Person{    private String name;    private int age;    public Person(String n,int m){                //有参数构造函数，实现给private成员变量传参数值的功能，同时直接输出值        name=n;        age=m;        System.out.println(name+"\n"+age);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个对象建立后，构造函数只运行一次。</p><p>如果想给对象的值再赋新的值，就要使用set和get方法，此时是当做一般函数使用</p><p>如下：</p><pre class="line-numbers language-none"><code class="language-none">package javastudy;public class ConfunDemo4 {    public static void main(String[] args) {            PersonDemo s=new PersonDemo("李三",33);        //new对象时，即调用对应的构造函数，并传值。同时，不能new同一个对象多次，否则会报错。            s.setName("李五");                            //对象建立后，想变更值时，就要用set/get方法，重新设置新的值            s.setName("阿尔法狗");                        //并可调用对象多次。            s.print();    }}class PersonDemo{    private String name;    private int age;    PersonDemo(String n,int m){                //建立有参构造函数，用于给两个private变量name、age赋值，同时输出值        name=n;        age=m;        System.out.println("姓名："+name+"年龄："+age);    }    public void setName(String x){            //set方法，用于再次给name赋值        name=x;            }    public String getName(){                //get方法，用于获取name的赋值        return name;    }    public void print(){        System.out.println(name);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="字母大小写判断与转换"><a href="#字母大小写判断与转换" class="headerlink" title="字母大小写判断与转换"></a>字母大小写判断与转换</h3><pre class="line-numbers language-none"><code class="language-none">Character.isDigit(char c)　//判断字符c是否是数字字符，如‘1’，‘2’，是则返回true，否则返回falseCharacter.isLetter(char c)  //判断字符c是否是字母Character.isLowerCase(char c)　//判断c是否是小写字母字符Character.isUpperCase(char c)　//判断c是否是大写字母字符Character.isLetterOrDigit(char c)　判断c是否是字母或数字字符Character.toLowerCase(char c)　//字母转换为小写字母字符Character.toUpperCase(char c)　//字母转换为大写字母字符<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>Java 中集合主要分为java.util.Collection和java.util.Map两大接口。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/87ff2a104a409b2942cbb33fd43efeee.png#pic_center" alt="在这里插入图片描述"></p><p>图表最下方的ArrayList、LinkedList、HashSet以及HashMap都是常用实现类。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><pre class="line-numbers language-none"><code class="language-none">// 无参构造实例化，初始容量为10List arrayList1 = new ArrayList();// 实例化一个初始容量为20的空列表List arrayList2 = new ArrayList(20);// 实例化一个集合元素为 arrayList2 的列表（由于 arrayList2 为空列表，因此其实例化的对象也为空列表）List arrayList3 = new ArrayList(arrayList2);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的方法可能会报错，所以引入泛型。</p><pre class="line-numbers language-none"><code class="language-none">List&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(); // () “括号”里面如果什么都不写，会采取默认容量，也可以复制，也可以将同类型的元素直接放进去<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Collections之间相互转换"><a href="#Collections之间相互转换" class="headerlink" title="Collections之间相互转换"></a>Collections之间相互转换</h4><p>背景：ArrayList元素去重</p><pre class="line-numbers language-none"><code class="language-none">import java.util.ArrayList;import java.util.Arrays;import java.util.LinkedHashSet; public class ArrayListExample {    public static void main(String[] args) {        ArrayList&lt;Integer&gt; numbersList = new ArrayList&lt;&gt;(Arrays.asList(1, 1, 2, 3, 3, 3, 4, 5, 6, 6, 6, 7, 8));        System.out.println(numbersList);        LinkedHashSet&lt;Integer&gt; hashSet = new LinkedHashSet&lt;&gt;(numbersList);        ArrayList&lt;Integer&gt; listWithoutDuplicates = new ArrayList&lt;&gt;(hashSet);        System.out.println(listWithoutDuplicates);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：</p><pre class="line-numbers language-none"><code class="language-none">[1, 1, 2, 3, 3, 3, 4, 5, 6, 6, 6, 7, 8][1, 2, 3, 4, 5, 6, 7, 8]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="ArrayList数据去重"><a href="#ArrayList数据去重" class="headerlink" title="ArrayList数据去重"></a>ArrayList数据去重</h3><p><a href="https://blog.csdn.net/The_clown/article/details/113339283">原文链接</a></p><p><strong>法一：</strong><br>LinkedHashSet是在一个ArrayList删除重复数据的最佳方法。</p><p>LinkedHashSet在内部完成两件事：</p><p> 1 删除重复数据<br> 2 保持添加到其中的数据的顺序</p><pre class="line-numbers language-none"><code class="language-none">import java.util.ArrayList;import java.util.Arrays;import java.util.LinkedHashSet; public class ArrayListExample {    public static void main(String[] args) {        ArrayList&lt;Integer&gt; numbersList = new ArrayList&lt;&gt;(Arrays.asList(1, 1, 2, 3, 3, 3, 4, 5, 6, 6, 6, 7, 8));        System.out.println(numbersList);        LinkedHashSet&lt;Integer&gt; hashSet = new LinkedHashSet&lt;&gt;(numbersList);        ArrayList&lt;Integer&gt; listWithoutDuplicates = new ArrayList&lt;&gt;(hashSet);        System.out.println(listWithoutDuplicates);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>法二：</strong><br>要从arraylist中删除重复项，我们也可以使用java 8 stream api。使用steam的distinct()方法返回一个由不同数据组成的流，通过对象的equals（）方法进行比较。<br>收集所有区域数据List使用Collectors.toList()。<br>Java程序，用于在不使用Set的情况下从java中的arraylist中删除重复项。</p><pre class="line-numbers language-none"><code class="language-none">import java.util.ArrayList;import java.util.Arrays;import java.util.List;import java.util.stream.Collectors; public class ArrayListExample {    public static void main(String[] args) {        ArrayList&lt;Integer&gt; numbersList = new ArrayList&lt;&gt;(Arrays.asList(1, 1, 2, 3, 3, 3, 4, 5, 6, 6, 6, 7, 8));        System.out.println(numbersList);        List&lt;Integer&gt; listWithoutDuplicates = numbersList.stream().distinct().collect(Collectors.toList());        System.out.println(listWithoutDuplicates);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>法三：</strong><br>利用HashSet不能添加重复数据的特性 由于HashSet不能保证添加顺序，所以只能作为判断条件保证顺序：</p><pre class="line-numbers language-none"><code class="language-none">private static void removeDuplicate(List&lt;String&gt; list) {    HashSet&lt;String&gt; set = new HashSet&lt;String&gt;(list.size());    List&lt;String&gt; result = new ArrayList&lt;String&gt;(list.size());    for (String str : list) {        if (set.add(str)) {            result.add(str);        }    }    list.clear();    list.addAll(result);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>法四：</strong><br>利用List的contains方法循环遍历,重新排序,只添加一次数据,避免重复：</p><pre class="line-numbers language-none"><code class="language-none">private static void removeDuplicate(List&lt;String&gt; list) {    List&lt;String&gt; result = new ArrayList&lt;String&gt;(list.size());    for (String str : list) {        if (!result.contains(str)) {            result.add(str);        }    }    list.clear();    list.addAll(result);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>法五：双重for循环去重</strong></p><pre class="line-numbers language-none"><code class="language-none">for (int i = 0; i &lt; list.size(); i++) { for (int j = 0; j &lt; list.size(); j++) { if(i!=j&amp;&amp;list.get(i)==list.get(j)) { list.remove(list.get(j));  } } }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Collections-sort"><a href="#Collections-sort" class="headerlink" title="Collections.sort()"></a>Collections.sort()</h3><p><a href="https://www.jianshu.com/p/32f9578b9acc">原文链接</a></p><blockquote><p>Collections类中的sort方法可以对实现了List接口的集合进行排序。这个方法假定列表元素实现了Comparable接口。</p></blockquote><h4 id="sort常用形式"><a href="#sort常用形式" class="headerlink" title="sort常用形式"></a>sort常用形式</h4><p><strong>sort有两种重载形式，第一种（默认升序）：</strong></p><pre class="line-numbers language-none"><code class="language-none">static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>根据官方文档的描述，这个方法将列表元素进行升序排序，但是列表要满足以下条件：<br>  1.列表元素实现了Comparable接口，且任意两个列表元素都是可比的。<br>  2.列表必须支持set方法。</p><p>实现代码如下：</p><pre class="line-numbers language-none"><code class="language-none">import java.util.*;public class Sort {    public static void main(String[] args) {                Scanner scan = new Scanner(System.in);        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();                          //用户输入10个整数        System.out.println("请输入10个整数：");        for(int i = 0; i &lt; 10; i++)                              {            list.add(scan.nextInt());        }        scan.close();                //排序        Collections.sort(list);                //输出排序结果       System.out.println(list);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：<br><img src="https://img-blog.csdnimg.cn/img_convert/ccfb2d08efa818a82b206d9ed8054630.png#pic_center" alt="在这里插入图片描述"></p><p><strong>sort第二种重载（降序）：</strong></p><pre class="line-numbers language-none"><code class="language-none">public static &lt;T&gt; void sort(List&lt;T&gt; list,Comparator&lt;? super T&gt; c)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果想采用其他方式进行排序，那么可将一个Comparator对象作为sort方法的第二个参数。当要进行逆序排序时，最简便的方法是将Collections.reverseOrder()作为第二个参数。</p><pre class="line-numbers language-none"><code class="language-none">import java.util.*;public class Sort {    public static void main(String[] args) {                Scanner scan = new Scanner(System.in);        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();                          //用户输入10个整数        System.out.println("请输入10个整数：");        for(int i = 0; i &lt; 10; i++)                              {            list.add(scan.nextInt());        }        scan.close();                //逆序排序        Collections.sort(list,Collections.reverseOrder());                //输出排序结果        System.out.println(list);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：<br><img src="https://img-blog.csdnimg.cn/img_convert/5bce696faab5422217b9fd87c15c610b.png#pic_center" alt="在这里插入图片描述"><br>看到这里，对 <code>Comparator</code>这个词多关注下</p><h4 id="排序对象不是基本数据类型"><a href="#排序对象不是基本数据类型" class="headerlink" title="排序对象不是基本数据类型"></a>排序对象不是基本数据类型</h4><blockquote><p>定义一个点类，其中有整型属性x和y，代表其坐标；除了这两个属性以外没有其他属性。随机产生10个点，并按照这些点与原点(0,0)之间的距离大小对点进行降序排序。</p></blockquote><p>如果仍想通过sort方法进行排序的话，首先点类就必须满足上面曾经提过的约束条件：点对象是可比的，因此点类必须实现Comparable接口。查看官方文档可知，Comparable接口中只有一个方法：</p><pre class="line-numbers language-none"><code class="language-none">int compareTo(T o)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>调用这个方法的对象将会与参数o进行比较，小于o、等于o和大于o分别对应的返回值为负数、0和正数。对象之间相对大小的判断方法是自定义的，在这个问题中，就是通过比较各点与原点之间的距离来判断大小，所以点类的实现如下：</p><pre class="line-numbers language-none"><code class="language-none">class Point implements Comparable&lt;Point&gt;{        private int x;    private int y;        public Point(int x,int y)    {        this.x = x;        this.y = y;    }        @Override    //如果该点到原点的距离大于o点到原点的距离，则该点大于o点    public int compareTo(Point o) {        int distance1 = (this.x) * (this.x) + (this.y) * (this.y);        int distance2 = (o.x) * (o.x) + (o.y) * (o.y);                return (distance1 &gt; distance2) ? 1 : ((distance1 == distance2) ? 0 : -1);     }        @Override    public String toString() {        return "(" + x + ","+  y + ")";    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为要进行降序排序，所以可以通过将Collections.reverseOrder()作为sort方法的第二个参数来实现：</p><pre class="line-numbers language-none"><code class="language-none">public class SortDemo {    private static List&lt;Point&gt; list = new ArrayList&lt;&gt;();        public static void main(String[] args) {                //随机生成10个点        for(int i = 0; i &lt; 10; i++)        {            //点的坐标取值在[1,20]之间            int x = (int)(Math.random() * 20) + 1;            int y = (int)(Math.random() * 20) + 1;                        list.add(new Point(x,y));        }        System.out.print("排序前：");        System.out.println(list);                //降序排序        Collections.sort(list,Collections.reverseOrder());                System.out.print("排序后：");        System.out.println(list);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：<br><img src="https://img-blog.csdnimg.cn/img_convert/2a13ef90ac25d9d1c73a21f774ce4611.png#pic_center" alt="在这里插入图片描述"></p><p><strong>sort方法小结：</strong><br>实现了Comparable接口的类都可以用sort方法进行排序，默认的排序方法是升序；如果想进行降序排序，只需把Collections.reverseOrder作为第二个参数传给sort方法。</p><h4 id="Comparator接口"><a href="#Comparator接口" class="headerlink" title="Comparator接口"></a>Comparator接口</h4><p>上面反复提到的Collections.reverseOrder方法返回的是一个Comparator对象。其实Comparator接口并不陌生，常用的equals方法就来自这个接口。Comparator接口用来定义两个对象之间的比较方法，它有一个叫做compare的方法，函数签名如下：</p><pre class="line-numbers language-none"><code class="language-none">int compare(T o1,T o2)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>o1 &gt; o2，返回正数；o1 = o2，返回0；o1 &lt; o2，返回负数。<br>  从前面的例子可以看出，可以使用Comparator对象来控制sort的排序方法，这是如何实现的？查看sort方法的相关源码，我发现其中有这样一段代码：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/da415407eb899af9aab66f06ba75028a.png#pic_center" alt="在这里插入图片描述"><br>注意看图中用红线框起来的部分。经分析可知，这段代码实现了这样的逻辑：如果compare的返回值为正数，就交换进行比较的两个元素的位置。于是可以得出这样一个结论，如果让 x &gt; y 时compare(x,y)返回正数，那么交换 x 和 y 的位置后大的元素在后，这就实现了升序排序；反之，如果让 x &lt; y 时compare(x,y)返回正数，那么交换位置后小的元素在后，这就实现了降序排序。这就是Comparator对象控制排序方式的原理。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/69bf5bc0fb7fa88c13d7a45defa84b1c.png#pic_center" alt="在这里插入图片描述"></p><p>通过Comparator对象来实现点对象的降序排序，一种可行的实现方式如下：</p><pre class="line-numbers language-none"><code class="language-none">import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;import java.util.List;//点类class Point {        private int x;    private int y;        public Point(int x,int y)    {        this.x = x;        this.y = y;    }        public int getX() {        return x;    }    public int getY() {        return y;    }        @Override    public String toString() {        return "(" + x + ","+  y + ")";    }}public class SortDemo {    private static List&lt;Point&gt; list = new ArrayList&lt;&gt;();        public static void main(String[] args) {                //随机生成10个点        for(int i = 0; i &lt; 10; i++)        {            //点的坐标取值在[1,20]之间            int x = (int)(Math.random() * 20) + 1;            int y = (int)(Math.random() * 20) + 1;                        list.add(new Point(x,y));        }        System.out.print("排序前：");        System.out.println(list);                //降序排序        Collections.sort(list,new Comparator&lt;Point&gt;() {            @Override            //当 o1 &lt; o2 时返回正数            public int compare(Point o1, Point o2) {                int distance1 = (o1.getX()) * (o1.getX()) + (o1.getY()) * (o1.getY());                int distance2 = (o2.getX()) * (o2.getX()) + (o2.getY()) * (o2.getY());                                return (distance1 &lt; distance2) ? 1 : ((distance1 == distance2) ? 0 : -1);             }                    });                System.out.print("排序后：");        System.out.println(list);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：<br><img src="https://img-blog.csdnimg.cn/img_convert/997282c1a828c3c32ff7ed4600419ccd.png#pic_center" alt="在这里插入图片描述"></p><h3 id="Arrays-sort"><a href="#Arrays-sort" class="headerlink" title="Arrays.sort()"></a>Arrays.sort()</h3><p><a href="https://www.cnblogs.com/SupremeBoy/p/12717532.html">原文</a><br>Arrays.sort()是经过调优排序算法，性能能达到n*log(n)</p><p><strong>Arrays.sort()重载了四类方法</strong></p><ul><li>sort(T[] a)：对指定T型数组按数字升序排序。 </li><li>sort(T[] a,int formIndex, int toIndex)：对指定T型数组的指定范围按数字升序排序。</li><li>sort(T[] a, Comparator&lt;? supre T&gt; c): 根据指定比较器产生的顺序对指定对象数组进行排序。</li><li>sort(T[] a, int formIndex, int toIndex, Comparator&lt;? supre T&gt; c): 根据指定比较器产生的顺序对指定对象数组的指定对象数组进行排序。</li></ul><h4 id="sort-T-a"><a href="#sort-T-a" class="headerlink" title="sort(T[] a)"></a>sort(T[] a)</h4><p>对指定T型数组按数字升序排序。</p><pre class="line-numbers language-none"><code class="language-none">import java.util.Arrays;import java.util.Comparator;public class ArraysSort {    public static void main(String[] args) {        int[] a={2,5,4,3,1,8};        Arrays.sort(a);        System.out.println(Arrays.toString(a));    }}// 结果// [1, 2, 3, 4, 5, 8]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="sort-T-a-int-formIndex-int-toIndex"><a href="#sort-T-a-int-formIndex-int-toIndex" class="headerlink" title="sort(T[] a,int formIndex, int toIndex)"></a>sort(T[] a,int formIndex, int toIndex)</h4><p>对指定T型数组的指定范围按数字升序排序。</p><pre class="line-numbers language-none"><code class="language-none">import java.util.Arrays;import java.util.Comparator;public class ArraysSort {    public static void main(String[] args) {        int[] a={2,5,4,3,1,8};        Arrays.sort(a,2,5);        System.out.println(Arrays.toString(a));    }}// 结果// [2, 5, 1, 3, 4, 8]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="sort-T-a-Comparator-lt-supre-T-gt-c"><a href="#sort-T-a-Comparator-lt-supre-T-gt-c" class="headerlink" title="sort(T[] a, Comparator<? supre T> c)"></a>sort(T[] a, Comparator&lt;? supre T&gt; c)</h4><p>（1）按第一维元素比较二维数组<br>代码：</p><pre class="line-numbers language-none"><code class="language-none">import java.util.Arrays;import java.util.Comparator;public class ArraysSort {    public static void main(String[] args) {        int[][] nums=new int[][]{{1,3},{1,2},{4,5},{3,7}};        //方法一        Arrays.sort(nums,new Comparator&lt;int[]&gt;(){            @Override            public int compare(int[] a,int[] b){                if(a[0]==b[0]){                    return a[1]-b[1];                }else{                    return a[0]-b[0];                }            }        });        // 方法二，使用匿名表达式        // (a,b)-&gt;a[1]-b[1]会自动转变成上面的形式        /*Arrays.sort(nums,(a,b)-&gt;a[1]-b[1]);*/        for (int[] num : nums) {            System.out.println(Arrays.toString(num));        }        int[] a={2,5,4,3,1,8};        Arrays.sort(a,2,5);        System.out.println(Arrays.toString(a));    }}// 结果/*[1, 2][1, 3][3, 7][4, 5]*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）按第二维元素比较二维数组</p><pre class="line-numbers language-none"><code class="language-none">import java.util.Arrays;import java.util.Comparator;public class ArraysSort {    public static void main(String[] args) {        int[][] nums=new int[][]{{1,3},{1,2},{4,5},{3,7}};        //方法一        Arrays.sort(nums,new Comparator&lt;int[]&gt;(){            @Override            public int compare(int[] a,int[] b){                if(a[1]==b[1]){                    return a[0]-b[0];                }else{                    return a[1]-b[1];                }            }        });        //方法二        /*Arrays.sort(nums,(a,b)-&gt;a[1]-b[1]);*/        for (int[] num : nums) {            System.out.println(Arrays.toString(num));        }    }}// 结果/*[1, 2][1, 3][4, 5][3, 7]*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实这个方法最重要的还是类对象的比较</p><p>由于我们可以自定义比较器，所以我们可以使用策略模式，使得在运行时选择不同的算法</p><pre class="line-numbers language-none"><code class="language-none">import java.util.Arrays;import java.util.Comparator;class Dog{    int size;    int weight;    public Dog(int s, int w){        size = s;        weight = w;    }}class DogSizeComparator implements Comparator&lt;Dog&gt;{    @Override    public int compare(Dog o1, Dog o2) {        return o1.size - o2.size;    }}class DogWeightComparator implements Comparator&lt;Dog&gt;{    @Override    public int compare(Dog o1, Dog o2) {        return o1.weight - o2.weight;    }}public class ArraysSort {    public static void main(String[] args) {        Dog d1 = new Dog(2, 50);        Dog d2 = new Dog(1, 30);        Dog d3 = new Dog(3, 40);        Dog[] dogArray = {d1, d2, d3};        printDogs(dogArray);        Arrays.sort(dogArray, new DogSizeComparator());        printDogs(dogArray);        Arrays.sort(dogArray, new DogWeightComparator());        printDogs(dogArray);    }    public static void printDogs(Dog[] dogs){        for(Dog d: dogs)            System.out.print("size="+d.size + " weight=" + d.weight + " ");        System.out.println();    }}// 结果/*size=2 weight=50 size=1 weight=30 size=3 weight=40 size=1 weight=30 size=2 weight=50 size=3 weight=40 size=1 weight=30 size=3 weight=40 size=2 weight=50 */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么在参数中会出现super呢？这意味着这类型可以是T或者它的父类型。这就是的该方法可以允许所有子类使用相同的比较器。详细见代码：</p><pre class="line-numbers language-none"><code class="language-none">import java.util.Arrays;import java.util.Comparator;class Animal{    int size;}class Dog extends Animal{    public Dog(int s){        size = s;    }}class Cat extends Animal{    public Cat(int s){        size  = s;    }}class AnimalSizeComparator implements Comparator&lt;Animal&gt;{    @Override    public int compare(Animal o1, Animal o2) {        return o1.size - o2.size;    }}public class ArraysSort {    public static void main(String[] args) {        Dog d1 = new Dog(2);        Dog d2 = new Dog(1);        Dog d3 = new Dog(3);        Dog[] dogArray = {d1, d2, d3};        printDogs(dogArray);        Arrays.sort(dogArray, new AnimalSizeComparator());        printDogs(dogArray);        System.out.println();                Cat c1 = new Cat(2);        Cat c2 = new Cat(1);        Cat c3 = new Cat(3);        Cat[] catArray = {c1, c2, c3};        printDogs(catArray);        Arrays.sort(catArray, new AnimalSizeComparator());        printDogs(catArray);    }    public static void printDogs(Animal[] animals){        for(Animal a: animals)            System.out.print("size="+a.size + " ");        System.out.println();    }}// 结果/*size=2 size=1 size=3 size=1 size=2 size=3 size=2 size=1 size=3 size=1 size=2 size=3 */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="sort-T-a-int-formIndex-int-toIndex-Comparator-lt-supre-T-gt-c"><a href="#sort-T-a-int-formIndex-int-toIndex-Comparator-lt-supre-T-gt-c" class="headerlink" title="sort(T[] a, int formIndex, int toIndex, Comparator<? supre T> c)"></a>sort(T[] a, int formIndex, int toIndex, Comparator&lt;? supre T&gt; c)</h4><p>根据指定比较器产生的顺序对指定对象数组的指定对象数组进行排序。</p><pre class="line-numbers language-none"><code class="language-none">import java.util.Arrays;import java.util.Comparator;public class ArraysSort {    public static void main(String[] args) {        int[][] nums=new int[][]{{1,3},{1,2},{4,5},{3,7}};                Arrays.sort(nums,2,4,new Comparator&lt;int[]&gt;(){            @Override            public int compare(int[] a,int[] b){                if(a[0]==b[0]){                    return a[1]-b[1];                }else{                    return a[0]-b[0];                }            }        });    }}// 结果/*[1, 3][1, 2][3, 7][4, 5]可以看到只对第三行和第四行排序了*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="判断变量类型"><a href="#判断变量类型" class="headerlink" title="判断变量类型"></a>判断变量类型</h3><p>1.使用反射的方法： <code>变量名.getClass().getSimpleName()</code>来判断。<br>2.使用 instanceof 来判断：<code>变量名 instanceof 类型</code>来判断。</p><p>1.使用反射的方法来判断<br><img src="https://img-blog.csdnimg.cn/img_convert/2c5f884df06f5761442c47f2e648a233.png#pic_center" alt="在这里插入图片描述"><br>2.使用 instanceof 来判断<br><img src="https://img-blog.csdnimg.cn/img_convert/911efc74c4904e65843c8411be1308d1.png#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Java基础知识&quot;&gt;&lt;a href=&quot;#Java基础知识&quot; class=&quot;headerlink&quot; title=&quot;Java基础知识&quot;&gt;&lt;/a&gt;Java基础知识&lt;/h2&gt;&lt;h3 id=&quot;反射&quot;&gt;&lt;a href=&quot;#反射&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="Java" scheme="https://gaofeng-lin.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://gaofeng-lin.github.io/tags/Java/"/>
    
    <category term="SpringBoot" scheme="https://gaofeng-lin.github.io/tags/SpringBoot/"/>
    
    <category term="动态规划" scheme="https://gaofeng-lin.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="数据结构" scheme="https://gaofeng-lin.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>算法总结</title>
    <link href="https://gaofeng-lin.github.io/posts/57899/"/>
    <id>https://gaofeng-lin.github.io/posts/57899/</id>
    <published>2022-01-25T16:00:00.000Z</published>
    <updated>2022-07-23T03:15:38.084Z</updated>
    
    <content type="html"><![CDATA[<h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><p>力扣876：<br>快慢指针：比较经典的做法是：</p><p><strong>使用两个指针变量，刚开始都位于链表的第 1 个结点，一个永远一次只走 1 步，一个永远一次只走 2 步，一个在前，一个在后，同时走。这样当快指针走完的时候，慢指针就来到了链表的中间位置。</strong></p><p><strong>不一定同时从起点一起走，也有可能快指针先走基本，在按照相同补发或不同步伐一起走。</strong></p><p>根据这种确定性去解决链表中的一些问题。使用这种思想还可以解决链表的以下问题：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">「力扣」第 <span class="token number">19</span> 题： 倒数第 k 个结点，快指针先走几步，不是靠猜的，要在纸上画图模拟一下，就清楚了；「力扣」第 <span class="token number">141</span> 题：环形链表，在环中的时候可以想象，<span class="token class-name">A</span> 同学开始有存款 <span class="token number">100</span> 元，每天赚 <span class="token number">1</span> 元，<span class="token class-name">B</span> 同学开始有存款 <span class="token number">50</span> 元，每天赚 <span class="token number">2</span> 元，<span class="token class-name">B</span> 同学一定会在某一天和 <span class="token class-name">A</span> 同学的存款一样；「力扣」第 <span class="token number">142</span> 题：环形链表 II；「力扣」第 <span class="token number">161</span> 题：相交链表，起点不同，构造相同长度让它们相遇，同样是利用了同步走这个等量关系。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="动态规划解题框架"><a href="#动态规划解题框架" class="headerlink" title="动态规划解题框架"></a>动态规划解题框架</h2><p>框架：</p><pre class="line-numbers language-none"><code class="language-none">for 状态1 in 状态1的所有取值：    for 状态2 in 状态2的所有取值：        for ...            dp[状态1][状态2][...] = 择优(选择1，选择2...)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="股票问题"><a href="#股票问题" class="headerlink" title="股票问题"></a>股票问题</h3><p><a href="https://labuladong.gitee.io/algo/1/12/">原链接</a></p><p>重点看一下最大交易次数k</p><pre class="line-numbers language-none"><code class="language-none">dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])              max( 今天选择 rest,        今天选择 sell       )dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])            max( 今天选择 rest,         今天选择 buy         )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>只有从状态0到1，k才会变化。就是从未持有到持有</strong></p><h2 id="回溯（两种形式）与动态规划"><a href="#回溯（两种形式）与动态规划" class="headerlink" title="回溯（两种形式）与动态规划"></a>回溯（两种形式）与动态规划</h2><p>动态规划一般有两种形式：<strong>自顶向下和自底向上</strong></p><p><img src="https://labuladong.gitee.io/algo/images/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%e8%af%a6%e8%a7%a3%e8%bf%9b%e9%98%b6/3.jpg" alt="在这里插入图片描述"></p><p><img src="https://labuladong.gitee.io/algo/images/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%e8%af%a6%e8%a7%a3%e8%bf%9b%e9%98%b6/4.jpg" alt="在这里插入图片描述"></p><p>不用管细节，回溯/递归是树，动态规划是数组。</p><p><strong>结论：</strong></p><ol><li>自顶向下就是回溯<strong>函数</strong>，自底向上就是dp数组。</li><li>回溯需要单独的一个<strong>回溯函数</strong>，可以是void类型，也可以是非void类型；如果要使用备忘录优化，需要使用非void类型</li><li>有的题没法用备忘录，<strong>二叉树最大深度</strong>就不行。备忘录是记录后面会用到的结果，这个题记了也没有。</li><li>自底向上就不需要额外的函数，就是<strong>dp数组</strong></li><li>dp函数变化的是函数的形参数值，dp数组变化的是索引</li></ol><h3 id="两种形式的dp函数-买卖股票题目"><a href="#两种形式的dp函数-买卖股票题目" class="headerlink" title="两种形式的dp函数(买卖股票题目)"></a>两种形式的dp函数(买卖股票题目)</h3><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/submissions/">void与非void写法</a></p><p>带备忘录写法：<br><img src="https://pic.leetcode-cn.com/3148f3ca40281cb5664a318cda501f7ed7e8fe770149129605ec0572b2a79325-4.jpg" alt="在这里插入图片描述"></p><pre class="line-numbers language-none"><code class="language-none">class Solution {    public int maxProfit(int[] prices) {        if(prices==null || prices.length==0) {            return 0;        }        Map&lt;Pair,Integer&gt; map = new HashMap&lt;Pair,Integer&gt;();        return dfs(map,prices,0,false);    }    private int dfs(Map&lt;Pair,Integer&gt; map,int[] prices,int index,boolean status) {        //Pair对象封装了index和status，作为map的key        Pair p = new Pair(index,status);        if(map.containsKey(p)) {            return map.get(p);        }        if(index==prices.length) {            map.put(p,0);            return 0;        }        int a=0,b=0,c=0;        a = dfs(map,prices,index+1,status);        if(status) {            b = dfs(map,prices,index+1,false)+prices[index];        } else {            c = dfs(map,prices,index+1,true)-prices[index];        }        map.put(p,Math.max(Math.max(a,b),c));        return map.get(p);    }    //自定义一个Pair类，封装 index和status    private class Pair {        private final int index;        private final boolean status;        Pair(int index,boolean status) {            this.index = index;            this.status = status;        }        //这里需要实现自定义的equals和hashCode函数        public boolean equals(Object obj) {            Pair other = (Pair)obj;            if(other.index!=this.index) {                return false;            }            if(other.status!=this.status) {                return false;            }            return true;        }        public int hashCode() {            if(this.status) {                return this.index+1;            } else {                return this.index+0;            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="备忘录回溯与dp数组"><a href="#备忘录回溯与dp数组" class="headerlink" title="备忘录回溯与dp数组"></a>备忘录回溯与dp数组</h3><p><a href="https://labuladong.gitee.io/algo/3/23/66/">凑零钱</a></p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/solution/kan-bu-dong-di-gui-de-kan-guo-lai-xi-wan-1akq/">原链接</a><br><strong>Rules Number One</strong>，基本上，所有的递归问题都可以用递推公式来表示。有了这个递推公式，我们就可以很轻松地将它改为递归代码。。所以，遇到递归不要怕，先想递推公式。</p><p>例1: (比较明显的能递推公式的问题)</p><ul><li>问题：斐波那契数列的第n项 </li><li>递推公式：</li></ul><pre class="line-numbers language-none"><code class="language-none">f(n)=f(n-1)+f(n-2) 其中，f(0)=0,f(1)=1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>终止条件：</li></ul><pre class="line-numbers language-none"><code class="language-none">if (n &lt;= 2) return 1;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>递归代码：</li></ul><pre class="line-numbers language-none"><code class="language-none">int f(int n) {  if (n &lt;= 2) return 1;  return f(n-1) + f(n-2);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>例2:(不那么明显的有递推公式的问题)</p><ul><li>问题：逆序打印一个数组 </li><li>递推公式：</li></ul><pre class="line-numbers language-none"><code class="language-none">假设令F(n)=逆序遍历长度为n的数组那么F(n)= 打印数组中下标为n的元素 + F(n-1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>终止条件：</li></ul><pre class="line-numbers language-none"><code class="language-none">if (n &lt;0) return ;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>递归代码：</li></ul><pre class="line-numbers language-none"><code class="language-none">public void Print(int[] nums,int n){    if(n&lt;0) return;    System.out.println(nums[n]);    Print(nums,n-1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>到这里，不知道大家对写递归有没有一些理解了。其实写递归不能总想着去把递归平铺展开，这样脑子里就会循环，一层一层往下调，然后再一层一层返回，试图想搞清楚计算机每一步都是怎么执行的，这样就很容易被绕进去。对于递归代码，这种试图想清楚整个递和归过程的做法，实际上是进入了一个思维误区。只要找到<strong>递推公式</strong>，我们就能很轻松地写出递归代码。</p><p>到这里，我想进一步跟大家说明我这个思路是比较能够容易出代码的，那么就树的遍历问题来和大家讲。递归总是和树分不开，其中，最典型的便是树的遍历问题。刚开始学的时候，不知道大家是怎么理解先／中／后序遍历的递归写法的，这里我提供我的思路供参考，以前序遍历为例：</p><ul><li>问题：二叉树的先序遍历 </li><li>递推公式：</li></ul><pre class="line-numbers language-none"><code class="language-none">令F(Root)为问题:遍历以Root为根节点的二叉树，令F(Root.left)为问题:遍历以F(Root.left)为根节点的二叉树令F(Root.right)为问题:遍历以F(Root.right)为根节点的二叉树那么其递推公式为：F(Root)=遍历Root节点+F(Root.left)+F(Root.right)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>递归代码：</li></ul><pre class="line-numbers language-none"><code class="language-none">public void preOrder(TreeNode node){    if(node==null) return;    System.out.println(node.val);    preOrder(node.left);    preOrder(node.righr);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Rules Number Two</strong>, 递归是一种关于某个重复动作(完成重复性的功能)的形式化描述。具体点讲，如果一个问题 A 可以分解为若干子问题 B、C、D，你可以假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A。而且，你只需要思考问题 A 与子问题 B、C、D 两层之间的关系即可，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系(也就是说，递归只能考虑当前层和下一层的关系，不能继续往下深入)。我们需要屏蔽掉递归细节，理解为完成了某种功能的形式化描述即可。</p><ul><li>问题：单向链表的反转 </li><li>递推公式</li></ul><pre class="line-numbers language-none"><code class="language-none">令F(node)为问题:反转以node为头节点的单向链表；一般，我们需要考虑F(n)和F(n-1)的关系，那么这里，如果n代表以node为头节点的单向链表，那么n-1就代表以node.next为头节点的单向链表.所以，我们令F(node.next)为问题：反转以node.next为头节点的单向链表；那么，F(node)和F(node.next)之间的关系是？这里我们来简单画个图，假设我们反转3个节点的链表：1 -&gt; 2 -&gt; 3那么，F(node=1)=F(node=2)+?这里假设子问题F(node=2)已经解决，那么我们如何解决F(node=1)：很明显，我们需要反转node=2和node=1， 即 node.next.next=node; 同时 node.next=null;所以，这个问题就可以是：F(node=1)=F(node=2)+ 反转node=2和node=1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>递归代码：</li></ul><pre class="line-numbers language-none"><code class="language-none">public ListNode reverseList(ListNode head) {        if(head == null || head.next == null) {  //终止条件并不难想            return head;        }        ListNode node = reverseList(head.next);        head.next.next = head;        head.next = null;        return node;  //按上面的例子，F(node=1)和F(node=2)它俩反转后的头节点是同一个    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3.写递归的小tips</strong></p><ul><li>将问题抽象化，可以将问题抽象为f(n)（或者其他的数学符号）,<br>然后用f(n)代表欲求的问题，然后去发现和子问题（比如f(n-1)）的递推关系！（这一点在写动态规划的时候特别有用，其实动态规划就是记忆化的递归！）</li><li>递归函数是带语义的，但是记住一个递归函数只有一个语义，如果在写递归函数实现的时候，发现出现了多个语义，需要对新出现的语义重新定义一个函数！</li><li>在写递归函数的时候，可以先写子问题f(n-1)，再写所求问题f(n)，这样的话就很好知道f(n)和f(n-1)的关系，更容易保证一个递归函数只包含一个语义。</li></ul><h2 id="求数组所有子数组的方法"><a href="#求数组所有子数组的方法" class="headerlink" title="求数组所有子数组的方法"></a>求数组所有子数组的方法</h2><p>一个包含n个元素的集合,求它的所有子集。比如集合A= {1,2,3}, 它的所有子集是:<br>{ {1}, {2}, {3}, {1,2}, {1,3}, {2,3}, {1,2,3}, @}(@表示空集)。</p><p>这种问题一般有两种思路，先说说第一种，递归。递归肯定要基于一个归纳法的思想，这个思想用到了二叉树的遍历，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/145f041b48acaf3f3657f6a985a4696b.png#pic_center" alt="在这里插入图片描述"></p><p>可以这样理解这张图，从集合A的每个元素自身分析，它只有两种状态，或是某个子集的元素，或是不属于任何子集，所以求子集的过程就可以看成对每个元素进行“取舍”的过程。上图中，根结点是初始状态，叶子结点是终结状态，该状态下的8个叶子结点就表示集合A的8个子集。第i层(i=1,2,3…n)表示已对前面i-1层做了取舍，所以这里可以用递归了。整个过程其实就是对二叉树的先序遍历。<br>代码见方法getSonSet1。</p><p>还有一种思想比较巧妙，可以叫按位对应法。如集合A={a,b,c},对于任意一个元素，在每个子集中，要么存在，要么不存在。<br>映射为子集：<br>(a,b,c)<br>(1,1,1)-&gt;(a,b,c)<br>(1,1,0)-&gt;(a,b)<br>(1,0,1)-&gt;(a,c)<br>(1,0,0)-&gt;(a)<br>(0,1,1)-&gt;(b,c)<br>(0,1,0)-&gt;(b)<br>(0,0,1)-&gt;©<br>(0,0,0)-&gt;@(@表示空集)<br>观察以上规律，与计算机中数据存储方式相似，故可以通过一个整型数与集合映射00…00 ~ 11…11（1表示有，0表示无，反之亦可），通过该整型数逐次增可遍历获取所有的数，即获取集合的相应子集。<br>实现代码见方法getSonSet2</p><pre class="line-numbers language-none"><code class="language-none">import java.util.ArrayList;import java.util.List;public class SonSet {public static void main(String[] args){int[] arr={1,2,3};List&lt;Integer&gt; aList=new ArrayList&lt;Integer&gt;();List&lt;Integer&gt; bList=new ArrayList&lt;Integer&gt;();for(int i=0;i&lt;arr.length;i++){aList.add(arr[i]);}getSonSet1(0,aList,bList); //方法1，递归法System.out.println("----数组arr公用，分割线-----");getSonSet2(arr,arr.length); //方法2，按位对应法}/* * 递归法*/public static void getSonSet1(int i,List&lt;Integer&gt; aList,List&lt;Integer&gt; bList){if(i&gt;aList.size()-1){if(bList.size()&lt;=0){System.out.print("@");}else {/*for(int v:bList){System.out.print(v+",");//可以直接用这种方法输出bList数组里所有值，但是每个子数组最后就会带逗号}*/System.out.print(bList.get(0));for(int m=1;m&lt;bList.size();m++){System.out.print(","+bList.get(m));}}System.out.println();}else {bList.add(aList.get(i));getSonSet1(i+1, aList, bList);int bLen=bList.size();bList.remove(bLen-1);getSonSet1(i+1, aList, bList);}}/* *按位对应法。*/private static void getSonSet2(int[] arr, int length) {int mark=0;int nEnd=1&lt;&lt;length;boolean bNullSet=false;for(mark=0;mark&lt;nEnd;mark++){bNullSet=true;for(int i=0;i&lt;length;i++){if(((1&lt;&lt;i)&amp;mark)!=0){//该位有元素输出bNullSet=false;System.out.print(arr[i]+",");}}if(bNullSet){//空集合System.out.print("@");}System.out.println();}}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-none"><code class="language-none">1,2,31,21,312,323@----数组arr公用，分割线-----@1,2,1,2,3,1,3,2,3,1,2,3,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h3><p>原始</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//按照刚才那个动图进行对应</span><span class="token comment">//冒泡排序两两比较的元素是没有被排序过的元素---&gt;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>array<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//控制比较轮次，一共 n-1 趟</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>array<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//控制两个挨着的元素进行比较</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> array<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">int</span> temp <span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                array<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>优化</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> arr<span class="token punctuation">;</span>     <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">boolean</span> isSorted  <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment">//有序标记，每一轮的初始是true</span>         <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                 isSorted  <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment">//有元素交换，所以不是有序，标记变为false</span>                 <span class="token keyword">int</span> t <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                 arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                 arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>             <span class="token punctuation">}</span>         <span class="token punctuation">}</span>         <span class="token comment">//一趟下来是否发生位置交换，如果没有交换直接跳出大循环</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>isSorted <span class="token punctuation">)</span>              <span class="token keyword">break</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">return</span> arr<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="岛屿类问题的通用解法、DFS-遍历框架"><a href="#岛屿类问题的通用解法、DFS-遍历框架" class="headerlink" title="岛屿类问题的通用解法、DFS 遍历框架"></a>岛屿类问题的通用解法、DFS 遍历框架</h2><p><a href="https://leetcode-cn.com/problems/number-of-islands/solution/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/">原文链接</a><br>我们所熟悉的 DFS（深度优先搜索）问题通常是在树或者图结构上进行的。而我们今天要讨论的 DFS 问题，是在一种「网格」结构中进行的。岛屿问题是这类网格 DFS 问题的典型代表。网格结构遍历起来要比二叉树复杂一些，如果没有掌握一定的方法，DFS 代码容易写得冗长繁杂。</p><p>本文将以岛屿问题为例，展示网格类问题 DFS 通用思路，以及如何让代码变得简洁。</p><h3 id="网格问题的基本概念"><a href="#网格问题的基本概念" class="headerlink" title="网格问题的基本概念"></a>网格问题的基本概念</h3><p>我们首先明确一下岛屿问题中的网格结构是如何定义的，以方便我们后面的讨论。</p><p>网格问题是由 m \times nm×n 个小方格组成一个网格，每个小方格与其上下左右四个方格认为是相邻的，要在这样的网格上进行某种搜索。</p><p>岛屿问题是一类典型的网格问题。每个格子中的数字可能是 0 或者 1。我们把数字为 0 的格子看成海洋格子，数字为 1 的格子看成陆地格子，这样相邻的陆地格子就连接成一个岛屿。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/eae61771e4f546c7e2572db3832696b8.png#pic_center" alt="在这里插入图片描述"><br>在这样一个设定下，就出现了各种岛屿问题的变种，包括岛屿的数量、面积、周长等。不过这些问题，基本都可以用 DFS 遍历来解决。</p><h3 id="DFS-的基本结构"><a href="#DFS-的基本结构" class="headerlink" title="DFS 的基本结构"></a>DFS 的基本结构</h3><p>网格结构要比二叉树结构稍微复杂一些，它其实是一种简化版的图结构。要写好网格上的 DFS 遍历，我们首先要理解二叉树上的 DFS 遍历方法，再类比写出网格结构上的 DFS 遍历。我们写的二叉树 DFS 遍历一般是这样的：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">traverse</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 判断 base case</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 访问两个相邻结点：左子结点、右子结点</span>    <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，二叉树的 DFS 有两个要素：<strong>「访问相邻结点」和「判断 base case」</strong>。</p><p>第一个要素是<strong>访问相邻结点</strong>。二叉树的相邻结点非常简单，只有左子结点和右子结点两个。二叉树本身就是一个递归定义的结构：一棵二叉树，它的左子树和右子树也是一棵二叉树。那么我们的 DFS 遍历只需要递归调用左子树和右子树即可。</p><p>第二个要素是 <strong>判断 base case</strong>。一般来说，二叉树遍历的 base case 是 root == null。这样一个条件判断其实有两个含义：一方面，这表示 root 指向的子树为空，不需要再往下遍历了。另一方面，在 root == null 的时候及时返回，可以让后面的 root.left 和 root.right 操作不会出现空指针异常。</p><p>对于网格上的 DFS，我们完全可以参考二叉树的 DFS，写出网格 DFS 的两个要素：</p><p>首先，网格结构中的格子有多少相邻结点？答案是上下左右四个。对于格子 (r, c) 来说（r 和 c 分别代表行坐标和列坐标），四个相邻的格子分别是 (r-1, c)、(r+1, c)、(r, c-1)、(r, c+1)。换句话说，网格结构是「四叉」的。<br><img src="https://img-blog.csdnimg.cn/img_convert/76496d04f877bc1d1157d0ed514e833b.png#pic_center" alt="在这里插入图片描述"><br>其次，网格 DFS 中的 base case 是什么？从二叉树的 base case 对应过来，应该是网格中不需要继续遍历、grid[r][c] 会出现数组下标越界异常的格子，也就是那些超出网格范围的格子。<br><img src="https://img-blog.csdnimg.cn/img_convert/cc2be06dade85d546c2b6655e3b5c9e6.png#pic_center" alt="在这里插入图片描述"><br>这一点稍微有些反直觉，坐标竟然可以临时超出网格的范围？这种方法我称为「先污染后治理」—— 甭管当前是在哪个格子，先往四个方向走一步再说，如果发现走出了网格范围再赶紧返回。这跟二叉树的遍历方法是一样的，先递归调用，发现 root == null 再返回。</p><p>这样，我们得到了网格 DFS 遍历的框架代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 判断 base case</span>    <span class="token comment">// 如果坐标 (r, c) 超出了网格范围，直接返回</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">inArea</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> r<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 访问上、下、左、右四个相邻结点</span>    <span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> r <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> r<span class="token punctuation">,</span> c <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> r<span class="token punctuation">,</span> c <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 判断坐标 (r, c) 是否在网格中</span><span class="token keyword">boolean</span> <span class="token function">inArea</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> r <span class="token operator">&amp;&amp;</span> r <span class="token operator">&lt;</span> grid<span class="token punctuation">.</span>length         <span class="token operator">&amp;&amp;</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> c <span class="token operator">&amp;&amp;</span> c <span class="token operator">&lt;</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="如何避免重复遍历"><a href="#如何避免重复遍历" class="headerlink" title="如何避免重复遍历"></a>如何避免重复遍历</h3><p>网格结构的 DFS 与二叉树的 DFS 最大的不同之处在于，遍历中可能遇到遍历过的结点。这是因为，网格结构本质上是一个「图」，我们可以把每个格子看成图中的结点，每个结点有向上下左右的四条边。在图中遍历时，自然可能遇到重复遍历结点。</p><p>如何避免这样的重复遍历呢？答案是标记已经遍历过的格子。以岛屿问题为例，我们需要在所有值为 1 的陆地格子上做 DFS 遍历。每走过一个陆地格子，就把格子的值改为 2，这样当我们遇到 2 的时候，就知道这是遍历过的格子了。也就是说，每个格子可能取三个值：</p><p>0 —— 海洋格子<br>1 —— 陆地格子（未遍历过）<br>2 —— 陆地格子（已遍历过）<br>我们在框架代码中加入避免重复遍历的语句：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 判断 base case</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">inArea</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> r<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 如果这个格子不是岛屿，直接返回</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>grid<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    grid<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 将格子标记为「已遍历过」</span>        <span class="token comment">// 访问上、下、左、右四个相邻结点</span>    <span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> r <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> r<span class="token punctuation">,</span> c <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> r<span class="token punctuation">,</span> c <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 判断坐标 (r, c) 是否在网格中</span><span class="token keyword">boolean</span> <span class="token function">inArea</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> r <span class="token operator">&amp;&amp;</span> r <span class="token operator">&lt;</span> grid<span class="token punctuation">.</span>length         <span class="token operator">&amp;&amp;</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> c <span class="token operator">&amp;&amp;</span> c <span class="token operator">&lt;</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><h3 id="二叉树BFS"><a href="#二叉树BFS" class="headerlink" title="二叉树BFS"></a>二叉树BFS</h3><p><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/solution/bfshe-di-gui-zui-hou-liang-chong-ji-bai-liao-100-2/">原文</a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> tree<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tree <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>tree<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//相当于把数据加入到队列尾部</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//poll方法相当于移除队列头部的元素</span>        <span class="token class-name">TreeNode</span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>leetcode 116</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Node</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token class-name">Node</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//每一层的数量</span>        <span class="token keyword">int</span> levelCount <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//前一个节点</span>        <span class="token class-name">Node</span> pre <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> levelCount<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//出队</span>            <span class="token class-name">Node</span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//如果pre为空就表示node节点是这一行的第一个，</span>            <span class="token comment">//没有前一个节点指向他，否则就让前一个节点指向他</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>pre <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                pre<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">//然后再让当前节点成为前一个节点</span>            pre <span class="token operator">=</span> node<span class="token punctuation">;</span>            <span class="token comment">//左右子节点如果不为空就入队</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> root<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>优化版本：<br>上面运行效率并不是很高，这是因为我们把节点不同的入队然后再不停的出队，其实可以不需要队列，每一行都可以看成一个链表比如第一行就是只有一个节点的链表，第二行是只有两个节点的链表（假如根节点的左右两个子节点都不为空）……<br><img src="https://img-blog.csdnimg.cn/img_convert/f5c37a62f65367e19edbdaa65c8f24bb.png#pic_center" alt="在这里插入图片描述"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Node</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token class-name">Node</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token comment">//cur我们可以把它看做是每一层的链表</span>    <span class="token class-name">Node</span> cur <span class="token operator">=</span> root<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//遍历当前层的时候，为了方便操作在下一</span>        <span class="token comment">//层前面添加一个哑结点（注意这里是访问</span>        <span class="token comment">//当前层的节点，然后把下一层的节点串起来）</span>        <span class="token class-name">Node</span> dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//pre表示下一层节点的前一个节点</span>        <span class="token class-name">Node</span> pre <span class="token operator">=</span> dummy<span class="token punctuation">;</span>                <span class="token comment">//然后开始遍历当前层的链表</span>        <span class="token comment">//因为是完美二叉树，如果有左子节点就一定有右子节点</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> cur<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//让pre节点的next指向当前节点的左子节点，也就是把它串起来</span>            pre<span class="token punctuation">.</span>next <span class="token operator">=</span> cur<span class="token punctuation">.</span>left<span class="token punctuation">;</span>            <span class="token comment">//然后再更新pre</span>            pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token comment">//pre节点的next指向当前节点的右子节点，</span>            pre<span class="token punctuation">.</span>next <span class="token operator">=</span> cur<span class="token punctuation">.</span>right<span class="token punctuation">;</span>            pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token comment">//继续访问这一行的下一个节点</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//把下一层串联成一个链表之后，让他赋值给cur，</span>        <span class="token comment">//后续继续循环，直到cur为空为止</span>        cur <span class="token operator">=</span> dummy<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> root<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;快慢指针&quot;&gt;&lt;a href=&quot;#快慢指针&quot; class=&quot;headerlink&quot; title=&quot;快慢指针&quot;&gt;&lt;/a&gt;快慢指针&lt;/h2&gt;&lt;p&gt;力扣876：&lt;br&gt;快慢指针：比较经典的做法是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用两个指针变量，刚开始都位于链表的第 1 </summary>
      
    
    
    
    <category term="算法" scheme="https://gaofeng-lin.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="动态规划" scheme="https://gaofeng-lin.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="数据结构" scheme="https://gaofeng-lin.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="递归" scheme="https://gaofeng-lin.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
    <category term="DFS" scheme="https://gaofeng-lin.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>git操作</title>
    <link href="https://gaofeng-lin.github.io/posts/3828/"/>
    <id>https://gaofeng-lin.github.io/posts/3828/</id>
    <published>2022-01-13T16:00:00.000Z</published>
    <updated>2022-07-23T03:15:44.906Z</updated>
    
    <content type="html"><![CDATA[<h2 id="config相关命令"><a href="#config相关命令" class="headerlink" title="config相关命令"></a>config相关命令</h2><h3 id="查看配置信息"><a href="#查看配置信息" class="headerlink" title="查看配置信息"></a>查看配置信息</h3><ol><li>查看系统config</li></ol><pre class="line-numbers language-none"><code class="language-none">git config --system --list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>查看当前用户（global）配置</li></ol><pre class="line-numbers language-none"><code class="language-none">git config --global  --list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>查看当前仓库配置信息</li></ol><pre class="line-numbers language-none"><code class="language-none">git config -- local    --list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="设置-x2F-修改配置信息"><a href="#设置-x2F-修改配置信息" class="headerlink" title="设置/修改配置信息"></a>设置/修改配置信息</h3><p>设置用户名：</p><pre class="line-numbers language-none"><code class="language-none">git config --global user.name "github用户名"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>设置邮箱</p><pre class="line-numbers language-none"><code class="language-none">git config --global user.email "github注册邮箱"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="查看提交记录"><a href="#查看提交记录" class="headerlink" title="查看提交记录"></a>查看提交记录</h2><h3 id="查看指定文件的历史提交记录"><a href="#查看指定文件的历史提交记录" class="headerlink" title="查看指定文件的历史提交记录"></a>查看指定文件的历史提交记录</h3><pre class="line-numbers language-none"><code class="language-none">git log -- &lt;file&gt;  //主要，这个文件要在当前目录才能直接输文件名，否则要给出路径<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/b1dc02f3dc8d4c888f7d98443524a64f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="查看每次提交的内容差异"><a href="#查看每次提交的内容差异" class="headerlink" title="查看每次提交的内容差异"></a>查看每次提交的内容差异</h3><pre class="line-numbers language-none"><code class="language-none">git log -p -2 -- &lt;file&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>参数：-p 表示每次提交的内容差异，-2 则表示显示最近的两次更新。</p><p>说明：该选项除了显示基本信息之外，还在附带了每次 commit 的变化。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/381402cab6344a00b05b3a42fe128a60.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="根据哈希值查看修改代码细节"><a href="#根据哈希值查看修改代码细节" class="headerlink" title="根据哈希值查看修改代码细节"></a>根据哈希值查看修改代码细节</h3><pre class="line-numbers language-none"><code class="language-none">git show 哈希值<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">git show 哈希值 文件名 //具体某个文件的变化<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="根据分支或用户查看提交信息"><a href="#根据分支或用户查看提交信息" class="headerlink" title="根据分支或用户查看提交信息"></a>根据分支或用户查看提交信息</h3><pre class="line-numbers language-none"><code class="language-none">git log 分支名git log --authot='用户名'//这两个命令可以通过 | xargs  与 git show搭配用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="单词层面上的对比"><a href="#单词层面上的对比" class="headerlink" title="单词层面上的对比"></a>单词层面上的对比</h3><pre class="line-numbers language-none"><code class="language-none">git log --word-diff -- &lt;file&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>参数：–word-diff 表示获取单词层面上的对比。</p></blockquote><blockquote><p>说明：进行单词层面的对比常常是没什么用的。不过当你需要在书籍、论文这种很大的文本文件上进行对比的时候，这个功能就显出用武之地了。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/dbf8557886aa4e16905b75a0fc368c29.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>提示：新增加的单词被 {+ +} 括起来，被删除的单词被 [- -] 括起来。</strong></p><h3 id="图形化查看提交历史"><a href="#图形化查看提交历史" class="headerlink" title="图形化查看提交历史"></a>图形化查看提交历史</h3><pre class="line-numbers language-none"><code class="language-none">gitk -- &lt;file&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>说明：随 Git 一同发布的 gitk 就是这样一种工具。它是用 Tcl/Tk 写成的，基本上相当于 git log 命令的可视化版本，凡是<br>git log 可以用的选项也都能用在 gitk 上。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/b981ba602f044894b93bf19d74116145.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>**</p><blockquote><p>gitk中文乱码问题</p></blockquote><p>**<br>解决办法：<br>打开git的配置文件(根据自己安装的git目录，此处为安装在D盘)：D:\Program Files\Git\etc\gitconfig</p><p>在文件内追加以下内容：</p><pre class="line-numbers language-none"><code class="language-none">[gui]  encoding = utf-8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="提取git中某个文件的所有版本并按顺序命名"><a href="#提取git中某个文件的所有版本并按顺序命名" class="headerlink" title="提取git中某个文件的所有版本并按顺序命名"></a>提取git中某个文件的所有版本并按顺序命名</h3><pre class="line-numbers language-none"><code class="language-none">git log --follow --pretty=format:%H 文件名 | xargs -I{} sh -c 'git show {}:文件名 &gt; 文件名.{}'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>文件名需要进行替换，不可直接输入 文件名 三个字</strong></p><br><p><strong>如果出现</strong> </p><blockquote><p>Did you menan ‘哈希值：路径’ aka ‘哈希值：路径’</p></blockquote><p>字眼的错误</p><p>给第二个文件名添加 <code>./</code></p><h3 id="git将远程分支按分支名在本地建立文件夹"><a href="#git将远程分支按分支名在本地建立文件夹" class="headerlink" title="git将远程分支按分支名在本地建立文件夹"></a>git将远程分支按分支名在本地建立文件夹</h3><pre class="line-numbers language-none"><code class="language-none">git branch -r | xargs -d/ -n1 | grep -v 'origin' | xargs -I{} sh -c 'mkdir "C:\Users\76585\Desktop\try\{}" '<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令分线见 <strong>博客–Linux Shell命令总结</strong></p><h2 id="git-常用操作"><a href="#git-常用操作" class="headerlink" title="git 常用操作"></a>git 常用操作</h2><h3 id="git-pull-与-git-push-详解"><a href="#git-pull-与-git-push-详解" class="headerlink" title="git pull 与 git push 详解"></a>git pull 与 git push 详解</h3><p>1.git remote</p><pre class="line-numbers language-none"><code class="language-none">git remote add origin url  //这里面的origin 是给远程仓库起名字，不是给本地仓库！<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2.git pull</p><pre class="line-numbers language-none"><code class="language-none">git pull 其实就是 git fetch 和 git merge FETCH_HEAD 的简写。 命令格式如下：git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">将远程主机 origin 的 master 分支拉取过来，与本地的 brantest 分支合并。git pull origin master:brantest如果远程分支是与当前分支合并，则冒号后面的部分可以省略。git pull origin master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.git push </p><pre class="line-numbers language-none"><code class="language-none">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;如果本地分支名与远程分支名相同，则可以省略冒号：git push &lt;远程主机名&gt; &lt;本地分支名&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实例：<br>以下命令将本地的 master 分支推送到 origin 主机的 master 分支。</p><pre class="line-numbers language-none"><code class="language-none">git push origin master相等于：git push origin master:master如果本地版本与远程版本有差异，但又要强制推送可以使用 --force 参数：git push --force origin master删除主机的分支可以使用 --delete 参数，以下命令表示删除 origin 主机的 master 分支：git push origin --delete master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="将本地代码上传到远程仓库"><a href="#将本地代码上传到远程仓库" class="headerlink" title="将本地代码上传到远程仓库"></a>将本地代码上传到远程仓库</h3><p>1.（电脑里得先下载git）登录coding，新建一个仓库，点击代码浏览可以看到<br><img src="https://img-blog.csdnimg.cn/dfad51be62a440cd86b764c2e4f16487.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/7063830ad8194b8792977f5750a8d1d4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>2.在本地新建一个文件夹，作为项目根目录，再此启动 Git Bash ，进入目录，并输入</p><pre class="line-numbers language-none"><code class="language-none">git init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3.将本地仓库和我们在coding上创建的远程仓库对接起来，输入</p><pre class="line-numbers language-none"><code class="language-none">git remote add *yourname* *git_url*  //不用输这条，输下面那条<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>add 后面输入你的仓库名字，自定义。git_url代表你的git地址，这里我命名为origin</p><pre class="line-numbers language-none"><code class="language-none">git remote add origin *url* //这条指令是上面的详细版，输入这个就好。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>（这里可能会出现叫你设置邮箱，和姓名，跟着提示设置就行了，或者可以选择以SSH公钥进行连接，不过得先去配置公钥）</p></blockquote><p>回车成功后可以输入</p><pre class="line-numbers language-none"><code class="language-none">git remote -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4.为了我们的代码是最新的状态 和 提交时不会产生冲突，我们先执行下pull操作，将远程仓库最新代码拉到我们本地来，输入</p><pre class="line-numbers language-none"><code class="language-none">git pull origin master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>（origin就是我们上面设置的仓库名，master代表主分支，你可以把分支理解为一块区域，我们最终编写完成的代码都要整合到master分支里面去。然后，我们还可创建一些其他分支，去保存我们正在编写中，或者尚未测试的代码。）</p></blockquote><p>执行完后，你可以查看目录下的文件，这时我们本地的文件就和远程仓库里面master分支里的文件一样了。</p><p>5.接下来我们来模拟写代码并上传到远程仓库去。<br>我们新建一个 a.js文件，并编辑一些内容进去。首先将a文件添加到暂存区</p><pre class="line-numbers language-none"><code class="language-none">git add a.js //（add后面可以带多个文件名字，用空格隔开；或者输入 . 代表全部）//然后再提交到本地仓库中去git commit -m "first commit"//然后我们需要把它push到远程仓库中去。输入git push origin master  //push到origin的master主分支里面，成功后会显示提示消息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查看远程仓库的情况"><a href="#查看远程仓库的情况" class="headerlink" title="查看远程仓库的情况"></a>查看远程仓库的情况</h3><p>查看当前配置有哪些远程仓库</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> remote<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>本地与远程仓库的取消<br><strong>git remote remove “仓库名”</strong></p><p><strong>可以同时关联多个仓库，名字起的不一样就好，不一定非要用origin。但是要注意的是，git pull 和 git push指定的仓库名字也要改变。不然容易出问题。</strong></p><h3 id="分支的使用"><a href="#分支的使用" class="headerlink" title="分支的使用"></a>分支的使用</h3><p><strong>mster代表主分支，最终的代码都整合到这里面去，我们可以看下</strong><br><img src="https://img-blog.csdnimg.cn/fcc0d993653e42e7a48a10d25328f11e.png" alt="在这里插入图片描述"></p><p><strong>这里只有一个主分支master。<br>有一种情况就是，一个项目多人开发，我的任务需要开发一个功能，我没办法短时间内就开发测试等等一系列完成。所以我可以新建一个分支，然后把每次完成的代码都上传到这个分支里面去，最后等到所有操作都完成后，我再把这个分支整合到master中去。下面看步骤</strong></p><p>1.首先查看当前分支</p><pre class="line-numbers language-none"><code class="language-none">git branch -a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>-a代表查看本地和远程的分支，此时我们看到都只有一个master分支<br><img src="https://img-blog.csdnimg.cn/8e219832c5df4eef8c7da9dce7cd1829.png" alt="在这里插入图片描述"></p><p>2.新建分支dev</p><pre class="line-numbers language-none"><code class="language-none">git checkout -b dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>执行该命令，会在本地创建一个新分支。该分支是从当前分支上生成的，所有内容和当前分支一样。</strong></p><p>-b代表同时切换到dev分支下面去，这时你可以再去查看分支</p><p>3.然后我们重新写一个b.js文件，再执行add，commit，最后push</p><pre class="line-numbers language-none"><code class="language-none">git add b.jsgit commit -m "dev"git push origin dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意push时要到dev分支</strong></p><p>成功后我们去coding看已经有了dev，并且dev下有b.js，而master没有b.js<br><img src="https://img-blog.csdnimg.cn/ca05925c026f48d4af3cc08ced1632da.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_12,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>master：<br><img src="https://img-blog.csdnimg.cn/abc1cba6a233436a8a4731ec90324646.png" alt="在这里插入图片描述"></p><p>我们可以再去看看分支情况，</p><p>git branch -a<br><img src="https://img-blog.csdnimg.cn/5323471b84664e88b25f3f6228da4e74.png" alt="在这里插入图片描述"></p><p>此时已经有了两个分支，且当前位于dev分之下<br>切换分支可以用 <strong>git checkout [branch-name]</strong></p><h3 id="将远程git仓库里的指定分支拉取到本地（本地不存在的分支）"><a href="#将远程git仓库里的指定分支拉取到本地（本地不存在的分支）" class="headerlink" title="将远程git仓库里的指定分支拉取到本地（本地不存在的分支）"></a>将远程git仓库里的指定分支拉取到本地（本地不存在的分支）</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> checkout -b<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上述命令虽然能生成新分支，但是会复制当前分支。但有时从远程仓库拉取分支，我只想要远程那个分支，不想先复制别的，这样拉下来会有冲突。<br>方法如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> checkout -b 本地分支名 origin/远程分支名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个将会自动创建一个新的本地分支，并与指定的远程分支关联起来。</p><p>如果出现提示：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">fatal: Cannot update paths and switch to branch <span class="token string">'dev2'</span> at the same time.Did you intend to checkout <span class="token string">'origin/dev2'</span> <span class="token function">which</span> can not be resolved as commit?<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>或者：</p><pre class="line-numbers language-none"><code class="language-none">fatal: 'origin/xlh' is not a commit and a branch 'xlh' cannot be created from it<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>git remote发现远程仓库的新分支没有显示出来，git fetch就好</strong></p><p>表示拉取不成功或远程仓库信息没有更新。我们需要先执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> fetch<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后再执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> checkout -b 本地分支名 origin/远程分支名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><p><strong>查看分支</strong></p><pre class="line-numbers language-none"><code class="language-none">git branch -a //远程的是红色<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>删除本地分支</strong></p><pre class="line-numbers language-none"><code class="language-none">git branch -d &lt;BranchName&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>删除远程分支</strong></p><pre class="line-numbers language-none"><code class="language-none">git push origin --delete &lt;BranchName&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="整合分支"><a href="#整合分支" class="headerlink" title="整合分支"></a>整合分支</h3><p><strong>当我们在dev下折腾完成后，最终要整合到master中去，看步骤</strong></p><p>1.切换本地分支到master</p><pre class="line-numbers language-none"><code class="language-none">git checkout master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2.将远程仓库的最新代码pull下来！！因为期间其他人可能已经提交代码到远程master了，所以你首先得更新下自己本地的master代码</p><pre class="line-numbers language-none"><code class="language-none">git pull origin master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>假如有改动过，那么执行后会显示改动的信息</p><p>3.然后再把本地的dev代码整合到master，输入</p><pre class="line-numbers language-none"><code class="language-none">git merge dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>merge整合操作，把dev整合到当前分之下（当前分支为master）。会提示增加了东西<br><img src="https://img-blog.csdnimg.cn/249f2d65516c483a9517f8ce5affb72f.png" alt="在这里插入图片描述"></p><p>4.由于当前的东西已经在本地仓库里面了，所以最后我们再执行push，到远程仓库的master</p><pre class="line-numbers language-none"><code class="language-none">git push origin master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>成功后你可看到，master下已经有b.js文件了<br><img src="https://img-blog.csdnimg.cn/1f2c3d8b692b42619534a683d2c3f21a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_11,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="本地从远程仓库拉取代码，只在某分支开发"><a href="#本地从远程仓库拉取代码，只在某分支开发" class="headerlink" title="本地从远程仓库拉取代码，只在某分支开发"></a>本地从远程仓库拉取代码，只在某分支开发</h3><p>远程仓库有master，dev1两个分支。本地用git clone拉取代码，<code>git branch -a</code>查看，本地只有一个分支。此时用<code>git checkout dev1</code> 切换到dev1分支。代码和远程仓库一致。可以用<code>git log</code>来确认是否是该分支（因为git log 只能看到当前分支的提交记录）</p><h3 id="回退到某版本"><a href="#回退到某版本" class="headerlink" title="回退到某版本"></a>回退到某版本</h3><pre class="line-numbers language-none"><code class="language-none">git reset --hard 139dcfaa558e3276b30b6b2e5cbbb9c00bbdca96 //后面的是git提交的历史版本号，上git上面找到复制下来就行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="回退到某版本，且放弃之前的记录"><a href="#回退到某版本，且放弃之前的记录" class="headerlink" title="回退到某版本，且放弃之前的记录"></a>回退到某版本，且放弃之前的记录</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> reset --hard回退之后，如果直接push会出错，因为我们本地库HEAD指向的版本比远程库的要旧，所以我们要用“git push -f”强制推上去<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="撤回git-commit-操作"><a href="#撤回git-commit-操作" class="headerlink" title="撤回git commit 操作"></a>撤回git commit 操作</h3><p>写完代码后，我们一般这样</p><p>git add .</p><p>git commit -m “msg”</p><p>执行完commit后，想撤回commit，怎么办？<br><strong>1. 撤回操作</strong></p><pre class="line-numbers language-git" data-language="git"><div class="caption"><span>reset --soft HEAD^``` （ps：如果控制台出现More?，则将命令改成 git reset --soft HEAD^^即可）</span></div><code class="language-git">这样就成功的撤销了你的commit注意，仅仅是撤回commit操作，您写的代码仍然保留。**说一下个人理解：**HEAD^的意思是上一个版本，也可以写成HEAD~1如果你进行了2次commit，想都撤回，可以使用HEAD~2**2. 参数：****--mixed**意思是：不删除工作空间改动代码，撤销commit，并且撤销git add . 操作这个为默认参数,git reset --mixed HEAD^ 和 git reset HEAD^ 效果是一样的。**--soft**不删除工作空间改动代码，撤销commit，不撤销git add .**--hard**删除工作空间改动代码，撤销commit，撤销git add .注意完成这个操作后，就恢复到了上一次的commit状态。**3. 修改注释**顺便说一下，如果commit注释写错了，只是想改一下注释，只需要：git commit --amend此时会进入默认vim编辑器，修改注释完毕后保存就好了。<span class="token comment">### 将现有代码保存带其它仓库</span>1. git remote add neworigin **<span class="token string">"url"</span>**2. git push -u neworigin **<span class="token string">"分支名"</span>**3. 如果第二条命令不行就：git push -u neworigin **<span class="token string">"分支名"</span>** : **<span class="token string">"分支名"</span>**<span class="token comment">## git bash安装zip</span>git bash有些话可能没法执行zip命令1.打开https://sourceforge.net/projects/gnuwin32/files/2.2.找到zip和bzip2，由于zip依赖bzip2.dll，**下载zip-3.0-bin.zip和bzip2-1.0.5-bin.zip**，解压后，复制zip-3.0-bin的bin目录下的**zip.exe** 和bzip2-1.0.5-bin的bin目录下的**bzip2.dll**到 **git/usr/bin/**```bash放置的目录不能放错，一开始放到了git/bin/目录下，结果不行。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="git-所遇问题"><a href="#git-所遇问题" class="headerlink" title="git 所遇问题"></a>git 所遇问题</h2><h3 id="ssh-connect-to-host-github-com-port-22-Connection-refused"><a href="#ssh-connect-to-host-github-com-port-22-Connection-refused" class="headerlink" title="ssh: connect to host github.com port 22: Connection refused"></a>ssh: connect to host github.com port 22: Connection refused</h3><p><a href="https://segmentfault.com/a/1190000041909858">原链接</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;config相关命令&quot;&gt;&lt;a href=&quot;#config相关命令&quot; class=&quot;headerlink&quot; title=&quot;config相关命令&quot;&gt;&lt;/a&gt;config相关命令&lt;/h2&gt;&lt;h3 id=&quot;查看配置信息&quot;&gt;&lt;a href=&quot;#查看配置信息&quot; class=&quot;</summary>
      
    
    
    
    <category term="git" scheme="https://gaofeng-lin.github.io/categories/git/"/>
    
    
    <category term="运维" scheme="https://gaofeng-lin.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="Linux" scheme="https://gaofeng-lin.github.io/tags/Linux/"/>
    
    <category term="git" scheme="https://gaofeng-lin.github.io/tags/git/"/>
    
    <category term="代码管理" scheme="https://gaofeng-lin.github.io/tags/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>python</title>
    <link href="https://gaofeng-lin.github.io/posts/51872/"/>
    <id>https://gaofeng-lin.github.io/posts/51872/</id>
    <published>2022-01-13T16:00:00.000Z</published>
    <updated>2022-07-23T03:16:10.149Z</updated>
    
    <content type="html"><![CDATA[<h2 id="所遇问题"><a href="#所遇问题" class="headerlink" title="所遇问题"></a>所遇问题</h2><h3 id="输出格式有问题"><a href="#输出格式有问题" class="headerlink" title="输出格式有问题"></a>输出格式有问题</h3><p>背景：python2.7，IDE：VSCode<br>源码：<br><img src="https://img-blog.csdnimg.cn/aad38ed43cf14169a81178f15d5cab6b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>two.txt:<br><img src="https://img-blog.csdnimg.cn/30f55f74a6f04008af34c386d4ac4631.png" alt="在这里插入图片描述"></p><p>输出：<br><img src="https://img-blog.csdnimg.cn/006fd38c10064562b5261b067cd0d0e8.png" alt="在这里插入图片描述"><br>预期应该为商品，单价，数量。</p><p>修改最后一行的print<br><img src="https://img-blog.csdnimg.cn/be1c33ec8b6e4593806ab989758d5641.png" alt="在这里插入图片描述"></p><h3 id="打包pip-install-包"><a href="#打包pip-install-包" class="headerlink" title="打包pip install 包"></a>打包pip install 包</h3><blockquote><p>背景：内网需要安装python和一些包，无法连互联网，只能外网下载再u盘拷过去。</p></blockquote><ol><li><p>在外网机器Python的安装目录中新建一个文件夹，如packages：<br> <img src="https://img-blog.csdnimg.cn/f86df46c2cc4468fa89c15c1708df6fe.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>进入到packages文件夹下，shift按住，鼠标右键“在此处打开命令行”，输入pip<br>list查看系统中安装了哪些python包，如下：<br><img src="https://img-blog.csdnimg.cn/730bff4d9f30437790528bf4db3797cb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>把所有包名及版本号，重定向到requirements.txt中</p><pre class="line-numbers language-none"><code class="language-none">pip freeze &gt;requirements.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>然后下载系统中已经安装的所有包到一个目录下，比如在packages的packages中，使用如下命令,此时packages下有两个文件：</p></li></ol><pre class="line-numbers language-none"><code class="language-none">pip download -r requirements.txt -d packages<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/1db7754fe1984892849f3d5adca5bc5b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><ol start="5"><li>内网安装。先复制刚才外网机器上的文件夹pacjages到内网机器对应的目录<br><img src="https://img-blog.csdnimg.cn/8a4c18aa77c040dd925733f93ade928e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li><li>进入到D:\Python37\packages下，打开命令行，执行安装</li></ol><pre class="line-numbers language-none"><code class="language-none">pip install --no-index --find-links=packages -r requirements.txt <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果失败，可以一个一个安装</p><pre class="line-numbers language-none"><code class="language-none">pip install XXXX包名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="python2-7-卸载失败问题"><a href="#python2-7-卸载失败问题" class="headerlink" title="python2.7 卸载失败问题"></a>python2.7 卸载失败问题</h3><blockquote><p>背景：使用.msi文件进行卸载，出现以下情况：</p></blockquote><p><img src="https://img-blog.csdnimg.cn/bcd0965e3e1c4c929422fa9b879729cb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>解决方法：<br>找到出问题的版本，个人当时出问题的版本是2.7.10。官网下载msi文件。<br><img src="https://img-blog.csdnimg.cn/93c843b909ec45ec85865dbf3c2ae945.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>依次运行。</p><h3 id="open函数传参数出错"><a href="#open函数传参数出错" class="headerlink" title="open函数传参数出错"></a>open函数传参数出错</h3><blockquote><p>背景：python2.7，open函数传递参数。<br>自定义函数，函数里面调用open函数</p></blockquote><p><img src="https://img-blog.csdnimg.cn/4c36a39430c747eb86e933b2ae67b809.png" alt="在这里插入图片描述"><br>如果不在路径前面加r，就会报错。按理说应该是<br>open(file_path,mode)</p><p>后面写出函数，拼接的时候老出错。<br><strong>解决办法：</strong></p><blockquote><p>路径使用/<br>‘C:/Users/76585/Desktop/compare/one.txt’</p></blockquote><p>open函数可以正常使用open(path,mode)</p><h3 id="Python编码错误的解决办法SyntaxError-Non-ASCII-character-‘-xe5’-in-file"><a href="#Python编码错误的解决办法SyntaxError-Non-ASCII-character-‘-xe5’-in-file" class="headerlink" title="Python编码错误的解决办法SyntaxError: Non-ASCII character ‘\xe5’ in file"></a>Python编码错误的解决办法SyntaxError: Non-ASCII character ‘\xe5’ in file</h3><blockquote><p>原因：python的默认编码文件是用的ASCII码，而你的python文件中使用了中文等非英语字符</p></blockquote><p>解决办法：</p><p>在Python源文件的最开始一行，加入一句：</p><pre class="line-numbers language-none"><code class="language-none">##coding=UTF-8（等号换为”:“也可以）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-none"><code class="language-none">##-*- coding:UTF-8 -*-<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="RuntimeError-dictionary-changed-size-during-iteration"><a href="#RuntimeError-dictionary-changed-size-during-iteration" class="headerlink" title="RuntimeError: dictionary changed size during iteration"></a>RuntimeError: dictionary changed size during iteration</h3><p>在字典遍历过程中修改字典元素，报错 RuntimeError: dictionary changed size during iteration</p><p>得知遍历时不能修改字典元素</p><pre class="line-numbers language-none"><code class="language-none">for k in func_dict.keys():    if func_dict[k] is np.nan:        del func_dict[k]        continue<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>解决办法：将遍历条件改为列表</strong></p><pre class="line-numbers language-none"><code class="language-none">for k in list(func_dict.keys()):    if func_dict[k] is np.nan:        del func_dict[k]        continue<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="VScode-code-runner无法运行出正确的结果"><a href="#VScode-code-runner无法运行出正确的结果" class="headerlink" title="VScode code runner无法运行出正确的结果"></a>VScode code runner无法运行出正确的结果</h3><p>背景：<br>内网电脑上，通过python程序对文件进行读写操作，但是没有出现相应的结果。单步调试可以出正确的结果。</p><p>分析：<br>通过print 输出可以发现问题。命令行运行py文件可以得到正确的结果，说明原因出在code runner上面。</p><p>解决办法：<br>1.首选项找到设置<br><img src="https://img-blog.csdnimg.cn/84c82a81f052455385019bbc37bc93b2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>2.输入code-runner，找到 Executor Map<br><img src="https://img-blog.csdnimg.cn/b22a0f9e154642e0843ce47974245361.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>3.选择这个，（将设置复制为id）<br><img src="https://img-blog.csdnimg.cn/a78e8887588e4e0591da5a2f391335aa.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/59d97e84f5384682828af42b5d5f03a1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>将复制的内容粘贴到里面</p><p><img src="https://img-blog.csdnimg.cn/0bdfe664d55944f3b118f82861f2a31a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>修改其中python字段的python值替换为vscode左下角的python解释器：<br>结果如下;</p><pre class="line-numbers language-none"><code class="language-none">"python": "C:\\Python27\\python.exe -u" //注意转义符//下面这个也可以"python": "\"C:/Python27/python.exe\" -u"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/6eef8ba7ef9e47a9bbef68a0918f3b94.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="vscode进行调试，系统把conda-activate-base写入了用户输入区域该怎么办？"><a href="#vscode进行调试，系统把conda-activate-base写入了用户输入区域该怎么办？" class="headerlink" title="vscode进行调试，系统把conda activate base写入了用户输入区域该怎么办？"></a>vscode进行调试，系统把conda activate base写入了用户输入区域该怎么办？</h3><p><strong>问题：在运行调试的时候编译器在运行语句前没有进入虚拟base环境，于是在遇到激活用户输入语句时，自动输入了conda activate base ，导致程序出错</strong></p><p><img src="https://img-blog.csdnimg.cn/20190531113214107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5nZmVuZzg4ODE2OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>解决办法：避免在使用这些终端命令时激活虚拟环境和conda环境，<strong>请将python.terminal.activateEnvironment设置更改为false</strong></p><p><img src="https://img-blog.csdnimg.cn/2019053111303868.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5nZmVuZzg4ODE2OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>这个setting.json在在<code>C:\Users\Administrator\AppData\Roaming\Code\User\setting.json</code> 是个纯文本文件，直接打开就好。如果没有python.terminal.activateEnvironment这一行可以自己加上。</p><h2 id="技术知识点"><a href="#技术知识点" class="headerlink" title="技术知识点"></a>技术知识点</h2><h3 id="遍历文件夹下的文件名"><a href="#遍历文件夹下的文件名" class="headerlink" title="遍历文件夹下的文件名"></a>遍历文件夹下的文件名</h3><blockquote><p>#方法1：使用os.listdir</p></blockquote><pre class="line-numbers language-none"><code class="language-none">import osfor filename in os.listdir(r'c:\windows'):    print("文件夹名字",filename)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>#方法2：使用glob模块，可以设置文件过滤</p></blockquote><pre class="line-numbers language-none"><code class="language-none">import globfor filename in glob.glob(r'c:\windows\*.exe'):    print("是.exe的文件名",filename)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>#方法3：非递归</p></blockquote><pre class="line-numbers language-none"><code class="language-none">import osfor dirpath, dirnames, filenames in os.walk('D:'):    print('文件路径', dirpath)    print('文件夹名字',dirnames)    for filename in filenames:        print('文件名', filename)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="sorted排序"><a href="#sorted排序" class="headerlink" title="sorted排序"></a>sorted排序</h3><h4 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h4><p>文件夹里面的文件按照文件名里面的数字进行排序<br>文件如下：0.txt, 1.txt, 2.txt, 3.txt, 34.txt, 54.txt  …………….</p><pre class="line-numbers language-none"><code class="language-none">file_list=os.listdir(file_path)file_list.sort(key=lambda x:int((re.findall(r'\d+', str(x)))[0]))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>1.re.findall(r’\d+’, str(x))[0] 正则表达式提取数字，但结果是列表，所以把元素取出来，再用一个int转成整数类型</p><p>按照key来排序，后面是一个lambda表达式。</p><h4 id="对列表排序-返回的对象不会改变原列表"><a href="#对列表排序-返回的对象不会改变原列表" class="headerlink" title="对列表排序,返回的对象不会改变原列表"></a>对列表排序,返回的对象不会改变原列表</h4><pre class="line-numbers language-none"><code class="language-none">list = [1,5,7,2,4]sorted(list)Out[87]: [1, 2, 4, 5, 7]##可以设定时候排序方式，默认从小到大，设定reverse = False 可以从大到小sorted(list,reverse=False)Out[88]: [1, 2, 4, 5, 7]sorted(list,reverse=True)Out[89]: [7, 5, 4, 2, 1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="根据自定义规则来排序，使用参数：key"><a href="#根据自定义规则来排序，使用参数：key" class="headerlink" title="根据自定义规则来排序，使用参数：key"></a>根据自定义规则来排序，使用参数：key</h4><pre class="line-numbers language-none"><code class="language-none">## 使用key,默认搭配lambda函数使用sorted(chars,key=lambda x:len(x))Out[92]: ['a', 'is', 'boy', 'bruce', 'handsome']sorted(chars,key=lambda x:len(x),reverse= True)Out[93]: ['handsome', 'bruce', 'boy', 'is', 'a']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="根据自定义规则来排序，对元组构成的列表进行排序"><a href="#根据自定义规则来排序，对元组构成的列表进行排序" class="headerlink" title="根据自定义规则来排序，对元组构成的列表进行排序"></a>根据自定义规则来排序，对元组构成的列表进行排序</h4><pre class="line-numbers language-none"><code class="language-none">tuple_list = [('A', 1,5), ('B', 3,2), ('C', 2,6)]##key=lambda x: x[1]中可以任意选定x中可选的位置进行排序sorted(tuple_list, key=lambda x: x[1]) Out[94]: [('A', 1, 5), ('C', 2, 6), ('B', 3, 2)]sorted(tuple_list, key=lambda x: x[0])Out[95]: [('A', 1, 5), ('B', 3, 2), ('C', 2, 6)]sorted(tuple_list, key=lambda x: x[2])Out[96]: [('B', 3, 2), ('A', 1, 5), ('C', 2, 6)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="排序的元素是自定义类"><a href="#排序的元素是自定义类" class="headerlink" title="排序的元素是自定义类"></a>排序的元素是自定义类</h4><pre class="line-numbers language-none"><code class="language-none">class tuple_list: def __init__(self, one, two, three):  self.one = one  self.two = two  self.three = three def __repr__(self):  return repr((self.one, self.two, self.three))tuple_list_ = [tuple_list('A', 1,5), tuple_list('B', 3,2), tuple_list('C', 2,6)]sorted(tuple_list_, key=lambda x: x.one)Out[104]: [('A', 1, 5), ('B', 3, 2), ('C', 2, 6)]sorted(tuple_list_, key=lambda x: x.two)Out[105]: [('A', 1, 5), ('C', 2, 6), ('B', 3, 2)]sorted(tuple_list_, key=lambda x: x.three)Out[106]: [('B', 3, 2), ('A', 1, 5), ('C', 2, 6)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="根据多个字段来排序"><a href="#根据多个字段来排序" class="headerlink" title="根据多个字段来排序"></a>根据多个字段来排序</h4><pre class="line-numbers language-none"><code class="language-none">class tuple_list: def __init__(self, one, two, three):  self.one = one  self.two = two  self.three = three def __repr__(self):  return repr((self.one, self.two, self.three))tuple_list_ = [tuple_list('C', 1,5), tuple_list('A', 3,2), tuple_list('C', 2,6)]## 首先根据one的位置来排序，然后根据two的位置来排序sorted(tuple_list_, key=lambda x:(x.one, x.two))Out[112]: [('A', 3, 2), ('C', 1, 5), ('C', 2, 6)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="二维排序"><a href="#二维排序" class="headerlink" title="二维排序"></a>二维排序</h4><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt;l=[('a', 1), ('b', 2), ('c', 6), ('d', 4), ('e', 3)]&gt;&gt;&gt;sorted(l, key=lambda x:x[0])Out[39]: [('a', 1), ('b', 2), ('c', 6), ('d', 4), ('e', 3)]&gt;&gt;&gt;sorted(l, key=lambda x:x[0], reverse=True)Out[40]: [('e', 3), ('d', 4), ('c', 6), ('b', 2), ('a', 1)]&gt;&gt;&gt;sorted(l, key=lambda x:x[1])Out[41]: [('a', 1), ('b', 2), ('e', 3), ('d', 4), ('c', 6)]&gt;&gt;&gt;sorted(l, key=lambda x:x[1], reverse=True)Out[42]: [('c', 6), ('d', 4), ('e', 3), ('b', 2), ('a', 1)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><h4 id="字符串切割"><a href="#字符串切割" class="headerlink" title="字符串切割"></a>字符串切割</h4><p>注：使用前需要引入包（import re）<br>功能：split能够按照所能匹配的字串将字符串进行切分，返回切分后的字符串列表<br>形式：</p><pre class="line-numbers language-none"><code class="language-none">re.split(pattern, string[, maxsplit=0, flags=0])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>pattern:匹配的字符串<br>string:需要切分的字符串<br>maxsplit:分隔次数，默认为0(即不限次数)<br>flags:标志位，用于控制正则表达式的匹配方式，比如：是否区分大小写，，，如下图所示</p><p>具体分析：</p><pre class="line-numbers language-none"><code class="language-none">//传入某个文件的绝对路径（file_path），根据 '\'进行分割，将结果存入列表，再取出最后一个，就是文件名。new_line= re.split(r'[/]',str(file_path))file_name=new_line[-1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="替换字符串中的匹配项"><a href="#替换字符串中的匹配项" class="headerlink" title="替换字符串中的匹配项"></a>替换字符串中的匹配项</h4><p><strong>re.sub()</strong> </p><pre><code>def sub(pattern, repl, string, count=0, flags=0):    """Return the string obtained by replacing the leftmost    non-overlapping occurrences of the pattern in string by the    replacement repl.  repl can be either a string or a callable;    if a string, backslash escapes in it are processed.  If it is    a callable, it's passed the match object and must return    a replacement string to be used."""    return _compile(pattern, flags).sub(repl, string, count)</code></pre><p>从上面的代码中可以看到re.sub()方法中含有5个参数，下面进行一一说明（加粗的为必须参数）：<br>（1）<strong>pattern</strong>：该参数表示正则中的模式字符串；<br>（2）<strong>repl</strong>：该参数表示要替换的字符串（即匹配到pattern后替换为repl），也可以是个函数；<br>（3）<strong>string</strong>：该参数表示要被处理（查找替换）的原始字符串；<br>（4）count：可选参数，表示是要替换的最大次数，而且必须是非负整数，该参数默认为0，即所有的匹配都会被替换；<br>（5）flags：可选参数，表示编译时用的匹配模式（如忽略大小写、多行模式等），数字形式，默认为0。</p><p>使用案例：<br><strong>1.匹配单一数字</strong><br>（1）只匹配单一数字</p><pre><code>&gt;&gt;&gt; import re&gt;&gt;&gt; s"大家好，我是一个程序员小白。I 'm so glad to introduce myself, and I’m 18 years old.   Today is 2020/01/01. It is a wonderful DAY! @HHHHello,,,#111ComeHere222...66？AA？zz？——http://welcome.cn"&gt;&gt;&gt; re.sub(r'[0-9]', '*', s)"大家好，我是一个程序员小白。I 'm so glad to introduce myself, and I’m ** years old.   Today is ****/**/**. It is a wonderful DAY! @HHHHello,,,#***ComeHere***...**？AA？zz？——http://welcome.cn"</code></pre><p>上面 re.sub(r’[0-9]’, ‘*’, s) 这句话则表示只匹配单一数字，并将每一个数字替换为一个星号 。</p><p>（2）只匹配单一字母</p><pre><code>&gt;&gt;&gt; s"大家好，我是一个程序员小白。I 'm so glad to introduce myself, and I’m 18 years old.   Today is 2020/01/01. It is a wonderful DAY! @HHHHello,,,#111ComeHere222...66？AA？zz？——http://welcome.cn"&gt;&gt;&gt; re.sub(r'[a-z]', '*', s)"大家好，我是一个程序员小白。I '* ** **** ** ********* ******, *** I’* 18 ***** ***.   T**** ** 2020/01/01. I* ** * ********* DAY! @HHHH****,,,#111C***H***222...66？AA？**？——****://*******.**"&gt;&gt;&gt; re.sub(r'[A-Z]', '*', s)"大家好，我是一个程序员小白。* 'm so glad to introduce myself, and *’m 18 years old.   *oday is 2020/01/01. *t is a wonderful ***! @****ello,,,#111*ome*ere222...66？**？zz？——http://welcome.cn"&gt;&gt;&gt; re.sub(r'[A-Za-z]', '*', s)"大家好，我是一个程序员小白。* '* ** **** ** ********* ******, *** *’* 18 ***** ***.   ***** ** 2020/01/01. ** ** * ********* ***! @********,,,#111********222...66？**？**？——****://*******.**"</code></pre><p>上面 re.sub(r’[a-z]’, ‘<em>‘, s) 这句话则表示只匹配单一小写字母，并将每一个小写字母替换为一个星号 。<br>上面 re.sub(r’[A-Z]’, ‘</em>‘, s) 这句话则表示只匹配单一大写字母，并将每一个大写字母替换为一个星号 。<br>上面 re.sub(r’[A-Za-z]’, ‘*’, s) 这句话则表示只匹配单一字母，并将每一个字母替换为一个星号 。</p><p>（3）匹配单一数字和字母</p><pre><code>&gt;&gt;&gt; s"大家好，我是一个程序员小白。I 'm so glad to introduce myself, and I’m 18 years old.   Today is 2020/01/01. It is a wonderful DAY! @HHHHello,,,#111ComeHere222...66？AA？zz？——http://welcome.cn"&gt;&gt;&gt; re.sub(r'[0-9A-Z]', '*', s)"大家好，我是一个程序员小白。* 'm so glad to introduce myself, and *’m ** years old.   *oday is ****/**/**. *t is a wonderful ***! @****ello,,,#****ome*ere***...**？**？zz？——http://welcome.cn"&gt;&gt;&gt; re.sub(r'[0-9a-z]', '*', s)"大家好，我是一个程序员小白。I '* ** **** ** ********* ******, *** I’* ** ***** ***.   T**** ** ****/**/**. I* ** * ********* DAY! @HHHH****,,,#***C***H******...**？AA？**？——****://*******.**"&gt;&gt;&gt; re.sub(r'[0-9A-Za-z]', '*', s)"大家好，我是一个程序员小白。* '* ** **** ** ********* ******, *** *’* ** ***** ***.   ***** ** ****/**/**. ** ** * ********* ***! @********,,,#**************...**？**？**？——****://*******.**"</code></pre><p>上面 re.sub(r’[0-9A-Z]’, ‘<em>‘, s) 这句话则表示只匹配单一数字和大写字母，并将每一个数字和大写字母替换为一个星号 。<br>上面 re.sub(r’[0-9a-z]’, ‘</em>‘, s) 这句话则表示只匹配单一数字和小写字母，并将每一个数字和小写字母替换为一个星号 。<br>上面 re.sub(r’[0-9A-Za-z]’, ‘*’, s) 这句话则表示只匹配单一数字和字母，并将每一个数字和字母替换为一个星号 。</p><p><strong>2.匹配多个数字或字母</strong><br>注意：这里的所说的多个指的是大于等于一个。</p><p>（1）匹配多个数字</p><pre><code>&gt;&gt;&gt; s"大家好，我是一个程序员小白。I 'm so glad to introduce myself, and I’m 18 years old.   Today is 2020/01/01. It is a wonderful DAY! @HHHHello,,,#111ComeHere222...66？AA？zz？——http://welcome.cn"&gt;&gt;&gt; re.sub(r'[0-9]+', '*', s)"大家好，我是一个程序员小白。I 'm so glad to introduce myself, and I’m * years old.   Today is */*/*. It is a wonderful DAY! @HHHHello,,,#*ComeHere*...*？AA？zz？——http://welcome.cn"</code></pre><p>上面 re.sub(r’[0-9]+’, ‘*’, s) 这句话则表示匹配多个连续的数字，并将多个连续的数字替换为一个星号 。</p><p>（2）匹配多个字母</p><pre><code>&gt;&gt;&gt; s"大家好，我是一个程序员小白。I 'm so glad to introduce myself, and I’m 18 years old.   Today is 2020/01/01. It is a wonderful DAY! @HHHHello,,,#111ComeHere222...66？AA？zz？——http://welcome.cn"&gt;&gt;&gt; re.sub(r'[a-z]+', '*', s)"大家好，我是一个程序员小白。I '* * * * * *, * I’* 18 * *.   T* * 2020/01/01. I* * * * DAY! @HHHH*,,,#111C*H*222...66？AA？*？——*://*.*"&gt;&gt;&gt; re.sub(r'[A-Z]+', '*', s)"大家好，我是一个程序员小白。* 'm so glad to introduce myself, and *’m 18 years old.   *oday is 2020/01/01. *t is a wonderful *! @*ello,,,#111*ome*ere222...66？*？zz？——http://welcome.cn"&gt;&gt;&gt; re.sub(r'[a-zA-Z]+', '*', s)"大家好，我是一个程序员小白。* '* * * * * *, * *’* 18 * *.   * * 2020/01/01. * * * * *! @*,,,#111*222...66？*？*？——*://*.*"</code></pre><p>上面 re.sub(r’[a-z]+’, ‘<em>‘, s) 这句话则表示匹配多个连续的小写字母，并将多个连续的小写字母替换为一个星号 。<br>上面 re.sub(r’[A-Z]+’, ‘</em>‘, s) 这句话则表示匹配多个连续的大写字母，并将多个连续的大写字母替换为一个星号 。<br>上面 re.sub(r’[A-Za-z]+’, ‘*’, s) 这句话则表示匹配多个连续的字母，并将多个连续的字母替换为一个星号 。</p><p>（3）匹配多个数字和字母</p><pre><code>&gt;&gt;&gt; s"大家好，我是一个程序员小白。I 'm so glad to introduce myself, and I’m 18 years old.   Today is 2020/01/01. It is a wonderful DAY! @HHHHello,,,#111ComeHere222...66？AA？zz？——http://welcome.cn"&gt;&gt;&gt; re.sub(r'[0-9a-zA-Z]+', '*', s)"大家好，我是一个程序员小白。* '* * * * * *, * *’* * * *.   * * */*/*. * * * * *! @*,,,#*...*？*？*？——*://*.*"</code></pre><p>上面 re.sub(r’[0-9A-Za-z]+’, ‘*’, s) 这句话则表示匹配多个连续的数字和字母，并将多个连续的数字、连续的字母、连续的数字和字母替换为一个星号 。</p><p><strong>3.匹配其他</strong></p><p>（1）匹配非数字</p><pre><code>&gt;&gt;&gt; s"大家好，我是一个程序员小白。I 'm so glad to introduce myself, and I’m 18 years old.   Today is 2020/01/01. It is a wonderful DAY! @HHHHello,,,#111ComeHere222...66？AA？zz？——http://welcome.cn"&gt;&gt;&gt; re.sub(r'[^0-9]', '*', s)'********************************************************18***********************2020*01*01**************************************111********222***66**************************'&gt;&gt;&gt; re.sub(r'[^0-9]+', '*', s)'*18*2020*01*01*111*222*66*'</code></pre><p>上面 re.sub(r’[^0-9]’, ‘<em>‘, s) 这句话则表示匹配单个非数字，并将单个非数字替换为一个星号 。<br>上面 re.sub(r’[^0-9]+’, ‘</em>‘, s) 这句话则表示匹配多个连续的非数字，并将多个连续的非数字替换为一个星号 。</p><p>（2）匹配非字母</p><pre><code>&gt;&gt;&gt; s"大家好，我是一个程序员小白。I 'm so glad to introduce myself, and I’m 18 years old.   Today is 2020/01/01. It is a wonderful DAY! @HHHHello,,,#111ComeHere222...66？AA？zz？——http://welcome.cn"&gt;&gt;&gt; re.sub(r'[^a-z]', '*', s)'*****************m*so*glad*to*introduce*myself**and***m****years*old*****oday*is**************t*is*a*wonderful***********ello********ome*ere************zz***http***welcome*cn'&gt;&gt;&gt; re.sub(r'[^A-Z]', '*', s)'**************I*************************************I*******************T********************I*****************DAY***HHHH***********C***H************AA***********************'&gt;&gt;&gt; re.sub(r'[^A-Za-z]', '*', s)'**************I**m*so*glad*to*introduce*myself**and*I*m****years*old****Today*is*************It*is*a*wonderful*DAY***HHHHello*******ComeHere*********AA*zz***http***welcome*cn'&gt;&gt;&gt; re.sub(r'[^a-z]+', '*', s)'*m*so*glad*to*introduce*myself*and*m*years*old*oday*is*t*is*a*wonderful*ello*ome*ere*zz*http*welcome*cn'&gt;&gt;&gt; re.sub(r'[^A-Z]+', '*', s)'*I*I*T*I*DAY*HHHH*C*H*AA*'&gt;&gt;&gt; re.sub(r'[^A-Za-z]+', '*', s)'*I*m*so*glad*to*introduce*myself*and*I*m*years*old*Today*is*It*is*a*wonderful*DAY*HHHHello*ComeHere*AA*zz*http*welcome*cn'</code></pre><p>上面 re.sub(r’[^a-z]’, ‘<em>‘, s) 这句话则表示匹配单个非小写字母，并将单个非小写字母替换为一个星号 。<br>上面 re.sub(r’[^A-Z]’, ‘</em>‘, s) 这句话则表示匹配单个非大写字母，并将单个非大写字母替换为一个星号 。<br>上面 re.sub(r’[^A-Za-z]’, ‘<em>‘, s) 这句话则表示匹配单个非字母，并将单个非字母替换为一个星号 。<br>上面 re.sub(r’[^a-z]+’, ‘</em>‘, s) 这句话则表示匹配多个连续的非小写字母，并将多个连续的非小写字母替换为一个星号 。<br>上面 re.sub(r’[^A-Z]+’, ‘<em>‘, s) 这句话则表示匹配多个连续的非大写字母，并将多个连续的非大写字母替换为一个星号 。<br>上面 re.sub(r’[^A-Za-z]+’, ‘</em>‘, s) 这句话则表示匹配多个连续的非字母，并将多个连续的非字母替换为一个星号 。</p><p>（3）匹配非数字和非字母</p><pre><code>&gt;&gt;&gt; s"大家好，我是一个程序员小白。I 'm so glad to introduce myself, and I’m 18 years old.   Today is 2020/01/01. It is a wonderful DAY! @HHHHello,,,#111ComeHere222...66？AA？zz？——http://welcome.cn"&gt;&gt;&gt; re.sub(r'[^0-9A-Za-z]', '*', s)'**************I**m*so*glad*to*introduce*myself**and*I*m*18*years*old****Today*is*2020*01*01**It*is*a*wonderful*DAY***HHHHello****111ComeHere222***66*AA*zz***http***welcome*cn'&gt;&gt;&gt; re.sub(r'[^0-9A-Za-z]+', '*', s)'*I*m*so*glad*to*introduce*myself*and*I*m*18*years*old*Today*is*2020*01*01*It*is*a*wonderful*DAY*HHHHello*111ComeHere222*66*AA*zz*http*welcome*cn'</code></pre><p>上面 re.sub(r’[^0-9A-Za-z]’, ‘<em>‘, s) 这句话则表示匹配单个非数字和非字母，并将单个非数字和非字母替换为一个星号 。<br>上面 re.sub(r’[^0-9A-Za-z]+’, ‘</em>‘, s) 这句话则表示匹配多个连续的非数字和非字母，并将多个连续的非数字和非字母替换为一个星号 。</p><p>（4）匹配固定形式<br>a.只保留字母和空格，将 repl 设置为空字符即可。</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; s"大家好，我是一个程序员小白。I 'm so glad to introduce myself, and I’m 18 years old.   Today is 2020/01/01. It is a wonderful DAY! @HHHHello,,,#111ComeHere222...66？AA？zz？——http://welcome.cn"&gt;&gt;&gt; re.sub(r'[^a-z ]', '', s)' m so glad to introduce myself and m  years old   oday is  t is a wonderful  elloomeerezzhttpwelcomecn'&gt;&gt;&gt; re.sub(r'[^a-z ]+', '', s)' m so glad to introduce myself and m  years old   oday is  t is a wonderful  elloomeerezzhttpwelcomecn'&gt;&gt;&gt; re.sub(r'[^A-Za-z ]', '', s)'I m so glad to introduce myself and Im  years old   Today is  It is a wonderful DAY HHHHelloComeHereAAzzhttpwelcomecn'&gt;&gt;&gt; re.sub(r'[^A-Za-z ]+', '', s)'I m so glad to introduce myself and Im  years old   Today is  It is a wonderful DAY HHHHelloComeHereAAzzhttpwelcomecn'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果要使句子语义和结构更完整，则要先将其余字符替换为空格（即repl设置为空格），然后去除多余的空格，如下：</p><pre><code>&gt;&gt;&gt; s1 = re.sub(r'[^A-Za-z ]+', ' ', s)&gt;&gt;&gt; s1' I  m so glad to introduce myself  and I m   years old    Today is   It is a wonderful DAY   HHHHello ComeHere AA zz http welcome cn'&gt;&gt;&gt; re.sub(r'[ ]+', ' ', s1)' I m so glad to introduce myself and I m years old Today is It is a wonderful DAY HHHHello ComeHere AA zz http welcome cn'</code></pre><p>b.去除以 @ 开头的英文单词</p><pre><code>&gt;&gt;&gt; s"大家好，我是一个程序员小白。I 'm so glad to introduce myself, and I’m 18 years old.   Today is 2020/01/01. It is a wonderful DAY! @HHHHello,,,#111ComeHere222...66？AA？zz？——http://welcome.cn"&gt;&gt;&gt; re.sub(r'@[A-Za-z]+', '', s)"大家好，我是一个程序员小白。I 'm so glad to introduce myself, and I’m 18 years old.   Today is 2020/01/01. It is a wonderful DAY! ,,,#111ComeHere222...66？AA？zz？——http://welcome.cn"</code></pre><p>c.去除以 ？结尾的英文单词和数字（注意这是中文问号）</p><pre><code>&gt;&gt;&gt; s"大家好，我是一个程序员小白。I 'm so glad to introduce myself, and I’m 18 years old.   Today is 2020/01/01. It is a wonderful DAY! @HHHHello,,,#111ComeHere222...66？AA？zz？——http://welcome.cn"&gt;&gt;&gt; re.sub(r'[A-Za-z]+？', '', s)"大家好，我是一个程序员小白。I 'm so glad to introduce myself, and I’m 18 years old.   Today is 2020/01/01. It is a wonderful DAY! @HHHHello,,,#111ComeHere222...66？——http://welcome.cn"&gt;&gt;&gt; re.sub(r'[0-9A-Za-z]+？', '', s)"大家好，我是一个程序员小白。I 'm so glad to introduce myself, and I’m 18 years old.   Today is 2020/01/01. It is a wonderful DAY! @HHHHello,,,#111ComeHere222...——http://welcome.cn"</code></pre><p>d.去除原始字符串中的URL</p><pre><code>&gt;&gt;&gt; s"大家好，我是一个程序员小白。I 'm so glad to introduce myself, and I’m 18 years old.   Today is 2020/01/01. It is a wonderful DAY! @HHHHello,,,#111ComeHere222...66？AA？zz？——http://welcome.cn"&gt;&gt;&gt; re.sub(r'http[:.]+\S+', '', s)"大家好，我是一个程序员小白。I 'm so glad to introduce myself, and I’m 18 years old.   Today is 2020/01/01. It is a wonderful DAY! @HHHHello,,,#111ComeHere222...66？AA？zz？——"</code></pre><h4 id="字符串提取–提取数字"><a href="#字符串提取–提取数字" class="headerlink" title="字符串提取–提取数字"></a>字符串提取–提取数字</h4><pre class="line-numbers language-none"><code class="language-none">re.findall(r'\d+', str(string))// '\d'是正则表达式，+表示匹配多个，如果不加，就是单个的数字<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="字符串相似度比较"><a href="#字符串相似度比较" class="headerlink" title="字符串相似度比较"></a>字符串相似度比较</h4><p>python自带比较相似度的模块，difflib。比较两个字符串的模块是difflib.SequenceMatcher，使用起来很简单：</p><pre class="line-numbers language-none"><code class="language-none">import difflib def string_similar(s1, s2):    return difflib.SequenceMatcher(None, s1, s2).quick_ratio() print string_similar('爱尔眼科沪滨医院', '沪滨爱尔眼科医院')print string_similar('安定区妇幼保健站', '定西市安定区妇幼保健站')print string_similar('广州市医院', '广东省中医院')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-none"><code class="language-none">1.00.8421052631580.606060606061<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中None的位置是一个函数，用来去掉自己不想算在内的元素。比如我想把空格排除在外：</p><pre class="line-numbers language-none"><code class="language-none">seq = difflib.SequenceMatcher(lambda x:x=" ", a, b)ratio = seq.ratio()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="去掉字符串两端的引号"><a href="#去掉字符串两端的引号" class="headerlink" title="去掉字符串两端的引号"></a>去掉字符串两端的引号</h4><p>背景：有时候会出现这种情况的字符串<code>'"srting"'</code>，用type查看，是string。如果里面是整数，需要和某个整数比大小，没法直接用int强制转，需要先去掉外面那层引号</p><pre class="line-numbers language-none"><code class="language-none">方法：eval()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例子：</p><pre class="line-numbers language-none"><code class="language-none">a='"srting"'print(a)b=eval(a)print(b)//输出//"srting"//srting<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>eval()用途：<br><img src="https://img-blog.csdnimg.cn/488f4321054b442b97e9b42813e0e565.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/a384434e602d4276b5b6da7546bc67db.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/33d9dc9d343b4111afabc96caceac82d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/9fec5d3536be40d1ad0676f202dd95bc.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/bed4ceca7318472d959ef280c707247c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h4 id="字符串转数字，数字转字符串"><a href="#字符串转数字，数字转字符串" class="headerlink" title="字符串转数字，数字转字符串"></a>字符串转数字，数字转字符串</h4><p>字符串str转数字:<br>float(str)<br>int(str)</p><p>数字num转字符串<br>str(num)</p><h3 id="变量转换"><a href="#变量转换" class="headerlink" title="变量转换"></a>变量转换</h3><p><strong>字符串、数字互转看字符串里面的操作</strong></p><h4 id="数字、bytes"><a href="#数字、bytes" class="headerlink" title="数字、bytes"></a>数字、bytes</h4><p>数字num转bytes:<br>需将num转为str，再利用codec的encode函数，将str转为bytes：encode(str(num))</p><p>bytes转数字:<br>int(bytes)<br>float(bytes)</p><h4 id="字符串、bytes"><a href="#字符串、bytes" class="headerlink" title="字符串、bytes"></a>字符串、bytes</h4><p>字符串转bytes:</p><pre class="line-numbers language-none"><code class="language-none">from codec import encode,decodeencode(str)//法二bytes(str,'UTF-8')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>bytes转字符串：</p><pre class="line-numbers language-none"><code class="language-none">//法一from codec import encode,decodedecode(bytes)//法二str(bytes,'UTF-8')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="循环删除元素"><a href="#循环删除元素" class="headerlink" title="循环删除元素"></a>循环删除元素</h3><p><strong>循环删除列表中元素时千万别用正序遍历，一定要用反序遍历！</strong></p><pre class="line-numbers language-none"><code class="language-none">def test(data):    for i in data:        data.remove(i)    return datadata = [1, 2, 3]print(test(data))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>面对以上代码，乍一看以为会打印出空列表，因为test函数内通过for的方法将data中的元素都删除了，其实不然，实际输出如下：<br>原列表在内存中为：<br><img src="https://img-blog.csdnimg.cn/img_convert/bdec075c9903308b5eb69f34f3b4cad1.png#pic_center" alt="在这里插入图片描述"><br>第一次执行到data.remove(i)时将第一个元素‘1’删除，列表变为：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/26822bd2c18f3bb60a2028511ca0060d.png#pic_center" alt="在这里插入图片描述"><br>第二次执行到data.remove(i)时i为第二个元素，即‘3’，此时将‘3’删除，列表变为：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/79bbdbbe59e7d8d84f527e62a5bb581d.png#pic_center" alt="在这里插入图片描述"><br>此时列表已经没有第三个元素了，即退出循环，将[2]返回。<br>如何解决这个问题呢？ 我们可以用倒序删除的方法！</p><pre class="line-numbers language-none"><code class="language-none">def test(data):    for i in data[::-1]:        data.remove(i)    return datadata = [1, 2, 3]print(test(data))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="列表相关操作"><a href="#列表相关操作" class="headerlink" title="列表相关操作"></a>列表相关操作</h3><h4 id="列表头部插入元素"><a href="#列表头部插入元素" class="headerlink" title="列表头部插入元素"></a>列表头部插入元素</h4><pre class="line-numbers language-none"><code class="language-none">names.insert(0,'Bill') //第一个参数表示索引<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="两个列表取交集"><a href="#两个列表取交集" class="headerlink" title="两个列表取交集"></a>两个列表取交集</h4><pre class="line-numbers language-none"><code class="language-none">a=[i for i in list2 if i  in list1]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-none"><code class="language-none">list(set(a).intersection(b))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="列表取并集"><a href="#列表取并集" class="headerlink" title="列表取并集"></a>列表取并集</h4><pre class="line-numbers language-none"><code class="language-none">list(set(a).union(b))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">list(set(a) | set(b))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>多个列表取并集：</strong></p><pre class="line-numbers language-none"><code class="language-none">list(set(a).intersection(b,c)) <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="列表取差集"><a href="#列表取差集" class="headerlink" title="列表取差集"></a>列表取差集</h4><pre class="line-numbers language-none"><code class="language-none">list(set(a).difference(b))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">list(set(a).difference(b,c)) # 求特定1个list(a)中有，其他list(b、c)都没有的元素"""<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="列表排序（更详细操作见文档）"><a href="#列表排序（更详细操作见文档）" class="headerlink" title="列表排序（更详细操作见文档）"></a>列表排序（更详细操作见文档）</h4><pre class="line-numbers language-none"><code class="language-none">file_list.sort(key=lambda x:int(x[9:-4]))//根据关键字来排序，lambda是一个函数的简写。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">//下面两个写法是一样的g = lambda x:x+1 def g(x):     return x+1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="列表替换元素（更详细操作见文档）"><a href="#列表替换元素（更详细操作见文档）" class="headerlink" title="列表替换元素（更详细操作见文档）"></a>列表替换元素（更详细操作见文档）</h4><p>1.直接替换</p><pre class="line-numbers language-none"><code class="language-none">//假设要把列表中的a元素替换为b//首先得到a的索引，将这个索引的值赋为blist[list.index(a)]=b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>2.条件替换</p><pre class="line-numbers language-none"><code class="language-none"> lst = ['1', '2', '3'] rep = ['4' if x == '2' else x for x in lst] rep['1', '4', '3']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.批量替换</p><pre class="line-numbers language-none"><code class="language-none"> lst = ['1', '2', '3', '4', '5']pattern = ['3', '4']rep = ['d' if x in pattern else x for x in lst]rep['1', '2', 'd', 'd', '5']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4.映射替换</p><pre class="line-numbers language-none"><code class="language-none"> lst = ['1', '2', '3', '4', '5'] pattern = {'3':'three', '4':'four'} rep = [pattern[x] if x in pattern else x for x in lst]rep['1', '2', 'three', 'four', '5']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="列表截取元素"><a href="#列表截取元素" class="headerlink" title="列表截取元素"></a>列表截取元素</h4><p>l=list[0:4]</p><p>注意：列表的正向索引下标是从零开始，不是1，反向索引是到-1结束，不是0</p><p>正向索引（01234…）</p><p>1.只有头下标i和冒号（代表的是从该头下标i的元素开始截取，一直到最后）</p><p>2.只有冒号尾下标i（代表的是从开始一直截取到i-1的元素）</p><p>3.头下标i，冒号和尾下标j都有（代表的是从i一直截取到j-1的元素）</p><p>例程如下：</p><pre class="line-numbers language-none"><code class="language-none">list=['123','abc',0,True]x=list[1:]y=list[:3]z=list[2:3]print(x)print(y)print['abc', 0, True]['123', 'abc', 0][0]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>反向索引（……-2-1）</p><p>1.只有头下标i和冒号（代表的是从该头下标i的元素开始截取，一直到最后）</p><p>2.只有冒号尾下标i（代表的是从开始一直截取到i-1的元素）</p><p>3.头下标i，冒号和尾下标j都有（代表的是从i一直截取到j-1的元素</p><p>例程如下：</p><pre class="line-numbers language-none"><code class="language-none">list=['123','abc',0,True]x=list[-3:]y=list[:-2]z=list[-3:-1]print(x)print(y)print(z)['abc', 0, True]['123', 'abc']['abc', 0]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>加入步长的截取：</strong></p><p>前面讲到的截取是没有带步长的。如果想隔一定元素个数去截取列表，可以选择使用带有步长的截取方式</p><p>格式：</p><p>变量[头下标:尾下标:步长]<br>例如截取第三个到第五个元素，如果隔两个步长截取的话，就会截取到元素3和元素5，元素4就被跳过了</p><h4 id="列表查找重复元素"><a href="#列表查找重复元素" class="headerlink" title="列表查找重复元素"></a>列表查找重复元素</h4><p>推荐方法二</p><pre class="line-numbers language-none"><code class="language-none">方法一：mylist = [1,2,2,2,2,3,3,3,4,4,4,4]myset = set(mylist)for item in myset:    print("the %d has found %d" %(item,mylist.count(item)))the 1 has found 1the 2 has found 4the 3 has found 3the 4 has found 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">方法二：from collections import Countera = [1, 2, 3, 4, 3, 2, "奔奔", "benben", "奔奔"]b = dict(Counter(a))## 只展示重复元素print ([key for key,value in b.items() if value &gt; 1])## 展现重复元素和重复次数print ({key:value for key,value in b.items()if value &gt; 1})//结果[2, 3, '奔奔']{2: 2, 3: 2, '奔奔': 2}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">方法三：List=[1,2,2,2,2,3,3,3,4,4,4,4] a = {}for i in List:     if List.count(i)&gt;1:         a[i] = List.count(i)   print (a)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="XML相关操作"><a href="#XML相关操作" class="headerlink" title="XML相关操作"></a>XML相关操作</h3><h4 id="创建一个XML文档"><a href="#创建一个XML文档" class="headerlink" title="创建一个XML文档"></a>创建一个XML文档</h4><pre class="line-numbers language-none"><code class="language-none">import xml.dom.minidomimport re,oslist=['a', 'b', 'str_scheme_name', 'str_limiter']doc = xml.dom.minidom.Document() root = doc.createElement('version-check')doc.appendChild(root)for i in list:    var_name = doc.createElement(i)    version=doc.createElement('version')    version.setAttribute('v','100')    version.appendChild(doc.createTextNode(i))    var_name.appendChild(version)    root.appendChild(var_name)fp = open('C:/Users/76585/Desktop/shell/cfdname2/tow.xml', 'w')doc.writexml(fp, indent='\t', addindent='\t', newl='\n', encoding="utf-8")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="对现有XML文档进行修改"><a href="#对现有XML文档进行修改" class="headerlink" title="对现有XML文档进行修改"></a>对现有XML文档进行修改</h4><pre class="line-numbers language-none"><code class="language-none">tree=ET.parse('C:/Users/76585/Desktop/shell/cfdname2/tow.xml')         root=tree.getroot()// b是一个列表         for i in b:             newnode=ET.Element(i)             version=ET.Element('version')             version.attrib={"v":end}             version.text=i             newnode.append(version)             # newnode.text=end               root.append(newnode)             tree.write('C:/Users/76585/Desktop/shell/cfdname2/tow.xml')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><h4 id="特殊的去首尾空格方法"><a href="#特殊的去首尾空格方法" class="headerlink" title="特殊的去首尾空格方法"></a>特殊的去首尾空格方法</h4><p>strip是trim掉字符串两边的空格。<br>lstrip, trim掉左边的空格<br>rstrip, trim掉右边的空格</p><pre class="line-numbers language-none"><code class="language-none">theString = ' https://mp.csdn.net/postlist ' print theString.strip()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="判断情况总结"><a href="#判断情况总结" class="headerlink" title="判断情况总结"></a>判断情况总结</h3><h4 id="判断目录下的空文件夹并删除"><a href="#判断目录下的空文件夹并删除" class="headerlink" title="判断目录下的空文件夹并删除"></a>判断目录下的空文件夹并删除</h4><pre class="line-numbers language-none"><code class="language-none">## 导入osimport os## 让用户自行输入路径path=input('请输入文件目录路径')## 获取当前目录下的所有文件夹名称  得到的是一个列表folders=os.listdir(path)## # 遍历列表for folder in folders:    # 将上级路径path与文件夹名称folder拼接出文件夹的路径    folder2=os.listdir(path+'\\'+folder)    print(folder2)    # 若文件夹为空    if folder2==[]:        # 则打印此空文件的名称        print(folder)        # 并将此空文件夹删除        os.rmdir(path+'\\'+folder)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="判断文件内容为空"><a href="#判断文件内容为空" class="headerlink" title="判断文件内容为空"></a>判断文件内容为空</h4><p><strong>方法： size = os.path.getsize(file_path)</strong></p><ol><li>结果：如果 size == 0，则文件内容为空；</li><li>上述的 file_path 为需要判断大小的文件的存放路径。</li></ol><pre class="line-numbers language-none"><code class="language-none">if os.path.getsize(file_path) == 0:print('文件内容为空')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="变量类型判断"><a href="#变量类型判断" class="headerlink" title="变量类型判断"></a>变量类型判断</h4><blockquote><p>1、isinstance(参数1,参数2)<br><br><br>描述：该函数用来判断一个变量（参数1）是否是已知的变量类型(参数2) 类似于type()</p><p>参数1：变量</p><p>参数2：可以是直接或间接类名、基本类型或者由它们组成的元组。</p><p>返回值: 如果对象的类型与参数二的类型（classinfo）相同则返回 True，否则返回 False</p></blockquote><p><strong>方法2</strong></p><pre class="line-numbers language-none"><code class="language-none">type(num)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="深拷贝–deep-copy"><a href="#深拷贝–deep-copy" class="headerlink" title="深拷贝–deep copy"></a>深拷贝–deep copy</h3><p>背景：</p><pre class="line-numbers language-none"><code class="language-none">dict_min['name']=new_line[1]dict_mid[new_line[1]]=dict_min<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上面这段代码中，newline[1]发生变化时，dict_min发生变化，从而导致dict_mid受到影响。具体的效果<br><img src="https://img-blog.csdnimg.cn/27eafe4c3413473b8de9f92567056d70.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>name的值会依次被后面的值覆盖，但我们不希望之前的收到影响。</p><p>解决办法：</p><pre class="line-numbers language-none"><code class="language-none">dict_min['name']=new_line[1]dict_tmp=copy.deepcopy(dict_min)      dict_mid[new_line[1]]=dict_tmp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>看下深拷贝的例子：</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; import copy&gt;&gt;&gt; origin = [1, 2, [3, 4]]##origin 里边有三个元素：1， 2，[3, 4]&gt;&gt;&gt; cop1 = copy.copy(origin)&gt;&gt;&gt; cop2 = copy.deepcopy(origin)&gt;&gt;&gt; cop1 == cop2True&gt;&gt;&gt; cop1 is cop2False ##cop1 和 cop2 看上去相同，但已不再是同一个object&gt;&gt;&gt; origin[2][0] = "hey!" &gt;&gt;&gt; origin[1, 2, ['hey!', 4]]&gt;&gt;&gt; cop1[1, 2, ['hey!', 4]]&gt;&gt;&gt; cop2[1, 2, [3, 4]]##把origin内的子list [3, 4] 改掉了一个元素，观察 cop1 和 cop2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到 cop1，也就是 shallow copy 跟着 origin 改变了。而 cop2 ，也就是 deep copy 并没有变。</p><p>似乎 deep copy 更加符合我们对「复制」的直觉定义: 一旦复制出来了，就应该是独立的了。如果我们想要的是一个字面意义的「copy」，那就直接用 deep_copy 即可。</p><p>那么为什么会有 shallow copy 这样的「假」 copy 存在呢？ 这就是有意思的地方了。</p><p><strong>python的数据存储方式</strong><br>Python 存储变量的方法跟其他 OOP 语言不同。它与其说是把值赋给变量，不如说是给变量建立了一个到具体值的 reference。</p><p>当在 Python 中 a = something 应该理解为给 something 贴上了一个标签 a。当再赋值给 a 的时候，就好象把 a 这个标签从原来的 something 上拿下来，贴到其他对象上，建立新的 reference。 这就解释了一些 Python 中可能遇到的诡异情况：</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt; a = [1, 2, 3]&gt;&gt;&gt; b = a&gt;&gt;&gt; a = [4, 5, 6] //赋新的值给 a&gt;&gt;&gt; a[4, 5, 6]&gt;&gt;&gt; b[1, 2, 3]## a 的值改变后，b 并没有随着 a 变&gt;&gt;&gt; a = [1, 2, 3]&gt;&gt;&gt; b = a&gt;&gt;&gt; a[0], a[1], a[2] = 4, 5, 6 //改变原来 list 中的元素&gt;&gt;&gt; a[4, 5, 6]&gt;&gt;&gt; b[4, 5, 6]## a 的值改变后，b 随着 a 变了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面两段代码中，a 的值都发生了变化。区别在于，第一段代码中是直接赋给了 a 新的值（从 [1, 2, 3] 变为 [4, 5, 6]）；而第二段则是把 list 中每个元素分别改变。</p><p>而对 b 的影响则是不同的，一个没有让 b 的值发生改变，另一个变了。怎么用上边的道理来解释这个诡异的不同呢？</p><p>首次把 [1, 2, 3] 看成一个物品。a = [1, 2, 3] 就相当于给这个物品上贴上 a 这个标签。而 b = a 就是给这个物品又贴上了一个 b 的标签。</p><p>第一种情况：</p><p>a = [4, 5, 6] 就相当于把 a 标签从 [1 ,2, 3] 上撕下来，贴到了 [4, 5, 6] 上。</p><p>在这个过程中，[1, 2, 3] 这个物品并没有消失。 b 自始至终都好好的贴在 [1, 2, 3] 上，既然这个 reference 也没有改变过。 b 的值自然不变。</p><p>第二种情况：</p><p>a[0], a[1], a[2] = 4, 5, 6 则是直接改变了 [1, 2, 3] 这个物品本身。把它内部的每一部分都重新改装了一下。内部改装完毕后，[1, 2, 3] 本身变成了 [4, 5, 6]。</p><p>而在此过程当中，a 和 b 都没有动，他们还贴在那个物品上。因此自然 a b 的值都变成了 [4, 5, 6]。</p><p>搞明白这个之后就要问了，<strong>对于一个复杂对象的浅copy，在copy的时候到底发生了什么？</strong><br>再看一段代码：</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; import copy&gt;&gt;&gt; origin = [1, 2, [3, 4]]##origin 里边有三个元素：1， 2，[3, 4]&gt;&gt;&gt; cop1 = copy.copy(origin)&gt;&gt;&gt; cop2 = copy.deepcopy(origin)&gt;&gt;&gt; cop1 == cop2True&gt;&gt;&gt; cop1 is cop2False ##cop1 和 cop2 看上去相同，但已不再是同一个object&gt;&gt;&gt; origin[2][0] = "hey!" &gt;&gt;&gt; origin[1, 2, ['hey!', 4]]&gt;&gt;&gt; cop1[1, 2, ['hey!', 4]]&gt;&gt;&gt; cop2[1, 2, [3, 4]]##把origin内的子list [3, 4] 改掉了一个元素，观察 cop1 和 cop2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>学过docker的人应该对镜像这个概念不陌生，我们可以把镜像的概念套用在copy上面。</p><p>copy对于一个复杂对象的子对象并不会完全复制，什么是复杂对象的子对象呢？就比如序列里的嵌套序列，字典里的嵌套序列等都是复杂对象的子对象。对于子对象，python会把它当作一个公共镜像存储起来，所有对他的复制都被当成一个引用，所以说当其中一个引用将镜像改变了之后另一个引用使用镜像的时候镜像已经被改变了。</p><p>所以说看这里的origin[2]，也就是 [3, 4] 这个 list。根据 shallow copy 的定义，在 cop1[2] 指向的是同一个 list [3, 4]。那么，如果这里我们改变了这个 list，就会导致 origin 和 cop1 同时改变。这就是为什么上边 origin[2][0] = “hey!” 之后，cop1 也随之变成了 [1, 2, [‘hey!’, 4]]。</p><p>deepcopy的时候会将复杂对象的每一层复制一个单独的个体出来。<br>这时候的 origin[2] 和 cop2[2] 虽然值都等于 [3, 4]，但已经不是同一个 list了。即我们寻常意义上的复制。</p><h3 id="json相关操作"><a href="#json相关操作" class="headerlink" title="json相关操作"></a>json相关操作</h3><p><strong>dumps和dump 序列化方法</strong><br>dumps只完成了序列化为str，<br>dump必须传文件描述符，将序列化的str保存到文件中<br>下面使用实际的例子依次介绍：</p><pre class="line-numbers language-none"><code class="language-none">import jsonkey={ "people": [{ "Name": "Brett", "名字":"McLaughlin", '1': 1 },{ "Name": "Jason", "名字":"Hunter", '2': 1},{ "Name": "Elliotte", "名字":"Harold", '3': 1 }]}print(json.dumps(key,sort_keys=True,indent =4,ensure_ascii=False))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出效果如下：</p><pre class="line-numbers language-none"><code class="language-none">{    "people": [        {            "1": 1,            "Name": "Brett",            "名字": "McLaughlin"        },        {            "2": 1,            "Name": "Jason",            "名字": "Hunter"        },        {            "3": 1,            "Name": "Elliotte",            "名字": "Harold"        }    ]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>非常简便的将所需要的数据流畅的保存下来了，下面我们介绍相关的参数：<br>（1）indent=4：缩进，python中默认缩进是4个，前端和css默认是2个<br>（2）sort_keys=True/False：以key为标准，按key的a-z字母排序<br>（3）separators=(‘，’，‘：’)：减少空格，增加传输速度，参数是要保留的标点符号，json只保留 逗号和冒号就行。<br>下面我们将其保存在json的文件中：</p><pre class="line-numbers language-none"><code class="language-none">with open("E:\\测试.json", "w+",encoding='utf-8_sig')as f:    json.dump(key,f,sort_keys=True,indent =4,ensure_ascii=False) //另外一种写法f= open("E:\\测试.json", "w",encoding='utf-8_sig')  //可能会报encoding的相关错，去掉就好<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>loads和load 反序列化方法</strong><br>loads 只完成了反序列化，<br>load 只接收文件描述符，完成了读取文件和反序列化<br>同样用上述例子介绍：</p><pre class="line-numbers language-none"><code class="language-none">key_1=json.dumps(key,sort_keys=True,indent =4,ensure_ascii=False)print(json.loads(key_1))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>输出为：</p><pre class="line-numbers language-none"><code class="language-none">{'people': [{'1': 1, 'Name': 'Brett', '名字': 'McLaughlin'}, {'2': 1, 'Name': 'Jason', '名字': 'Hunter'}, {'3': 1, 'Name': 'Elliotte', '名字': 'Harold'}]}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>即将其反输出<br>下面读取json文件也是一样的：</p><pre class="line-numbers language-none"><code class="language-none">with open("E:\\测试.json", "r+",encoding='utf-8_sig')as f:    data=json.load(f)print(data)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>特别注意：</strong><br><em><strong>如果打开的文件为空，那么json.load(f)会报错，里面必须有内容才能用这个打开</strong></em></p><h3 id="字典相关操作"><a href="#字典相关操作" class="headerlink" title="字典相关操作"></a>字典相关操作</h3><h4 id="如何检查字典-Python-中是否存在某个值"><a href="#如何检查字典-Python-中是否存在某个值" class="headerlink" title="如何检查字典(Python)中是否存在某个值"></a>如何检查字典(Python)中是否存在某个值</h4><p>d = {‘1’: ‘one’, ‘3’: ‘three’, ‘2’: ‘two’, ‘5’: ‘five’, ‘4’: ‘four’}</p><p>我需要一种方法来找出这个字典中是否存在诸如“one”或“two”这样的值。</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; d = {'1': 'one', '3': 'three', '2': 'two', '5': 'five', '4': 'four'}&gt;&gt;&gt; 'one' in d.values()True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="强制结束程序或暂停程序"><a href="#强制结束程序或暂停程序" class="headerlink" title="强制结束程序或暂停程序"></a>强制结束程序或暂停程序</h3><pre class="line-numbers language-none"><code class="language-none">import syssys.exit()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">##暂停程序input()用法：直接在欲等待处输入input()即可。特点：优点：不需要借助模块，执行到此处阻塞等待人工输入。缺点：程序结束时候需要强制结束或者在控制台输入值。time.sleep()用法：导入time模块；在欲等待处输入time.sleep(time)（time为数字，表示秒）即可。特点：优点：动态等待程序执行完毕，不需要强行终止，等待时间可调。缺点：需要导入模块，等待规定时间结束后便继续往下执行。os.system("pause")用法：导入os模块；在欲等待处输入os.system("pause")即可。特点：优点：不必强行终止；不必等待时间，可自由按下enter继续。缺点：导入模块，执行系统命令。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python执行shell脚本"><a href="#python执行shell脚本" class="headerlink" title="python执行shell脚本"></a>python执行shell脚本</h3><h4 id="os-system-“command”"><a href="#os-system-“command”" class="headerlink" title="os.system(“command”)"></a>os.system(“command”)</h4><p>这是python自带的执行shell命令的方法，其中最后一个0是这个命令的返回值，为0表示命令执行成功。但是使用system()无法将执行的结果保存起来。</p><pre class="line-numbers language-none"><code class="language-none">import osprint(os.system("touch a.txt")) //需要用引号将命令括起来<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="os-popen-“command”-方法"><a href="#os-popen-“command”-方法" class="headerlink" title="os.popen(“command”)方法"></a>os.popen(“command”)方法</h4><p>上面的os.system()方法没办法查看shell命令返回的结果，通过 os.popen() 返回的是 file read 的对象，对其进行读取 read() 的操作可以看到执行的输出。</p><p>注意：os.popen() 返回的是一个文件对象f哦！！！</p><pre class="line-numbers language-none"><code class="language-none">import osf=os.popen("ls -l")  # 返回的是一个文件对象print(f.read())            # 通过文件的read()读取所返回的内容'''total 4-rw-rw-r-- 1 tengjian tengjian  0 11月  5 09:32 a.txt-rw-rw-r-- 1 tengjian tengjian 81 11月  5 09:32 python_shell.py'''<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>对于有返回值的shell命令，建议使用 os.popen()<br>对于没有返回值的shell命令，建议使用 os.system()</strong></p><h3 id="在for循环体内修改i值"><a href="#在for循环体内修改i值" class="headerlink" title="在for循环体内修改i值"></a>在for循环体内修改i值</h3><p><strong>场景：在循环体内判断条件发生时，重新执行执行当前循环体（保留当前i值）<br>常规：类似的需求一般会在循环体里写一个 if 加上continue / break<br>实际：但是在for循环内修改i值，只会对当前一次的循环体内有效</strong></p><pre class="line-numbers language-none"><code class="language-none">for i in range(1,5):    print("i in use:", i)    i = 20    print("i modified:", i)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">//结果i in use: 1i modified: 20i in use: 2i modified: 20i in use: 3i modified: 20i in use: 4i modified: 20<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>原理：想想 in 操作符的概念，应该就能明白了<br>解读：每次for循环，相当于是从range(1,5)这个类似list里做取数的动作，修改的只是取出的值，并不是取数来源的值<br>解决：使用 while 替换 for</strong></p><pre class="line-numbers language-none"><code class="language-none">i = 1while i &lt; 6:    print(i)    if(i % 2 == 0):        i += 2    i += 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">//结果125<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="修改文件"><a href="#修改文件" class="headerlink" title="修改文件"></a>修改文件</h3><pre class="line-numbers language-none"><code class="language-none">##!/usr/bin/env python## -*- coding: utf-8 -*-## @Date    : 2019-04-25 14:35:58## @Author  : 迷风小白def changetext(a,b): with open('test','r',encoding='utf-8') as f:  lines=[] # 创建了一个空列表，里面没有元素  for line in f.readlines():   if line!='\n':    lines.append(line)  f.close() with open('test','w',encoding='utf-8') as f:  for line in lines:   if a in line:    line = b     f.write('%s\n' %line) //关键代码   else:    f.write('%s' %line)   //关键代码changetext('pig','cow')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="from-import和import的区别"><a href="#from-import和import的区别" class="headerlink" title="from import和import的区别"></a>from import和import的区别</h3><pre class="line-numbers language-none"><code class="language-none">import Module # 引入模块from Module import Other # 引入模块中的类、函数或者变量from Module import * # 引入模块中的所有‘公开’成员<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br><p><strong>举例</strong></p><pre class="line-numbers language-none"><code class="language-none">from datetime import datetime##引入 datetime 模块中的 datetime 类,然后就可以通过datetime这个类调用now() 方法了##即,内部可以通过datetime.now()来调用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">import datetime##引入datetime 模块,然后通过这个模块来调用模块中的类datetime和类datetime中的方法now()##即：内部可以通过datetime.datetime.now()来调用也就是说，有一个模块datetime,这个模块中有一个类datetime,在这个类中有一个方法now()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;所遇问题&quot;&gt;&lt;a href=&quot;#所遇问题&quot; class=&quot;headerlink&quot; title=&quot;所遇问题&quot;&gt;&lt;/a&gt;所遇问题&lt;/h2&gt;&lt;h3 id=&quot;输出格式有问题&quot;&gt;&lt;a href=&quot;#输出格式有问题&quot; class=&quot;headerlink&quot; title=&quot;输出格</summary>
      
    
    
    
    <category term="python" scheme="https://gaofeng-lin.github.io/categories/python/"/>
    
    
    <category term="python" scheme="https://gaofeng-lin.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>前端框架</title>
    <link href="https://gaofeng-lin.github.io/posts/15854/"/>
    <id>https://gaofeng-lin.github.io/posts/15854/</id>
    <published>2022-01-13T16:00:00.000Z</published>
    <updated>2022-07-23T03:15:25.771Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><h3 id="创建react项目"><a href="#创建react项目" class="headerlink" title="创建react项目"></a>创建react项目</h3><pre class="line-numbers language-none"><code class="language-none">npm install create-react-appnpx create-react-app myapp --template typescripe<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果create-react-app是全局安装的，那么前面的npx/npm可以省略</p><h3 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h3><p>重点关注三个文件：</p><pre class="line-numbers language-none"><code class="language-none">src/App.js //实现 React 组件src/index.js // React 世界的入口public/index.html //挂载的页面<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>1.index.html</p><pre class="line-numbers language-none"><code class="language-none">这个是一个模板文件，里面有过id为root的div标签，会被index.js文件中的JSX替换这个DOM节点。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/c8637d56e86b4868a275d4a01a1db9c1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>2.index.js</p><pre class="line-numbers language-none"><code class="language-none">关键就是这个ReactDOM.render()简单来说，ReactDOM.render() 会使用你的 JSX 来替换你的 HTML 中的一个 DOM 节点。这样你就可以很容易地把 React 集成到每一个其他的应用中。ReactDOM.render() 可以在你的应用中被多次使用。你可以在多个地方使用它来加载简单的 JSX 语法、单个 React 组件、多个 React 组件或者整个应用。但是在一个纯 React 的应用中，你只会使用一次用来加载你的整个组件树。ReactDOM.render() 有两个传入参数。第一个是准备渲染的 JSX。第二个参数指定了 React应用在你的 HTML 中的放置的位置。这个位置是一个 id='root' 的元素。你可以在文件public/index.html 中找到这个 id 属性<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/5a6381d4f99b4a56b00f07e3ee28f9c7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>3.App.js<br>在inde.js文件里面，ReactDOM.render() 总会很好地渲染你的 App 组件。一般来说，某个组件叫xxx，那么他的代码就叫xxx.js。要想知道页面被渲染成什么样，就看看里面内容。<br><img src="https://img-blog.csdnimg.cn/378a772ce66d41e9b70b563c6319a470.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="react-router-dom路由"><a href="#react-router-dom路由" class="headerlink" title="react-router-dom路由"></a>react-router-dom路由</h3><p><strong>1.这是react-router-dom5的用法，现在默认安装的是6，下面会写6的语法</strong></p><p><a href="https://www.jianshu.com/p/8954e9fb0c7e">原文章链接</a><br>来源：简书</p><p><strong>使用背景：使用React构建的单页面应用，要想实现页面间的跳转，首先想到的就是使用路由。在React中，常用的有两个包可以实现这个需求，那就是react-router和react-router-dom。本文主要针对react-router-dom进行说明。</strong></p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>首先进入项目目录，使用npm安装react-router-dom：</p><pre class="line-numbers language-none"><code class="language-none">npm install react-router-dom --save-dev //这里可以使用cnpm代替npm命令；//--save-dev 标记表示该 node 包只是用作开发环境的一部分，并不会被作为你产品代码的一部分发布。哪种 node 包适用这个场景呢？设想你需要一些 node 包辅助测试你的应用，然后需要通过 npm 来安装这些包，但是不希望他们混入产品代码里面。测试过程应该只会发生在开发阶段，而不是在线上部署运行的时候。因为那个时候已经用不到测试代码了，你的应用应该已经被测试完而且可以被你的用户使用了。这可能是你唯一的使用 --save-dev的场景。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><p>然后我们新建两个页面，分别命名为“home”和“detail”。在页面中编写如下代码：<br>detail.js</p><pre class="line-numbers language-none"><code class="language-none">import React from 'react';export default class Home extends React.Component {    render() {        return (            &lt;div&gt;                &lt;a&gt;去detail&lt;/a&gt;            &lt;/div&gt;        )    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>home.js</p><pre class="line-numbers language-none"><code class="language-none">import React from 'react';export default class Home extends React.Component {    render() {        return (            &lt;div&gt;                &lt;a&gt;回到home&lt;/a&gt;            &lt;/div&gt;        )    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后再新建一个路由组件，命名为“Router.js”，并编写如下代码：</p><pre class="line-numbers language-none"><code class="language-none">import React from 'react';import {HashRouter, Route, Switch} from 'react-router-dom';import Home from '../home';import Detail from '../detail';const BasicRoute = () =&gt; (    &lt;HashRouter&gt;        &lt;Switch&gt;            &lt;Route exact path="/" component={Home}/&gt;            &lt;Route exact path="/detail" component={Detail}/&gt;        &lt;/Switch&gt;    &lt;/HashRouter&gt;);export default BasicRoute;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上代码定义了一个纯路由组件，将两个页面组件Home和Detail使用Route组件包裹，外面套用Switch作路由匹配，当路由组件检测到地址栏与Route的path匹配时，就会自动加载响应的页面。<br>然后在入口文件中——我这里指定的是index.js——编写如下代码：</p><pre class="line-numbers language-none"><code class="language-none">import React from 'react';import ReactDOM from 'react-dom';import Router from './router/router';ReactDOM.render(  &lt;Router/&gt;,  document.getElementById('root'));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里相当于向页面返回了一个路由组件。我们先运行项目看一下效果，在地址栏输入“<a href="http://localhost:3000/#/%E2%80%9D%EF%BC%9A">http://localhost:3000/#/”：</a><br><img src="https://img-blog.csdnimg.cn/37aee935c7534aa39a98acfcf884e278.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>输入“<a href="http://localhost:3000/#/detail%E2%80%9D%EF%BC%9A">http://localhost:3000/#/detail”：</a><br><img src="https://img-blog.csdnimg.cn/891f1a191f764e2295b057870300cd76.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p><strong>通过a标签跳转</strong><br>可以看到其实路由已经开始工作了，接下来我们再来做页面间的跳转。在home.js和detail.js中，我们修改如下代码：</p><pre class="line-numbers language-none"><code class="language-none">import React from 'react';    export default class Home extends React.Component {        render() {            return (                &lt;div&gt;                &lt;a href='#/detail'&gt;去detail&lt;/a&gt;            &lt;/div&gt;        )    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>home.js</p><pre class="line-numbers language-none"><code class="language-none">import React from 'react';export default class Home extends React.Component {    render() {        return (            &lt;div&gt;                &lt;a href='#/'&gt;回到home&lt;/a&gt;            &lt;/div&gt;        )    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重新打包运行，在浏览器地址栏输入“<a href="http://localhost:3000/%E2%80%9D%EF%BC%8C%E8%AF%95%E8%AF%95%E7%9C%8B%E9%A1%B5%E9%9D%A2%E8%83%BD%E5%90%A6%E6%AD%A3%E5%B8%B8%E8%B7%B3%E8%BD%AC%E3%80%82%E5%A6%82%E6%9E%9C%E4%B8%8D%E8%83%BD%EF%BC%8C%E8%AF%B7%E6%8C%89%E6%AD%A5%E9%AA%A4%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%A3%80%E6%9F%A5%E4%BB%A3%E7%A0%81%E6%98%AF%E5%90%A6%E6%9C%89%E8%AF%AF%E3%80%82%E4%BB%A5%E4%B8%8A%E6%98%AF%E4%BD%BF%E7%94%A8a%E6%A0%87%E7%AD%BE%E7%9A%84href%E8%BF%9B%E8%A1%8C%E9%A1%B5%E9%9D%A2%E9%97%B4%E8%B7%B3%E8%BD%AC%EF%BC%8C%E6%AD%A4%E5%A4%96react-router-dom%E8%BF%98%E6%8F%90%E4%BE%9B%E4%BA%86%E9%80%9A%E8%BF%87%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%B9%E5%BC%8F%E8%B7%B3%E8%BD%AC%E9%A1%B5%E9%9D%A2%E3%80%82">http://localhost:3000/”，试试看页面能否正常跳转。如果不能，请按步骤一步一步检查代码是否有误。以上是使用a标签的href进行页面间跳转，此外react-router-dom还提供了通过函数的方式跳转页面。</a></p><p><strong>通过函数跳转</strong></p><p>首先我们需要修改router.js中的两处代码：<br>然后在home.js中：<br>import React from ‘react’;</p><pre class="line-numbers language-none"><code class="language-none">...import {HashRouter, Route, Switch, hashHistory} from 'react-router-dom';...&lt;HashRouter history={hashHistory}&gt;...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在a标签下面添加一个按钮并加上onClick事件，通过this.props.history.push这个函数跳转到detail页面。在路由组件中加入的代码就是将history这个对象注册到组件的props中去，然后就可以在子组件中通过props调用history的push方法跳转页面。</p><p>很多场景下，我们还需要在页面跳转的同时传递参数，在react-router-dom中，同样提供了两种方式进行传参。</p><p>链接：<a href="https://www.jianshu.com/p/8954e9fb0c7e">https://www.jianshu.com/p/8954e9fb0c7e</a><br>来源：简书</p><pre class="line-numbers language-none"><code class="language-none">export default class Home extends React.Component {    constructor(props) {        super(props);    }            render() {        return (            &lt;div&gt;                &lt;a href='#/detail'&gt;去detail&lt;/a&gt;                &lt;button onClick={() =&gt; this.props.history.push('detail')}&gt;通过函数跳转&lt;/button&gt;            &lt;/div&gt;        )    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>url传参</strong><br>在router.js中，修改如下代码：</p><pre class="line-numbers language-none"><code class="language-none">...&lt;Route exact path="/detail/:id" component={Detail}/&gt;...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后修改detail.js，使用this.props.match.params获取url传过来的参数：</p><pre class="line-numbers language-none"><code class="language-none">...componentDidMount() {    console.log(this.props.match.params);}...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在地址栏输入“<a href="http://localhost:3000/#/detail/3%E2%80%9D%EF%BC%8C%E6%89%93%E5%BC%80%E6%8E%A7%E5%88%B6%E5%8F%B0%EF%BC%9A">http://localhost:3000/#/detail/3”，打开控制台：</a><br><img src="https://img-blog.csdnimg.cn/d803a9af4817410c8649c09bbf06cdea.png" alt="在这里插入图片描述"><br>可以看到传过去的id=3已经被获取到了。react-router-dom就是通过“/:”去匹配url传递的参数。</p><p><strong>隐式传参</strong><br>此外还可以通过push函数隐式传参。</p><p>修改home.js代码如下：</p><pre class="line-numbers language-none"><code class="language-none">import React from 'react';export default class Home extends React.Component {    constructor(props) {        super(props);    }            render() {        return (            &lt;div&gt;                &lt;a href='#/detail/3'&gt;去detail&lt;/a&gt;                    &lt;button onClick={() =&gt; this.props.history.push({                        pathname: '/detail',                        state: {                            id: 3                        }                })}&gt;通过函数跳转&lt;/button&gt;            &lt;/div&gt;        )    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在detail.js中，就可以使用this.props.history.location.state获取home传过来的参数：</p><pre class="line-numbers language-none"><code class="language-none">componentDidMount() {    //console.log(this.props.match.params);    console.log(this.props.history.location.state);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>跳转后打开控制台可以看到参数被打印：<br><img src="https://img-blog.csdnimg.cn/972fb5894c804e8c9203fc6d304cf0c5.png" alt="在这里插入图片描述"><br><strong>嵌套路由</strong></p><p>嵌套路由的适用场景还是比较多的，接下来就来介绍一下实现方法。<br>首先在Vue中实现嵌套路由，只需要将配置文件写成children嵌套，然后在需要展示子路由的位置加上<router-view></router-view>即可。React中应该如何实现呢？其实原理和Vue类似，只需要在父级路由中包含子路由即可。这样说可能很多同学会一头雾水，直接上代码（不使用上面的例子）：</p><p>首先定义父级组件MainLayout</p><pre class="line-numbers language-none"><code class="language-none">import React from 'react';import './MainLayout.scss';const { Header, Sider, Content } = Layout;export default class MainLayout extends React.Component {    render() {        return (            &lt;div className='main-layout'&gt;                父组件            &lt;/div&gt;        );    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后定义子组件Home：</p><pre class="line-numbers language-none"><code class="language-none">import React, {useState} from 'react';import {Modal, Select} from "antd";import {connect} from 'react-redux';import {addCount} from '../../servers/home';function Home(props) {    const [visible, setVisible] = useState(false);    const {countNum: {count}, dispatch} = props;    return (        &lt;div&gt;            子组件        &lt;/div&gt;    )}export default Home;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后将它们添加进路由router.js，并且关联父子关系：</p><pre class="line-numbers language-none"><code class="language-none">import React from 'react';import {HashRouter, Route, Switch} from "react-router-dom";import Home from '../pages/Home/Home';import MainLayout from '../layout/MainLayout';const BasicRouter = () =&gt; (    &lt;HashRouter&gt;        &lt;Switch&gt;            &lt;Route path="/index" component={                &lt;MainLayout&gt;                  &lt;Route exact path="/" component={Home}/&gt;                  &lt;Route exact path="/index" component={Home}/&gt;                  &lt;Route path="/index/home" component={Home}/&gt;                &lt;/MainLayout&gt;             }/&gt;        &lt;/Switch&gt;    &lt;/HashRouter&gt;);export default BasicRouter;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在MainLayout中，修改如下代码：</p><pre class="line-numbers language-none"><code class="language-none">import React from 'react';import './MainLayout.scss';const { Header, Sider, Content } = Layout;export default class MainLayout extends React.Component {    render() {        return (            &lt;div className='main-layout'&gt;                {this.props.children}            &lt;/div&gt;        );    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如此，一个嵌套路由就完成了。</p><p><strong>2.react-router-dom版本6语法</strong></p><p>&lt; Switch &gt;  -&gt;    &lt; Routes &gt;<br>component={hello}  -&gt; element={&lt; hello /&gt;}</p><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>组件，从概念上类似于 JavaScript 函数。它接受任意的入参（即 “props”），并返回用于描述页面展示内容的 React 元素。</p><p>1.函数组件<br>定义组件最简单的方式就是编写 JavaScript 函数：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">Welcome</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>Hello<span class="token punctuation">,</span> <span class="token punctuation">{</span>props<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>该函数是一个有效的 React 组件，因为它接收唯一带有数据的 “props”（代表属性）对象与并返回一个 React 元素。这类组件被称为“函数组件”，因为它本质上就是 JavaScript 函数。</p><p>2.class组件</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">Welcome</span> <span class="token keyword">extends</span> <span class="token class-name">React</span><span class="token punctuation">.</span>Component <span class="token punctuation">{</span>  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>Hello<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述两个组件在 React 里是等效的。</p><h3 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h3><p><a href="https://www.jianshu.com/p/1b32ceb8295c">原文</a></p><p>组件从概念上看就是一个函数，可以接受一个参数作为输入值，这个参数就是props，所以可以把props理解为从外部传入组件内部的数据。由于React是单向数据流，所以props基本上也就是从服父级组件向子组件传递的数据。</p><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">Hello</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>hello world  <span class="token operator">+</span>  <span class="token punctuation">{</span>props<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span><span class="token punctuation">}</span>React<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>    <span class="token operator">&lt;</span>Hello name<span class="token operator">=</span><span class="token string">"zhangshan"</span><span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>    document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>‘&lt;’ Hello name=”zhangshan”/‘&gt;’,是什么意思？</p><p>为什么我们在方法里面获取的数据是<code>{props.name}</code>里面获取到我们传递的name的？</p><p><strong>其实就是我们把参数name=”zhangshan” 放在了props里，props这个东西不需要我们定义，这个是react里面就存在的一个东西，专门用来存放我们的要传递的参数的。</strong></p><p>但是在我们的<code>function Hello(props)</code>里面，必须显式地传入我们的props。</p><p>那如果要传递很多参数呢？</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">Hello</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>hello world  <span class="token operator">+</span>  <span class="token punctuation">{</span>props<span class="token punctuation">.</span>name<span class="token punctuation">}</span> <span class="token operator">+</span> <span class="token punctuation">{</span>props<span class="token punctuation">.</span>id<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span><span class="token punctuation">}</span>React<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>    <span class="token operator">&lt;</span>Hello name<span class="token operator">=</span><span class="token string">"zhangshan"</span> id<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">12</span><span class="token punctuation">}</span><span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>    document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>相当于，我们把name和id都放入了props里面。props里面到底能够容纳多少的参数，目前我们不考虑。</p><p>但是我们发现id={12}，这个参数的样式跟到我们的name=”zhangshan”不一样，为什么呢？</p><p><strong>id我们需要传入的是一个数字，所以我们不能用分号，如果我们用分号的话id=“12”，那么12就是一个字符串了。</strong></p><p>最后还有一个很重要的点：<code>props是只读的</code></p><p>什么是只读呢？</p><p>意思是任何修改props里面参数的操作，都是错误的！例如下面：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">Hello</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">{</span>    props<span class="token punctuation">.</span>name<span class="token operator">=</span><span class="token string">"lisi"</span>    <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>hello world  <span class="token operator">+</span>  <span class="token punctuation">{</span>props<span class="token punctuation">.</span>name<span class="token punctuation">}</span> <span class="token operator">+</span> <span class="token punctuation">{</span>props<span class="token punctuation">.</span>id<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="只读性"><a href="#只读性" class="headerlink" title="只读性"></a>只读性</h4><p>props经常被用作渲染组件和初始化状态，当一个组件被实例化之后，它的props是只读的，不可改变的。如果props在渲染过程中可以被改变，会导致这个组件显示的形态变得不可预测。只有通过父组件重新渲染的方式才可以把新的props传入组件中</p><h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><p>在组件中，我们最好为props中的参数设置一个defaultProps，并且制定它的类型。比如，这样：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">Item<span class="token punctuation">.</span>defaultProps <span class="token operator">=</span> <span class="token punctuation">{</span>  item<span class="token operator">:</span> <span class="token string">'Hello Props'</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Item<span class="token punctuation">.</span>propTypes <span class="token operator">=</span> <span class="token punctuation">{</span>  item<span class="token operator">:</span> PropTypes<span class="token punctuation">.</span><span class="token builtin">string</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关于propTypes，可以声明为以下几种类型：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">optionalArray<span class="token operator">:</span> PropTypes<span class="token punctuation">.</span>array<span class="token punctuation">,</span>optionalBool<span class="token operator">:</span> PropTypes<span class="token punctuation">.</span>bool<span class="token punctuation">,</span>optionalFunc<span class="token operator">:</span> PropTypes<span class="token punctuation">.</span>func<span class="token punctuation">,</span>optionalNumber<span class="token operator">:</span> PropTypes<span class="token punctuation">.</span><span class="token builtin">number</span><span class="token punctuation">,</span>optionalObject<span class="token operator">:</span> PropTypes<span class="token punctuation">.</span>object<span class="token punctuation">,</span>optionalString<span class="token operator">:</span> PropTypes<span class="token punctuation">.</span><span class="token builtin">string</span><span class="token punctuation">,</span>optionalSymbol<span class="token operator">:</span> PropTypes<span class="token punctuation">.</span><span class="token builtin">symbol</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，bool和func是简写。<br><a href="https://link.segmentfault.com/?enc=XZBU0TmiI6SKqfvrMkCdjw==.Sre3YLwtIWGHuDErH33uREve5dWfkwURRNAKvKUhsV/VWVJDhYMqXAyqrVb8z42nC0Ov/X24XCdEp4w8kBAeuFpnjcoVi7lyjo7s1ldlwUY=">复杂数据类型</a></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>props是一个从外部传进组件的参数，主要作为就是从父组件向子组件传递数据，它具有可读性和不变性，只能通过外部组件主动传入新的props来重新渲染子组件，否则子组件的props以及展现形式不会改变。</p><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p><a href="https://segmentfault.com/a/1190000011184076">原文</a></p><p>State is similar to props, but it is private and fully controlled by the component.</p><h4 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h4><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">ItemList</span> <span class="token keyword">extends</span> <span class="token class-name">React</span><span class="token punctuation">.</span>Component<span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>      itemList<span class="token operator">:</span><span class="token string">'一些数据'</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>      <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>itemList<span class="token punctuation">}</span>    <span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先，在组件初始化的时候，通过this.state给组件设定一个初始的state，在第一次render的时候就会用这个数据来渲染组件。<br>如果要传参数，constructor、super括号里面都要加入props</p><h4 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h4><p>state不同于props的一点是，state是可以被改变的。不过，不可以直接通过this.state=的方式来修改，而需要通过this.setState()方法来修改state。</p><p>比如，我们经常会通过异步操作来获取数据，我们需要在didMount阶段来执行异步操作：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'url'</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>response <span class="token operator">=&gt;</span> response<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>itemList<span class="token operator">:</span>item<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当数据获取完成后，通过this.setState来修改数据状态。</p><p>当我们调用this.setState方法时，React会更新组件的数据状态state，并且重新调用render方法，也就是会对组件进行重新渲染。</p><p><strong>注意：通过this.state=来初始化state，使用this.setState来修改state，constructor是唯一能够初始化的地方。</strong></p><p>setState接受一个对象或者函数作为第一个参数，只需要传入需要更新的部分即可，不需要传入整个对象，比如：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">ItemList</span> <span class="token keyword">extends</span> <span class="token class-name">React</span><span class="token punctuation">.</span>Component<span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>      name<span class="token operator">:</span><span class="token string">'axuebin'</span><span class="token punctuation">,</span>      age<span class="token operator">:</span><span class="token number">25</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>age<span class="token operator">:</span><span class="token number">18</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在执行完setState之后的state应该是{name:’axuebin’,age:18}。</p><p>setState还可以接受第二个参数，它是一个函数，会在setState调用完成并且组件开始重新渲染时被调用，可以用来监听渲染是否完成：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  name<span class="token operator">:</span><span class="token string">'xb'</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setState finished'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>state的主要作用是用于组件保存、控制以及修改自己的状态，它只能在constructor中初始化，它算是组件的私有属性，不可通过外部访问和修改，只能通过组件内部的this.setState来修改，修改state属性会导致组件的重新渲染。</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li>state是组件自己管理数据，控制自己的状态，可变；</li><li>props是外部传入的数据参数，不可变；</li><li>没有state的叫做无状态组件，有state的叫做有状态组件；</li><li>多用props，少用state。也就是多写无状态组件。</li></ul><h3 id="ant-design"><a href="#ant-design" class="headerlink" title="ant design"></a>ant design</h3><p>使用方法。<br><img src="https://img-blog.csdnimg.cn/3b09dec16e4946f6a9b46e1a55e1c5d6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>打开组件对应的源码，把里面的东西复制出来。</p><pre class="line-numbers language-none"><code class="language-none">import { Layout, Menu, Breadcrumb, Icon } from 'antd';import React, { Component } from "react";import "antd/dist/antd.css";const { SubMenu } = Menu;const { Header, Content, Sider } = Layout;class SiderDemo extends Component {　　render(){     return(  &lt;Layout&gt;    &lt;Header className="header"&gt;      &lt;div className="logo" /&gt;      &lt;Menu        theme="dark"        mode="horizontal"        defaultSelectedKeys={['2']}        style={{ lineHeight: '64px' }}      &gt;        &lt;Menu.Item key="1"&gt;nav 1&lt;/Menu.Item&gt;        &lt;Menu.Item key="2"&gt;nav 2&lt;/Menu.Item&gt;        &lt;Menu.Item key="3"&gt;nav 3&lt;/Menu.Item&gt;      &lt;/Menu&gt;    &lt;/Header&gt;    &lt;Layout&gt;      &lt;Sider width={200} style={{ background: '#fff' }}&gt;        &lt;Menu          mode="inline"          defaultSelectedKeys={['1']}          defaultOpenKeys={['sub1']}          style={{ height: '100%', borderRight: 0 }}        &gt;          &lt;SubMenu key="sub1" title={&lt;span&gt;&lt;Icon type="user" /&gt;subnav 1&lt;/span&gt;}&gt;            &lt;Menu.Item key="1"&gt;option1&lt;/Menu.Item&gt;            &lt;Menu.Item key="2"&gt;option2&lt;/Menu.Item&gt;            &lt;Menu.Item key="3"&gt;option3&lt;/Menu.Item&gt;            &lt;Menu.Item key="4"&gt;option4&lt;/Menu.Item&gt;          &lt;/SubMenu&gt;          &lt;SubMenu key="sub2" title={&lt;span&gt;&lt;Icon type="laptop" /&gt;subnav 2&lt;/span&gt;}&gt;            &lt;Menu.Item key="5"&gt;option5&lt;/Menu.Item&gt;            &lt;Menu.Item key="6"&gt;option6&lt;/Menu.Item&gt;            &lt;Menu.Item key="7"&gt;option7&lt;/Menu.Item&gt;            &lt;Menu.Item key="8"&gt;option8&lt;/Menu.Item&gt;          &lt;/SubMenu&gt;          &lt;SubMenu key="sub3" title={&lt;span&gt;&lt;Icon type="notification" /&gt;subnav 3&lt;/span&gt;}&gt;            &lt;Menu.Item key="9"&gt;option9&lt;/Menu.Item&gt;            &lt;Menu.Item key="10"&gt;option10&lt;/Menu.Item&gt;            &lt;Menu.Item key="11"&gt;option11&lt;/Menu.Item&gt;            &lt;Menu.Item key="12"&gt;option12&lt;/Menu.Item&gt;          &lt;/SubMenu&gt;        &lt;/Menu&gt;      &lt;/Sider&gt;      &lt;Layout style={{ padding: '0 24px 24px' }}&gt;        &lt;Breadcrumb style={{ margin: '16px 0' }}&gt;          &lt;Breadcrumb.Item&gt;Home&lt;/Breadcrumb.Item&gt;          &lt;Breadcrumb.Item&gt;List&lt;/Breadcrumb.Item&gt;          &lt;Breadcrumb.Item&gt;App&lt;/Breadcrumb.Item&gt;        &lt;/Breadcrumb&gt;        &lt;Content style={{ background: '#fff', padding: 24, margin: 0, minHeight: 280 }}&gt;          Content        &lt;/Content&gt;      &lt;/Layout&gt;    &lt;/Layout&gt;    &lt;/Layout&gt;    )}}export default SiderDemo;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上面的为例，组件叫做SiderDemo。return里面的内容就是源码里面ReactDOM.renderd里面的东西，这里面最后的mountNode去掉了。<br>其余的东西放到class外面。<br><img src="https://img-blog.csdnimg.cn/b2954d452d23433d8ecfd48074bf2c67.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>引入：<br><img src="https://img-blog.csdnimg.cn/19507c43b4a94db283f8c9bff258c5ce.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="组件中对a标签的href的带变量拼接"><a href="#组件中对a标签的href的带变量拼接" class="headerlink" title="组件中对a标签的href的带变量拼接"></a>组件中对a标签的href的带变量拼接</h3><p>关键点是外面加了大括号</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">linkContent=&lt;a href=<span class="token punctuation">{</span><span class="token keyword">DATA</span><span class="token punctuation">.</span>serverUrl+<span class="token string">'service/apartment'</span><span class="token operator">+</span>url+<span class="token string">'?apartmentId='</span><span class="token operator">+</span>urlID<span class="token punctuation">}</span>&gt;&lt;p&gt;名称：<span class="token punctuation">{</span>this<span class="token punctuation">.</span>props<span class="token punctuation">.</span>name<span class="token punctuation">}</span>&lt;<span class="token operator">/</span>p&gt;&lt;<span class="token operator">/</span>a&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="向路由组件传递参数"><a href="#向路由组件传递参数" class="headerlink" title="向路由组件传递参数"></a>向路由组件传递参数</h3><p><a href="https://blog.csdn.net/zeroheitao/article/details/118057313?spm=1001.2101.3001.6661.1&amp;depth_1-utm_relevant_index=1">原文链接</a></p><h3 id="import导入时带与不带花括号"><a href="#import导入时带与不带花括号" class="headerlink" title="import导入时带与不带花括号{}"></a>import导入时带与不带花括号{}</h3><p><strong>一个模块中只能有一个默认导出export default，但是却可以有任意命名导出export（0个、1个、多个）</strong></p><ol><li>不带花括号{}，引用js文件中默认导出（export default）的模块</li></ol><p>import模块时的可随意命名。export default默认导出不能加花括号{}。</p><ol start="2"><li>带花括号{}，引用js文件中export导出的同名模块</li></ol><p>import模块时的命名必须一致。export命名导出必须加花括号{}。</p><h2 id="React-Hooks"><a href="#React-Hooks" class="headerlink" title="React Hooks"></a>React Hooks</h2><p><a href="https://www.ruanyifeng.com/blog/2019/09/react-hooks.html">原链接</a></p><p>Redux 的作者 Dan Abramov 总结了组件类的几个缺点：</p><ul><li>大型组件很难拆分和重构，也很难测试。</li><li>业务逻辑分散在组件的各个方法之中，导致重复逻辑或关联逻辑。</li><li>组件类引入了复杂的编程模式，比如 render props 和高阶组件。</li></ul><p>函数组件必须是纯函数，不能包含状态，也不支持生命周期方法，因此无法取代类。</p><p><strong>React Hooks 的设计目的，就是加强版函数组件，完全不使用”类”，就能写出一个全功能的组件。</strong></p><p>React Hooks 的意思是，组件尽量写成纯函数，如果需要外部功能和副作用，就用钩子把外部代码”钩”进来。 React Hooks 就是那些钩子。</p><p>四个最常用的钩子：<br>-useState()<br>-useContext()<br>-useReducer()<br>-useEffect()</p><h2 id="umijs"><a href="#umijs" class="headerlink" title="umijs"></a>umijs</h2><h3 id="加载组件出错"><a href="#加载组件出错" class="headerlink" title="加载组件出错"></a>加载组件出错</h3><p><strong>错误信息如下：</strong></p><pre class="line-numbers language-none"><code class="language-none">[@umijs/runtime] load component failed Error: Module "./antd/es/select/style" does not exist in container. while loading "./antd/es/select/style" from webpack/container/reference/mf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果增加了一个新的组件，不在构建范围之内，就会出错。<br><strong>解决办法：</strong><br>删除.umi缓存，然后重新启动，这个是 mfsu 没有自动编译导致的。</p><h2 id="React-基本使用"><a href="#React-基本使用" class="headerlink" title="React 基本使用"></a>React 基本使用</h2><p><a href="https://www.zhihu.com/question/469727631/answer/2527266963">原链接</a></p><h3 id="脚手架"><a href="#脚手架" class="headerlink" title="脚手架"></a>脚手架</h3><pre class="line-numbers language-none"><code class="language-none">npm install create-react-appnpx create-react-app myapp --template typescripe<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果create-react-app是全局安装的，那么前面的npx/npm可以省略</p><h3 id="组件开发"><a href="#组件开发" class="headerlink" title="组件开发"></a>组件开发</h3><h4 id="创建组件"><a href="#创建组件" class="headerlink" title="创建组件"></a>创建组件</h4><p>Vue 创建组件 index.vue</p><p>React 创建组件 index.jsx 或者 index.tsx，jsx 顾名思义是写 JS 的，tsx 肯定就是写 TS的哈 两者创建组件区别只是后缀名不一致</p><h4 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h4><p>Vue 是用 &lt; template &gt; “内容”&lt;/ template &gt;</p><p><strong>注意点：函数名首字母是要大写的</strong><br>React 是用 return 后面的内容是用 () 包起来的，里面用的是 JSX 语法来开发组件的</p><pre class="line-numbers language-none"><code class="language-none">// 函数式组件export default function HelloWorld() {    return (        &lt;div&gt;HelloWorld&lt;/div&gt;    )}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h4><p>Vue 语法: class=”类名”</p><p>React 语法: className=”类名”</p><pre class="line-numbers language-none"><code class="language-none">export default function HelloWorld() {    return (        &lt;div className="box"&gt;HelloWorld&lt;/div&gt;    )}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Style"><a href="#Style" class="headerlink" title="Style"></a>Style</h4><pre class="line-numbers language-none"><code class="language-none">Vue 语法: style="{color: 'red'}"React 语法 style={{ color: 'red' }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>注意点：其中 style 接受的值是一个对象，且用 {} 括号传入，而且对象的属性名只能用驼峰式来命名</strong></p><pre class="line-numbers language-none"><code class="language-none">export default function HelloWorld() {        return (            &lt;div style={{ color: 'red' }}&gt;HelloWorld&lt;/div&gt;        )    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="组件的使用"><a href="#组件的使用" class="headerlink" title="组件的使用"></a>组件的使用</h3><p>Vue 使用组件先引入再注册最后使用组件</p><p>React 相当于函数，只有引入的概念，没有注册的概念，所以引入进来就可以使用</p><pre class="line-numbers language-none"><code class="language-none">import HelloWorld from './HelloWorld';    // &lt;&gt; &lt;/&gt; 相当于根标签    export default function Index() {        return (            &lt;&gt;                &lt;HelloWorld /&gt;            &lt;/&gt;        )    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="声明状态变量"><a href="#声明状态变量" class="headerlink" title="声明状态变量"></a>声明状态变量</h3><p>Vue 声明变量是在 data 里面定义的<br>React 使用 useState 返回的第一个值，进行声明变量的</p><p><strong>注意点：Vue 使用数据是双大括号 ,React 使用数据是单大括号</strong></p><pre class="line-numbers language-none"><code class="language-none">import React, { useState } from 'react';        export default function HelloWorld() {    const [title] = useState('豆豆'); // 括号里面是给初始值    const [count] = useState(20);        return (            &lt;&gt;                &lt;div&gt;{ title }&lt;/div&gt;                &lt;div&gt;{ count }&lt;/div&gt;            &lt;/&gt;        )    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><h3 id="绑定事件"><a href="#绑定事件" class="headerlink" title="绑定事件"></a>绑定事件</h3><h3 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h3><h3 id="父子组件通讯"><a href="#父子组件通讯" class="headerlink" title="父子组件通讯"></a>父子组件通讯</h3><h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="react-hook-重复不停的运行"><a href="#react-hook-重复不停的运行" class="headerlink" title="react hook 重复不停的运行"></a>react hook 重复不停的运行</h3><p>打开控制台就能看见不停的运行，原因目前还没找到，解决方法如下：<br><a href="https://www.csdn.net/tags/MtTaMg0sNTIyMzc1LWJsb2cO0O0O.html">相关链接</a><br><strong>给useEffect传递一个空数组（[]）作为第二个参数</strong></p><pre class="line-numbers language-none"><code class="language-none">useEffect(() =&gt; {  getModuleNameInfo(+productid, +projectId)},[])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;React&quot;&gt;&lt;a href=&quot;#React&quot; class=&quot;headerlink&quot; title=&quot;React&quot;&gt;&lt;/a&gt;React&lt;/h2&gt;&lt;h3 id=&quot;创建react项目&quot;&gt;&lt;a href=&quot;#创建react项目&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="前端开发" scheme="https://gaofeng-lin.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="JavaScript" scheme="https://gaofeng-lin.github.io/tags/JavaScript/"/>
    
    <category term="Vue" scheme="https://gaofeng-lin.github.io/tags/Vue/"/>
    
    <category term="React" scheme="https://gaofeng-lin.github.io/tags/React/"/>
    
    <category term="Json" scheme="https://gaofeng-lin.github.io/tags/Json/"/>
    
  </entry>
  
</feed>
