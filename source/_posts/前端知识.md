---
title: 前端知识
date: 2022/1/14


categories:
  - 前端开发
  
tags:
  - Vue
  - React
  - JavaScript
  - Json
---





#  React

## 创建react项目

```
npm install create-react-app
npx create-react-app myapp --template typescripe
```
如果create-react-app是全局安装的，那么前面的npx/npm可以省略

##  启动流程
重点关注三个文件：

```
src/App.js //实现 React 组件

src/index.js // React 世界的入口

public/index.html //挂载的页面
```
1.index.html

```
这个是一个模板文件，里面有过id为root的div标签，会被index.js文件中的JSX替换这个DOM节点。
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/c8637d56e86b4868a275d4a01a1db9c1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16)
2.index.js

```
关键就是这个ReactDOM.render()

简单来说，ReactDOM.render() 会使用你的 JSX 来替换你的 HTML 中的一个 DOM 节点。这
样你就可以很容易地把 React 集成到每一个其他的应用中。ReactDOM.render() 可以在你的
应用中被多次使用。你可以在多个地方使用它来加载简单的 JSX 语法、单个 React 组件、
多个 React 组件或者整个应用。但是在一个纯 React 的应用中，你只会使用一次用来加载你
的整个组件树。
ReactDOM.render() 有两个传入参数。第一个是准备渲染的 JSX。第二个参数指定了 React
应用在你的 HTML 中的放置的位置。这个位置是一个 id='root' 的元素。你可以在文件
public/index.html 中找到这个 id 属性
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/5a6381d4f99b4a56b00f07e3ee28f9c7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16)
3.App.js
在inde.js文件里面，ReactDOM.render() 总会很好地渲染你的 App 组件。一般来说，某个组件叫xxx，那么他的代码就叫xxx.js。要想知道页面被渲染成什么样，就看看里面内容。
![在这里插入图片描述](https://img-blog.csdnimg.cn/378a772ce66d41e9b70b563c6319a470.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16)


##  react-router-dom路由
**1.这是react-router-dom5的用法，现在默认安装的是6，下面会写6的语法**

[原文章链接](https://www.jianshu.com/p/8954e9fb0c7e)
来源：简书

**使用背景：使用React构建的单页面应用，要想实现页面间的跳转，首先想到的就是使用路由。在React中，常用的有两个包可以实现这个需求，那就是react-router和react-router-dom。本文主要针对react-router-dom进行说明。**


###  安装
首先进入项目目录，使用npm安装react-router-dom：

```
npm install react-router-dom --save-dev //这里可以使用cnpm代替npm命令；

//--save-dev 标记表示该 node 包只是用作开发环境的一部分，并不会被作为你产品代码的一
部分发布。哪种 node 包适用这个场景呢？设想你需要一些 node 包辅助测试你的应用，然
后需要通过 npm 来安装这些包，但是不希望他们混入产品代码里面。测试过程应该只会发
生在开发阶段，而不是在线上部署运行的时候。因为那个时候已经用不到测试代码了，你
的应用应该已经被测试完而且可以被你的用户使用了。这可能是你唯一的使用 --save-dev
的场景。
```
###  基本操作
然后我们新建两个页面，分别命名为“home”和“detail”。在页面中编写如下代码：
detail.js
```
import React from 'react';

export default class Home extends React.Component {
    render() {
        return (
            <div>
                <a>去detail</a>
            </div>
        )
    }
}
```
home.js

```
import React from 'react';

export default class Home extends React.Component {
    render() {
        return (
            <div>
                <a>回到home</a>
            </div>
        )
    }
}
```
然后再新建一个路由组件，命名为“Router.js”，并编写如下代码：

```
import React from 'react';
import {HashRouter, Route, Switch} from 'react-router-dom';
import Home from '../home';
import Detail from '../detail';


const BasicRoute = () => (
    <HashRouter>
        <Switch>
            <Route exact path="/" component={Home}/>
            <Route exact path="/detail" component={Detail}/>
        </Switch>
    </HashRouter>
);

export default BasicRoute;
```
如上代码定义了一个纯路由组件，将两个页面组件Home和Detail使用Route组件包裹，外面套用Switch作路由匹配，当路由组件检测到地址栏与Route的path匹配时，就会自动加载响应的页面。
然后在入口文件中——我这里指定的是index.js——编写如下代码：

```
import React from 'react';
import ReactDOM from 'react-dom';
import Router from './router/router';

ReactDOM.render(
  <Router/>,
  document.getElementById('root')
);
```

这里相当于向页面返回了一个路由组件。我们先运行项目看一下效果，在地址栏输入“http://localhost:3000/#/”：
![在这里插入图片描述](https://img-blog.csdnimg.cn/37aee935c7534aa39a98acfcf884e278.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16)

输入“http://localhost:3000/#/detail”：
![在这里插入图片描述](https://img-blog.csdnimg.cn/891f1a191f764e2295b057870300cd76.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16)
**通过a标签跳转**
可以看到其实路由已经开始工作了，接下来我们再来做页面间的跳转。在home.js和detail.js中，我们修改如下代码：

```
import React from 'react';


    export default class Home extends React.Component {
        render() {
            return (
                <div>
                <a href='#/detail'>去detail</a>
            </div>
        )
    }
}
```
home.js

```
import React from 'react';

export default class Home extends React.Component {
    render() {
        return (
            <div>
                <a href='#/'>回到home</a>
            </div>
        )
    }
}
```
重新打包运行，在浏览器地址栏输入“http://localhost:3000/”，试试看页面能否正常跳转。如果不能，请按步骤一步一步检查代码是否有误。以上是使用a标签的href进行页面间跳转，此外react-router-dom还提供了通过函数的方式跳转页面。

**通过函数跳转**

首先我们需要修改router.js中的两处代码：
然后在home.js中：
import React from 'react';
```
...
import {HashRouter, Route, Switch, hashHistory} from 'react-router-dom';
...
<HashRouter history={hashHistory}>
...
```
在a标签下面添加一个按钮并加上onClick事件，通过this.props.history.push这个函数跳转到detail页面。在路由组件中加入的代码就是将history这个对象注册到组件的props中去，然后就可以在子组件中通过props调用history的push方法跳转页面。

很多场景下，我们还需要在页面跳转的同时传递参数，在react-router-dom中，同样提供了两种方式进行传参。


链接：https://www.jianshu.com/p/8954e9fb0c7e
来源：简书


```
export default class Home extends React.Component {
    constructor(props) {
        super(props);
    }
    
    
    render() {
        return (
            <div>
                <a href='#/detail'>去detail</a>
                <button onClick={() => this.props.history.push('detail')}>通过函数跳转</button>
            </div>
        )
    }
}
```
**url传参**
在router.js中，修改如下代码：

```
...
<Route exact path="/detail/:id" component={Detail}/>
...
```
然后修改detail.js，使用this.props.match.params获取url传过来的参数：

```
...
componentDidMount() {
    console.log(this.props.match.params);
}
...
```
在地址栏输入“http://localhost:3000/#/detail/3”，打开控制台：
![在这里插入图片描述](https://img-blog.csdnimg.cn/d803a9af4817410c8649c09bbf06cdea.png)
可以看到传过去的id=3已经被获取到了。react-router-dom就是通过“/:”去匹配url传递的参数。

**隐式传参**
此外还可以通过push函数隐式传参。

修改home.js代码如下：

```
import React from 'react';


export default class Home extends React.Component {
    constructor(props) {
        super(props);
    }
    
    
    render() {
        return (
            <div>
                <a href='#/detail/3'>去detail</a>
                    <button onClick={() => this.props.history.push({
                        pathname: '/detail',
                        state: {
                            id: 3
                        }
                })}>通过函数跳转</button>
            </div>
        )
    }
}
```
在detail.js中，就可以使用this.props.history.location.state获取home传过来的参数：

```
componentDidMount() {
    //console.log(this.props.match.params);
    console.log(this.props.history.location.state);
}
```
跳转后打开控制台可以看到参数被打印：
![在这里插入图片描述](https://img-blog.csdnimg.cn/972fb5894c804e8c9203fc6d304cf0c5.png)
**嵌套路由**

嵌套路由的适用场景还是比较多的，接下来就来介绍一下实现方法。
首先在Vue中实现嵌套路由，只需要将配置文件写成children嵌套，然后在需要展示子路由的位置加上<router-view></router-view>即可。React中应该如何实现呢？其实原理和Vue类似，只需要在父级路由中包含子路由即可。这样说可能很多同学会一头雾水，直接上代码（不使用上面的例子）：

首先定义父级组件MainLayout

```
import React from 'react';
import './MainLayout.scss';

const { Header, Sider, Content } = Layout;


export default class MainLayout extends React.Component {

    render() {
        return (
            <div className='main-layout'>
                父组件
            </div>
        );
    }
}
```
然后定义子组件Home：

```
import React, {useState} from 'react';
import {Modal, Select} from "antd";
import {connect} from 'react-redux';
import {addCount} from '../../servers/home';


function Home(props) {
    const [visible, setVisible] = useState(false);
    const {countNum: {count}, dispatch} = props;

    return (
        <div>
            子组件
        </div>
    )
}

export default Home;
```
然后将它们添加进路由router.js，并且关联父子关系：

```
import React from 'react';
import {HashRouter, Route, Switch} from "react-router-dom";
import Home from '../pages/Home/Home';
import MainLayout from '../layout/MainLayout';

const BasicRouter = () => (
    <HashRouter>
        <Switch>
            <Route path="/index" component={
                <MainLayout>
                  <Route exact path="/" component={Home}/>
                  <Route exact path="/index" component={Home}/>
                  <Route path="/index/home" component={Home}/>
                </MainLayout>
             }/>
        </Switch>
    </HashRouter>
);


export default BasicRouter;
```

在MainLayout中，修改如下代码：

```
import React from 'react';
import './MainLayout.scss';

const { Header, Sider, Content } = Layout;


export default class MainLayout extends React.Component {

    render() {
        return (
            <div className='main-layout'>
                {this.props.children}
            </div>
        );
    }
}
```
如此，一个嵌套路由就完成了。

**2.react-router-dom版本6语法**

< Switch >  ->    < Routes >
component={hello}  -> element={< hello />}

## 组件
组件，从概念上类似于 JavaScript 函数。它接受任意的入参（即 “props”），并返回用于描述页面展示内容的 React 元素。

1.函数组件
定义组件最简单的方式就是编写 JavaScript 函数：

```typescript
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}
```
该函数是一个有效的 React 组件，因为它接收唯一带有数据的 “props”（代表属性）对象与并返回一个 React 元素。这类组件被称为“函数组件”，因为它本质上就是 JavaScript 函数。

2.class组件

```typescript
class Welcome extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}</h1>;
  }
}
```
上述两个组件在 React 里是等效的。
## Props
[原文](https://www.jianshu.com/p/1b32ceb8295c)

组件从概念上看就是一个函数，可以接受一个参数作为输入值，这个参数就是props，所以可以把props理解为从外部传入组件内部的数据。由于React是单向数据流，所以props基本上也就是从服父级组件向子组件传递的数据。

### 用法

```typescript
function Hello(props){
    return <div>hello world  +  {props.name}</div>
}

React.render(
    <Hello name="zhangshan"/>,
    document.getElementById('app')
)
```
'<' Hello name="zhangshan"/'>',是什么意思？

为什么我们在方法里面获取的数据是`{props.name}`里面获取到我们传递的name的？

**其实就是我们把参数name="zhangshan" 放在了props里，props这个东西不需要我们定义，这个是react里面就存在的一个东西，专门用来存放我们的要传递的参数的。**

但是在我们的`function Hello(props)`里面，必须显式地传入我们的props。

那如果要传递很多参数呢？

```typescript
function Hello(props){
    return <div>hello world  +  {props.name} + {props.id}</div>
}

React.render(
    <Hello name="zhangshan" id={12}/>,
    document.getElementById('app')
)
```

相当于，我们把name和id都放入了props里面。props里面到底能够容纳多少的参数，目前我们不考虑。

但是我们发现id={12}，这个参数的样式跟到我们的name="zhangshan"不一样，为什么呢？

**id我们需要传入的是一个数字，所以我们不能用分号，如果我们用分号的话id=“12”，那么12就是一个字符串了。**

最后还有一个很重要的点：`props是只读的`

什么是只读呢？

意思是任何修改props里面参数的操作，都是错误的！例如下面：

```typescript
function Hello(props){
    props.name="lisi"
    return <div>hello world  +  {props.name} + {props.id}</div>
}
```

### 只读性
props经常被用作渲染组件和初始化状态，当一个组件被实例化之后，它的props是只读的，不可改变的。如果props在渲染过程中可以被改变，会导致这个组件显示的形态变得不可预测。只有通过父组件重新渲染的方式才可以把新的props传入组件中

### 默认参数
在组件中，我们最好为props中的参数设置一个defaultProps，并且制定它的类型。比如，这样：

```typescript
Item.defaultProps = {
  item: 'Hello Props',
};

Item.propTypes = {
  item: PropTypes.string,
};
```
关于propTypes，可以声明为以下几种类型：

```typescript
optionalArray: PropTypes.array,
optionalBool: PropTypes.bool,
optionalFunc: PropTypes.func,
optionalNumber: PropTypes.number,
optionalObject: PropTypes.object,
optionalString: PropTypes.string,
optionalSymbol: PropTypes.symbol,
```
注意，bool和func是简写。
[复杂数据类型](https://link.segmentfault.com/?enc=XZBU0TmiI6SKqfvrMkCdjw==.Sre3YLwtIWGHuDErH33uREve5dWfkwURRNAKvKUhsV/VWVJDhYMqXAyqrVb8z42nC0Ov/X24XCdEp4w8kBAeuFpnjcoVi7lyjo7s1ldlwUY=)
### 总结
props是一个从外部传进组件的参数，主要作为就是从父组件向子组件传递数据，它具有可读性和不变性，只能通过外部组件主动传入新的props来重新渲染子组件，否则子组件的props以及展现形式不会改变。

## state
[原文](https://segmentfault.com/a/1190000011184076)

State is similar to props, but it is private and fully controlled by the component.
### 用法

```typescript
export default class ItemList extends React.Component{
  constructor(){
    super();
    this.state = {
      itemList:'一些数据',
    }
  }
  render(){
    return (
      {this.state.itemList}
    )
  }
}
```
首先，在组件初始化的时候，通过this.state给组件设定一个初始的state，在第一次render的时候就会用这个数据来渲染组件。
如果要传参数，constructor、super括号里面都要加入props

### setState
state不同于props的一点是，state是可以被改变的。不过，不可以直接通过this.state=的方式来修改，而需要通过this.setState()方法来修改state。

比如，我们经常会通过异步操作来获取数据，我们需要在didMount阶段来执行异步操作：

```typescript
componentDidMount(){
  fetch('url')
    .then(response => response.json())
    .then((data) => {
      this.setState({itemList:item});  
    }
}
```
当数据获取完成后，通过this.setState来修改数据状态。

当我们调用this.setState方法时，React会更新组件的数据状态state，并且重新调用render方法，也就是会对组件进行重新渲染。

**注意：通过this.state=来初始化state，使用this.setState来修改state，constructor是唯一能够初始化的地方。**

setState接受一个对象或者函数作为第一个参数，只需要传入需要更新的部分即可，不需要传入整个对象，比如：

```typescript
export default class ItemList extends React.Component{
  constructor(){
    super();
    this.state = {
      name:'axuebin',
      age:25,
    }
  }
  componentDidMount(){
    this.setState({age:18})  
  }
}
```
在执行完setState之后的state应该是{name:'axuebin',age:18}。

setState还可以接受第二个参数，它是一个函数，会在setState调用完成并且组件开始重新渲染时被调用，可以用来监听渲染是否完成：

```typescript
this.setState({
  name:'xb'
},()=>console.log('setState finished'))
```
### 总结
state的主要作用是用于组件保存、控制以及修改自己的状态，它只能在constructor中初始化，它算是组件的私有属性，不可通过外部访问和修改，只能通过组件内部的this.setState来修改，修改state属性会导致组件的重新渲染。

### 区别

 - state是组件自己管理数据，控制自己的状态，可变；
 - props是外部传入的数据参数，不可变；
 - 没有state的叫做无状态组件，有state的叫做有状态组件；
 - 多用props，少用state。也就是多写无状态组件。

## ant design
使用方法。
![在这里插入图片描述](https://img-blog.csdnimg.cn/3b09dec16e4946f6a9b46e1a55e1c5d6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16)
打开组件对应的源码，把里面的东西复制出来。

```
import { Layout, Menu, Breadcrumb, Icon } from 'antd';
import React, { Component } from "react";
import "antd/dist/antd.css";


const { SubMenu } = Menu;
const { Header, Content, Sider } = Layout;

class SiderDemo extends Component {
　　render(){
     return(
  <Layout>
    <Header className="header">
      <div className="logo" />
      <Menu
        theme="dark"
        mode="horizontal"
        defaultSelectedKeys={['2']}
        style={{ lineHeight: '64px' }}
      >
        <Menu.Item key="1">nav 1</Menu.Item>
        <Menu.Item key="2">nav 2</Menu.Item>
        <Menu.Item key="3">nav 3</Menu.Item>
      </Menu>
    </Header>
    <Layout>
      <Sider width={200} style={{ background: '#fff' }}>
        <Menu
          mode="inline"
          defaultSelectedKeys={['1']}
          defaultOpenKeys={['sub1']}
          style={{ height: '100%', borderRight: 0 }}
        >
          <SubMenu key="sub1" title={<span><Icon type="user" />subnav 1</span>}>
            <Menu.Item key="1">option1</Menu.Item>
            <Menu.Item key="2">option2</Menu.Item>
            <Menu.Item key="3">option3</Menu.Item>
            <Menu.Item key="4">option4</Menu.Item>
          </SubMenu>
          <SubMenu key="sub2" title={<span><Icon type="laptop" />subnav 2</span>}>
            <Menu.Item key="5">option5</Menu.Item>
            <Menu.Item key="6">option6</Menu.Item>
            <Menu.Item key="7">option7</Menu.Item>
            <Menu.Item key="8">option8</Menu.Item>
          </SubMenu>
          <SubMenu key="sub3" title={<span><Icon type="notification" />subnav 3</span>}>
            <Menu.Item key="9">option9</Menu.Item>
            <Menu.Item key="10">option10</Menu.Item>
            <Menu.Item key="11">option11</Menu.Item>
            <Menu.Item key="12">option12</Menu.Item>
          </SubMenu>
        </Menu>
      </Sider>
      <Layout style={{ padding: '0 24px 24px' }}>
        <Breadcrumb style={{ margin: '16px 0' }}>
          <Breadcrumb.Item>Home</Breadcrumb.Item>
          <Breadcrumb.Item>List</Breadcrumb.Item>
          <Breadcrumb.Item>App</Breadcrumb.Item>
        </Breadcrumb>
        <Content style={{ background: '#fff', padding: 24, margin: 0, minHeight: 280 }}>
          Content
        </Content>
      </Layout>
    </Layout>
    </Layout>
    )}
}
export default SiderDemo;

```

以上面的为例，组件叫做SiderDemo。return里面的内容就是源码里面ReactDOM.renderd里面的东西，这里面最后的mountNode去掉了。
其余的东西放到class外面。
![在这里插入图片描述](https://img-blog.csdnimg.cn/b2954d452d23433d8ecfd48074bf2c67.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16)
引入：
![在这里插入图片描述](https://img-blog.csdnimg.cn/19507c43b4a94db283f8c9bff258c5ce.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16)

## 组件中对a标签的href的带变量拼接
关键点是外面加了大括号
```powershell
linkContent=<a href={DATA.serverUrl+'service/apartment'+url+'?apartmentId='+urlID}><p>名称：{this.props.name}</p></a>
```

## 向路由组件传递参数
[原文链接](https://blog.csdn.net/zeroheitao/article/details/118057313?spm=1001.2101.3001.6661.1&depth_1-utm_relevant_index=1)


# Dom

## Dom简介
DOM (Document Object Model，文档对象模型) 是 W3C 制定的访问、操作 HTML 和XML的标准。

DOM 节点是契合HTML标准的，可以对其细分：

整个文档是一个文档节点
HTML 元素内的文本是文本节点
每个 HTML 元素是元素节点
每个 HTML 属性是属性节点
注释为注释节点

![在这里插入图片描述](http://img.mukewang.com/wiki/5e82d6a40942890d12001242.jpg)


## 获取与操作Dom

**详细的可以看慕课网**

获取 DOM 节点的方式有很多，这里例举几个常用的，所有的 DOM 元素都具有以下方法：

element.getElementById
element.getElementByName
element.getElementsByTagName
element.getElementsByClassName
element.querySelector
element.querySelectorAll

# Npm
## 查看包信息
方案一：
**直接看package.json，项目相关的都在里面**

方案二：

查看全局已安装（-g 的意思是 global 全局的意思）

```
$ npm ls -g
```
查看当前项目已安装包（项目跟目录必须有 package.json 文件）
```bash
$ npm ls
```
查看包本版

```bash
npm view <packagename> versions --json
```

同样也是会把所有包的依赖显示出来。同上，加上 --depth 0 就好了。

```bash
$ npm ls --depth 0
```

如果只想显示生产环境依赖的包

```bash
$ npm ls --depth 0 --prod
```

只显示开发环境依赖的包

```bash
$ npm ls --depth 0 --dev
```

## npm 与 npx
在npm的基础之上，npx让npm包中的命令行工具和其他可执行文件在使用上变得更加简单。它极大地简化了我们之前使用纯粹的npm时所需要的大量步骤。

**区别1.一个永久存在，一个临时安装，用完后删除**

```
npm install -g create-react-app
create-react-app test-app
```
```
npx create-react-app test-app
```
npm他会在本地全局性的安装create-react-app，这个包会存储在node目录下面去。以后创建react项目直接执行create-react-app命令就可以了。
npx命令他会把create-react-app安装包临时安装上，等项目初始化完成以后，他就删除掉。

**npx 会帮你执行依赖包里的二进制文件**

执行webpack里面的文件 npm执行
```
npm i -D webpack ./node_modules/.bin/webpack -v
结果是：6.9.0

或者执行
npm i -D webpack`npm bin`/webpack -v

```
npx执行
```
npm i -D webpack
npx webpack -v
```
 npx 会自动查找当前依赖包中的可执行文件，如果找不到，就会去环境变量里面的 PATH 里找。如果依然找不到，就会帮你安装！

**区别3.npx可以执行文件，但是npm不可以**







# 异步
## 同步、异步
**同步** 行为通常指代码从上到下一行一行的顺序执行，后面的代码总是在前面的代码执行完成以后才会执行。
```
let a, b;
function foo() {
    a = 1;
}
foo();
b = a + 1;
console.log(b); //2
```

**异步** 行为则指代码并非按照顺序执行，后面的代码不一定总是在前面的代码执行完成以后才会执行。
```
let a, b;
function foo() {
    a = 1;
}
setTimeout(foo, 1000); //1 秒以后再调用 foo()
b = a + 1;
console.log(b); //NaN
```

1. 这里没有显式的调用 foo()，而是将函数名 foo 传递给 setTimeout，JavaScript 运行时在 1 秒以后会自动调用 foo()。

2. 首先代码依然顺序执行，当执行到 setTimeout(foo, 1000); 时，JavaScript 主线程发现这是一个将要异步执行的任务，就会将 foo() 放入 任务队列 然后继续执行下面的同步代码 b = a + 1;，当 b = a + 1; 执行完毕，所有同步代码都被执行完成，此时 JavaScript 主线程再去 任务队列 中取出需要执行的任务来执行，也就是 1 秒后执行 foo()。

3. 因为 b = a + 1; 先于 foo() 执行，所以这段异步操作执行后，变量 b 最终结果为 NaN。

## 回调函数
在 **异步** 操作示例中，**setTimeout(foo, 1000)**; 这句代码中的 **foo** 就可以被称作 回调函数。所谓 回调函数，就是被主线程放入到 任务队列 中的代码，这段代码通常以函数为单位，并且等到所有 同步 代码执行完成以后才会被执行。

所以上面的 **异步** 操作示例程序如果想得到与 **同步** 操作一样的结果，就得改成这样：

```
let a, b;
function foo() {
    a = 1;
    b = a + 1;
    console.log(b); //2
}
setTimeout(foo, 1000); //1 秒以后再调用 foo()
```
因为计算 b 的值时依赖 a 的值，而 a = 1; 是在 回调函数 中执行的，也就是说所有 同步 代码执行完成以后才会执行 回调函数 中的 异步 代码，所以 b = a + 1; 也要移动到 回调函数 中。回调函数 中的代码也是顺序执行的，所以 b = a + 1; 语句要放在 a = 1; 语句之后。这样就能使变量 b 最终结果为 2

## 获取异步函数返回值的方法

在项目中会遇到通过ajax、setTimeout等异步操作向后台获取数据，而js自身不会等待数据拿到后再进行下一步操作，所以会导致其他函数无法获取异步操作函数内的数据。例如：
```
function back(x,y){
    var ret;
    setTimeout(function(){
        ret = x + y;
    },1000)
    return ret;
};
 
console.log(back(10,20));    //undefined
```


1. 回调函数
```
function back(x,y,callback){
    setTimeout(function(){
        var ret = x + y
        callback(ret)
    },1000)
}
 
back(10,20,function(a){
    //在这里面就可以进行对数据的操作了
    
    console.log(a)	//a就是回调的结果，输出30
})
```
```
function getSomething(cb) {
    var r = 0;
    setTimeout(function() {
        r = 2;
        cb(r)//回调函数
    },10)
}
function compute(x) {
    alert(x * 2);
}
getSomething(compute);
```

2. 通过promise的方式
```
function getSomething() {
    var r = 0;
    return new Promise(function(resolve) {
        setTimeout(function(){
            r = 2;
            resolve(r);
        },10)
    })
}
function compute(x) {
    alert(x * 2);
}
getSomething().then(compute);
```

3. 通过async的方式
```
function getSomething() {
    var r = 0;
    return new Promise(function(resolve) {
        setTimeout(function() {
            r = 2;
            resolve(r);
        },10)
    })
}
async function compute() {
    var x = await getSomething();
    alert(x * 2);
}
compute();
```

4. 通过generator方式实现
```
function getSomething() {
    var r = 0;
    setTimeout(function() {
        r = 2;
        it.next(r);
    },10);
}
function *compute(it) {
    var x = yield getSomething();
    alert(x * 2);
}
var it = compute();
it.next();
//同步的写法实现异步的逻辑
```

5. 通过promise和generator相结合的方式
```
function getSomething() {
    var r = 0;
    return new Promise(function(resolve) {
        setTimeout(function() {
            r = 2;
            resolve(r);
        },10)
    })
}
function *compute() {
    var x = yield getSomething();
    alert(x * 2);
}
var it = compute();
it.next().value.then(function(value) {
    it.next(value);
})
```


## Ajax
**AJAX（Asynchronous Javascript And XML）翻译成中文就是“异步的Javascript和XML”**
**实现前后端数据的交互**

### 优点

```bash
1.Ajax最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。 (这一特点给用户的感受是在不知不觉中完成请求和响应过程) 2.Ajax不需要任何浏览器插件，但需要用户允许javaScript在浏览器上执行。
同步交互: 客户端发出一个请求后，需要等待服务器响应结束后，才能发出第二个请求。

异步交互: 客户端发出一个请求后，无需要等待服务器响应结束，就可以发出第二个请求。
```


Ajax使用JavaScript技术向服务器发送异步请求

Ajax请求无须刷新整个页面

因为服务器响应内容不再是整个页面，而是页面中的部分内容，所以Ajax性能高！

### 工作原理
![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/a83d7857217f3e6d72b8fab68fb3adb9.gif#pic_center)
# 跨域
[原文链接](https://blog.csdn.net/weixin_48837605/article/details/119494467)
## 什么是跨域
 当一个请求url的**协议,域名,端口**三者之间任意一个与当前的url不同都即为跨域
 

```bash
 当前页面url                  被请求页面url                是否跨域            原因
http://www.test.com/    http://www.test.com/index.html    否            同源（协议、域名、端口号相同）
http://www.test.com/    https://www.test.com/index.html   跨域          协议不同（http/https）
http://www.test.com/    http://www.baidu.com/             跨域          主域名不同（test/baidu）
http://www.test.com/    http://blog.test.com/             跨域          子域名不同（www/blog）
```

## 为什么会出现跨域
出于浏览器的同源策略限制.同源策略是一种约定,它是浏览器最核心也是最基本的安全功能,如果缺少了同源策略,则浏览器的正常的功能可能会受到影响,跨域收是Web是构建在同源策略基础上的,浏览器只是针对同源策略的一种实现,同源策略会阻止一个域的JavaScript脚本和另一个域的内容进行交互,所谓同源(即指同一个域)就是两个页面具备同样的协议(protocol),主机(host)和端口号(port)

**请求是跨域的，并不一定会报错。普通的图片请求，css文件请求是不会报错的**

## 跨域会阻止什么操作
浏览器是从两个方面去做这个同源策略的，一是针对接口的请求，二是针对Dom的查询

### 1.阻止接口请求
比如用ajax从http://192.168.100.150:8020/实验/jsonp.html页面向http://192.168.100.150:8081/zhxZone/webmana/dict/jsonp发起请求，由于两个url端口不同，所以属于跨域，在console打印台会报No 'Access-Control-Allow-Origin' header is present on the requested resource
![在这里插入图片描述](https://img-blog.csdnimg.cn/20181207092232976.png#pic_center)
值得说的是虽然浏览器禁止用户对请求返回数据的显示和操作，但浏览器确实是去请求了，如果服务器没有做限制的话会返回数据的，在调试模式的network中可以看到返回状态为200，且可看到返回数据
![在这里插入图片描述](https://img-blog.csdnimg.cn/20181207092757327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpYW56aGFuZzg2MQ==,size_16,color_FFFFFF,t_70#pic_center)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20181207092820725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpYW56aGFuZzg2MQ==,size_16,color_FFFFFF,t_70#pic_center)
### 2.阻止dom获取和操作
比如a页面中嵌入了iframe，src为不同源的b页面，则在a中无法操作b中的dom，也没有办法改变b中dom中的css样式。

而如果ab是同源的话是可以获取并操作的。

```bash
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
		<style type="text/css">
			iframe{
				width:100%;height:800px;
			}
		</style>
	</head>
	<body>
		<!--<iframe src="http://192.168.100.150:8081/zhxZone/webmana/attachment/imageManager" frameborder="0" id="iframe"></iframe>-->
		<iframe src="http://192.168.100.150:8020/实验/jsonp.html" frameborder="0" id="iframe"></iframe>
		<script type="text/javascript">
			var i=document.getElementById("iframe");
			i.onload=function(){
				/*console.log(i.contentDocument)
				console.log(i.contentWindow.document.getElementById("text").innerHTML)*/
				var b=i.contentWindow.document.getElementsByTagName("body")[0];
				i.contentWindow.document.getElementById("text").style.background="gray";
				i.contentWindow.document.getElementById("text").innerHTML="111";
			}
		</script>
	</body>
</html>
```
改变了iframe中的元素 

![在这里插入图片描述](https://img-blog.csdnimg.cn/8b0167fa9e5647359acc6466b8e421bd.png)


甚至是可以获取iframe中的cookie

```bash
var i=document.getElementById("iframe");
i.onload=function(){
	console.log(i.contentDocument.cookie)
}
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/681d3b6bcb6d4b039578fc23e6de073b.png)

不用说也知道这是极为危险的，所以浏览器才会阻止非同源操作dom

浏览器的这个限制虽然不能保证完全安全，但是会增加攻击的困难性

虽然安全机制挺好，可以抵御坏人入侵，但有时我们自己需要跨域请求接口数据或者操作自己的dom，也被浏览器阻止了，所以就需要跨域

跨域的前提肯定是你和服务器是一伙的，你可以控制服务器返回的数据，否则跨域是无法完成的 

## 解决跨域的方法
### 前端jsp
### CORS方案
**就是通过服务器设置响应头来实现跨域**

CORS才是解决跨域的真正解决方案。
前端需要做什么？
无需做任何事情，正常发送Ajax请求即可。
后端需要做什么？
需要加 响应头 。或者使用第三方模块 cors 。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210807230949959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80ODgzNzYwNQ==,size_16,color_FFFFFF,t_70#pic_center)
### 代理服务器（一般用Nginx）
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210807231812945.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80ODgzNzYwNQ==,size_16,color_FFFFFF,t_70#pic_center)
   1).代理服务和前端服务之间由于协议域名端口三者统一不存在跨域的问题,可以直接发送请求

   2).代理服务和后端服务之间并不通过浏览器没有同源策略的限制,可以直接发送请求

这里是一个nginx启用COSR的参考配置

```bash
#
# Wide-open CORS config for nginx
#
location / {
     if ($request_method = 'OPTIONS') {
        add_header 'Access-Control-Allow-Origin' '*';
        add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS';
        #
        # Custom headers and headers various browsers *should* be OK with but aren't
        #
        add_header 'Access-Control-Allow-Headers' 'DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type';
        #
        # Tell client that this pre-flight info is valid for 20 days
        #
        add_header 'Access-Control-Max-Age' 1728000;
        add_header 'Content-Type' 'text/plain charset=UTF-8';
        add_header 'Content-Length' 0;
        return 204;
     }
     if ($request_method = 'POST') {
        add_header 'Access-Control-Allow-Origin' '*';
        add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS';
        add_header 'Access-Control-Allow-Headers' 'DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type';
     }
     if ($request_method = 'GET') {
        add_header 'Access-Control-Allow-Origin' '*';
        add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS';
        add_header 'Access-Control-Allow-Headers' 'DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type';
     }
}
```

# 调试方法
**快捷键：**

```typescript
F8：进入下一个断点
F10：单步执行，不进入子函数
F11：单步执行，遇到子函数会进入子函数
shift+F11：跳出当前函数
```
