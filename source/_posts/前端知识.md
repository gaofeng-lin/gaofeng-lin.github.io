---
title: 前端知识
date: 2022/1/14


categories:
  - 前端开发
  
tags:
  - Vue
  - React
  - JavaScript
  - Json
---





#  React
##  启动流程
重点关注三个文件：

```
src/App.js //实现 React 组件

src/index.js // React 世界的入口

public/index.html //挂载的页面
```
1.index.html

```
这个是一个模板文件，里面有过id为root的div标签，会被index.js文件中的JSX替换这个DOM节点。
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/c8637d56e86b4868a275d4a01a1db9c1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16)
2.index.js

```
关键就是这个ReactDOM.render()

简单来说，ReactDOM.render() 会使用你的 JSX 来替换你的 HTML 中的一个 DOM 节点。这
样你就可以很容易地把 React 集成到每一个其他的应用中。ReactDOM.render() 可以在你的
应用中被多次使用。你可以在多个地方使用它来加载简单的 JSX 语法、单个 React 组件、
多个 React 组件或者整个应用。但是在一个纯 React 的应用中，你只会使用一次用来加载你
的整个组件树。
ReactDOM.render() 有两个传入参数。第一个是准备渲染的 JSX。第二个参数指定了 React
应用在你的 HTML 中的放置的位置。这个位置是一个 id='root' 的元素。你可以在文件
public/index.html 中找到这个 id 属性
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/5a6381d4f99b4a56b00f07e3ee28f9c7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16)
3.App.js
在inde.js文件里面，ReactDOM.render() 总会很好地渲染你的 App 组件。一般来说，某个组件叫xxx，那么他的代码就叫xxx.js。要想知道页面被渲染成什么样，就看看里面内容。
![在这里插入图片描述](https://img-blog.csdnimg.cn/378a772ce66d41e9b70b563c6319a470.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16)


##  react-router-dom路由
**1.这是react-router-dom5的用法，现在默认安装的是6，下面会写6的语法**

[原文章链接](https://www.jianshu.com/p/8954e9fb0c7e)
来源：简书

**使用背景：使用React构建的单页面应用，要想实现页面间的跳转，首先想到的就是使用路由。在React中，常用的有两个包可以实现这个需求，那就是react-router和react-router-dom。本文主要针对react-router-dom进行说明。**


###  安装
首先进入项目目录，使用npm安装react-router-dom：

```
npm install react-router-dom --save-dev //这里可以使用cnpm代替npm命令；

//--save-dev 标记表示该 node 包只是用作开发环境的一部分，并不会被作为你产品代码的一
部分发布。哪种 node 包适用这个场景呢？设想你需要一些 node 包辅助测试你的应用，然
后需要通过 npm 来安装这些包，但是不希望他们混入产品代码里面。测试过程应该只会发
生在开发阶段，而不是在线上部署运行的时候。因为那个时候已经用不到测试代码了，你
的应用应该已经被测试完而且可以被你的用户使用了。这可能是你唯一的使用 --save-dev
的场景。
```
###  基本操作
然后我们新建两个页面，分别命名为“home”和“detail”。在页面中编写如下代码：
detail.js
```
import React from 'react';

export default class Home extends React.Component {
    render() {
        return (
            <div>
                <a>去detail</a>
            </div>
        )
    }
}
```
home.js

```
import React from 'react';

export default class Home extends React.Component {
    render() {
        return (
            <div>
                <a>回到home</a>
            </div>
        )
    }
}
```
然后再新建一个路由组件，命名为“Router.js”，并编写如下代码：

```
import React from 'react';
import {HashRouter, Route, Switch} from 'react-router-dom';
import Home from '../home';
import Detail from '../detail';


const BasicRoute = () => (
    <HashRouter>
        <Switch>
            <Route exact path="/" component={Home}/>
            <Route exact path="/detail" component={Detail}/>
        </Switch>
    </HashRouter>
);

export default BasicRoute;
```
如上代码定义了一个纯路由组件，将两个页面组件Home和Detail使用Route组件包裹，外面套用Switch作路由匹配，当路由组件检测到地址栏与Route的path匹配时，就会自动加载响应的页面。
然后在入口文件中——我这里指定的是index.js——编写如下代码：

```
import React from 'react';
import ReactDOM from 'react-dom';
import Router from './router/router';

ReactDOM.render(
  <Router/>,
  document.getElementById('root')
);
```

这里相当于向页面返回了一个路由组件。我们先运行项目看一下效果，在地址栏输入“http://localhost:3000/#/”：
![在这里插入图片描述](https://img-blog.csdnimg.cn/37aee935c7534aa39a98acfcf884e278.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16)

输入“http://localhost:3000/#/detail”：
![在这里插入图片描述](https://img-blog.csdnimg.cn/891f1a191f764e2295b057870300cd76.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16)
**通过a标签跳转**
可以看到其实路由已经开始工作了，接下来我们再来做页面间的跳转。在home.js和detail.js中，我们修改如下代码：

```
import React from 'react';


    export default class Home extends React.Component {
        render() {
            return (
                <div>
                <a href='#/detail'>去detail</a>
            </div>
        )
    }
}
```
home.js

```
import React from 'react';

export default class Home extends React.Component {
    render() {
        return (
            <div>
                <a href='#/'>回到home</a>
            </div>
        )
    }
}
```
重新打包运行，在浏览器地址栏输入“http://localhost:3000/”，试试看页面能否正常跳转。如果不能，请按步骤一步一步检查代码是否有误。以上是使用a标签的href进行页面间跳转，此外react-router-dom还提供了通过函数的方式跳转页面。

**通过函数跳转**

首先我们需要修改router.js中的两处代码：
然后在home.js中：
import React from 'react';
```
...
import {HashRouter, Route, Switch, hashHistory} from 'react-router-dom';
...
<HashRouter history={hashHistory}>
...
```
在a标签下面添加一个按钮并加上onClick事件，通过this.props.history.push这个函数跳转到detail页面。在路由组件中加入的代码就是将history这个对象注册到组件的props中去，然后就可以在子组件中通过props调用history的push方法跳转页面。

很多场景下，我们还需要在页面跳转的同时传递参数，在react-router-dom中，同样提供了两种方式进行传参。


链接：https://www.jianshu.com/p/8954e9fb0c7e
来源：简书


```
export default class Home extends React.Component {
    constructor(props) {
        super(props);
    }
    
    
    render() {
        return (
            <div>
                <a href='#/detail'>去detail</a>
                <button onClick={() => this.props.history.push('detail')}>通过函数跳转</button>
            </div>
        )
    }
}
```
**url传参**
在router.js中，修改如下代码：

```
...
<Route exact path="/detail/:id" component={Detail}/>
...
```
然后修改detail.js，使用this.props.match.params获取url传过来的参数：

```
...
componentDidMount() {
    console.log(this.props.match.params);
}
...
```
在地址栏输入“http://localhost:3000/#/detail/3”，打开控制台：
![在这里插入图片描述](https://img-blog.csdnimg.cn/d803a9af4817410c8649c09bbf06cdea.png)
可以看到传过去的id=3已经被获取到了。react-router-dom就是通过“/:”去匹配url传递的参数。

**隐式传参**
此外还可以通过push函数隐式传参。

修改home.js代码如下：

```
import React from 'react';


export default class Home extends React.Component {
    constructor(props) {
        super(props);
    }
    
    
    render() {
        return (
            <div>
                <a href='#/detail/3'>去detail</a>
                    <button onClick={() => this.props.history.push({
                        pathname: '/detail',
                        state: {
                            id: 3
                        }
                })}>通过函数跳转</button>
            </div>
        )
    }
}
```
在detail.js中，就可以使用this.props.history.location.state获取home传过来的参数：

```
componentDidMount() {
    //console.log(this.props.match.params);
    console.log(this.props.history.location.state);
}
```
跳转后打开控制台可以看到参数被打印：
![在这里插入图片描述](https://img-blog.csdnimg.cn/972fb5894c804e8c9203fc6d304cf0c5.png)
**嵌套路由**

嵌套路由的适用场景还是比较多的，接下来就来介绍一下实现方法。
首先在Vue中实现嵌套路由，只需要将配置文件写成children嵌套，然后在需要展示子路由的位置加上<router-view></router-view>即可。React中应该如何实现呢？其实原理和Vue类似，只需要在父级路由中包含子路由即可。这样说可能很多同学会一头雾水，直接上代码（不使用上面的例子）：

首先定义父级组件MainLayout

```
import React from 'react';
import './MainLayout.scss';

const { Header, Sider, Content } = Layout;


export default class MainLayout extends React.Component {

    render() {
        return (
            <div className='main-layout'>
                父组件
            </div>
        );
    }
}
```
然后定义子组件Home：

```
import React, {useState} from 'react';
import {Modal, Select} from "antd";
import {connect} from 'react-redux';
import {addCount} from '../../servers/home';


function Home(props) {
    const [visible, setVisible] = useState(false);
    const {countNum: {count}, dispatch} = props;

    return (
        <div>
            子组件
        </div>
    )
}

export default Home;
```
然后将它们添加进路由router.js，并且关联父子关系：

```
import React from 'react';
import {HashRouter, Route, Switch} from "react-router-dom";
import Home from '../pages/Home/Home';
import MainLayout from '../layout/MainLayout';

const BasicRouter = () => (
    <HashRouter>
        <Switch>
            <Route path="/index" component={
                <MainLayout>
                  <Route exact path="/" component={Home}/>
                  <Route exact path="/index" component={Home}/>
                  <Route path="/index/home" component={Home}/>
                </MainLayout>
             }/>
        </Switch>
    </HashRouter>
);


export default BasicRouter;
```

在MainLayout中，修改如下代码：

```
import React from 'react';
import './MainLayout.scss';

const { Header, Sider, Content } = Layout;


export default class MainLayout extends React.Component {

    render() {
        return (
            <div className='main-layout'>
                {this.props.children}
            </div>
        );
    }
}
```
如此，一个嵌套路由就完成了。

**2.react-router-dom版本6语法**

< Switch >  ->    < Routes >
component={hello}  -> element={< hello />}

## 组件
组件，从概念上类似于 JavaScript 函数。它接受任意的入参（即 “props”），并返回用于描述页面展示内容的 React 元素。

1.函数组件
定义组件最简单的方式就是编写 JavaScript 函数：

```typescript
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}
```
该函数是一个有效的 React 组件，因为它接收唯一带有数据的 “props”（代表属性）对象与并返回一个 React 元素。这类组件被称为“函数组件”，因为它本质上就是 JavaScript 函数。

2.class组件

```typescript
class Welcome extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}</h1>;
  }
}
```
上述两个组件在 React 里是等效的。
## Props
[原文](https://www.jianshu.com/p/1b32ceb8295c)

组件从概念上看就是一个函数，可以接受一个参数作为输入值，这个参数就是props，所以可以把props理解为从外部传入组件内部的数据。由于React是单向数据流，所以props基本上也就是从服父级组件向子组件传递的数据。

### 用法

```typescript
function Hello(props){
    return <div>hello world  +  {props.name}</div>
}

React.render(
    <Hello name="zhangshan"/>,
    document.getElementById('app')
)
```
'<' Hello name="zhangshan"/'>',是什么意思？

为什么我们在方法里面获取的数据是`{props.name}`里面获取到我们传递的name的？

**其实就是我们把参数name="zhangshan" 放在了props里，props这个东西不需要我们定义，这个是react里面就存在的一个东西，专门用来存放我们的要传递的参数的。**

但是在我们的`function Hello(props)`里面，必须显式地传入我们的props。

那如果要传递很多参数呢？

```typescript
function Hello(props){
    return <div>hello world  +  {props.name} + {props.id}</div>
}

React.render(
    <Hello name="zhangshan" id={12}/>,
    document.getElementById('app')
)
```

相当于，我们把name和id都放入了props里面。props里面到底能够容纳多少的参数，目前我们不考虑。

但是我们发现id={12}，这个参数的样式跟到我们的name="zhangshan"不一样，为什么呢？

**id我们需要传入的是一个数字，所以我们不能用分号，如果我们用分号的话id=“12”，那么12就是一个字符串了。**

最后还有一个很重要的点：`props是只读的`

什么是只读呢？

意思是任何修改props里面参数的操作，都是错误的！例如下面：

```typescript
function Hello(props){
    props.name="lisi"
    return <div>hello world  +  {props.name} + {props.id}</div>
}
```

### 只读性
props经常被用作渲染组件和初始化状态，当一个组件被实例化之后，它的props是只读的，不可改变的。如果props在渲染过程中可以被改变，会导致这个组件显示的形态变得不可预测。只有通过父组件重新渲染的方式才可以把新的props传入组件中

### 默认参数
在组件中，我们最好为props中的参数设置一个defaultProps，并且制定它的类型。比如，这样：

```typescript
Item.defaultProps = {
  item: 'Hello Props',
};

Item.propTypes = {
  item: PropTypes.string,
};
```
关于propTypes，可以声明为以下几种类型：

```typescript
optionalArray: PropTypes.array,
optionalBool: PropTypes.bool,
optionalFunc: PropTypes.func,
optionalNumber: PropTypes.number,
optionalObject: PropTypes.object,
optionalString: PropTypes.string,
optionalSymbol: PropTypes.symbol,
```
注意，bool和func是简写。
[复杂数据类型](https://link.segmentfault.com/?enc=XZBU0TmiI6SKqfvrMkCdjw==.Sre3YLwtIWGHuDErH33uREve5dWfkwURRNAKvKUhsV/VWVJDhYMqXAyqrVb8z42nC0Ov/X24XCdEp4w8kBAeuFpnjcoVi7lyjo7s1ldlwUY=)
### 总结
props是一个从外部传进组件的参数，主要作为就是从父组件向子组件传递数据，它具有可读性和不变性，只能通过外部组件主动传入新的props来重新渲染子组件，否则子组件的props以及展现形式不会改变。

## state
[原文](https://segmentfault.com/a/1190000011184076)

State is similar to props, but it is private and fully controlled by the component.
### 用法

```typescript
export default class ItemList extends React.Component{
  constructor(){
    super();
    this.state = {
      itemList:'一些数据',
    }
  }
  render(){
    return (
      {this.state.itemList}
    )
  }
}
```
首先，在组件初始化的时候，通过this.state给组件设定一个初始的state，在第一次render的时候就会用这个数据来渲染组件。
如果要传参数，constructor、super括号里面都要加入props

### setState
state不同于props的一点是，state是可以被改变的。不过，不可以直接通过this.state=的方式来修改，而需要通过this.setState()方法来修改state。

比如，我们经常会通过异步操作来获取数据，我们需要在didMount阶段来执行异步操作：

```typescript
componentDidMount(){
  fetch('url')
    .then(response => response.json())
    .then((data) => {
      this.setState({itemList:item});  
    }
}
```
当数据获取完成后，通过this.setState来修改数据状态。

当我们调用this.setState方法时，React会更新组件的数据状态state，并且重新调用render方法，也就是会对组件进行重新渲染。

**注意：通过this.state=来初始化state，使用this.setState来修改state，constructor是唯一能够初始化的地方。**

setState接受一个对象或者函数作为第一个参数，只需要传入需要更新的部分即可，不需要传入整个对象，比如：

```typescript
export default class ItemList extends React.Component{
  constructor(){
    super();
    this.state = {
      name:'axuebin',
      age:25,
    }
  }
  componentDidMount(){
    this.setState({age:18})  
  }
}
```
在执行完setState之后的state应该是{name:'axuebin',age:18}。

setState还可以接受第二个参数，它是一个函数，会在setState调用完成并且组件开始重新渲染时被调用，可以用来监听渲染是否完成：

```typescript
this.setState({
  name:'xb'
},()=>console.log('setState finished'))
```
### 总结
state的主要作用是用于组件保存、控制以及修改自己的状态，它只能在constructor中初始化，它算是组件的私有属性，不可通过外部访问和修改，只能通过组件内部的this.setState来修改，修改state属性会导致组件的重新渲染。

### 区别

 - state是组件自己管理数据，控制自己的状态，可变；
 - props是外部传入的数据参数，不可变；
 - 没有state的叫做无状态组件，有state的叫做有状态组件；
 - 多用props，少用state。也就是多写无状态组件。

## ant design
使用方法。
![在这里插入图片描述](https://img-blog.csdnimg.cn/3b09dec16e4946f6a9b46e1a55e1c5d6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16)
打开组件对应的源码，把里面的东西复制出来。

```
import { Layout, Menu, Breadcrumb, Icon } from 'antd';
import React, { Component } from "react";
import "antd/dist/antd.css";


const { SubMenu } = Menu;
const { Header, Content, Sider } = Layout;

class SiderDemo extends Component {
　　render(){
     return(
  <Layout>
    <Header className="header">
      <div className="logo" />
      <Menu
        theme="dark"
        mode="horizontal"
        defaultSelectedKeys={['2']}
        style={{ lineHeight: '64px' }}
      >
        <Menu.Item key="1">nav 1</Menu.Item>
        <Menu.Item key="2">nav 2</Menu.Item>
        <Menu.Item key="3">nav 3</Menu.Item>
      </Menu>
    </Header>
    <Layout>
      <Sider width={200} style={{ background: '#fff' }}>
        <Menu
          mode="inline"
          defaultSelectedKeys={['1']}
          defaultOpenKeys={['sub1']}
          style={{ height: '100%', borderRight: 0 }}
        >
          <SubMenu key="sub1" title={<span><Icon type="user" />subnav 1</span>}>
            <Menu.Item key="1">option1</Menu.Item>
            <Menu.Item key="2">option2</Menu.Item>
            <Menu.Item key="3">option3</Menu.Item>
            <Menu.Item key="4">option4</Menu.Item>
          </SubMenu>
          <SubMenu key="sub2" title={<span><Icon type="laptop" />subnav 2</span>}>
            <Menu.Item key="5">option5</Menu.Item>
            <Menu.Item key="6">option6</Menu.Item>
            <Menu.Item key="7">option7</Menu.Item>
            <Menu.Item key="8">option8</Menu.Item>
          </SubMenu>
          <SubMenu key="sub3" title={<span><Icon type="notification" />subnav 3</span>}>
            <Menu.Item key="9">option9</Menu.Item>
            <Menu.Item key="10">option10</Menu.Item>
            <Menu.Item key="11">option11</Menu.Item>
            <Menu.Item key="12">option12</Menu.Item>
          </SubMenu>
        </Menu>
      </Sider>
      <Layout style={{ padding: '0 24px 24px' }}>
        <Breadcrumb style={{ margin: '16px 0' }}>
          <Breadcrumb.Item>Home</Breadcrumb.Item>
          <Breadcrumb.Item>List</Breadcrumb.Item>
          <Breadcrumb.Item>App</Breadcrumb.Item>
        </Breadcrumb>
        <Content style={{ background: '#fff', padding: 24, margin: 0, minHeight: 280 }}>
          Content
        </Content>
      </Layout>
    </Layout>
    </Layout>
    )}
}
export default SiderDemo;

```

以上面的为例，组件叫做SiderDemo。return里面的内容就是源码里面ReactDOM.renderd里面的东西，这里面最后的mountNode去掉了。
其余的东西放到class外面。
![在这里插入图片描述](https://img-blog.csdnimg.cn/b2954d452d23433d8ecfd48074bf2c67.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16)
引入：
![在这里插入图片描述](https://img-blog.csdnimg.cn/19507c43b4a94db283f8c9bff258c5ce.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16)

## 组件中对a标签的href的带变量拼接
关键点是外面加了大括号
```powershell
linkContent=<a href={DATA.serverUrl+'service/apartment'+url+'?apartmentId='+urlID}><p>名称：{this.props.name}</p></a>
```

## 向路由组件传递参数
[原文链接](https://blog.csdn.net/zeroheitao/article/details/118057313?spm=1001.2101.3001.6661.1&depth_1-utm_relevant_index=1)

# Npm
## 查看包信息
方案一：
**直接看package.json，项目相关的都在里面**

方案二：

查看全局已安装（-g 的意思是 global 全局的意思）

```
$ npm ls -g
```
查看当前项目已安装包（项目跟目录必须有 package.json 文件）
```bash
$ npm ls
```
查看包本版

```bash
npm view <packagename> versions --json
```

同样也是会把所有包的依赖显示出来。同上，加上 --depth 0 就好了。

```bash
$ npm ls --depth 0
```

如果只想显示生产环境依赖的包

```bash
$ npm ls --depth 0 --prod
```

只显示开发环境依赖的包

```bash
$ npm ls --depth 0 --dev
```

## npm 与 npx
在npm的基础之上，npx让npm包中的命令行工具和其他可执行文件在使用上变得更加简单。它极大地简化了我们之前使用纯粹的npm时所需要的大量步骤。

**区别1.一个永久存在，一个临时安装，用完后删除**

```
npm install -g create-react-app
create-react-app test-app
```
```
npx create-react-app test-app
```
npm他会在本地全局性的安装create-react-app，这个包会存储在node目录下面去。以后创建react项目直接执行create-react-app命令就可以了。
npx命令他会把create-react-app安装包临时安装上，等项目初始化完成以后，他就删除掉。

**npx 会帮你执行依赖包里的二进制文件**

执行webpack里面的文件 npm执行
```
npm i -D webpack ./node_modules/.bin/webpack -v
结果是：6.9.0

或者执行
npm i -D webpack`npm bin`/webpack -v

```
npx执行
```
npm i -D webpack
npx webpack -v
```
 npx 会自动查找当前依赖包中的可执行文件，如果找不到，就会去环境变量里面的 PATH 里找。如果依然找不到，就会帮你安装！

**区别3.npx可以执行文件，但是npm不可以**






# Javascript 
## 箭头函数
箭头函数本质还是函数，我们来看看他与JavaScript中普通函数的区别，先看看写法上的区别。
![在这里插入图片描述](https://img-blog.csdnimg.cn/2b6243000b0d48f69f6baf1e77293818.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16)
**解释**
写箭头函数，我们记住一个顺序就好，参数、箭头、函数体、这个顺序记住就足够了，参数、箭头、函数体、这三个是必须的，函数名可以没有，但这三项必须有，一些简写的方式也是简写这三项里的东西。

**简写**
1、只有一个参数时，() 可省略

```
//不简写
var demo = (x) =>{
    console.log(x);
}

//简写
var demo = x =>{
    console.log(x);
}
```
2、函数体只有一句时， {} 可以省略

```
//不简写
var demo = (x) =>{
    console.log(x);
}

//简写
var demo = x => console.log(x);
```
3、函数体只有一条返回语句时，{} 和 return 都可以省略

```
//不简写
var demo = (x) => {
     return x;
}

//简写
var demo = (x) => x;   

//注意别写成这样  
var demo = (x) =>{ x };  
//或者 这样  
var demo = (x) => return  x;  
//要省略就都省略，不省略就都不省，别省一半,不然会出错的。
```

**注意：**
箭头函数放 参数 的地方就在 () 内，
没有参数，() 必须写，
一个参数，() 可写可不写，
多个参数，() 必须写。

箭头函数放 函数体 的地方在 {}内，
函数体 就 一句 {} 可写可不写，
函数体 不止一句，{} 必须写。

如果不知道，() {} 写不写，该不该省略，那就写，写了不会错。

**箭头函数 如果要返回一个对象，要简写的话， 需要用()包住这个对象**

```
//不简写
var demo = () =>{ 
    return {x:1};
}  

//简写
var demo = () =>({x:1});
```
为什么会这样？因为如果不加 () ，那{ } 就表示的是语法块，不是表示一个对象，而加上()，按照规范来说，() 里面 { } 就会被解析为对象了。

对于 {x:1} 这个情况，他不仅可以表示一个对象，这个对象有个x属性，值为1，也可以表示为语法块中含有 名为 x 的 label，忘记 label语法的话，可以看[这里](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/label)
如果不是很明白，可以看看这个[回答](https://www.zhihu.com/question/40902815)，应该会理解的更加深刻。
所以这也解释了为什么会出现下面代码中的情况

```
// 不报错
var demo = () =>{x:1};

// 报错
var demo = (y) =>{y,x:1};
```
**对象的方法用 箭头函数写时，this 的指向 可能和你想的不一样**

```
window.name='window';
var obj = {
    name:'obj',
    show_name:() =>{
        console.log(this.name);
    }    
}
obj.show_name(); //window
```
JavaScript使用的是函数作用域，在上面这段代码中对象的括号是不能封闭作用域的，所以此时的this还是指向window。
我们换成普通函数看看

```
window.name='window';
var obj = {
    name:'obj',
    show_name: function (){
        console.log(this.name);
    }    
}
obj.show_name();  //obj
```
换成普通函数，this 就不是指向window，而是指向 obj 对象了

箭头函数 与 普通函数 其他的区别

> 1、箭头函数没有自己的this。箭头函数会捕获其所在上下文的 this 值，作为自己的 this 值。
>  2、箭头函数 this不可变。call()、apply()、bind()、这些方法也 无法改变 箭头函数 this 的指向。
>   3、箭头函数 不能用 new关键字来实例化对象，不然会报错。 
>   4、箭头函数没有arguments对象。

1、箭头函数没有自己的this。箭头函数会捕获其所在上下文的 this 值，作为自己的 this 值。

```
window.name = 'window';
var obj = {
    name:'obj',
    show_name:function (){
        function fn (){
            console.log(this.name);
        }
        fn();
    },
}
obj.show_name();  // window
```
声明一个 obj 对象，有一个name属性 与 show_name方法，上面这段代码，我的本意是想显示 obj对象的name， 但是没和我想的一样，一般我们会用 一个变量 self 或者 that 之类的留住this,像这样

```
window.name = 'window';
var obj = {
    name:'obj',
    show_name:function (){
        //留住this
        var that = this;
        function fn (){
            console.log(that.name);
        }
        fn();
    },
}
obj.show_name();  //obj
```
通常来说，箭头函数内部的this就是外层代码块的this

```
window.name = 'window';
var obj = {
    name:'obj',
    show_name:function (){
        var fn = () => {
            console.log(this.name);
        }
        fn();
    },
}
obj.show_name(); //obj
```
2、箭头函数 this 不可变。call()、apply()、bind()、这些方法也 无法改变 箭头函数 this 的指向。

```
window.name = 'window';
var obj = {
    name:'obj',
}
function show_name(){
    //这里 show_name 是一个普通的全局函数，所以他的this指window
    console.log(this.name);
}
//用了 call 方法，把 show_nam 的this 指向了 obj 对象
show_name.call(obj);  //obj
```
箭头函数 this 不可变

```
window.name = 'window';
var obj = {
    name:'obj',
}
var show_name = () => {
    //这里 show_name 是箭头函数，他的this指window，并且不会变
    console.log(this.name);
}
//用了 call 方法，但是 this 没变，所以打印了 window
show_name.call(obj);  //window
```
3、箭头函数 不能用 new 关键字来实例化对象，不然会报错，箭头函数的this 不可变，new 也改变不了 this的 指向，而且更为重要的是，箭头函数内部并没有 [[Construct]] 方法，所以会没有原型属性（prototype），所以箭头函数没法当构造函数。

![在这里插入图片描述](https://img-blog.csdnimg.cn/7803115884ae4f6ab5f8d4cd73cfe038.png)
4、箭头函数没有arguments对象，不能通过arguments对象访问传入参数，但是可以用rest参数实现
。[不了解的看这里](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Rest_parameters)

```
var demo = (...theArgs) => theArgs;
demo(1,2,3); //[1,2,3]
```

**总结**
在来看一遍 箭头函数 与 普通函数，除了写法上的区别

> 1、箭头函数没有自己的this。箭头函数会捕获其所在上下文的 this 值，作为自己的 this 值。 
> 2、箭头函数 this不可变。call()、apply()、bind()、这些方法也 无法改变 箭头函数 this 的指向。 
> 3、箭头函数 不能用 new关键字来实例化对象，不然会报错。 
> 4、箭头函数没有arguments对象。

可以看出，最重要的区别还是 在 this 上，所以要想用好 箭头函数，还是要对 this 有一定认识的。


# Json
## Json schema

> 简单说，Json Schema 其实就是一个标准的 Json 串，它以一个 Json 串来描述我们需要的数据规范，并且支持注释以及验证 Json 文档，即我们可以用 Json Schema 来验证所给的 Json 串是否满足我们需要的数据格式规范。

Json Schema 在我们平时的工作中最常用的有两个，一个就是上面说的用于验证 Json 串的合法性；另一个就是用于定义我们的 API，定义好 API 后，我们可以直接用工具生成我们的 API，这样利于我们对 API 的维护。

### 验证 Json 串的合法性
比如，我们定义的 Json Schema 为：

```
{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "title": "Product",
    "description": "A product from Acme's catalog",
    "type": "object",
    "properties": {
        "id": {
            "description": "The unique identifier for a product",
            "type": "integer"
        },
        "name": {
            "description": "Name of the product",
            "type": "string"
        },
        "price": {
            "type": "number",
            "minimum": 0,
            "exclusiveMinimum": true
        }
    },
    "required": ["id", "name", "price"]
}

```
在上述 Json Schema 中

 - 最上面的 $shcema 是一个关键字，它表示我们所定义的 Schema 和http://json-schema.org/draft-04/schema#（Json Schema 的 v4 规范）是一致的
  
 - title 指的是标题。
 - description 用于描述我们所定义的 Schema，上述表明我们定义的是一个来自 Acme 目录的商品。

  

 - type 表示我们定义的是一个 object 对象。
 - properties 中就是 Schema 的属性了，这里面的是核心。我们可以看到该Schema 一共有三个属性，分别是
   id(integer), name(string), prince(number)。 最后的
 - required 表明三个属性都是必须的。

给定了上述 Schema，我们就可以验证给定的 Json 是否是合规的了。比如：

```
{
  "id": 1,
  "name": "watermelon"
}

```
显然，这个 Json 缺少了一个属性 price，所以它不合规。

```
{
  "id": 1,
  "name": ["knife", "spoon"],
  "price": 4
}

```
这个 Json 的 name 属性是一个数组，我们上面规定 name 只能是 String，显然这个也不是合规的。

```
{
  "id": 1,
  "name": "watermelon",
  "price": 4
}

```
这个，就满足了上面定义的所有规则，因此这个是一个合规的 Json。

### 定义 API
其实，使用我们上面的 Json Schema 便能进行 API 的定义了，只不过是定义 API 的话可能还需要更多的支持。比如，对于 Java，我们需要能实现 extend 等关键字的支持，还需要能进行枚举 enum 类型等的定义。这里只简单使用上述的内容显然不够了，我们还需要扩充一些关键字的使用。

目前，大家使用最多的将 Json Schema 转换为 Java Bean 的一个库是 jsonschema2pojo，后面我将依托这个库支持的内容对 Json Schema 的格式进行深入解析，此库支持的也是比较通用的。

# ES6
## 链判断运算符
作用：当访问一个对象属性是用来判断对 象 是 否 存 在
为什么要判断？？？？？
在项目中如果你不去判断对象是否存在在去访问属性，项目就崩了


**在es5要这样判断**

```
const userName = Obj &&
	Obj.userInfo && 
	Obj.userInfo.userName ；//这样判断是不是很繁琐

```
**es6写法**

```
const userName = Obj?.userInfo?.userName;  //对比上面少了一大串

```
**在es5的是否我们经常使用"||" 来设置默认值**

```
let a = a.name || 'default'

```
**es6提供了null判断符 ？ ？ 两个问号来判断，只有当左边的值为null、undefined右边的值才会生效**

```
		let a = undefined ?? 'default'
		let a2 = null ?? 'default';
		console.log(a); //default
		console.log(a2); //default

```

## 扩展运算符-三个点

### 对象的扩展运算
对象中的扩展运算符(...)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中

```
let bar = { a: 1, b: 2 };
let baz = { ...bar }; // { a: 1, b: 2 }
```
上述方法实际上等价于:

```
let bar = { a: 1, b: 2 };
let baz = Object.assign({}, bar); // { a: 1, b: 2 }
```
Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。

Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。**(如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性)。**

同样，如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。

```
let bar = {a: 1, b: 2};
let baz = {...bar, ...{a:2, b: 4}};  // {a: 2, b: 4}
```
利用上述特性就可以很方便的修改对象的部分属性。在redux中的reducer函数规定必须是一个纯函数（如果不是很清楚什么是纯函数的可以参考这里），reducer中的state对象要求不能直接修改，可以通过扩展运算符把修改路径的对象都复制一遍，然后产生一个新的对象返回。

这里有点需要注意的是扩展运算符对对象实例的拷贝属于一种浅拷贝。肯定有人要问什么是浅拷贝？我们知道javascript中有两种数据类型，分别是基础数据类型和引用数据类型。基础数据类型是按值访问的，常见的基础数据类型有Number、String、Boolean、Null、Undefined，这类变量的拷贝的时候会完整的复制一份；引用数据类型比如Array，在拷贝的时候拷贝的是对象的引用，当原对象发生变化的时候，拷贝对象也跟着变化，比如：

```
let obj1 = { a: 1, b: 2};
let obj2 = { ...obj1, b: '2-edited'};
console.log(obj1); // {a: 1, b: 2}
console.log(obj2); //  {a: 1, b: "2-edited"}
```
上面这个例子扩展运算符拷贝的对象是基础数据类型，因此对obj2的修改并不会影响obj1，如果改成这样：

```
let obj1 = { a: 1, b: 2, c: {nickName: 'd'}};
let obj2 = { ...obj1};
obj2.c.nickName = 'd-edited';
console.log(obj1); // {a: 1, b: 2, c: {nickName: 'd-edited'}}
console.log(obj2); // {a: 1, b: 2, c: {nickName: 'd-edited'}}

```
这里可以看到，对obj2的修改影响到了被拷贝对象obj1，原因上面已经说了，因为obj1中的对象c是一个引用数据类型，拷贝的时候拷贝的是对象的引用。

### 数组的扩展运算
1.可以将数组转换为参数序列

```
function add(x, y) {
  return x + y;
}

const numbers = [4, 38];
add(...numbers) // 42

```
2.可以复制数组

如果直接通过下列的方式进行数组复制是不可取的：

```
const arr1 = [1, 2];
const arr2 = arr1;
arr2[0] = 2;
arr1 // [2, 2]
```
原因上面已经介绍过，用扩展运算符就很方便：

```
const arr1 = [1, 2];
const arr2 = [...arr1];
```
还是记住那句话：**扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中**，这里参数对象是个数组，数组里面的所有对象都是基础数据类型，将所有基础数据类型重新拷贝到新的数组中。

3.扩展运算符可以与解构赋值结合起来，用于生成数组

```
const [first, ...rest] = [1, 2, 3, 4, 5];
first // 1
rest  // [2, 3, 4, 5]
```
**如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。**

```
const [...rest, last] = [1, 2, 3, 4, 5];
// 报错
const [first, ...rest, last] = [1, 2, 3, 4, 5];
// 报错

```
扩展运算符还可以将字符串转为真正的数组

```
[...'hello']
// [ "h", "e", "l", "l", "o" ]
```
比较常见的应用是可以将某些数据结构转为数组,比如：

```
// arguments对象
function foo() {
  const args = [...arguments];
}
```
## map
[原文链接](https://blog.csdn.net/wangdan_2013/article/details/78316844)

```
let numbers = [1, 5, 10, 15];
let doubles = numbers.map((x) => {
   return x * 2;
});

// doubles is now [2, 10, 20, 30]
// numbers is still [1, 5, 10, 15]


let numbers = [1, 4, 9];
let roots = numbers.map(Math.sqrt);

// roots is now [1, 2, 3]
// numbers is still [1, 4, 9]
```
**语法**

```
let array = arr.map(function callback(currentValue, index, array) { 
    // Return element for new_array 
}[, thisArg])
//currentValue，数组中正在处理的当前元素。
//index，数组中正在处理的当前元素的索引。
//array，map 方法被调用的数组。
//thisArg可选的。执行 callback 函数时 使用的this 值。
//返回值：一个新数组，每个元素都是回调函数的结果。
```
**描述**
map 方法会给原数组中的每个元素都按顺序调用一次 callback 函数。callback 每次执行后的返回值（包括 undefined）组合起来形成一个新数组。 callback 函数只会在有值的索引上被调用；那些从来没被赋过值或者使用 delete 删除的索引则不会被调用。

callback 函数会被自动传入三个参数：数组元素，元素索引，原数组本身。

如果 thisArg 参数有值，则每次 callback 函数被调用的时候，this 都会指向 thisArg 参数上的这个对象。如果省略了 thisArg 参数,或者赋值为 null 或 undefined，则 this 指向全局对象 。

map 不修改调用它的原数组本身（当然可以在 callback 执行时改变原数组）。

使用 map 方法处理数组时，数组元素的范围是在 callback 方法第一次调用之前就已经确定了。在 map 方法执行的过程中：原数组中新增加的元素将不会被 callback 访问到；若已经存在的元素被改变或删除了，则它们的传递到 callback 的值是 map 方法遍历到它们的那一时刻的值；而被删除的元素将不会被访问到。

**更多用法见原文**

# Ajax
**AJAX（Asynchronous Javascript And XML）翻译成中文就是“异步的Javascript和XML”**
**实现前后端数据的交互**

## 优点

```bash
1.Ajax最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。 (这一特点给用户的感受是在不知不觉中完成请求和响应过程) 2.Ajax不需要任何浏览器插件，但需要用户允许javaScript在浏览器上执行。
同步交互: 客户端发出一个请求后，需要等待服务器响应结束后，才能发出第二个请求。

异步交互: 客户端发出一个请求后，无需要等待服务器响应结束，就可以发出第二个请求。
```


Ajax使用JavaScript技术向服务器发送异步请求

Ajax请求无须刷新整个页面

因为服务器响应内容不再是整个页面，而是页面中的部分内容，所以Ajax性能高！

## 工作原理
![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/a83d7857217f3e6d72b8fab68fb3adb9.gif#pic_center)
# 跨域
[原文链接](https://blog.csdn.net/weixin_48837605/article/details/119494467)
## 什么是跨域
 当一个请求url的**协议,域名,端口**三者之间任意一个与当前的url不同都即为跨域
 

```bash
 当前页面url                  被请求页面url                是否跨域            原因
http://www.test.com/    http://www.test.com/index.html    否            同源（协议、域名、端口号相同）
http://www.test.com/    https://www.test.com/index.html   跨域          协议不同（http/https）
http://www.test.com/    http://www.baidu.com/             跨域          主域名不同（test/baidu）
http://www.test.com/    http://blog.test.com/             跨域          子域名不同（www/blog）
```

## 为什么会出现跨域
出于浏览器的同源策略限制.同源策略是一种约定,它是浏览器最核心也是最基本的安全功能,如果缺少了同源策略,则浏览器的正常的功能可能会受到影响,跨域收是Web是构建在同源策略基础上的,浏览器只是针对同源策略的一种实现,同源策略会阻止一个域的JavaScript脚本和另一个域的内容进行交互,所谓同源(即指同一个域)就是两个页面具备同样的协议(protocol),主机(host)和端口号(port)

**请求是跨域的，并不一定会报错。普通的图片请求，css文件请求是不会报错的**

## 跨域会阻止什么操作
浏览器是从两个方面去做这个同源策略的，一是针对接口的请求，二是针对Dom的查询

### 1.阻止接口请求
比如用ajax从http://192.168.100.150:8020/实验/jsonp.html页面向http://192.168.100.150:8081/zhxZone/webmana/dict/jsonp发起请求，由于两个url端口不同，所以属于跨域，在console打印台会报No 'Access-Control-Allow-Origin' header is present on the requested resource
![在这里插入图片描述](https://img-blog.csdnimg.cn/20181207092232976.png#pic_center)
值得说的是虽然浏览器禁止用户对请求返回数据的显示和操作，但浏览器确实是去请求了，如果服务器没有做限制的话会返回数据的，在调试模式的network中可以看到返回状态为200，且可看到返回数据
![在这里插入图片描述](https://img-blog.csdnimg.cn/20181207092757327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpYW56aGFuZzg2MQ==,size_16,color_FFFFFF,t_70#pic_center)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20181207092820725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpYW56aGFuZzg2MQ==,size_16,color_FFFFFF,t_70#pic_center)
### 2.阻止dom获取和操作
比如a页面中嵌入了iframe，src为不同源的b页面，则在a中无法操作b中的dom，也没有办法改变b中dom中的css样式。

而如果ab是同源的话是可以获取并操作的。

```bash
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
		<style type="text/css">
			iframe{
				width:100%;height:800px;
			}
		</style>
	</head>
	<body>
		<!--<iframe src="http://192.168.100.150:8081/zhxZone/webmana/attachment/imageManager" frameborder="0" id="iframe"></iframe>-->
		<iframe src="http://192.168.100.150:8020/实验/jsonp.html" frameborder="0" id="iframe"></iframe>
		<script type="text/javascript">
			var i=document.getElementById("iframe");
			i.onload=function(){
				/*console.log(i.contentDocument)
				console.log(i.contentWindow.document.getElementById("text").innerHTML)*/
				var b=i.contentWindow.document.getElementsByTagName("body")[0];
				i.contentWindow.document.getElementById("text").style.background="gray";
				i.contentWindow.document.getElementById("text").innerHTML="111";
			}
		</script>
	</body>
</html>
```
改变了iframe中的元素 

![在这里插入图片描述](https://img-blog.csdnimg.cn/8b0167fa9e5647359acc6466b8e421bd.png)


甚至是可以获取iframe中的cookie

```bash
var i=document.getElementById("iframe");
i.onload=function(){
	console.log(i.contentDocument.cookie)
}
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/681d3b6bcb6d4b039578fc23e6de073b.png)

不用说也知道这是极为危险的，所以浏览器才会阻止非同源操作dom

浏览器的这个限制虽然不能保证完全安全，但是会增加攻击的困难性

虽然安全机制挺好，可以抵御坏人入侵，但有时我们自己需要跨域请求接口数据或者操作自己的dom，也被浏览器阻止了，所以就需要跨域

跨域的前提肯定是你和服务器是一伙的，你可以控制服务器返回的数据，否则跨域是无法完成的 

## 解决跨域的方法
### 前端jsp
### CORS方案
**就是通过服务器设置响应头来实现跨域**

CORS才是解决跨域的真正解决方案。
前端需要做什么？
无需做任何事情，正常发送Ajax请求即可。
后端需要做什么？
需要加 响应头 。或者使用第三方模块 cors 。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210807230949959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80ODgzNzYwNQ==,size_16,color_FFFFFF,t_70#pic_center)
### 代理服务器（一般用Nginx）
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210807231812945.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80ODgzNzYwNQ==,size_16,color_FFFFFF,t_70#pic_center)
   1).代理服务和前端服务之间由于协议域名端口三者统一不存在跨域的问题,可以直接发送请求

   2).代理服务和后端服务之间并不通过浏览器没有同源策略的限制,可以直接发送请求

这里是一个nginx启用COSR的参考配置

```bash
#
# Wide-open CORS config for nginx
#
location / {
     if ($request_method = 'OPTIONS') {
        add_header 'Access-Control-Allow-Origin' '*';
        add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS';
        #
        # Custom headers and headers various browsers *should* be OK with but aren't
        #
        add_header 'Access-Control-Allow-Headers' 'DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type';
        #
        # Tell client that this pre-flight info is valid for 20 days
        #
        add_header 'Access-Control-Max-Age' 1728000;
        add_header 'Content-Type' 'text/plain charset=UTF-8';
        add_header 'Content-Length' 0;
        return 204;
     }
     if ($request_method = 'POST') {
        add_header 'Access-Control-Allow-Origin' '*';
        add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS';
        add_header 'Access-Control-Allow-Headers' 'DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type';
     }
     if ($request_method = 'GET') {
        add_header 'Access-Control-Allow-Origin' '*';
        add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS';
        add_header 'Access-Control-Allow-Headers' 'DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type';
     }
}
```

# 调试方法
**快捷键：**

```typescript
F8：进入下一个断点
F10：单步执行，不进入子函数
F11：单步执行，遇到子函数会进入子函数
shift+F11：跳出当前函数
```
