---
title: 算法总结
date: 2022/1/26
update: 2022/1/27
categories:
  - 算法
  
tags:
  - 动态规划
  - 数据结构
  - 递归
---

# 动态规划解题框架
若确定给定问题具有重叠子问题和最优子结构，那么就可以使用动态规划求解。总体上看，求解可分为四步：

**1.状态定义**： 构建问题最优解模型，包括问题最优解的定义、有哪些计算解的自变量；

**2.初始状态**： 确定基础子问题的解（即已知解），原问题和子问题的解都是以基础子问题的解为起始点，在迭代计算中得到的；

**3.转移方程**： 确定原问题的解与子问题的解之间的关系是什么，以及使用何种选择规则从子问题最优解组合中选出原问题最优解；

**4.返回值：** 确定应返回的问题的解是什么，即动态规划在何处停止迭代；

完成以上步骤后，便容易写出对应的解题代码。

## 示例：斐波那契数列
状态定义：一维 dp 列表，设第 ii个斐波那契数为 dp[i]；

初始状态：已知第 0 , 1个斐波那契数分别为 dp[0] = 0, dp[1] =  1 ；

转移方程：后一个数字等于前两个数字之和，即


dp[i]=dp[i−1]+dp[i−2]

返回值：需求取的第 n 个斐波那契数 dp[n] ；

## 示例：蛋糕最高售价
状态定义：一维 dp 列表，设重量为 i 蛋糕的售价为 p(i) ，重量为 ii蛋糕切分后的最高售价为 dp[i] ；

初始状态：已知重量为 0 蛋糕的最高售价为 0 ，重量为 1 的蛋糕最高售价为 p(1) ；

转移方程：dp[n] 为 n 种切分组合中的最高售价组合，即

![在这里插入图片描述](https://img-blog.csdnimg.cn/100853ca38094c5997762c0b693ff41a.png)

返回值：需求取的重量为 n 的蛋糕最高售价 dp[n] ；

# 递归
[原链接](https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/solution/kan-bu-dong-di-gui-de-kan-guo-lai-xi-wan-1akq/)
**Rules Number One**，基本上，所有的递归问题都可以用递推公式来表示。有了这个递推公式，我们就可以很轻松地将它改为递归代码。。所以，遇到递归不要怕，先想递推公式。

例1: (比较明显的能递推公式的问题)

 - 问题：斐波那契数列的第n项 
 - 递推公式：

```
f(n)=f(n-1)+f(n-2) 其中，f(0)=0,f(1)=1
```

 - 终止条件：

```
if (n <= 2) return 1;
```

 - 递归代码：

```
int f(int n) {
  if (n <= 2) return 1;
  return f(n-1) + f(n-2);
}
```
例2:(不那么明显的有递推公式的问题)

 - 问题：逆序打印一个数组 
 - 递推公式：
 

```
假设令F(n)=逆序遍历长度为n的数组
那么F(n)= 打印数组中下标为n的元素 + F(n-1)
```

 - 终止条件：

```
if (n <0) return ;
```

 - 递归代码：

```
public void Print(int[] nums,int n){
    if(n<0) return;
    System.out.println(nums[n]);
    Print(nums,n-1);
}
```

到这里，不知道大家对写递归有没有一些理解了。其实写递归不能总想着去把递归平铺展开，这样脑子里就会循环，一层一层往下调，然后再一层一层返回，试图想搞清楚计算机每一步都是怎么执行的，这样就很容易被绕进去。对于递归代码，这种试图想清楚整个递和归过程的做法，实际上是进入了一个思维误区。只要找到**递推公式**，我们就能很轻松地写出递归代码。

到这里，我想进一步跟大家说明我这个思路是比较能够容易出代码的，那么就树的遍历问题来和大家讲。递归总是和树分不开，其中，最典型的便是树的遍历问题。刚开始学的时候，不知道大家是怎么理解先／中／后序遍历的递归写法的，这里我提供我的思路供参考，以前序遍历为例：

 - 问题：二叉树的先序遍历 
 - 递推公式：

```
令F(Root)为问题:遍历以Root为根节点的二叉树，
令F(Root.left)为问题:遍历以F(Root.left)为根节点的二叉树
令F(Root.right)为问题:遍历以F(Root.right)为根节点的二叉树
那么其递推公式为：
F(Root)=遍历Root节点+F(Root.left)+F(Root.right)
```

 - 递归代码：

```
public void preOrder(TreeNode node){
    if(node==null) return;
    System.out.println(node.val);
    preOrder(node.left);
    preOrder(node.righr);
}
```
**Rules Number Two**, 递归是一种关于某个重复动作(完成重复性的功能)的形式化描述。具体点讲，如果一个问题 A 可以分解为若干子问题 B、C、D，你可以假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A。而且，你只需要思考问题 A 与子问题 B、C、D 两层之间的关系即可，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系(也就是说，递归只能考虑当前层和下一层的关系，不能继续往下深入)。我们需要屏蔽掉递归细节，理解为完成了某种功能的形式化描述即可。

 - 问题：单向链表的反转 
 - 递推公式

```
令F(node)为问题:反转以node为头节点的单向链表；
一般，我们需要考虑F(n)和F(n-1)的关系，那么这里，如果n代表以node为头节点的单向链表，那么n-1就代表以node.next为头节点的单向链表.
所以，我们令F(node.next)为问题：反转以node.next为头节点的单向链表；
那么，F(node)和F(node.next)之间的关系是？这里我们来简单画个图，假设我们反转3个节点的链表：
1 -> 2 -> 3
那么，F(node=1)=F(node=2)+?
这里假设子问题F(node=2)已经解决，那么我们如何解决F(node=1)：
很明显，我们需要反转node=2和node=1， 即 node.next.next=node; 同时 node.next=null;
所以，这个问题就可以是：F(node=1)=F(node=2)+ 反转node=2和node=1
```

 - 递归代码：

```
public ListNode reverseList(ListNode head) {
        if(head == null || head.next == null) {  //终止条件并不难想
            return head;
        }
        ListNode node = reverseList(head.next);
        head.next.next = head;
        head.next = null;
        return node;  //按上面的例子，F(node=1)和F(node=2)它俩反转后的头节点是同一个
    }
```

**3.写递归的小tips**

 - 将问题抽象化，可以将问题抽象为f(n)（或者其他的数学符号）,
   然后用f(n)代表欲求的问题，然后去发现和子问题（比如f(n-1)）的递推关系！（这一点在写动态规划的时候特别有用，其实动态规划就是记忆化的递归！）
 - 递归函数是带语义的，但是记住一个递归函数只有一个语义，如果在写递归函数实现的时候，发现出现了多个语义，需要对新出现的语义重新定义一个函数！
 - 在写递归函数的时候，可以先写子问题f(n-1)，再写所求问题f(n)，这样的话就很好知道f(n)和f(n-1)的关系，更容易保证一个递归函数只包含一个语义。


# 求数组所有子数组的方法
一个包含n个元素的集合,求它的所有子集。比如集合A= {1,2,3}, 它的所有子集是:
{ {1}, {2}, {3}, {1,2}, {1,3}, {2,3}, {1,2,3}, @}(@表示空集)。

这种问题一般有两种思路，先说说第一种，递归。递归肯定要基于一个归纳法的思想，这个思想用到了二叉树的遍历，如下图所示：

![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/145f041b48acaf3f3657f6a985a4696b.png#pic_center)


可以这样理解这张图，从集合A的每个元素自身分析，它只有两种状态，或是某个子集的元素，或是不属于任何子集，所以求子集的过程就可以看成对每个元素进行“取舍”的过程。上图中，根结点是初始状态，叶子结点是终结状态，该状态下的8个叶子结点就表示集合A的8个子集。第i层(i=1,2,3…n)表示已对前面i-1层做了取舍，所以这里可以用递归了。整个过程其实就是对二叉树的先序遍历。
代码见方法getSonSet1。

还有一种思想比较巧妙，可以叫按位对应法。如集合A={a,b,c},对于任意一个元素，在每个子集中，要么存在，要么不存在。
映射为子集：
(a,b,c)
(1,1,1)->(a,b,c)
(1,1,0)->(a,b)
(1,0,1)->(a,c)
(1,0,0)->(a)
(0,1,1)->(b,c)
(0,1,0)->(b)
(0,0,1)->©
(0,0,0)->@(@表示空集)
观察以上规律，与计算机中数据存储方式相似，故可以通过一个整型数与集合映射00…00 ~ 11…11（1表示有，0表示无，反之亦可），通过该整型数逐次增可遍历获取所有的数，即获取集合的相应子集。
实现代码见方法getSonSet2

```
import java.util.ArrayList;
import java.util.List;

public class SonSet {

	public static void main(String[] args){
		int[] arr={1,2,3};
		
		List<Integer> aList=new ArrayList<Integer>();
		List<Integer> bList=new ArrayList<Integer>();
		for(int i=0;i<arr.length;i++){
			aList.add(arr[i]);
		}
		getSonSet1(0,aList,bList); //方法1，递归法
		
		System.out.println("----数组arr公用，分割线-----");
		
		getSonSet2(arr,arr.length); //方法2，按位对应法
	}

	/*
	 * 递归法
	*/
	public static void getSonSet1(int i,List<Integer> aList,List<Integer> bList){
		if(i>aList.size()-1){
			if(bList.size()<=0){
				System.out.print("@");
			}else {
				/*for(int v:bList){
					System.out.print(v+",");//可以直接用这种方法输出bList数组里所有值，但是每个子数组最后就会带逗号
				}*/
				System.out.print(bList.get(0));
				for(int m=1;m<bList.size();m++){
					System.out.print(","+bList.get(m));
				}
			}
			System.out.println();
		}else {
			bList.add(aList.get(i));
			getSonSet1(i+1, aList, bList);
			int bLen=bList.size();
			bList.remove(bLen-1);
			getSonSet1(i+1, aList, bList);
		}
	}
	
	
	/*
	 *按位对应法。
	*/
	private static void getSonSet2(int[] arr, int length) {
		int mark=0;
		int nEnd=1<<length;
		boolean bNullSet=false;
		for(mark=0;mark<nEnd;mark++){
			bNullSet=true;
			for(int i=0;i<length;i++){
				if(((1<<i)&mark)!=0){//该位有元素输出
					bNullSet=false;
					System.out.print(arr[i]+",");
				}
			}
			if(bNullSet){//空集合
				System.out.print("@");
			}
			System.out.println();
		}
	}
}

```
运行结果：

```
1,2,3
1,2
1,3
1
2,3
2
3
@
----数组arr公用，分割线-----
@
1,
2,
1,2,
3,
1,3,
2,3,
1,2,3,

```

# 排序
## 冒泡
原始

```java
//按照刚才那个动图进行对应
//冒泡排序两两比较的元素是没有被排序过的元素--->
public void bubbleSort(int[] array){
    for(int i=0;i<array.length-1;i++){//控制比较轮次，一共 n-1 趟
        for(int j=0;j<array.length-1-i;j++){//控制两个挨着的元素进行比较
            if(array[j] > array[j+1]){
                int temp = array[j];
                array[j] = array[j+1];
                array[j+1] = temp;
            }
        }
    }
}

```
优化

```java
public static int[] bubbleSort(int[] arr) {
     if (arr == null || arr.length < 2) {
          return arr;
     }
    for (int i = 0; i < arr.length - 1; i++) {
         boolean isSorted  = true;//有序标记，每一轮的初始是true
         for (int j = 0; j < arr.length -i - 1; j++) {
             if (arr[j + 1] < arr[j]) {
                 isSorted  = false;//有元素交换，所以不是有序，标记变为false
                 int t = arr[j];
                 arr[j] = arr[j+1];
                 arr[j+1] = t;
             }
         }
         //一趟下来是否发生位置交换，如果没有交换直接跳出大循环
         if(isSorted )
              break;
     }
     return arr;
}

```
