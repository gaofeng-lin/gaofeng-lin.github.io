---
title: 前端知识
date: 2022/6/1


categories:
  - 前端开发
  
tags:
  - Vue
  - React
  - JavaScript
  - Json
---






# JSX
[原链接]([https](https://blog.csdn.net/a153375250/article/details/53434299))
## JSX是什么

JSX是一种像下面这样的语法：
```
const element = <h1>Hello, world!</h1>;
```

它是一种JavaScript语法扩展，在React中可以方便地用来描述UI。
质上，JSX为我们提供了创建React元素方法（React.createElement(component, props, ...children)）的语法糖（syntactic sugar）。上面的代码实质上等价于：

```
var element = React.createElement(
  "h1",
  null,
  "Hello, world!"
);
```

## 在JSX中使用JavaScript表达式

在JSX中插入JavaScript表达式十分简单，直接**在JSX中将JS表达式用大括号括起来即可**。例如：

```
function formatName(user) {
  return user.firstName + ' ' + user.lastName;
}

const user = {
  firstName: 'Harper',
  lastName: 'Perez'
};

const element = (
  <h1>
    Hello, {formatName(user)}!
  </h1>
);

ReactDOM.render(
  element,
  document.getElementById('root')
);
```

上面的代码中用到了函数调用表达式fromatName(user)。

在JavaScript中，表达式就是一个短语，Javascript解释器会将其计算出一个结果，常量就是最简单的一类表达式。常用的表达式有：

- 变量名；
- 函数定义表达式；
- 属性访问表达式；
- 函数调用表达式；
- 算数表达式；
- 关系表达式；
- 逻辑表达式；

需要注意的是，if语句以及for循环不是JavaScript表达式，不能直接作为表达式写在{}中，但可以先将其赋值给一个变量（变量是一个JavaScript表达式）:

```
function NumberDescriber(props) {
  let description;
  if (props.number % 2 == 0) {
    description = <strong>even</strong>;
  } else {
    description = <i>odd</i>;
  }
  return <div>{props.number} is an {description} number</div>;
}
```

## JSX属性值

你可以使用引号将字符串字面量指定为属性值：
```const element = <div tabIndex="0"></div>;```
**注意这里的”0”是一个字符串字面量。**

或者你可以将一个JavaScript表达式嵌在一个大括号中作为属性值：
```const element = <img src={user.avatarUrl}></img>;```

这里用到的是JavaScript属性访问表达式，上面的代码将编译为：

```const element = React.createElement("img", { src: user.avatarUrl });```

## JSX的Children

首先JSX可以是一个不包含Children的empty tag。如：

```const element = <img src={user.avatarUrl} />;```

JSX也可以像HTML标签一样包含Children：

```
const element = (
  <div>
    <h1>Hello!</h1>
    <h2>Good to see you here.</h2>
  </div>
);
```
**后面一部分不是很重要，可看原文**
React自定义组件的chilren是不会像固有的HTML标签的子元素那样自动render的，我们看下面的例子：
```
代码1
class Test extends React.Component {
    render() {
      return (
        <div>
          Here is a list:
          <ul>
            <li>Item 1</li>
            <li>Item 2</li>
          </ul>
        </div>
      ) 
    }
};
ReactDOM.render(
    <Test />,
    document.getElementById('test')
);
```
以上代码定义的组件中都是build-in组件，类似div、p、ul、li等。它们中的子元素会直接render出来，像下面这样：

![在这里插入图片描述](http://wyuhao-img.oss-cn-shanghai.aliyuncs.com/img/blog_img/jsx/htmlrender.jpg)

但是如果你使用用户定义组件，比如：
```
class Test extends React.Component {
    render() {
      return (
      <Em>
        Here is a list:
        <ul>
          <li>Item 1</li>
          <li>Item 2</li>
        </ul>
      </Em>
    ) 
    }
};

class Em extends React.Component {
  render() {
    return (<div></div>);
  }
}

ReactDOM.render(
    <Test />,
    document.getElementById('test')
);
```
并不能得到跟上面代码1一样的结果，我们得到的只是一个空的div标签：

![在这里插入图片描述](http://wyuhao-img.oss-cn-shanghai.aliyuncs.com/img/blog_img/jsx/userrender.jpg)

如果你想得到和代码1一样的结果，需要显示地指定props.children，像下面这样：

```
class Test extends React.Component {
    render() {
      return (
          <Em>
            Here is a list:
            <ul>
              <li>Item 1</li>
              <li>Item 2</li>
            </ul>
          </Em>
      ) 
    }
};

class Em extends React.Component {
  render() {
    return (<div>{this.props.children}</div>);
  }
}

ReactDOM.render(
    <Test />,
    document.getElementById('test')
);
```


## JSX中的props

指定JSX中的props有以下几种方式：

1. 使用JavaScript表达式

任何有效的JavaScript表达式都可以作为prop的值，使用的时候将该表达式放在一对大括号中即可：

```
<MyComponent foo={1 + 2 + 3 + 4} />

<YourComponent clickTodo={(id) => this.props.handleClick(id)} />
```

2. 使用字符串字面量
字符串字面量可以作为prop值，下面的代码是等价的：

```
<MyComponent message="hello world" />

<MyComponent message={'hello world'} />
```

3. 使用扩展运算符
如果你想将一个prop对象传入JSX，你可以使用扩展运算符...直接将整个prop对象传入。下面的2个组件是等价的：

```
function App1() {
  return <Greeting firstName="Ben" lastName="Hector" />;
}

function App2() {
  const props = {firstName: 'Ben', lastName: 'Hector'};
  return <Greeting {...props} />;
}
```
扩展运算符是一个es6特性。是一种传递属性的十分便利的方式。但请注意不要滥用该运算符，注意不要将一大堆毫不相关的prop一股脑全部传入下面的组件中。


## JSX中的Children

React组件中有一个特殊的prop–props.children。它指代了JSX表达式中开闭标签中包含的内容。

下面讨论的是几种指定JSX的children的方法：

(1)使用字符串字面量
(2)JSX元素作为children
(3)JavaScript表达式
(4)函数children

## 注意事项
(1)使用JSX时要引入React库
(2)注意引入JSX中用到的自定义组件
(3)自定义组件首字母一定要大写
(4)元素标签名不能使用表达式
(5)设置style属性

在设置标签style属性的时候，要注意，我们是将一个描述style的对象以JavaScipt表达式的形式传入。因此应该有2层大括号：
```
<div style={{color:'red', margin:'10px auto'}}></div>
```

# 箭头函数


**总结**
在来看一遍 箭头函数 与 普通函数，除了写法上的区别

> 1、箭头函数没有自己的this。箭头函数会捕获其所在上下文的 this 值，作为自己的 this 值。 
> 2、箭头函数 this不可变。call()、apply()、bind()、这些方法也 无法改变 箭头函数 this 的指向。 
> 3、箭头函数 不能用 new关键字来实例化对象，不然会报错。 
> 4、箭头函数没有arguments对象。

可以看出，最重要的区别还是 在 this 上，所以要想用好 箭头函数，还是要对 this 有一定认识的。


箭头函数本质还是函数，我们来看看他与JavaScript中普通函数的区别，先看看写法上的区别。
![在这里插入图片描述](https://img-blog.csdnimg.cn/2b6243000b0d48f69f6baf1e77293818.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16)
**解释**
写箭头函数，我们记住一个顺序就好，参数、箭头、函数体、这个顺序记住就足够了，参数、箭头、函数体、这三个是必须的，函数名可以没有，但这三项必须有，一些简写的方式也是简写这三项里的东西。

**简写**
1、只有一个参数时，() 可省略

```
//不简写
var demo = (x) =>{
    console.log(x);
}

//简写
var demo = x =>{
    console.log(x);
}
```
2、函数体只有一句时， {} 可以省略

```
//不简写
var demo = (x) =>{
    console.log(x);
}

//简写
var demo = x => console.log(x);
```
3、函数体只有一条返回语句时，{} 和 return 都可以省略

```
//不简写
var demo = (x) => {
     return x;
}

//简写
var demo = (x) => x;   

//注意别写成这样  
var demo = (x) =>{ x };  
//或者 这样  
var demo = (x) => return  x;  
//要省略就都省略，不省略就都不省，别省一半,不然会出错的。
```

**注意：**
箭头函数放 参数 的地方就在 () 内，
没有参数，() 必须写，
一个参数，() 可写可不写，
多个参数，() 必须写。

箭头函数放 函数体 的地方在 {}内，
函数体 就 一句 {} 可写可不写，
函数体 不止一句，{} 必须写。

如果不知道，() {} 写不写，该不该省略，那就写，写了不会错。

**箭头函数 如果要返回一个对象，要简写的话， 需要用()包住这个对象**

```
//不简写
var demo = () =>{ 
    return {x:1};
}  

//简写
var demo = () =>({x:1});
```
为什么会这样？因为如果不加 () ，那{ } 就表示的是语法块，不是表示一个对象，而加上()，按照规范来说，() 里面 { } 就会被解析为对象了。

对于 {x:1} 这个情况，他不仅可以表示一个对象，这个对象有个x属性，值为1，也可以表示为语法块中含有 名为 x 的 label，忘记 label语法的话，可以看[这里](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/label)
如果不是很明白，可以看看这个[回答](https://www.zhihu.com/question/40902815)，应该会理解的更加深刻。
所以这也解释了为什么会出现下面代码中的情况

```
// 不报错
var demo = () =>{x:1};

// 报错
var demo = (y) =>{y,x:1};
```
**对象的方法用 箭头函数写时，this 的指向 可能和你想的不一样**

```
window.name='window';
var obj = {
    name:'obj',
    show_name:() =>{
        console.log(this.name);
    }    
}
obj.show_name(); //window
```
JavaScript使用的是函数作用域，在上面这段代码中对象的括号是不能封闭作用域的，所以此时的this还是指向window。
我们换成普通函数看看

```
window.name='window';
var obj = {
    name:'obj',
    show_name: function (){
        console.log(this.name);
    }    
}
obj.show_name();  //obj
```
换成普通函数，this 就不是指向window，而是指向 obj 对象了

箭头函数 与 普通函数 其他的区别

> 1、箭头函数没有自己的this。箭头函数会捕获其所在上下文的 this 值，作为自己的 this 值。
>  2、箭头函数 this不可变。call()、apply()、bind()、这些方法也 无法改变 箭头函数 this 的指向。
>   3、箭头函数 不能用 new关键字来实例化对象，不然会报错。 
>   4、箭头函数没有arguments对象。

1、箭头函数没有自己的this。箭头函数会捕获其所在上下文的 this 值，作为自己的 this 值。

```
window.name = 'window';
var obj = {
    name:'obj',
    show_name:function (){
        function fn (){
            console.log(this.name);
        }
        fn();
    },
}
obj.show_name();  // window
```
声明一个 obj 对象，有一个name属性 与 show_name方法，上面这段代码，我的本意是想显示 obj对象的name， 但是没和我想的一样，一般我们会用 一个变量 self 或者 that 之类的留住this,像这样

```
window.name = 'window';
var obj = {
    name:'obj',
    show_name:function (){
        //留住this
        var that = this;
        function fn (){
            console.log(that.name);
        }
        fn();
    },
}
obj.show_name();  //obj
```
通常来说，箭头函数内部的this就是外层代码块的this

```
window.name = 'window';
var obj = {
    name:'obj',
    show_name:function (){
        var fn = () => {
            console.log(this.name);
        }
        fn();
    },
}
obj.show_name(); //obj
```
2、箭头函数 this 不可变。call()、apply()、bind()、这些方法也 无法改变 箭头函数 this 的指向。

```
window.name = 'window';
var obj = {
    name:'obj',
}
function show_name(){
    //这里 show_name 是一个普通的全局函数，所以他的this指window
    console.log(this.name);
}
//用了 call 方法，把 show_nam 的this 指向了 obj 对象
show_name.call(obj);  //obj
```
箭头函数 this 不可变

```
window.name = 'window';
var obj = {
    name:'obj',
}
var show_name = () => {
    //这里 show_name 是箭头函数，他的this指window，并且不会变
    console.log(this.name);
}
//用了 call 方法，但是 this 没变，所以打印了 window
show_name.call(obj);  //window
```
3、箭头函数 不能用 new 关键字来实例化对象，不然会报错，箭头函数的this 不可变，new 也改变不了 this的 指向，而且更为重要的是，箭头函数内部并没有 [[Construct]] 方法，所以会没有原型属性（prototype），所以箭头函数没法当构造函数。

![在这里插入图片描述](https://img-blog.csdnimg.cn/7803115884ae4f6ab5f8d4cd73cfe038.png)
4、箭头函数没有arguments对象，不能通过arguments对象访问传入参数，但是可以用rest参数实现
。[不了解的看这里](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Rest_parameters)

```
var demo = (...theArgs) => theArgs;
demo(1,2,3); //[1,2,3]
```




# 链判断运算符
作用：当访问一个对象属性是用来判断对 象 是 否 存 在
为什么要判断？？？？？
在项目中如果你不去判断对象是否存在在去访问属性，项目就崩了


**在es5要这样判断**

```
const userName = Obj &&
	Obj.userInfo && 
	Obj.userInfo.userName ；//这样判断是不是很繁琐

```
**es6写法**

```
const userName = Obj?.userInfo?.userName;  //对比上面少了一大串

```
**在es5的是否我们经常使用"||" 来设置默认值**

```
let a = a.name || 'default'

```
**es6提供了null判断符 ？ ？ 两个问号来判断，只有当左边的值为null、undefined右边的值才会生效**

```
		let a = undefined ?? 'default'
		let a2 = null ?? 'default';
		console.log(a); //default
		console.log(a2); //default

```

# 扩展运算符-三个点

## 对象的扩展运算
对象中的扩展运算符(...)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中

```
let bar = { a: 1, b: 2 };
let baz = { ...bar }; // { a: 1, b: 2 }
```
上述方法实际上等价于:

```
let bar = { a: 1, b: 2 };
let baz = Object.assign({}, bar); // { a: 1, b: 2 }
```
Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。

Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。**(如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性)。**

同样，如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。

```
let bar = {a: 1, b: 2};
let baz = {...bar, ...{a:2, b: 4}};  // {a: 2, b: 4}
```
利用上述特性就可以很方便的修改对象的部分属性。在redux中的reducer函数规定必须是一个纯函数（如果不是很清楚什么是纯函数的可以参考这里），reducer中的state对象要求不能直接修改，可以通过扩展运算符把修改路径的对象都复制一遍，然后产生一个新的对象返回。

这里有点需要注意的是扩展运算符对对象实例的拷贝属于一种浅拷贝。肯定有人要问什么是浅拷贝？我们知道javascript中有两种数据类型，分别是基础数据类型和引用数据类型。基础数据类型是按值访问的，常见的基础数据类型有Number、String、Boolean、Null、Undefined，这类变量的拷贝的时候会完整的复制一份；引用数据类型比如Array，在拷贝的时候拷贝的是对象的引用，当原对象发生变化的时候，拷贝对象也跟着变化，比如：

```
let obj1 = { a: 1, b: 2};
let obj2 = { ...obj1, b: '2-edited'};
console.log(obj1); // {a: 1, b: 2}
console.log(obj2); //  {a: 1, b: "2-edited"}
```
上面这个例子扩展运算符拷贝的对象是基础数据类型，因此对obj2的修改并不会影响obj1，如果改成这样：

```
let obj1 = { a: 1, b: 2, c: {nickName: 'd'}};
let obj2 = { ...obj1};
obj2.c.nickName = 'd-edited';
console.log(obj1); // {a: 1, b: 2, c: {nickName: 'd-edited'}}
console.log(obj2); // {a: 1, b: 2, c: {nickName: 'd-edited'}}

```
这里可以看到，对obj2的修改影响到了被拷贝对象obj1，原因上面已经说了，因为obj1中的对象c是一个引用数据类型，拷贝的时候拷贝的是对象的引用。

## 数组的扩展运算
1.可以将数组转换为参数序列

```
function add(x, y) {
  return x + y;
}

const numbers = [4, 38];
add(...numbers) // 42

```
2.可以复制数组

如果直接通过下列的方式进行数组复制是不可取的：

```
const arr1 = [1, 2];
const arr2 = arr1;
arr2[0] = 2;
arr1 // [2, 2]
```
原因上面已经介绍过，用扩展运算符就很方便：

```
const arr1 = [1, 2];
const arr2 = [...arr1];
```
还是记住那句话：**扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中**，这里参数对象是个数组，数组里面的所有对象都是基础数据类型，将所有基础数据类型重新拷贝到新的数组中。

3.扩展运算符可以与解构赋值结合起来，用于生成数组

```
const [first, ...rest] = [1, 2, 3, 4, 5];
first // 1
rest  // [2, 3, 4, 5]
```
**如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。**

```
const [...rest, last] = [1, 2, 3, 4, 5];
// 报错
const [first, ...rest, last] = [1, 2, 3, 4, 5];
// 报错

```
扩展运算符还可以将字符串转为真正的数组

```
[...'hello']
// [ "h", "e", "l", "l", "o" ]
```
比较常见的应用是可以将某些数据结构转为数组,比如：

```
// arguments对象
function foo() {
  const args = [...arguments];
}
```
# map
[原文链接](https://blog.csdn.net/wangdan_2013/article/details/78316844)

```
let numbers = [1, 5, 10, 15];
let doubles = numbers.map((x) => {
   return x * 2;
});

// doubles is now [2, 10, 20, 30]
// numbers is still [1, 5, 10, 15]


let numbers = [1, 4, 9];
let roots = numbers.map(Math.sqrt);

// roots is now [1, 2, 3]
// numbers is still [1, 4, 9]
```
**语法**

```
let array = arr.map(function callback(currentValue, index, array) { 
    // Return element for new_array 
}[, thisArg])
//currentValue，数组中正在处理的当前元素。
//index，数组中正在处理的当前元素的索引。
//array，map 方法被调用的数组。
//thisArg可选的。执行 callback 函数时 使用的this 值。
//返回值：一个新数组，每个元素都是回调函数的结果。
```
**描述**
map 方法会给原数组中的每个元素都按顺序调用一次 callback 函数。callback 每次执行后的返回值（包括 undefined）组合起来形成一个新数组。 callback 函数只会在有值的索引上被调用；那些从来没被赋过值或者使用 delete 删除的索引则不会被调用。

callback 函数会被自动传入三个参数：数组元素，元素索引，原数组本身。

如果 thisArg 参数有值，则每次 callback 函数被调用的时候，this 都会指向 thisArg 参数上的这个对象。如果省略了 thisArg 参数,或者赋值为 null 或 undefined，则 this 指向全局对象 。

map 不修改调用它的原数组本身（当然可以在 callback 执行时改变原数组）。

使用 map 方法处理数组时，数组元素的范围是在 callback 方法第一次调用之前就已经确定了。在 map 方法执行的过程中：原数组中新增加的元素将不会被 callback 访问到；若已经存在的元素被改变或删除了，则它们的传递到 callback 的值是 map 方法遍历到它们的那一时刻的值；而被删除的元素将不会被访问到。

**更多用法见原文**


