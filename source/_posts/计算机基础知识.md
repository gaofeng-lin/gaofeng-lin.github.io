---
title: 计算机基础知识
date: 2022/3/6
categories:
  - 计算机基础知识
  - web
  - 操作系统
tags:
  - nginx
  - 编译
  - 环境变量
  - Cookie
  - Session
  - 密码学
  - 硬件知识
  - 线程、进程
abbrlink: 7909
---

## 环境变量
环境变量是系统变量当中的一种，就是PATH。Windows和DOS操作系统中的path环境变量，当要求系统运行一个程序而没有告诉它程序所在的完整路径时，系统除了在当前目录下面寻找此程序外，还应到path中指定的路径去找。用户通过设置环境变量，来更好的运行进程。

**说白了，把可执行程序的路径放到环境变量里面，那么以后在任意的理解下就可以直接使用这个可执行程序，而不用输入绝对路径，方便。**

1.在Windows中，是由可视化的窗口模式展现出来的
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190906150416564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNDQyNTI0,size_16,color_FFFFFF,t_70#pic_center)
2.linux中，在 `/etc/profile`文件中设置
可以直接用vim进入文件进行设置，也可以用下面的语句

```
echo "export PATH=${PATH}:/usr/local/go/bon" >> /etc/profile
```
最好还是用vim进行修改，用echo输入到为你文件中，会出现冗余，直接添加比较好。用冒号分隔。

修改好以后，需要更新环境变量

```
source /etc/profile
```

## 计算机网络

### 正向代理和反向代理区别
[原文链接](https://www.cnblogs.com/taostaryu/p/10547132.html)

**一 什么是代理**

代理其实就是一个中介，A和B本来可以直连，中间插入一个C，C就是中介。
刚开始的时候，代理多数是帮助内网client访问外网server用的
后来出现了反向代理，"反向"这个词在这儿的意思其实是指方向相反，即代理将来自外网客户端的请求转发到内网服务器，从外到内

 

**二 正向代理**

正向代理类似一个跳板机，代理访问外部资源

比如我们国内访问谷歌，直接访问访问不到，我们可以通过一个正向代理服务器，请求发到代理服，代理服务器能够访问谷歌，这样由代理去谷歌取到返回数据，再返回给我们，这样我们就能访问谷歌了
![在这里插入图片描述](https://img-blog.csdnimg.cn/cd381c5de09a40f2bfedae52042eb66d.png#pic_center)



**正向代理的用途：**

　　（1）访问原来无法访问的资源，如google

（2） 可以做缓存，加速访问资源

　　（3）对客户端访问授权，上网进行认证

　　（4）代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息
　　

**三 反向代理**
反向代理（Reverse Proxy）实际运行方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器

![在这里插入图片描述](https://img-blog.csdnimg.cn/85649ed3b62c40d38de64b5170114f5b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IiU54uXMeWPtw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)


 

**反向代理的作用：**
（1）保证内网的安全，阻止web攻击，大型网站，通常将反向代理作为公网访问地址，Web服务器是内网

（2）负载均衡，通过反向代理服务器来优化网站的负载

 

**四 总结
正向代理即是客户端代理, 代理客户端, 服务端不知道实际发起请求的客户端.
反向代理即是服务端代理, 代理服务端, 客户端不知道实际提供服务的服务端**

看图理解一：
![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/0c3860e58d2cffd66b808fe07631e358.png#pic_center)


看图理解二：
![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/7cc6fc2baf342df6a450a54ca2ad6b8a.png#pic_center)


正向代理中，proxy和client同属一个LAN，对server透明；
反向代理中，proxy和server同属一个LAN，对client透明。
实际上proxy在两种代理中做的事都是代为收发请求和响应，不过从结构上来看正好左右互换了下，所以把后出现的那种代理方式叫成了反向代理

**总结：**
正向代理: 买票的黄牛

反向代理: 租房的代理

### Nginx
[原文链接](https://juejin.cn/post/6844904129987526663)
“Nginx 是一款轻量级的 HTTP 服务器，采用事件驱动的异步非阻塞处理方式框架，这让其具有极好的 IO 性能，时常用于服务端的**反向代理**和**负载均衡**。”
Nginx 是一款 http 服务器 （或叫web服务器）。它是由俄罗斯人 伊戈尔·赛索耶夫为俄罗斯访问量第二的 Rambler.ru 站点开发的，并于2004年首次公开发布的。

```
web服务器：负责处理和响应用户请求，一般也称为http服务器，如 Apache、IIS、Nginx

应用服务器：存放和运行系统程序的服务器，负责处理程序中的业务逻辑，如 Tomcat、Weblogic、Jboss（现在大多数应用服务器也包含了web服务器的功能）
```

Nginx 是什么，总结一下就是这些：

 - 一种轻量级的web服务器
 - 设计思想是事件驱动的异步非阻塞处理（类node.js）
 - 占用内存少、启动速度快、并发能力强
 - 使用C语言开发
 - 扩展性好，第三方插件非常多
 - 在互联网项目中广泛应用

#### Nginx配置

**安装/卸载**

***安装、卸载、启动自查找资料***

修改配置
经常要用到的几个文件路径：

```
/usr/local/etc/nginx/nginx.conf （nginx配置文件路径）
/usr/local/var/www （nginx服务器默认的根目录）
/usr/local/Cellar/nginx/1.17.9 （nginx的安装路径）
/usr/local/var/log/nginx/error.log (nginx默认的日志路径)
```

nginx 默认配置文件简介：


```
## 首尾配置暂时忽略
server {  
        # 当nginx接到请求后，会匹配其配置中的service模块
        # 匹配方法就是将请求携带的host和port去跟配置中的server_name和listen相匹配
        listen       8080;        
        server_name  localhost; # 定义当前虚拟主机（站点）匹配请求的主机名

        location / {
            root   html; # Nginx默认值
            # 设定Nginx服务器返回的文档名
            index  index.html index.htm; # 先找根目录下的index.html，如果没有再找index.htm
        }
}

## 首尾配置暂时忽略
```


server{ } 其实是包含在 http{ } 内部的。每一个 server{ } 是一个虚拟主机（站点）。
上面代码块的意思是：当一个请求叫做localhost:8080请求nginx服务器时，该请求就会被匹配进该代码块的 server{ } 中执行。
当然 nginx 的配置非常多，用的时候可以根据文档进行配置。

英文文档：nginx.org/en/docs/
中文文档：www.nginx.cn/doc/

Nginx有哪些应用？
主要有4大应用（动静分离、正向代理、反向代理、负载均衡）

#### 动静分离
![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/e9d551a4479341cca95a54fbe13f3ebe.webp?x-oss-process=image/format,png#pic_center)


如上图所示，动静分离其实就是 Nginx 服务器将接收到的请求分为动态请求和静态请求。
静态请求直接从 nginx 服务器所设定的根目录路径去取对应的资源，动态请求转发给真实的后台（前面所说的应用服务器，如图中的Tomcat）去处理。
这样做不仅能给应用服务器减轻压力，将后台api接口服务化，还能将前后端代码分开并行开发和部署。（传送门：[nginx动静分离的好处](https://www.php.cn/nginx/424631.html)）

```
server {  
        listen       8080;        
        server_name  localhost;

        location / {
            root   html; # Nginx默认值
            index  index.html index.htm;
        }
        
        # 静态化配置，所有静态请求都转发给 nginx 处理，存放目录为 my-project
        location ~ .*\.(html|htm|gif|jpg|jpeg|bmp|png|ico|js|css)$ {
            root /usr/local/var/www/my-project; # 静态请求所代理到的根目录
        }
        
        # 动态请求匹配到path为'node'的就转发到8002端口处理
        location /node/ {  
            proxy_pass http://localhost:8002; # 充当服务代理
        }
}
```

访问静态资源 nginx 服务器会返回 my-project 里面的文件，如获取 index.html：
![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/34472ca6f5724173402dbaf6d4e6f8b3.webp?x-oss-process=image/format,png#pic_center)


访问动态请求 nginx 服务器会将它从8002端口请求到的内容，原封不动的返回回去：

![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/1f897ee545286a0b59fc4243f6af84b2.webp?x-oss-process=image/format,png#pic_center)
![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/ec6173b234f9c06fe646c9b709abb44e.webp?x-oss-process=image/format,png#pic_center)


#### 负载均衡

负载均衡是什么？
随着业务的不断增长和用户的不断增多，一台服务已经满足不了系统要求了。这个时候就出现了服务器 集群。
在服务器集群中，Nginx 可以将接收到的客户端请求“均匀地”（严格讲并不一定均匀，可以通过设置权重）分配到这个集群中所有的服务器上。这个就叫做负载均衡。
负载均衡的示意图如下：

![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/06ee1083810d768945b4234ba3e18204.webp?x-oss-process=image/format,png#pic_center)
负载均衡的作用

分摊服务器集群压力
保证客户端访问的稳定性

前面也提到了，负载均衡可以解决分摊服务器集群压力的问题。除此之外，Nginx还带有健康检查（服务器心跳检查）功能，会定期轮询向集群里的所有服务器发送健康检查请求，来检查集群中是否有服务器处于异常状态。
一旦发现某台服务器异常，那么在这以后代理进来的客户端请求都不会被发送到该服务器上（直健康检查发现该服务器已恢复正常），从而保证客户端访问的稳定性。

**配置负载均衡**

配置一个简单的负载均衡并不复杂，代码如下：

```
## 负载均衡：设置domain
upstream domain {
    server localhost:8000;
    server localhost:8001;
}
server {  
        listen       8080;        
        server_name  localhost;

        location / {
            # root   html; # Nginx默认值
            # index  index.html index.htm;
            
            proxy_pass http://domain; # 负载均衡配置，请求会被平均分配到8000和8001端口
            proxy_set_header Host $host:$server_port;
        }
}

```

8000和8001是我本地用 Node.js 起的两个服务，负载均衡成功后可以看到访问 localhost:8080 有时会访问到8000端口的页面，有时会访问到8001端口的页面。
![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/2299761055052914c2f089ab072b37fd.webp?x-oss-process=image/format,png#pic_center)
![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/3440c0ca236da8de821da682fcf157b1.webp?x-oss-process=image/format,png#pic_center)
能看到这个效果，就说明你配置的负载均衡策略生效了。
实际项目中的负载均衡远比这个案例要更加复杂，但是万变不离其宗，都是根据这个理想模型衍生出来的。
受集群单台服务器内存等资源的限制，负载均衡集群的服务器也不能无限增多。但因其良好的容错机制，负载均衡成为了实现高可用架构中必不可少的一环。

## 编译
不同的语言，不同的开发环境，编译出的东西不一定一样。

> 比如C/C++，windows下编出的是后缀为exe的可执行程序，双击就能直接运行。但如果在linux下编出的后缀是没有exe的，是一个可运行的二进制文件。原因是因为编译器不同，linux环境的编译器一般是gcc，windows下一般是MinGW等（用VSCODE跑C一般就是这个编译器）


> 不过java比较特殊，因为编出来的class文件是运行在JVM上，在os上一层，与操作系统没有直接联系。所以windows编出来的class，或者打包的tar/war可以直接扔到服务器（linux）上使用（B站黑马程序员的jenkins教程--（SpringCloud微服务部署）就是这样的）


## Web
### Session 与 Cookie
[原文链接](https://www.cnblogs.com/l199616j/p/11195667.html)

**会话（Session）跟踪是Web程序中常用的技术，用来跟踪用户的整个会话。常用的会话跟踪技术是Cookie与Session。Cookie通过在客户端记录信息确定用户身份，Session通过在服务器端记录信息确定用户身份。**

#### Cookie机制
在程序中，会话跟踪是很重要的事情。理论上，一个用户的所有请求操作都应该属于同一个会话，而另一个用户的所有请求操作则应该属于另一个会话，二者不能混淆。例如，用户A在超市购买的任何商品都应该放在A的购物车内，不论是用户A什么时间购买的，这都是属于同一个会话的，不能放入用户B或用户C的购物车内，这不属于同一个会话。

　　而Web应用程序是使用HTTP协议传输数据的。HTTP协议是无状态的协议。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话。即用户A购买了一件商品放入购物车内，当再次购买商品时服务器已经无法判断该购买行为是属于用户A的会话还是用户B的会话了。要跟踪该会话，必须引入一种机制。

　　Cookie就是这样的一种机制。它可以弥补HTTP协议无状态的不足。在Session出现之前，基本上所有的网站都采用Cookie来跟踪会话。

#### 什么是Cookie
Cookie意为“甜饼”，是由W3C组织提出，最早由Netscape社区发展的一种机制。目前Cookie已经成为标准，所有的主流浏览器如IE、Netscape、Firefox、Opera等都支持Cookie。

　　由于HTTP是一种无状态的协议，服务器单从网络连接上无从知道客户身份。怎么办呢？就给客户端们颁发一个通行证吧，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。这就是Cookie的工作原理。

　　Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。

![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/f8e326e26add2797b05d3ed8c17a8f8b.png#pic_center)
#### Session机制
Session是服务器端使用的一种记录客户端状态的机制，使用上比Cookie简单一些，相应的也增加了服务器的存储压力。

#### 什么是Session
Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。

　　如果说**Cookie机制是通过检查客户身上的“通行证”来确定客户身份的话，那么Session机制就是通过检查服务器上的“客户明细表”来确认客户身份。Session相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。**
　　
#### cookie和session的区别
**1、cookie数据存放在客户的浏览器上，session数据放在服务器上.**

简单的说，当你登录一个网站的时候，如果web服务器端使用的是session,那么所有的数据都保存在服务器上面，

 

客户端每次请求服务器的时候会发送 当前会话的session_id，服务器根据当前session_id判断相应的用户数据标志，以确定用户是否登录，或具有某种权限。

 

由于数据是存储在服务器 上面，所以你不能伪造，但是如果你能够获取某个登录用户的session_id，用特殊的浏览器伪造该用户的请求也是能够成功的。

 

session_id是服务器和客户端链接时候随机分配的，一般来说是不会有重复，但如果有大量的并发请求，也不是没有重复的可能性。


Session是由应用服务器维持的一个服务器端的存储空间，用户在连接服务器时，会由服务器生成一个唯一的SessionID,用该SessionID 为标识符来存取服务器端的Session存储空间。而SessionID这一数据则是保存到客户端，用Cookie保存的，用户提交页面时，会将这一 SessionID提交到服务器端，来存取Session数据。这一过程，是不用开发人员干预的。所以一旦客户端禁用Cookie，那么Session也会失效。

**2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。**

 

**3、设置cookie时间可以使cookie过期。但是使用session-destory（），我们将会销毁会话。**



**4、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用cookie。**

**5、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。(Session对象没有对存储的数据量的限制，其中可以保存更为复杂的数据类型)**

## 密码学
### MD5加密
**为什么要对密码MD5**
密码明文传递或者直接写到数据库中，都有被偷看的风险

**为什么要对密码做两次MD5**
现在存在的一些反查md5的软件，做两次为了更好的保密

**整体流程如何实现**

**1.整体加密流程**

```
MD5(MD5(pass明文+固定salt)+随机salt)
第一次固定salt写死在前端
第二次加密采用随机的salt 并将每次生成的salt保存在数据库中
```

**2.登录流程：**

```
前端对用户输入的密码进行md5加密（固定的salt）
将加密后的密码传递到后端
后端使用用户id取出用户信息
后端对加密后的密码在进行md5加密（取出盐），然后与数据库中存储的密码进行对比，
ok登录成功，否则登录失败
```

**3.注册流程**

```
前端对用户输入的密码进行md5加密（固定的salt）
将加密后的密码传递到后端
后端随机生成一个salt，
使用生成salt对前端传过来的密码进行加密，然后将加密后密码和salt一起保存到db中
```

## 硬件知识
### cpu核心数与线程数
[原文链接](https://zhuanlan.zhihu.com/p/86855590)

**物理 cpu 数（physical cpu）**

指主板上实际插入的 cpu 硬件个数（socket）。（但是这一概念经常被泛泛的说成是 cpu 数，这很容易导致与 core 数，processor 数等概念混淆，所以此处强调是物理 cpu 数）。

由于在主板上引入多个 cpu 插槽需要更复杂的硬件支持（连接不同插槽的 cpu 到内存和其他资源），通常只会在服务器上才这样做。在家用电脑中，一般主板上只会有一个 cpu 插槽。

**核心（core）**
一开始，每个物理 cpu 上只有一个核心（a single core），对操作系统而言，也就是同一时刻只能运行一个进程/线程。 为了提高性能，cpu 厂商开始在单个物理 cpu 上增加核心（实实在在的硬件存在），也就出现了双核心 cpu（dual-core cpu）以及多核心 cpu（multiple cores），这样一个双核心 cpu 就是同一时刻能够运行两个进程/线程的。

**同时多线程技术（simultaneous multithreading）和 超线程技术（hyper–threading/HT）**

本质一样，是为了提高单个 core 同一时刻能够执行的多线程数的技术（充分利用单个 core 的计算能力，尽量让其“一刻也不得闲”）。

simultaneous multithreading 缩写是 SMT，AMD 和其他 cpu 厂商的称呼。 hyper–threading 是 Intel 的称呼，可以认为 hyper–threading 是 SMT 的一种具体技术实现。

在类似技术下，产生了如下等价术语：

 - 虚拟 core： virtual core 
 - 逻辑 processer： logical processor 
 - 线程：thread

所以可以这样说：某款采用 SMT 技术的 4 核心 AMD cpu 提供了 8 线程同时执行的能力；某款采用 HT 技术的 2 核心 Intel cpu 提供了 4 线程同时执行的能力。

**查看 cpu 信息**
1.linux系统：

```
//法一
lscpu
```

```
CPU(s):                24
On-line CPU(s) list:   0-23
Thread(s) per core:    2
Core(s) per socket:    6
Socket(s):             2
```

```
//法二
cat /proc/cpuinfo
```

```
processor   : 0
vendor_id   : GenuineIntel
cpu family  : 6
model       : 60
model name  : Intel(R) Core(TM) i7-4700MQ CPU @ 2.40GHz
stepping    : 3
microcode   : 0x22
cpu MHz     : 2393.631
cache size  : 6144 KB
physical id : 0
siblings    : 8
core id     : 0
cpu cores   : 4
...

```
其中有几个physical id,机器上就安装了几个物理CPU
cpu core记录了每个物理CPU,内部有几个物理核
siblings 代表每个物理CPU有多少个逻辑核


2.windows
![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/c82b797044d88e27b217706604a29bc7.png#pic_center)
**多线程程序线程数**
为了让我们的多线程程序更好的利用 cpu 资源，我们通常会先了解机器拥有的 processor 数，有若干手段可以获取这一信息：

 - cpuinfo 中查看：比如上文中的 cat /proc/cpuinfo | grep "processor" | wc -l
 - top 命令查看：cpu0,cpu1,...
 - 编程：比如在 Java 中用 Runtime.getRuntime().availableProcessors()

具体在多线程程序中设置线程数多大，对计算密集型的程序有的建议是 processor count + 1，有的建议是 processor count 的 1.5 倍，都是经验值，实测为准。

**小结**

 - 一台完整的计算机可能包含一到多个物理 cpu 
 - 从单个物理 cpu （physical cpu）的角度看，其可能是单核心、双核心甚至多核心的
 - 从单个核心（core）的角度看，还有 SMT / HT 等技术让每个 core 对计算机操作系统而言用起来像多个物理 core 差不多

总的逻辑 cpu 数 = 物理 cpu 数 * 每颗物理 cpu 的核心数 * 每个核心的超线程数

### cpu 线程与进程关系
[原文链接](https://juejin.cn/post/6844904120684396552)
#### 进程与线程
两种常见解释

1.进程和线程都是一个时间段的描述，是CPU工作时间段的描述。
2.进程是资源分配的最小单位，线程是CPU调度的最小单位

解释：

 1. CPU太快了,只有缓存存储器SRAM才能勉强追上它的速度,因此,一台机器上同时开30个程序,CPU可以把这30个程序变成顺序执行，每个只执行一小段，立马切换到下一个程序，再执行一小段，再切回来，人是无感知的。
 2. ***一个程序准备开始执行的时候，相关资源必须要准备好，比如RAM地址，显卡，磁盘资源，这些准备好的东西打包一起就叫做上下文环境***，然后CPU开始执行程序A，当然只执行了一小段时间，CPU就要切换到别的程序执行B，以保证几个程序的并发，切换之前要把A的上下问状态保存起来，下次切回来的时候接着用。
 3. 因此，进程就是包换上下文切换的程序执行时间总和 = CPU加载上下文+CPU执行+CPU保存上下文
 4. 进程的颗粒度太大，每次都要有上下的调入，保存，调出。线程就是进程的小分支，比如进程A有a，b，c三个线程，那么线程a，b，c就共享了进程A的上下文环境，成为了更细小的执行时间。

#### 程序中的线程与CPU线程
看到这里会懵逼，假设一台8CPU32核的服务器，是不是跑的程序最多只能开32个线程呢？

答案当然是否定的，我们常说的进程中的线程，与CPU的线程，虽然都叫线程，但完全不是一回事。

程序的线程是软件概念，一个程序可以有多个线程，可以在一个CPU核上轮流**并发**执行。
CPU的线程是硬件的概念,就是核。八线程就是能让八个线程**并行**执行。

#### linux中的线程
暂时来不及总结，原文链接有。

## 概念
### 脚手架、框架、架构

 - 脚手架是指一个项目模板，通过这个模板可以生成固定模板的项目。 
 - 框架一般是说应用框架，就是别人已经搭建好的成熟组件，我们只需要填代码就行，比如Spring
   Boot就是一个框架，我们要开发spring应用，就可以在这个框架里面按照它的规范去写代码。
 - 架构是指解决特定业务场景的技术解决方案。
