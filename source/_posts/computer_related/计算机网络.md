---
title: 计算机网络
date: 205/04/16
categories:
  - 计算机基础知识
tags:
  - 计算机网络
---


## 计算机网络

### TCP/IP网络模型

一般都是七层模型，如果简答的划分，四层就可以。从上至下分别是：应用层、传输层、网络层、网络接口层

应用层：传输什么内容（图片、文字、音频）。定义​​数据格式​​和​​端到端交互规则​​。协议如HTTP、FTP。

HTTP定义网页请求/响应的格式（如 GET /index.html）

传输层：对应用层的数据进行封装，提供​​端到端通信​​（发送给哪个端口）。协议如TCP、UDP。

网络层：对传输层进程封装，通过​​逻辑寻址（IP地址）​​和​​路由选择​​，实现跨网络的设备间通信。IP协议

网络接口层：对网络层进行封装，找到传输的设备，嵌入MAC地址。同一局域网内​​通过物理地址（MAC地址）直接通信。

### cookie和session

#### cookie和seesion主要区别
星巴克开始优惠活动，每消费10杯咖啡，会免费赠送1杯。考虑到一个人一次性消费10杯咖啡几乎不可能，所以需要采取某种方式来记录顾客的消费数量。

1)分给顾客一张卡片，每消费一次记录一次；

2)发给顾客一张卡片，上面有卡号，顾客每消费一次，由店员在操作机上记录一次。

而方案一和二正是对应的客户端记录和服务端记录。与之相对应的正是cookie和session。 好了，我们进入正题。

#### 什么是cookie


HTTP是一种无状态协议,服务器没有办法单单从网络连接上面知道访问者的身份,为了解决这个问题,就诞生了Cookie

Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie

客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie。

#### cookie的弊端
cookie 可以让服务端程序跟踪每个客户端的访问，但是每次客户端的访问都必须传回这些Cookie，如果 Cookie 很多，这无形地增加了客户端与服务端的数据传输量，

![](https://img-blog.csdn.net/20180411123828426?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2puc2h1X2l0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

#### session

Session 的出现正是为了解决这个问题。同一个客户端每次和服务端交互时，不需要每次都传回所有的 Cookie 值，而是只要传回一个 ID，这个 ID 是客户端第一次访问服务器的时候生成的， 而且每个客户端是唯一的。这样每个客户端就有了一个唯一的 ID，客户端只要传回这个 ID 就行了，这个 ID 通常是 NANE 为JSESIONID 的一个 Cookie。


Session机制是一种服务端的机制，服务器使用一种类似散列表的结构来保存信息。

当程序需要为某个客户端的请求创建一个session的时候，服务器首先检查这个客户端里的请求里是否已包含了一个session标识--sessionID，

如果已经包含一个sessionID，则说明以前已经为此客户端创建过session，服务器就按照sessionID把这个session检索出来使用

如果客户端请求不包含sessionID，则为此客户端创建一个session并且声称一个与此session相关联的sessionID，

sessionID的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串(服务器会自动创建),这个sessionID将被在本次响应中返回给客户端保存。

### centOS7 桥接模式设置静态Ip的方法步骤
[原文链接](https://cloud.tencent.com/developer/article/1722144)

#### 前言
如果你虚拟机IP是自动获取的，难免会碰到IP经常变动，给xshell相关连接工具使用造成不便，那么怎么固定IP且正常访问外网地址呢？由于主机网络采用的是自动获取IP方式,所以每次重启机器可能导致IP地址的变更,不利于项目的部署和运行

静态ip就是虚拟机的ip 外界想要连你的虚拟机的ip 

#### 虚拟机选择桥接模式
注意虚拟机网卡要选择主机上网的网卡

#### 虚拟机设置静态ip(关键步骤)
![](https://ask.qcloudimg.com/http-save/yehe-1844341/npty8pp5hp.jpeg?imageView2/2/w/1620)

虚拟机的网卡名称是ens33

然后用vim编辑以下文件

**/etc/sysconfig/network-scripts/ifcfg-xxx**

上面的xxx就是虚拟机的网卡名称，不同的linux发行版名称可能不同。原因见原链接

需要修改的属性：
```
ONBOOT=YES #no换成yes
BOOTPROTO=static #dhcp换成static
添加：
IPADDR=192.168.230.129 #静态ip地址 与主机中IP的前三位一致，最后一位需要修改，不要跟主机ip一样导致发生冲突
GATEWAY=192.168.230.1 #默认网关 和物理主机一样就可以了
NETMASK=255.255.255.0 #子网掩码 和物理主机一样就可以了
DNS1=8.8.8.8　　　　　　#DNS，写谷歌的地址就可以了。
```

具体解释：
```
TYPE=Ethernet    # 网卡类型：为以太网
PROXY_METHOD=none   # 代理方式：关闭状态
BROWSER_ONLY=no    # 只是浏览器：否
BOOTPROTO=dhcp    # 网卡的引导协议：DHCP[中文名称: 动态主机配置协议]
DEFROUTE=yes    # 默认路由：是, 不明白的可以百度关键词 `默认路由`
IPV4_FAILURE_FATAL=no  # 是不开启IPV4致命错误检测：否
IPV6INIT=yes    # IPV6是否自动初始化: 是[不会有任何影响, 现在还没用到IPV6]
IPV6_AUTOCONF=yes   # IPV6是否自动配置：是[不会有任何影响, 现在还没用到IPV6]
IPV6_DEFROUTE=yes   # IPV6是否可以为默认路由：是[不会有任何影响, 现在还没用到IPV6]
IPV6_FAILURE_FATAL=no  # 是不开启IPV6致命错误检测：否
IPV6_ADDR_GEN_MODE=stable-privacy   # IPV6地址生成模型：stable-privacy [这只一种生成IPV6的策略]
NAME=ens33     # 网卡物理设备名称
UUID=f47bde51-fa78-4f79-b68f-d5dd90cfc698 # 通用唯一识别码, 每一个网卡都会有, 不能重复, 否两台linux只有一台网卡可用
DEVICE=ens33     # 网卡设备名称, 必须和 `NAME` 值一样
ONBOOT=no      # 是否开机启动， 要想网卡开机就启动或通过 `systemctl restart network`控制网卡,必须设置为 `yes`
```

#### 重启网络服务
```
#centos7

systemctl restart network 
```

#### 测试
输入命令ping www.baidu.com（测试外网） 

输入命令ping 192.168.2.153（宿主机ip） 

**注意：**
如果无法ping通宿主机，很有可能是因为防火墙。
宿主机无法ping通虚拟机，也有可能是因为防火墙。


### VMware三种网卡解析
[原文链接](https://blog.csdn.net/qq_41672971/article/details/125825563)

| 虚拟网卡名 | 网络属性 | 定义 |
|----        |   ----  | ----|
|  VMnet0   |  物理网卡 | Bridge桥接 |
| Vmnet1 |  虚拟网卡 | host-only仅主机 |
| VMnet8 | 虚拟网卡 | NAT |

**但是我们查看主机的网络链接，有时却看不见VMnet0**
![](https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/b5aa37b6f88245799d58da6be23b497a.png)



通过网络配置这里，能够看见使用那张网卡（这里是virtualbox，VMware也是差不多）
![](https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/eee41028523f4d33a06c7c0fec4c34a8.png)
**所以根据上面两张图的对比，本地网络连接中的以太网3就是桥接模式使用的网卡。**


### VM虚拟机-三种网络连接方式（桥接、NAT、仅主机模式）

[原文链接](https://blog.csdn.net/tjcwt2011/article/details/124664594)

#### 桥接
![](https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/2021082016475582.png)

**桥接，即架设了一条桥，让虚拟机成为一台真正的计算机，直接连入到实际网络中了。**

因此，它使得虚拟机能被分配到一个网络中独立的IP，所有网络功能完全和在网络中的真实机器一样，它和主机连接在同一个交换机上（此交换机通过vmnet0模拟），处于同一个 LAN，它可以访问网内任何一台机器。

**此模式下虚拟机：**

1. 可以与主机相互访问

2. 可以与网络中其他主机相互访问

3. 可以与其他虚拟机相互访问

所以，桥接模式下的虚拟机，你把它直接认为是真实计算机就行了。

默认情况下DHCP会自动为虚拟机配置网络，但如果你需要在桥接模式下，手动为虚拟系统配置IP地址时，配置的虚拟机的ip不能是已经被占用的地址，还要和宿主机器处于同一网段，不然会造成地址冲突，只有这样虚拟系统才能和宿主机器以及外网进行通信。

--------------------------------------

**复制物理网络连接状态**

一般在虚拟机设置为桥接时就能看见这个选项（无特殊要求默认不用勾选）

![](https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/20210820141133567.png)


这个选项是只在移动设备上有用，比如在笔记本上使用VMware软件，最开始主机用有线连接的局域网，开启虚拟机（使用桥接），虚拟机系统获取的局域网地址为192.168.1.4。然后你把主机的有线拔掉，连接上同一局域网的wifi时，如果你选择了复制物理网络连接状态这个选项，那你的虚拟机系统的IP不会变化（还是192.168.1.4），如果你没有选择复制物理网络连接状态这个选项，那你的虚拟机系统的IP可能就会发生变化，比如变为192.168.1.5。

#### NAT
![](https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/20210820164721916.png)

NAT，虚拟机访问网络的所有数据都是由主机提供的，虚拟机并不真实存在于网络中，主机与网络中的任何机器都不能查看和访问到虚拟机的存在。 

虚拟机和主机之间通过VMnet8这个网卡来模拟路由器的作用，进行nat地址转换功能，负责将虚拟机发到 VMnet8 的包进行地址转换之后发到实际的网络上，再将实际网络上返回的包进行地址转换后通过 VMnet8 发送给虚拟机。

此模式下虚拟机：

       可以单向访问主机

       可以单向访问其他网络中主机

       不可以访问其他虚拟机

虚拟机可以访问主机能访问到的所有网络，但是对于主机以及主机网络上的其他机器，虚拟机又是不可见的，甚至主机也访问不到虚拟机。包括所有nat模式下的虚拟机之间相互都不能访问，虚拟机与虚拟机各自完全独立，相互间无法通过网络访问彼此。


#### 仅主机
![](https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/20210820172148978.png)

仅主机，虚拟机的与主机通过VMnet1连接，VMnet1不提供提供任何路由服务，因此虚拟机只能和宿主机进行通信，而不能连接到实际网络上。

其实就是NAT模式去除了nat地址转换功能

此模式下虚拟机：

       可以与主机互相访问

       不可以访问其他网络中主机

       不可以访问其他虚拟机

仅主机模式看着很简单，但是其实这是一种比较复杂的模式，其他模式可以实现的功能，在仅主机模式下，通过虚拟机及网卡的设置都可以被实现。所以该模式需要有比较扎实的网络基础知识

这种模式下，我们可以理解为虚拟机在主机中模拟出一张专供虚拟机使用的网卡VMnet1，所有虚拟机都是连接到该网卡上的，我们可以通过设置这张网卡来实现上网及其他很多功能，比如（网卡共享、网卡桥接等）。

### 正向代理和反向代理区别
[原文链接](https://www.cnblogs.com/taostaryu/p/10547132.html)

**一 什么是代理**

代理其实就是一个中介，A和B本来可以直连，中间插入一个C，C就是中介。
刚开始的时候，代理多数是帮助内网client访问外网server用的
后来出现了反向代理，"反向"这个词在这儿的意思其实是指方向相反，即代理将来自外网客户端的请求转发到内网服务器，从外到内

 

**二 正向代理**

正向代理类似一个跳板机，代理访问外部资源

比如我们国内访问谷歌，直接访问访问不到，我们可以通过一个正向代理服务器，请求发到代理服，代理服务器能够访问谷歌，这样由代理去谷歌取到返回数据，再返回给我们，这样我们就能访问谷歌了
![](https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/cd381c5de09a40f2bfedae52042eb66d.png)



**正向代理的用途：**

　　（1）访问原来无法访问的资源，如google

（2） 可以做缓存，加速访问资源

　　（3）对客户端访问授权，上网进行认证

　　（4）代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息
　　

**三 反向代理**
反向代理（Reverse Proxy）实际运行方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器

![](https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/85649ed3b62c40d38de64b5170114f5b.png)


 

**反向代理的作用：**
（1）保证内网的安全，阻止web攻击，大型网站，通常将反向代理作为公网访问地址，Web服务器是内网

（2）负载均衡，通过反向代理服务器来优化网站的负载

 

**四 总结
正向代理即是客户端代理, 代理客户端, 服务端不知道实际发起请求的客户端.
反向代理即是服务端代理, 代理服务端, 客户端不知道实际提供服务的服务端**

看图理解一：
![](https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/0c3860e58d2cffd66b808fe07631e358.png)


看图理解二：
![](https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/7cc6fc2baf342df6a450a54ca2ad6b8a.png)


正向代理中，proxy和client同属一个LAN，对server透明；
反向代理中，proxy和server同属一个LAN，对client透明。
实际上proxy在两种代理中做的事都是代为收发请求和响应，不过从结构上来看正好左右互换了下，所以把后出现的那种代理方式叫成了反向代理

**总结：**
正向代理: 买票的黄牛

反向代理: 租房的代理

### Nginx
[原文链接](https://juejin.cn/post/6844904129987526663)
“Nginx 是一款轻量级的 HTTP 服务器，采用事件驱动的异步非阻塞处理方式框架，这让其具有极好的 IO 性能，时常用于服务端的**反向代理**和**负载均衡**。”
Nginx 是一款 http 服务器 （或叫web服务器）。它是由俄罗斯人 伊戈尔·赛索耶夫为俄罗斯访问量第二的 Rambler.ru 站点开发的，并于2004年首次公开发布的。

```
web服务器：负责处理和响应用户请求，一般也称为http服务器，如 Apache、IIS、Nginx

应用服务器：存放和运行系统程序的服务器，负责处理程序中的业务逻辑，如 Tomcat、Weblogic、Jboss（现在大多数应用服务器也包含了web服务器的功能）
```

Nginx 是什么，总结一下就是这些：

 - 一种轻量级的web服务器
 - 设计思想是事件驱动的异步非阻塞处理（类node.js）
 - 占用内存少、启动速度快、并发能力强
 - 使用C语言开发
 - 扩展性好，第三方插件非常多
 - 在互联网项目中广泛应用

#### Nginx配置

**安装/卸载**

***安装、卸载、启动自查找资料***

修改配置
经常要用到的几个文件路径：

```
/usr/local/etc/nginx/nginx.conf （nginx配置文件路径）
/usr/local/var/www （nginx服务器默认的根目录）
/usr/local/Cellar/nginx/1.17.9 （nginx的安装路径）
/usr/local/var/log/nginx/error.log (nginx默认的日志路径)
```

nginx 默认配置文件简介：


```
## 首尾配置暂时忽略
server {  
        # 当nginx接到请求后，会匹配其配置中的service模块
        # 匹配方法就是将请求携带的host和port去跟配置中的server_name和listen相匹配
        listen       8080;        
        server_name  localhost; # 定义当前虚拟主机（站点）匹配请求的主机名

        location / {
            root   html; # Nginx默认值
            # 设定Nginx服务器返回的文档名
            index  index.html index.htm; # 先找根目录下的index.html，如果没有再找index.htm
        }
}

## 首尾配置暂时忽略
```


server{ } 其实是包含在 http{ } 内部的。每一个 server{ } 是一个虚拟主机（站点）。
上面代码块的意思是：当一个请求叫做localhost:8080请求nginx服务器时，该请求就会被匹配进该代码块的 server{ } 中执行。
当然 nginx 的配置非常多，用的时候可以根据文档进行配置。

英文文档：nginx.org/en/docs/
中文文档：www.nginx.cn/doc/

Nginx有哪些应用？
主要有4大应用（动静分离、正向代理、反向代理、负载均衡）

#### 动静分离
![](https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/e9d551a4479341cca95a54fbe13f3ebe.webp)


如上图所示，动静分离其实就是 Nginx 服务器将接收到的请求分为动态请求和静态请求。
静态请求直接从 nginx 服务器所设定的根目录路径去取对应的资源，动态请求转发给真实的后台（前面所说的应用服务器，如图中的Tomcat）去处理。
这样做不仅能给应用服务器减轻压力，将后台api接口服务化，还能将前后端代码分开并行开发和部署。（传送门：[nginx动静分离的好处](https://www.php.cn/nginx/424631.html)）

```
server {  
        listen       8080;        
        server_name  localhost;

        location / {
            root   html; # Nginx默认值
            index  index.html index.htm;
        }
        
        # 静态化配置，所有静态请求都转发给 nginx 处理，存放目录为 my-project
        location ~ .*\.(html|htm|gif|jpg|jpeg|bmp|png|ico|js|css)$ {
            root /usr/local/var/www/my-project; # 静态请求所代理到的根目录
        }
        
        # 动态请求匹配到path为'node'的就转发到8002端口处理
        location /node/ {  
            proxy_pass http://localhost:8002; # 充当服务代理
        }
}
```

访问静态资源 nginx 服务器会返回 my-project 里面的文件，如获取 index.html：
![](https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/34472ca6f5724173402dbaf6d4e6f8b3.webp)


访问动态请求 nginx 服务器会将它从8002端口请求到的内容，原封不动的返回回去：

![](https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/1f897ee545286a0b59fc4243f6af84b2.webp)
![](https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/ec6173b234f9c06fe646c9b709abb44e.webp)


#### 负载均衡

负载均衡是什么？
随着业务的不断增长和用户的不断增多，一台服务已经满足不了系统要求了。这个时候就出现了服务器 集群。
在服务器集群中，Nginx 可以将接收到的客户端请求“均匀地”（严格讲并不一定均匀，可以通过设置权重）分配到这个集群中所有的服务器上。这个就叫做负载均衡。
负载均衡的示意图如下：

![](https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/06ee1083810d768945b4234ba3e18204.webp)
负载均衡的作用

分摊服务器集群压力
保证客户端访问的稳定性

前面也提到了，负载均衡可以解决分摊服务器集群压力的问题。除此之外，Nginx还带有健康检查（服务器心跳检查）功能，会定期轮询向集群里的所有服务器发送健康检查请求，来检查集群中是否有服务器处于异常状态。
一旦发现某台服务器异常，那么在这以后代理进来的客户端请求都不会被发送到该服务器上（直健康检查发现该服务器已恢复正常），从而保证客户端访问的稳定性。

**配置负载均衡**

配置一个简单的负载均衡并不复杂，代码如下：

```
## 负载均衡：设置domain
upstream domain {
    server localhost:8000;
    server localhost:8001;
}
server {  
        listen       8080;        
        server_name  localhost;

        location / {
            # root   html; # Nginx默认值
            # index  index.html index.htm;
            
            proxy_pass http://domain; # 负载均衡配置，请求会被平均分配到8000和8001端口
            proxy_set_header Host $host:$server_port;
        }
}

```

8000和8001是我本地用 Node.js 起的两个服务，负载均衡成功后可以看到访问 localhost:8080 有时会访问到8000端口的页面，有时会访问到8001端口的页面。
![](https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/2299761055052914c2f089ab072b37fd.webp)
![](https://cdn.jsdelivr.net/gh/gaofeng-lin/picture_bed/img1/3440c0ca236da8de821da682fcf157b1.webp)
能看到这个效果，就说明你配置的负载均衡策略生效了。
实际项目中的负载均衡远比这个案例要更加复杂，但是万变不离其宗，都是根据这个理想模型衍生出来的。
受集群单台服务器内存等资源的限制，负载均衡集群的服务器也不能无限增多。但因其良好的容错机制，负载均衡成为了实现高可用架构中必不可少的一环。

### ping和ssh

**ping 和 ssh 的连通性是相互独立的。如果你不能 ping 通一个 IP，不意味着你不能 ssh 到它；同样，如果你可以 ping 通一个 IP，也不意味着你可以 ssh 到它。**

ping 和 ssh 使用的是不同的网络协议和端口。ping 使用的是 ICMP (Internet Control Message Protocol)，而 ssh 使用的是 TCP 协议，默认端口为22。这意味着以下几种情况可能发生：

1. ICMP 被阻止：在许多网络环境中，出于安全原因，ICMP 可能被防火墙或路由器屏蔽。这意味着你可能无法 ping 通一个 IP，但是还是可以通过 ssh 连接它。

2. SSH 服务未运行：即使你可以 ping 通一个 IP，如果那台计算机上没有运行 SSH 服务，或者 SSH 服务配置不当，你仍然无法通过 ssh 连接它。

3. SSH 端口被阻止：某些网络可能允许 ICMP，但阻止了 SSH 的默认端口（22）。这可能是因为网络管理员想要防止未经授权的远程访问。

4. 使用非默认端口的 SSH：有时，为了安全或其他原因，SSH 可能配置为在非默认端口上运行。在这种情况下，即使默认的 SSH 端口被阻止，你仍然可能能够连接，只要你知道正确的端口号。

### 代理软件全局模型ip是否被修改
使用全局代理模式时，你的公共 IP 地址（从外部服务器或网站看到的 IP 地址）会被修改为代理服务器的 IP 地址。这是因为所有的网络请求都通过代理服务器进行，在到达最终的服务器或网站之前，首先到达代理服务器，然后由代理服务器转发。因此，对于外部服务器或网站，它们看到的请求似乎是来自代理服务器，而不是你的原始设备。

**不过本地cmd查看ip是没有变化的**